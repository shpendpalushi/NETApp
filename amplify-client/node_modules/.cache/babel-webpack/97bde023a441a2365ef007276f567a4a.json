{"ast":null,"code":"/**\r\n * DevExtreme (ui/pivot_grid/ui.pivot_grid.data_controller.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _callbacks = require(\"../../core/utils/callbacks\");\n\nvar _callbacks2 = _interopRequireDefault(_callbacks);\n\nvar _deferred = require(\"../../core/utils/deferred\");\n\nvar _extend2 = require(\"../../core/utils/extend\");\n\nvar _array = require(\"../../core/utils/array\");\n\nvar _iterator = require(\"../../core/utils/iterator\");\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _class = require(\"../../core/class\");\n\nvar _class2 = _interopRequireDefault(_class);\n\nvar _string = require(\"../../core/utils/string\");\n\nvar _string2 = _interopRequireDefault(_string);\n\nvar _common = require(\"../../core/utils/common\");\n\nvar _common2 = _interopRequireDefault(_common);\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _uiGrid_core = require(\"../grid_core/ui.grid_core.virtual_scrolling_core\");\n\nvar _uiGrid_core2 = _interopRequireDefault(_uiGrid_core);\n\nvar _uiGrid_core3 = require(\"../grid_core/ui.grid_core.virtual_columns_core\");\n\nvar _uiGrid_core4 = _interopRequireDefault(_uiGrid_core3);\n\nvar _uiGrid_core5 = require(\"../grid_core/ui.grid_core.state_storing_core\");\n\nvar _uiGrid_core6 = _interopRequireDefault(_uiGrid_core5);\n\nvar _data_source = require(\"./data_source\");\n\nvar _data_source2 = _interopRequireDefault(_data_source);\n\nvar _uiPivot_grid = require(\"./ui.pivot_grid.utils\");\n\nvar _uiPivot_grid2 = _interopRequireDefault(_uiPivot_grid);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar math = Math;\nvar GRAND_TOTAL_TYPE = \"GT\";\nvar TOTAL_TYPE = \"T\";\nvar DATA_TYPE = \"D\";\nvar NOT_AVAILABLE = \"#N/A\";\nvar CHANGING_DURATION_IF_PAGINATE = 300;\n\nvar proxyMethod = function proxyMethod(instance, methodName, defaultResult) {\n  if (!instance[methodName]) {\n    instance[methodName] = function () {\n      var dataSource = this._dataSource;\n      return dataSource ? dataSource[methodName].apply(dataSource, arguments) : defaultResult;\n    };\n  }\n};\n\nexports.DataController = _class2.default.inherit(function () {\n  function getHeaderItemText(item, description, options) {\n    var text = item.text;\n\n    if ((0, _type.isDefined)(item.displayText)) {\n      text = item.displayText;\n    } else {\n      if ((0, _type.isDefined)(item.caption)) {\n        text = item.caption;\n      } else {\n        if (item.type === GRAND_TOTAL_TYPE) {\n          text = options.texts.grandTotal;\n        }\n      }\n    }\n\n    if (item.isAdditionalTotal) {\n      text = _string2.default.format(options.texts.total || \"\", text);\n    }\n\n    return text;\n  }\n\n  function formatCellValue(value, dataField, errorText) {\n    return value === NOT_AVAILABLE ? errorText : (0, _uiPivot_grid.formatValue)(value, dataField);\n  }\n\n  var createHeaderInfo = function () {\n    var getHeaderItemsDepth = function getHeaderItemsDepth(headerItems) {\n      var depth = 0;\n      (0, _uiPivot_grid.foreachTree)(headerItems, function (items) {\n        depth = math.max(depth, items.length);\n      });\n      return depth;\n    };\n\n    var createInfoItem = function createInfoItem(headerItem, breadth, isHorizontal, isTree) {\n      var infoItem = {\n        type: headerItem.type,\n        text: headerItem.text\n      };\n\n      if (headerItem.path) {\n        infoItem.path = headerItem.path;\n      }\n\n      if (headerItem.width) {\n        infoItem.width = headerItem.width;\n      }\n\n      if ((0, _type.isDefined)(headerItem.wordWrapEnabled)) {\n        infoItem.wordWrapEnabled = headerItem.wordWrapEnabled;\n      }\n\n      if (headerItem.isLast) {\n        infoItem.isLast = true;\n      }\n\n      if (headerItem.sorted) {\n        infoItem.sorted = true;\n      }\n\n      if (headerItem.isMetric) {\n        infoItem.dataIndex = headerItem.dataIndex;\n      }\n\n      if ((0, _type.isDefined)(headerItem.expanded)) {\n        infoItem.expanded = headerItem.expanded;\n      }\n\n      if (breadth > 1) {\n        infoItem[isHorizontal ? \"colspan\" : \"rowspan\"] = breadth;\n      }\n\n      if (headerItem.depthSize && headerItem.depthSize > 1) {\n        infoItem[isHorizontal ? \"rowspan\" : \"colspan\"] = headerItem.depthSize;\n      }\n\n      if (headerItem.index >= 0) {\n        infoItem.dataSourceIndex = headerItem.index;\n      }\n\n      if (isTree && headerItem.children && headerItem.children.length && !headerItem.children[0].isMetric) {\n        infoItem.width = null;\n        infoItem.isWhiteSpace = true;\n      }\n\n      return infoItem;\n    };\n\n    var addInfoItem = function addInfoItem(info, options) {\n      var itemInfo;\n      var breadth = options.lastIndex - options.index || 1;\n\n      var addInfoItemCore = function addInfoItemCore(info, infoItem, itemIndex, depthIndex, isHorizontal) {\n        var index = isHorizontal ? depthIndex : itemIndex;\n\n        while (!info[index]) {\n          info.push([]);\n        }\n\n        if (isHorizontal) {\n          info[index].push(infoItem);\n        } else {\n          info[index].unshift(infoItem);\n        }\n      };\n\n      itemInfo = createInfoItem(options.headerItem, breadth, options.isHorizontal, options.isTree);\n      addInfoItemCore(info, itemInfo, options.index, options.depth, options.isHorizontal);\n\n      if (!options.headerItem.children || 0 === options.headerItem.children.length) {\n        return options.lastIndex + 1;\n      }\n\n      return options.lastIndex;\n    };\n\n    var isItemSorted = function isItemSorted(items, sortBySummaryPath) {\n      var path;\n      var item = items[0];\n      var stringValuesUsed = (0, _type.isString)(sortBySummaryPath[0]);\n      var headerItem = item.dataIndex >= 0 ? items[1] : item;\n\n      if (stringValuesUsed && sortBySummaryPath[0].indexOf(\"&[\") !== -1 && headerItem.key || !headerItem.key) {\n        path = (0, _uiPivot_grid.createPath)(items);\n      } else {\n        path = _iterator2.default.map(items, function (item) {\n          return item.dataIndex >= 0 ? item.value : item.text;\n        }).reverse();\n      }\n\n      if (item.type === GRAND_TOTAL_TYPE) {\n        path = path.slice(1);\n      }\n\n      return path.join(\"/\") === sortBySummaryPath.join(\"/\");\n    };\n\n    var getViewHeaderItems = function getViewHeaderItems(headerItems, headerDescriptions, cellDescriptions, depthSize, options) {\n      var cellDescriptionsCount = cellDescriptions.length;\n      var viewHeaderItems = createViewHeaderItems(headerItems, headerDescriptions);\n      var dataFields = options.dataFields;\n      var d = new _deferred.Deferred();\n      (0, _deferred.when)(viewHeaderItems).done(function (viewHeaderItems) {\n        options.notifyProgress(.5);\n\n        if (options.showGrandTotals) {\n          viewHeaderItems[!options.showTotalsPrior ? \"push\" : \"unshift\"]({\n            type: GRAND_TOTAL_TYPE,\n            isEmpty: options.isEmptyGrandTotal\n          });\n        }\n\n        var hideTotals = false === options.showTotals || dataFields.length > 0 && dataFields.length === options.hiddenTotals.length;\n        var hideData = dataFields.length > 0 && options.hiddenValues.length === dataFields.length;\n\n        if (hideData && hideTotals) {\n          depthSize = 1;\n        }\n\n        if (!hideTotals || \"tree\" === options.layout) {\n          addAdditionalTotalHeaderItems(viewHeaderItems, headerDescriptions, options.showTotalsPrior, \"tree\" === options.layout);\n        }\n\n        (0, _deferred.when)((0, _uiPivot_grid.foreachTreeAsync)(viewHeaderItems, function (items) {\n          var item = items[0];\n\n          if (!item.children || 0 === item.children.length) {\n            item.depthSize = depthSize - items.length + 1;\n          }\n        })).done(function () {\n          if (cellDescriptionsCount > 1) {\n            addMetricHeaderItems(viewHeaderItems, cellDescriptions, options);\n          }\n\n          !options.showEmpty && removeHiddenItems(viewHeaderItems);\n          options.notifyProgress(.75);\n          (0, _deferred.when)((0, _uiPivot_grid.foreachTreeAsync)(viewHeaderItems, function (items) {\n            var item = items[0];\n            var isMetric = item.isMetric;\n            var field = headerDescriptions[items.length - 1] || {};\n\n            if (item.type === DATA_TYPE && !isMetric) {\n              item.width = field.width;\n            }\n\n            if (true === hideData && item.type === DATA_TYPE) {\n              var parentChildren = (items[1] ? items[1].children : viewHeaderItems) || [];\n              parentChildren.splice((0, _array.inArray)(item, parentChildren), 1);\n              return;\n            }\n\n            if (isMetric) {\n              item.wordWrapEnabled = cellDescriptions[item.dataIndex].wordWrapEnabled;\n            } else {\n              item.wordWrapEnabled = field.wordWrapEnabled;\n            }\n\n            item.isLast = !item.children || !item.children.length;\n\n            if (item.isLast) {\n              _iterator2.default.each(options.sortBySummaryPaths, function (index, sortBySummaryPath) {\n                if (!(0, _type.isDefined)(item.dataIndex)) {\n                  sortBySummaryPath = sortBySummaryPath.slice(0);\n                  sortBySummaryPath.pop();\n                }\n\n                if (isItemSorted(items, sortBySummaryPath)) {\n                  item.sorted = true;\n                  return false;\n                }\n              });\n            }\n\n            item.text = getHeaderItemText(item, field, options);\n          })).done(function () {\n            if (!viewHeaderItems.length) {\n              viewHeaderItems.push({});\n            }\n\n            options.notifyProgress(1);\n            d.resolve(viewHeaderItems);\n          });\n        });\n      });\n      return d;\n    };\n\n    function createHeaderItem(childrenStack, depth, index) {\n      var parent = childrenStack[depth] = childrenStack[depth] || [];\n      var node = parent[index] = {};\n\n      if (childrenStack[depth + 1]) {\n        node.children = childrenStack[depth + 1];\n\n        for (var i = depth + 1; i < childrenStack.length; i++) {\n          childrenStack[i] = void 0;\n        }\n\n        childrenStack.length = depth + 1;\n      }\n\n      return node;\n    }\n\n    function createViewHeaderItems(headerItems, headerDescriptions) {\n      var headerDescriptionsCount = headerDescriptions && headerDescriptions.length || 0;\n      var childrenStack = [];\n      var d = new _deferred.Deferred();\n      var headerItem;\n      (0, _deferred.when)((0, _uiPivot_grid.foreachTreeAsync)(headerItems, function (items, index) {\n        var item = items[0];\n        var path = (0, _uiPivot_grid.createPath)(items);\n        headerItem = createHeaderItem(childrenStack, path.length, index);\n        headerItem.type = DATA_TYPE;\n        headerItem.value = item.value;\n        headerItem.path = path;\n        headerItem.text = item.text;\n        headerItem.index = item.index;\n        headerItem.displayText = item.displayText;\n        headerItem.key = item.key;\n        headerItem.isEmpty = item.isEmpty;\n\n        if (path.length < headerDescriptionsCount && (!item.children || 0 !== item.children.length)) {\n          headerItem.expanded = !!item.children;\n        }\n      })).done(function () {\n        d.resolve(createHeaderItem(childrenStack, 0, 0).children || []);\n      });\n      return d;\n    }\n\n    var addMetricHeaderItems = function addMetricHeaderItems(headerItems, cellDescriptions, options) {\n      (0, _uiPivot_grid.foreachTree)(headerItems, function (items) {\n        var item = items[0];\n        var i;\n\n        if (!item.children || 0 === item.children.length) {\n          item.children = [];\n\n          for (i = 0; i < cellDescriptions.length; i++) {\n            var isGrandTotal = item.type === GRAND_TOTAL_TYPE;\n            var isTotal = item.type === TOTAL_TYPE;\n            var isValue = item.type === DATA_TYPE;\n            var columnIsHidden = false === cellDescriptions[i].visible || isGrandTotal && (0, _array.inArray)(i, options.hiddenGrandTotals) !== -1 || isTotal && (0, _array.inArray)(i, options.hiddenTotals) !== -1 || isValue && (0, _array.inArray)(i, options.hiddenValues) !== -1;\n\n            if (columnIsHidden) {\n              continue;\n            }\n\n            item.children.push({\n              caption: cellDescriptions[i].caption,\n              path: item.path,\n              type: item.type,\n              value: i,\n              index: item.index,\n              dataIndex: i,\n              isMetric: true,\n              isEmpty: item.isEmpty && item.isEmpty[i]\n            });\n          }\n        }\n      });\n    };\n\n    var addAdditionalTotalHeaderItems = function addAdditionalTotalHeaderItems(headerItems, headerDescriptions, showTotalsPrior, isTree) {\n      showTotalsPrior = showTotalsPrior || isTree;\n      (0, _uiPivot_grid.foreachTree)(headerItems, function (items, index) {\n        var item = items[0];\n        var parentChildren = (items[1] ? items[1].children : headerItems) || [];\n        var dataField = headerDescriptions[items.length - 1];\n\n        if (item.type === DATA_TYPE && item.expanded && (false !== dataField.showTotals || isTree)) {\n          index !== -1 && parentChildren.splice(showTotalsPrior ? index : index + 1, 0, (0, _extend2.extend)({}, item, {\n            children: null,\n            type: TOTAL_TYPE,\n            expanded: showTotalsPrior ? true : null,\n            isAdditionalTotal: true\n          }));\n\n          if (showTotalsPrior) {\n            item.expanded = null;\n          }\n        }\n      });\n    };\n\n    var removeEmptyParent = function removeEmptyParent(items, index) {\n      var parent = items[index + 1];\n\n      if (!items[index].children.length && parent && parent.children) {\n        parent.children.splice((0, _array.inArray)(items[index], parent.children), 1);\n        removeEmptyParent(items, index + 1);\n      }\n    };\n\n    var removeHiddenItems = function removeHiddenItems(headerItems) {\n      (0, _uiPivot_grid.foreachTree)([{\n        children: headerItems\n      }], function (items, index) {\n        var item = items[0];\n        var parentChildren = (items[1] ? items[1].children : headerItems) || [];\n        var isEmpty = item.isEmpty;\n\n        if (isEmpty && isEmpty.length) {\n          isEmpty = item.isEmpty.filter(function (isEmpty) {\n            return isEmpty;\n          }).length === isEmpty.length;\n        }\n\n        if (item && !item.children && isEmpty) {\n          parentChildren.splice(index, 1);\n          removeEmptyParent(items, 1);\n        }\n      });\n    };\n\n    var fillHeaderInfo = function fillHeaderInfo(info, viewHeaderItems, depthSize, isHorizontal, isTree) {\n      var lastIndex = 0;\n      var index;\n      var depth;\n      var indexesByDepth = [0];\n      (0, _uiPivot_grid.foreachTree)(viewHeaderItems, function (items) {\n        var headerItem = items[0];\n        depth = headerItem.isMetric ? depthSize : items.length - 1;\n\n        while (indexesByDepth.length - 1 < depth) {\n          indexesByDepth.push(indexesByDepth[indexesByDepth.length - 1]);\n        }\n\n        index = indexesByDepth[depth] || 0;\n        lastIndex = addInfoItem(info, {\n          headerItem: headerItem,\n          index: index,\n          lastIndex: lastIndex,\n          depth: depth,\n          isHorizontal: isHorizontal,\n          isTree: isTree\n        });\n        indexesByDepth.length = depth;\n        indexesByDepth.push(lastIndex);\n      });\n    };\n\n    return function (headerItems, headerDescriptions, cellDescriptions, isHorizontal, options) {\n      var info = [];\n      var depthSize = getHeaderItemsDepth(headerItems) || 1;\n      var d = new _deferred.Deferred();\n      getViewHeaderItems(headerItems, headerDescriptions, cellDescriptions, depthSize, options).done(function (viewHeaderItems) {\n        fillHeaderInfo(info, viewHeaderItems, depthSize, isHorizontal, \"tree\" === options.layout);\n        options.notifyProgress(1);\n        d.resolve(info);\n      });\n      return d;\n    };\n  }();\n\n  function createSortPaths(headerFields, dataFields) {\n    var sortBySummaryPaths = [];\n\n    _iterator2.default.each(headerFields, function (index, headerField) {\n      var fieldIndex = _uiPivot_grid2.default.findField(dataFields, headerField.sortBySummaryField);\n\n      if (fieldIndex >= 0) {\n        sortBySummaryPaths.push((headerField.sortBySummaryPath || []).concat([fieldIndex]));\n      }\n    });\n\n    return sortBySummaryPaths;\n  }\n\n  function foreachRowInfo(rowsInfo, callback) {\n    var columnOffset = 0;\n    var columnOffsetResetIndexes = [];\n\n    for (var i = 0; i < rowsInfo.length; i++) {\n      for (var j = 0; j < rowsInfo[i].length; j++) {\n        var rowSpanOffset = (rowsInfo[i][j].rowspan || 1) - 1;\n        var visibleIndex = i + rowSpanOffset;\n\n        if (columnOffsetResetIndexes[i]) {\n          columnOffset -= columnOffsetResetIndexes[i];\n          columnOffsetResetIndexes[i] = 0;\n        }\n\n        if (false === callback(rowsInfo[i][j], visibleIndex, i, j, columnOffset)) {\n          break;\n        }\n\n        columnOffsetResetIndexes[i + (rowsInfo[i][j].rowspan || 1)] = (columnOffsetResetIndexes[i + (rowsInfo[i][j].rowspan || 1)] || 0) + 1;\n        columnOffset++;\n      }\n    }\n  }\n\n  function createCellsInfo(rowsInfo, columnsInfo, data, dataFields, dataFieldArea, errorText) {\n    var info = [];\n    var dataFieldAreaInRows = \"row\" === dataFieldArea;\n    var dataSourceCells = data.values;\n    dataSourceCells.length && foreachRowInfo(rowsInfo, function (rowInfo, rowIndex) {\n      var row = info[rowIndex] = [];\n      var dataRow = dataSourceCells[rowInfo.dataSourceIndex >= 0 ? rowInfo.dataSourceIndex : data.grandTotalRowIndex] || [];\n      rowInfo.isLast && _uiGrid_core4.default.foreachColumnInfo(columnsInfo, function (columnInfo, columnIndex) {\n        var dataIndex = (dataFieldAreaInRows ? rowInfo.dataIndex : columnInfo.dataIndex) || 0;\n        var dataField = dataFields[dataIndex];\n\n        if (columnInfo.isLast && dataField) {\n          var cell = dataRow[columnInfo.dataSourceIndex >= 0 ? columnInfo.dataSourceIndex : data.grandTotalColumnIndex];\n          var cellValue;\n\n          if (!Array.isArray(cell)) {\n            cell = [cell];\n          }\n\n          cellValue = cell[dataIndex];\n          row[columnIndex] = {\n            text: formatCellValue(cellValue, dataField, errorText),\n            value: cellValue,\n            format: dataField.format,\n            dataType: dataField.dataType,\n            columnType: columnInfo.type,\n            rowType: rowInfo.type,\n            rowPath: rowInfo.path || [],\n            columnPath: columnInfo.path || [],\n            dataIndex: dataIndex\n          };\n\n          if (dataField.width) {\n            row[columnIndex].width = dataField.width;\n          }\n        }\n      });\n    });\n    return info;\n  }\n\n  function getHeaderIndexedItems(headerItems, options) {\n    var visibleIndex = 0;\n    var indexedItems = [];\n    (0, _uiPivot_grid.foreachTree)(headerItems, function (items) {\n      var headerItem = items[0];\n      var path = (0, _uiPivot_grid.createPath)(items);\n\n      if (headerItem.children && false === options.showTotals) {\n        return;\n      }\n\n      var indexedItem = (0, _extend2.extend)(true, {}, headerItem, {\n        visibleIndex: visibleIndex++,\n        path: path\n      });\n\n      if ((0, _type.isDefined)(indexedItem.index)) {\n        indexedItems[indexedItem.index] = indexedItem;\n      } else {\n        indexedItems.push(indexedItem);\n      }\n    });\n    return indexedItems;\n  }\n\n  function createScrollController(dataController, component, dataAdapter) {\n    if (component && \"virtual\" === component.option(\"scrolling.mode\")) {\n      return new _uiGrid_core2.default.VirtualScrollController(component, (0, _extend2.extend)({\n        hasKnownLastPage: function hasKnownLastPage() {\n          return true;\n        },\n        pageCount: function pageCount() {\n          return math.ceil(this.totalItemsCount() / this.pageSize());\n        },\n        updateLoading: function updateLoading() {},\n        itemsCount: function itemsCount() {\n          if (this.pageIndex() < this.pageCount() - 1) {\n            return this.pageSize();\n          } else {\n            return this.totalItemsCount() % this.pageSize();\n          }\n        },\n        items: function items() {\n          return [];\n        },\n        viewportItems: function viewportItems() {\n          return [];\n        },\n        onChanged: function onChanged() {},\n        isLoading: function isLoading() {\n          return dataController.isLoading();\n        },\n        changingDuration: function changingDuration() {\n          var dataSource = dataController._dataSource;\n\n          if (dataSource.paginate()) {\n            return CHANGING_DURATION_IF_PAGINATE;\n          }\n\n          return dataController._changingDuration || 0;\n        }\n      }, dataAdapter));\n    }\n  }\n\n  function getHiddenTotals(dataFields) {\n    var result = [];\n\n    _iterator2.default.each(dataFields, function (index, field) {\n      if (false === field.showTotals) {\n        result.push(index);\n      }\n    });\n\n    return result;\n  }\n\n  function getHiddenValues(dataFields) {\n    var result = [];\n    dataFields.forEach(function (field, index) {\n      if (void 0 === field.showValues && false === field.showTotals || false === field.showValues) {\n        result.push(index);\n      }\n    });\n    return result;\n  }\n\n  function getHiddenGrandTotalsTotals(dataFields, columnFields) {\n    var result = [];\n\n    _iterator2.default.each(dataFields, function (index, field) {\n      if (false === field.showGrandTotals) {\n        result.push(index);\n      }\n    });\n\n    if (0 === columnFields.length && result.length === dataFields.length) {\n      result = [];\n    }\n\n    return result;\n  }\n\n  var members = {\n    ctor: function ctor(options) {\n      var that = this;\n\n      var virtualScrollControllerChanged = that._fireChanged.bind(that);\n\n      options = that._options = options || {};\n      that.dataSourceChanged = (0, _callbacks2.default)();\n      that._dataSource = that._createDataSource(options);\n      that._rowsScrollController = createScrollController(that, options.component, {\n        totalItemsCount: function totalItemsCount() {\n          return that.totalRowCount();\n        },\n        pageIndex: function pageIndex(index) {\n          return that.rowPageIndex(index);\n        },\n        pageSize: function pageSize() {\n          return that.rowPageSize();\n        },\n        load: function load() {\n          if (that._rowsScrollController.pageIndex() >= this.pageCount()) {\n            that._rowsScrollController.pageIndex(this.pageCount() - 1);\n          }\n\n          return that._rowsScrollController.handleDataChanged(function () {\n            if (that._dataSource.paginate()) {\n              that._dataSource.load();\n            } else {\n              virtualScrollControllerChanged.apply(this, arguments);\n            }\n          });\n        }\n      });\n      that._columnsScrollController = createScrollController(that, options.component, {\n        totalItemsCount: function totalItemsCount() {\n          return that.totalColumnCount();\n        },\n        pageIndex: function pageIndex(index) {\n          return that.columnPageIndex(index);\n        },\n        pageSize: function pageSize() {\n          return that.columnPageSize();\n        },\n        load: function load() {\n          if (that._columnsScrollController.pageIndex() >= this.pageCount()) {\n            that._columnsScrollController.pageIndex(this.pageCount() - 1);\n          }\n\n          return that._columnsScrollController.handleDataChanged(function () {\n            if (that._dataSource.paginate()) {\n              that._dataSource.load();\n            } else {\n              virtualScrollControllerChanged.apply(this, arguments);\n            }\n          });\n        }\n      });\n      that._stateStoringController = new _uiGrid_core6.default.StateStoringController(options.component).init();\n      that._columnsInfo = [];\n      that._rowsInfo = [];\n      that._cellsInfo = [];\n      that.expandValueChanging = (0, _callbacks2.default)();\n      that.loadingChanged = (0, _callbacks2.default)();\n      that.progressChanged = (0, _callbacks2.default)();\n      that.scrollChanged = (0, _callbacks2.default)();\n      that.load();\n\n      that._update();\n\n      that.changed = (0, _callbacks2.default)();\n    },\n    _fireChanged: function _fireChanged() {\n      var that = this;\n      var startChanging = new Date();\n      that.changed && !that._lockChanged && that.changed.fire();\n      that._changingDuration = new Date() - startChanging;\n    },\n    _correctSkipsTakes: function _correctSkipsTakes(rowIndex, rowSkip, rowSpan, levels, skips, takes) {\n      var endIndex = rowSpan ? rowIndex + rowSpan - 1 : rowIndex;\n      skips[levels.length] = skips[levels.length] || 0;\n      takes[levels.length] = takes[levels.length] || 0;\n\n      if (endIndex < rowSkip) {\n        skips[levels.length]++;\n      } else {\n        takes[levels.length]++;\n      }\n    },\n    _calculatePagingForRowExpandedPaths: function _calculatePagingForRowExpandedPaths(options, skips, takes, rowExpandedSkips, rowExpandedTakes) {\n      var rows = this._rowsInfo;\n      var rowCount = Math.min(options.rowSkip + options.rowTake, rows.length);\n      var rowExpandedPaths = options.rowExpandedPaths;\n      var levels = [];\n      var expandedPathIndexes = {};\n      var i;\n      var j;\n      var path;\n      rowExpandedPaths.forEach(function (path, index) {\n        expandedPathIndexes[path] = index;\n      });\n\n      for (i = 0; i < rowCount; i++) {\n        takes.length = skips.length = levels.length + 1;\n\n        for (j = 0; j < rows[i].length; j++) {\n          var cell = rows[i][j];\n\n          if (\"D\" === cell.type) {\n            this._correctSkipsTakes(i, options.rowSkip, cell.rowspan, levels, skips, takes);\n\n            path = cell.path || path;\n            var expandIndex = path && path.length > 1 ? expandedPathIndexes[path.slice(0, -1)] : -1;\n\n            if (expandIndex >= 0) {\n              rowExpandedSkips[expandIndex] = skips[levels.length] || 0;\n              rowExpandedTakes[expandIndex] = takes[levels.length] || 0;\n            }\n\n            if (cell.rowspan) {\n              levels.push(cell.rowspan);\n            }\n          }\n        }\n\n        levels = levels.map(function (level) {\n          return level - 1;\n        }).filter(function (level) {\n          return level > 0;\n        });\n      }\n    },\n    _calculatePagingForColumnExpandedPaths: function _calculatePagingForColumnExpandedPaths(options, skips, takes, expandedSkips, expandedTakes) {\n      var skipByPath = {};\n      var takeByPath = {};\n\n      _uiGrid_core4.default.foreachColumnInfo(this._columnsInfo, function (columnInfo, columnIndex) {\n        if (\"D\" === columnInfo.type && columnInfo.path && void 0 === columnInfo.dataIndex) {\n          var colspan = columnInfo.colspan || 1;\n          var path = columnInfo.path.slice(0, -1).toString();\n          skipByPath[path] = skipByPath[path] || 0;\n          takeByPath[path] = takeByPath[path] || 0;\n\n          if (columnIndex + colspan <= options.columnSkip) {\n            skipByPath[path]++;\n          } else {\n            if (columnIndex < options.columnSkip + options.columnTake) {\n              takeByPath[path]++;\n            }\n          }\n        }\n      });\n\n      skips[0] = skipByPath[[]];\n      takes[0] = takeByPath[[]];\n      options.columnExpandedPaths.forEach(function (path, index) {\n        var skip = skipByPath[path];\n        var take = takeByPath[path];\n\n        if (void 0 !== skip) {\n          expandedSkips[index] = skip;\n        }\n\n        if (void 0 !== take) {\n          expandedTakes[index] = take;\n        }\n      });\n    },\n    _processPagingForExpandedPaths: function _processPagingForExpandedPaths(options, area, storeLoadOptions, reload) {\n      var expandedPaths = options[area + \"ExpandedPaths\"];\n      var expandedSkips = expandedPaths.map(function () {\n        return 0;\n      });\n      var expandedTakes = expandedPaths.map(function () {\n        return reload ? options.pageSize : 0;\n      });\n      var skips = [];\n      var takes = [];\n\n      if (!reload) {\n        if (\"row\" === area) {\n          this._calculatePagingForRowExpandedPaths(options, skips, takes, expandedSkips, expandedTakes);\n        } else {\n          this._calculatePagingForColumnExpandedPaths(options, skips, takes, expandedSkips, expandedTakes);\n        }\n      }\n\n      this._savePagingForExpandedPaths(options, area, storeLoadOptions, skips[0], takes[0], expandedSkips, expandedTakes);\n    },\n    _savePagingForExpandedPaths: function _savePagingForExpandedPaths(options, area, storeLoadOptions, skip, take, expandedSkips, expandedTakes) {\n      var expandedPaths = options[area + \"ExpandedPaths\"];\n      options[area + \"ExpandedPaths\"] = [];\n      options[area + \"Skip\"] = void 0 !== skip ? skip : options[area + \"Skip\"];\n      options[area + \"Take\"] = void 0 !== take ? take : options[area + \"Take\"];\n\n      for (var i = 0; i < expandedPaths.length; i++) {\n        if (expandedTakes[i]) {\n          var _extend;\n\n          var isOppositeArea = options.area && options.area !== area;\n          storeLoadOptions.push((0, _extend2.extend)({\n            area: area,\n            headerName: area + \"s\"\n          }, options, (_extend = {}, _defineProperty(_extend, area + \"Skip\", expandedSkips[i]), _defineProperty(_extend, area + \"Take\", expandedTakes[i]), _defineProperty(_extend, isOppositeArea ? \"oppositePath\" : \"path\", expandedPaths[i]), _extend)));\n        }\n      }\n    },\n    _handleCustomizeStoreLoadOptions: function _handleCustomizeStoreLoadOptions(storeLoadOptions, reload) {\n      var _this = this;\n\n      var options = storeLoadOptions[0];\n      var rowsScrollController = this._rowsScrollController;\n\n      if (this._dataSource.paginate() && rowsScrollController) {\n        var rowPageSize = rowsScrollController._dataSource.pageSize();\n\n        if (\"rows\" === options.headerName) {\n          options.rowSkip = 0;\n          options.rowTake = rowPageSize;\n          options.rowExpandedPaths = [];\n        } else {\n          options.rowSkip = rowsScrollController.beginPageIndex() * rowPageSize;\n          options.rowTake = (rowsScrollController.endPageIndex() - rowsScrollController.beginPageIndex() + 1) * rowPageSize;\n\n          this._processPagingForExpandedPaths(options, \"row\", storeLoadOptions, reload);\n        }\n      }\n\n      var columnsScrollController = this._columnsScrollController;\n\n      if (this._dataSource.paginate() && columnsScrollController) {\n        var columnPageSize = columnsScrollController._dataSource.pageSize();\n\n        storeLoadOptions.forEach(function (options, index) {\n          if (\"columns\" === options.headerName) {\n            options.columnSkip = 0;\n            options.columnTake = columnPageSize;\n            options.columnExpandedPaths = [];\n          } else {\n            options.columnSkip = columnsScrollController.beginPageIndex() * columnPageSize;\n            options.columnTake = (columnsScrollController.endPageIndex() - columnsScrollController.beginPageIndex() + 1) * columnPageSize;\n\n            _this._processPagingForExpandedPaths(options, \"column\", storeLoadOptions, reload);\n          }\n        });\n      }\n    },\n    load: function load() {\n      var that = this;\n      var stateStoringController = this._stateStoringController;\n\n      if (stateStoringController.isEnabled() && !stateStoringController.isLoaded()) {\n        stateStoringController.load().always(function (state) {\n          if (state) {\n            that._dataSource.state(state);\n          } else {\n            that._dataSource.load();\n          }\n        });\n      } else {\n        that._dataSource.load();\n      }\n    },\n    calculateVirtualContentParams: function calculateVirtualContentParams(contentParams) {\n      var that = this;\n      var rowsScrollController = that._rowsScrollController;\n      var columnsScrollController = that._columnsScrollController;\n\n      if (rowsScrollController && columnsScrollController) {\n        rowsScrollController.viewportItemSize(contentParams.virtualRowHeight);\n        rowsScrollController.viewportSize(contentParams.viewportHeight / rowsScrollController.viewportItemSize());\n        rowsScrollController.setContentSize(contentParams.itemHeights);\n        columnsScrollController.viewportItemSize(contentParams.virtualColumnWidth);\n        columnsScrollController.viewportSize(contentParams.viewportWidth / columnsScrollController.viewportItemSize());\n        columnsScrollController.setContentSize(contentParams.itemWidths);\n\n        _common2.default.deferUpdate(function () {\n          columnsScrollController.loadIfNeed();\n          rowsScrollController.loadIfNeed();\n        });\n\n        that.scrollChanged.fire({\n          left: columnsScrollController.getViewportPosition(),\n          top: rowsScrollController.getViewportPosition()\n        });\n        return {\n          contentTop: rowsScrollController.getContentOffset(),\n          contentLeft: columnsScrollController.getContentOffset(),\n          width: columnsScrollController.getVirtualContentSize(),\n          height: rowsScrollController.getVirtualContentSize()\n        };\n      }\n    },\n    setViewportPosition: function setViewportPosition(left, top) {\n      this._rowsScrollController.setViewportPosition(top || 0);\n\n      this._columnsScrollController.setViewportPosition(left || 0);\n    },\n    subscribeToWindowScrollEvents: function subscribeToWindowScrollEvents($element) {\n      this._rowsScrollController && this._rowsScrollController.subscribeToWindowScrollEvents($element);\n    },\n    updateWindowScrollPosition: function updateWindowScrollPosition(position) {\n      this._rowsScrollController && this._rowsScrollController.scrollTo(position);\n    },\n    updateViewOptions: function updateViewOptions(options) {\n      (0, _extend2.extend)(this._options, options);\n\n      this._update();\n    },\n    _handleExpandValueChanging: function _handleExpandValueChanging(e) {\n      this.expandValueChanging.fire(e);\n    },\n    _handleLoadingChanged: function _handleLoadingChanged(isLoading) {\n      this.loadingChanged.fire(isLoading);\n    },\n    _handleProgressChanged: function _handleProgressChanged(progress) {\n      this.progressChanged.fire(progress);\n    },\n    _handleFieldsPrepared: function _handleFieldsPrepared(e) {\n      this._options.onFieldsPrepared && this._options.onFieldsPrepared(e);\n    },\n    _createDataSource: function _createDataSource(options) {\n      var that = this;\n      var dataSourceOptions = options.dataSource;\n      var dataSource;\n      that._isSharedDataSource = dataSourceOptions instanceof _data_source2.default;\n\n      if (that._isSharedDataSource) {\n        dataSource = dataSourceOptions;\n      } else {\n        dataSource = new _data_source2.default(dataSourceOptions);\n      }\n\n      that._expandValueChangingHandler = that._handleExpandValueChanging.bind(that);\n      that._loadingChangedHandler = that._handleLoadingChanged.bind(that);\n      that._fieldsPreparedHandler = that._handleFieldsPrepared.bind(that);\n      that._customizeStoreLoadOptionsHandler = that._handleCustomizeStoreLoadOptions.bind(that);\n\n      that._changedHandler = function () {\n        that._update();\n\n        that.dataSourceChanged.fire();\n      };\n\n      that._progressChangedHandler = function (progress) {\n        that._handleProgressChanged(.8 * progress);\n      };\n\n      dataSource.on(\"changed\", that._changedHandler);\n      dataSource.on(\"expandValueChanging\", that._expandValueChangingHandler);\n      dataSource.on(\"loadingChanged\", that._loadingChangedHandler);\n      dataSource.on(\"progressChanged\", that._progressChangedHandler);\n      dataSource.on(\"fieldsPrepared\", that._fieldsPreparedHandler);\n      dataSource.on(\"customizeStoreLoadOptions\", that._customizeStoreLoadOptionsHandler);\n      return dataSource;\n    },\n    getDataSource: function getDataSource() {\n      return this._dataSource;\n    },\n    isLoading: function isLoading() {\n      return this._dataSource.isLoading();\n    },\n    beginLoading: function beginLoading() {\n      this._dataSource.beginLoading();\n    },\n    endLoading: function endLoading() {\n      this._dataSource.endLoading();\n    },\n    _update: function _update() {\n      var that = this;\n      var dataSource = that._dataSource;\n      var options = that._options;\n      var columnFields = dataSource.getAreaFields(\"column\");\n      var rowFields = dataSource.getAreaFields(\"row\");\n      var dataFields = dataSource.getAreaFields(\"data\");\n      var dataFieldsForRows = \"row\" === options.dataFieldArea ? dataFields : [];\n      var dataFieldsForColumns = \"row\" !== options.dataFieldArea ? dataFields : [];\n      var data = dataSource.getData();\n      var hiddenTotals = getHiddenTotals(dataFields);\n      var hiddenValues = getHiddenValues(dataFields);\n      var hiddenGrandTotals = getHiddenGrandTotalsTotals(dataFields, columnFields);\n      var grandTotalsAreHiddenForNotAllDataFields = dataFields.length > 0 ? hiddenGrandTotals.length !== dataFields.length : true;\n\n      var notifyProgress = function notifyProgress(progress) {\n        this.progress = progress;\n\n        that._handleProgressChanged(.8 + .1 * rowOptions.progress + .1 * columnOptions.progress);\n      };\n\n      var rowOptions = {\n        isEmptyGrandTotal: data.isEmptyGrandTotalRow,\n        texts: options.texts || {},\n        hiddenTotals: hiddenTotals,\n        hiddenValues: hiddenValues,\n        hiddenGrandTotals: [],\n        showTotals: options.showRowTotals,\n        showGrandTotals: false !== options.showRowGrandTotals && grandTotalsAreHiddenForNotAllDataFields,\n        sortBySummaryPaths: createSortPaths(columnFields, dataFields),\n        showTotalsPrior: \"rows\" === options.showTotalsPrior || \"both\" === options.showTotalsPrior,\n        showEmpty: !options.hideEmptySummaryCells,\n        layout: options.rowHeaderLayout,\n        fields: rowFields,\n        dataFields: dataFields,\n        progress: 0,\n        notifyProgress: notifyProgress\n      };\n      var columnOptions = {\n        isEmptyGrandTotal: data.isEmptyGrandTotalColumn,\n        texts: options.texts || {},\n        hiddenTotals: hiddenTotals,\n        hiddenValues: hiddenValues,\n        hiddenGrandTotals: hiddenGrandTotals,\n        showTotals: options.showColumnTotals,\n        showTotalsPrior: \"columns\" === options.showTotalsPrior || \"both\" === options.showTotalsPrior,\n        showGrandTotals: false !== options.showColumnGrandTotals && grandTotalsAreHiddenForNotAllDataFields,\n        sortBySummaryPaths: createSortPaths(rowFields, dataFields),\n        showEmpty: !options.hideEmptySummaryCells,\n        fields: columnFields,\n        dataFields: dataFields,\n        progress: 0,\n        notifyProgress: notifyProgress\n      };\n\n      if (!(0, _type.isDefined)(data.grandTotalRowIndex)) {\n        data.grandTotalRowIndex = getHeaderIndexedItems(data.rows, rowOptions).length;\n      }\n\n      if (!(0, _type.isDefined)(data.grandTotalColumnIndex)) {\n        data.grandTotalColumnIndex = getHeaderIndexedItems(data.columns, columnOptions).length;\n      }\n\n      dataSource._changeLoadingCount(1);\n\n      (0, _deferred.when)(createHeaderInfo(data.columns, columnFields, dataFieldsForColumns, true, columnOptions), createHeaderInfo(data.rows, rowFields, dataFieldsForRows, false, rowOptions)).always(function () {\n        dataSource._changeLoadingCount(-1);\n      }).done(function (columnsInfo, rowsInfo) {\n        that._columnsInfo = columnsInfo;\n        that._rowsInfo = rowsInfo;\n\n        if (that._rowsScrollController && that._columnsScrollController && that.changed && !that._dataSource.paginate()) {\n          that._rowsScrollController.reset();\n\n          that._columnsScrollController.reset();\n\n          that._lockChanged = true;\n\n          that._rowsScrollController.load();\n\n          that._columnsScrollController.load();\n\n          that._lockChanged = false;\n        }\n      }).done(function () {\n        that._fireChanged();\n\n        if (that._stateStoringController.isEnabled() && !that._dataSource.isLoading()) {\n          that._stateStoringController.state(that._dataSource.state());\n\n          that._stateStoringController.save();\n        }\n      });\n    },\n    getRowsInfo: function getRowsInfo(getAllData) {\n      var that = this;\n      var rowsInfo = that._rowsInfo;\n      var scrollController = that._rowsScrollController;\n      var rowspan;\n      var i;\n\n      if (scrollController && !getAllData) {\n        var startIndex = scrollController.beginPageIndex() * that.rowPageSize();\n        var endIndex = scrollController.endPageIndex() * that.rowPageSize() + that.rowPageSize();\n        var newRowsInfo = [];\n        var maxDepth = 1;\n        foreachRowInfo(rowsInfo, function (rowInfo, visibleIndex, rowIndex, _, columnIndex) {\n          var isVisible = visibleIndex >= startIndex && rowIndex < endIndex;\n          var index = rowIndex < startIndex ? 0 : rowIndex - startIndex;\n          var cell = rowInfo;\n\n          if (isVisible) {\n            newRowsInfo[index] = newRowsInfo[index] || [];\n            rowspan = rowIndex < startIndex ? rowInfo.rowspan - (startIndex - rowIndex) || 1 : rowInfo.rowspan;\n\n            if (startIndex + index + rowspan > endIndex) {\n              rowspan = endIndex - (index + startIndex) || 1;\n            }\n\n            if (rowspan !== rowInfo.rowspan) {\n              cell = (0, _extend2.extend)({}, cell, {\n                rowspan: rowspan\n              });\n            }\n\n            newRowsInfo[index].push(cell);\n            maxDepth = math.max(maxDepth, columnIndex + 1);\n          } else {\n            if (i > endIndex) {\n              return false;\n            }\n          }\n        });\n        foreachRowInfo(newRowsInfo, function (rowInfo, visibleIndex, rowIndex, columnIndex, realColumnIndex) {\n          var colspan = rowInfo.colspan || 1;\n\n          if (realColumnIndex + colspan > maxDepth) {\n            newRowsInfo[rowIndex][columnIndex] = (0, _extend2.extend)({}, rowInfo, {\n              colspan: maxDepth - realColumnIndex || 1\n            });\n          }\n        });\n        return newRowsInfo;\n      }\n\n      return rowsInfo;\n    },\n    getColumnsInfo: function getColumnsInfo(getAllData) {\n      var that = this;\n      var info = that._columnsInfo;\n      var scrollController = that._columnsScrollController;\n\n      if (scrollController && !getAllData) {\n        var startIndex = scrollController.beginPageIndex() * that.columnPageSize();\n        var endIndex = scrollController.endPageIndex() * that.columnPageSize() + that.columnPageSize();\n        info = _uiGrid_core4.default.createColumnsInfo(info, startIndex, endIndex);\n      }\n\n      return info;\n    },\n    totalRowCount: function totalRowCount() {\n      return this._rowsInfo.length;\n    },\n    rowPageIndex: function rowPageIndex(index) {\n      if (void 0 !== index) {\n        this._rowPageIndex = index;\n      }\n\n      return this._rowPageIndex || 0;\n    },\n    totalColumnCount: function totalColumnCount() {\n      var count = 0;\n\n      if (this._columnsInfo && this._columnsInfo.length) {\n        for (var i = 0; i < this._columnsInfo[0].length; i++) {\n          count += this._columnsInfo[0][i].colspan || 1;\n        }\n      }\n\n      return count;\n    },\n    rowPageSize: function rowPageSize(size) {\n      if (void 0 !== size) {\n        this._rowPageSize = size;\n      }\n\n      return this._rowPageSize || 20;\n    },\n    columnPageSize: function columnPageSize(size) {\n      if (void 0 !== size) {\n        this._columnPageSize = size;\n      }\n\n      return this._columnPageSize || 20;\n    },\n    columnPageIndex: function columnPageIndex(index) {\n      if (void 0 !== index) {\n        this._columnPageIndex = index;\n      }\n\n      return this._columnPageIndex || 0;\n    },\n    getCellsInfo: function getCellsInfo(getAllData) {\n      var rowsInfo = this.getRowsInfo(getAllData);\n      var columnsInfo = this.getColumnsInfo(getAllData);\n\n      var data = this._dataSource.getData();\n\n      var texts = this._options.texts || {};\n      return createCellsInfo(rowsInfo, columnsInfo, data, this._dataSource.getAreaFields(\"data\"), this._options.dataFieldArea, texts.dataNotAvailable);\n    },\n    dispose: function dispose() {\n      var that = this;\n\n      if (that._isSharedDataSource) {\n        that._dataSource.off(\"changed\", that._changedHandler);\n\n        that._dataSource.off(\"expandValueChanging\", that._expandValueChangingHandler);\n\n        that._dataSource.off(\"loadingChanged\", that._loadingChangedHandler);\n\n        that._dataSource.off(\"progressChanged\", that._progressChangedHandler);\n\n        that._dataSource.off(\"fieldsPrepared\", that._fieldsPreparedHandler);\n\n        that._dataSource.off(\"customizeStoreLoadOptions\", that._customizeStoreLoadOptionsHandler);\n      } else {\n        that._dataSource.dispose();\n      }\n\n      that._columnsScrollController && that._columnsScrollController.dispose();\n      that._rowsScrollController && that._rowsScrollController.dispose();\n\n      that._stateStoringController.dispose();\n\n      that.expandValueChanging.empty();\n      that.changed.empty();\n      that.loadingChanged.empty();\n      that.progressChanged.empty();\n      that.scrollChanged.empty();\n      that.dataSourceChanged.empty();\n    }\n  };\n  proxyMethod(members, \"applyPartialDataSource\");\n  proxyMethod(members, \"collapseHeaderItem\");\n  proxyMethod(members, \"expandHeaderItem\");\n  proxyMethod(members, \"getData\");\n  proxyMethod(members, \"isEmpty\");\n  return members;\n}());","map":null,"metadata":{},"sourceType":"script"}