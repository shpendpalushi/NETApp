{"ast":null,"code":"/**\r\n * DevExtreme (viz/axes/xy_axes.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _range = require(\"../translators/range\");\n\nvar _range2 = _interopRequireDefault(_range);\n\nvar _format_helper = require(\"../../format_helper\");\n\nvar _date = require(\"../../core/utils/date\");\n\nvar _date2 = _interopRequireDefault(_date);\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _datetime_breaks = require(\"./datetime_breaks\");\n\nvar _common = require(\"../../core/utils/common\");\n\nvar _utils = require(\"../core/utils\");\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _axes_constants = require(\"./axes_constants\");\n\nvar _axes_constants2 = _interopRequireDefault(_axes_constants);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar getNextDateUnit = _date2.default.getNextDateUnit;\nvar correctDateWithUnitBeginning = _date2.default.correctDateWithUnitBeginning;\nvar _math = Math;\nvar _max = _math.max;\nvar TOP = _axes_constants2.default.top;\nvar BOTTOM = _axes_constants2.default.bottom;\nvar LEFT = _axes_constants2.default.left;\nvar RIGHT = _axes_constants2.default.right;\nvar CENTER = _axes_constants2.default.center;\nvar SCALE_BREAK_OFFSET = 3;\nvar RANGE_RATIO = .3;\nvar WAVED_LINE_CENTER = 2;\nvar WAVED_LINE_TOP = 0;\nvar WAVED_LINE_BOTTOM = 4;\nvar WAVED_LINE_LENGTH = 24;\nvar TICKS_CORRECTIONS = {\n  left: -1,\n  top: -1,\n  right: 0,\n  bottom: 0,\n  center: -.5\n};\n\nfunction prepareDatesDifferences(datesDifferences, tickInterval) {\n  var dateUnitInterval;\n  var i;\n\n  if (\"week\" === tickInterval) {\n    tickInterval = \"day\";\n  }\n\n  if (\"quarter\" === tickInterval) {\n    tickInterval = \"month\";\n  }\n\n  if (datesDifferences[tickInterval]) {\n    for (i = 0; i < _date2.default.dateUnitIntervals.length; i++) {\n      dateUnitInterval = _date2.default.dateUnitIntervals[i];\n\n      if (datesDifferences[dateUnitInterval]) {\n        datesDifferences[dateUnitInterval] = false;\n        datesDifferences.count--;\n      }\n\n      if (dateUnitInterval === tickInterval) {\n        break;\n      }\n    }\n  }\n}\n\nfunction sortingBreaks(breaks) {\n  return breaks.sort(function (a, b) {\n    return a.from - b.from;\n  });\n}\n\nfunction filterBreaks(breaks, viewport, breakStyle) {\n  var minVisible = viewport.minVisible;\n  var maxVisible = viewport.maxVisible;\n  var breakSize = breakStyle ? breakStyle.width : 0;\n  return breaks.reduce(function (result, currentBreak) {\n    var from = currentBreak.from;\n    var to = currentBreak.to;\n    var lastResult = result[result.length - 1];\n    var newBreak;\n\n    if (!(0, _type.isDefined)(from) || !(0, _type.isDefined)(to)) {\n      return result;\n    }\n\n    if (from > to) {\n      to = [from, from = to][0];\n    }\n\n    if (result.length && from < lastResult.to) {\n      if (to > lastResult.to) {\n        lastResult.to = to > maxVisible ? maxVisible : to;\n\n        if (lastResult.gapSize) {\n          lastResult.gapSize = void 0;\n          lastResult.cumulativeWidth += breakSize;\n        }\n      }\n    } else {\n      if ((from >= minVisible && from < maxVisible || to <= maxVisible && to > minVisible) && to - from < maxVisible - minVisible) {\n        from = from >= minVisible ? from : minVisible;\n        to = to <= maxVisible ? to : maxVisible;\n        newBreak = {\n          from: from,\n          to: to,\n          cumulativeWidth: (lastResult ? lastResult.cumulativeWidth : 0) + breakSize\n        };\n\n        if (currentBreak.gapSize) {\n          newBreak.gapSize = _date2.default.convertMillisecondsToDateUnits(to - from);\n          newBreak.cumulativeWidth = lastResult ? lastResult.cumulativeWidth : 0;\n        }\n\n        result.push(newBreak);\n      }\n    }\n\n    return result;\n  }, []);\n}\n\nfunction getMarkerDates(min, max, markerInterval) {\n  var origMin = min;\n  var dates;\n  min = correctDateWithUnitBeginning(min, markerInterval);\n  max = correctDateWithUnitBeginning(max, markerInterval);\n  dates = _date2.default.getSequenceByInterval(min, max, markerInterval);\n\n  if (dates.length && origMin > dates[0]) {\n    dates = dates.slice(1);\n  }\n\n  return dates;\n}\n\nfunction getStripHorizontalAlignmentPosition(alignment) {\n  var position = \"start\";\n\n  if (\"center\" === alignment) {\n    position = \"center\";\n  }\n\n  if (\"right\" === alignment) {\n    position = \"end\";\n  }\n\n  return position;\n}\n\nfunction getStripVerticalAlignmentPosition(alignment) {\n  var position = \"start\";\n\n  if (\"center\" === alignment) {\n    position = \"center\";\n  }\n\n  if (\"bottom\" === alignment) {\n    position = \"end\";\n  }\n\n  return position;\n}\n\nfunction getMarkerInterval(tickInterval) {\n  var markerInterval = getNextDateUnit(tickInterval);\n\n  if (\"quarter\" === markerInterval) {\n    markerInterval = getNextDateUnit(markerInterval);\n  }\n\n  return markerInterval;\n}\n\nfunction getMarkerFormat(curDate, prevDate, tickInterval, markerInterval) {\n  var format = markerInterval;\n\n  var datesDifferences = prevDate && _date2.default.getDatesDifferences(prevDate, curDate);\n\n  if (prevDate && \"year\" !== tickInterval) {\n    prepareDatesDifferences(datesDifferences, tickInterval);\n    format = (0, _format_helper.getDateFormatByDifferences)(datesDifferences);\n  }\n\n  return format;\n}\n\nfunction getMaxSide(act, boxes) {\n  return boxes.reduce(function (prevValue, box) {\n    return _max(prevValue, act(box));\n  }, 0);\n}\n\nfunction getDistanceByAngle(bBox, rotationAngle) {\n  rotationAngle = _math.abs(rotationAngle);\n  rotationAngle = rotationAngle % 180 >= 90 ? 90 - rotationAngle % 90 : rotationAngle % 90;\n  var a = rotationAngle * (_math.PI / 180);\n\n  if (a >= _math.atan(bBox.height / bBox.width)) {\n    return bBox.height / _math.abs(_math.sin(a));\n  } else {\n    return bBox.width;\n  }\n}\n\nfunction getMaxConstantLinePadding(constantLines) {\n  return constantLines.reduce(function (padding, options) {\n    return _max(padding, options.paddingTopBottom);\n  }, 0);\n}\n\nfunction getConstantLineLabelMarginForVerticalAlignment(constantLines, alignment, labelHeight) {\n  return constantLines.some(function (options) {\n    return options.label.verticalAlignment === alignment;\n  }) && labelHeight || 0;\n}\n\nfunction getLeftMargin(bBox) {\n  return _math.abs(bBox.x) || 0;\n}\n\nfunction getRightMargin(bBox) {\n  return _math.abs(bBox.width - _math.abs(bBox.x)) || 0;\n}\n\nfunction generateRangesOnPoints(points, edgePoints, getRange) {\n  var i;\n  var length;\n  var maxRange = null;\n  var ranges = [];\n  var curValue;\n  var prevValue;\n  var curRange;\n\n  for (i = 1, length = points.length; i < length; i++) {\n    curValue = points[i];\n    prevValue = points[i - 1];\n    curRange = getRange(curValue, prevValue);\n\n    if (edgePoints.indexOf(curValue) >= 0) {\n      if (!maxRange || curRange > maxRange.length) {\n        maxRange = {\n          start: curValue,\n          end: prevValue,\n          length: curRange\n        };\n      }\n    } else {\n      if (maxRange && curRange < maxRange.length) {\n        ranges.push(maxRange);\n      } else {\n        ranges.push({\n          start: curValue,\n          end: prevValue,\n          length: curRange\n        });\n      }\n\n      maxRange = null;\n    }\n  }\n\n  if (maxRange) {\n    ranges.push(maxRange);\n  }\n\n  return ranges;\n}\n\nfunction generateAutoBreaks(_ref, series, _ref2) {\n  var logarithmBase = _ref.logarithmBase,\n      type = _ref.type,\n      maxAutoBreakCount = _ref.maxAutoBreakCount;\n  var minVisible = _ref2.minVisible,\n      maxVisible = _ref2.maxVisible;\n  var breaks = [];\n  var getRange = \"logarithmic\" === type ? function (min, max) {\n    return _utils2.default.getLog(max / min, logarithmBase);\n  } : function (min, max) {\n    return max - min;\n  };\n  var visibleRange = getRange(minVisible, maxVisible);\n  var points = series.reduce(function (result, s) {\n    var points = s.getPointsInViewPort();\n    result[0] = result[0].concat(points[0]);\n    result[1] = result[1].concat(points[1]);\n    return result;\n  }, [[], []]);\n  var sortedAllPoints = points[0].concat(points[1]).sort(function (a, b) {\n    return b - a;\n  });\n  var edgePoints = points[1].filter(function (p) {\n    return points[0].indexOf(p) < 0;\n  });\n  var minDiff = RANGE_RATIO * visibleRange;\n  var ranges = generateRangesOnPoints(sortedAllPoints, edgePoints, getRange).sort(function (a, b) {\n    return b.length - a.length;\n  });\n  var epsilon = _math.min.apply(null, ranges.map(function (r) {\n    return r.length;\n  })) / 1e3;\n\n  var _maxAutoBreakCount = (0, _type.isDefined)(maxAutoBreakCount) ? _math.min(maxAutoBreakCount, ranges.length) : ranges.length;\n\n  for (var i = 0; i < _maxAutoBreakCount; i++) {\n    if (ranges[i].length >= minDiff) {\n      if (visibleRange <= ranges[i].length) {\n        break;\n      }\n\n      visibleRange -= ranges[i].length;\n\n      if (visibleRange > epsilon || visibleRange < -epsilon) {\n        breaks.push({\n          from: ranges[i].start,\n          to: ranges[i].end\n        });\n        minDiff = RANGE_RATIO * visibleRange;\n      }\n    } else {\n      break;\n    }\n  }\n\n  sortingBreaks(breaks);\n  return breaks;\n}\n\nmodule.exports = {\n  linear: {\n    _getStep: function _getStep(boxes, rotationAngle) {\n      var spacing = this._options.label.minSpacing;\n      var func = this._isHorizontal ? function (box) {\n        return box.width + spacing;\n      } : function (box) {\n        return box.height;\n      };\n      var maxLabelLength = getMaxSide(func, boxes);\n\n      if (rotationAngle) {\n        maxLabelLength = getDistanceByAngle({\n          width: maxLabelLength,\n          height: this._getMaxLabelHeight(boxes, 0)\n        }, rotationAngle);\n      }\n\n      return _axes_constants2.default.getTicksCountInRange(this._majorTicks, this._isHorizontal ? \"x\" : \"y\", maxLabelLength);\n    },\n    _getMaxLabelHeight: function _getMaxLabelHeight(boxes, spacing) {\n      return getMaxSide(function (box) {\n        return box.height;\n      }, boxes) + spacing;\n    },\n    _validateOverlappingMode: function _validateOverlappingMode(mode, displayMode) {\n      if (this._isHorizontal && (\"rotate\" === displayMode || \"stagger\" === displayMode) || !this._isHorizontal) {\n        return _axes_constants2.default.validateOverlappingMode(mode);\n      }\n\n      return mode;\n    },\n    _validateDisplayMode: function _validateDisplayMode(mode) {\n      return this._isHorizontal ? mode : \"standard\";\n    },\n    getMarkerTrackers: function getMarkerTrackers() {\n      return this._markerTrackers;\n    },\n    _getSharpParam: function _getSharpParam(opposite) {\n      return this._isHorizontal ^ opposite ? \"h\" : \"v\";\n    },\n    _createAxisElement: function _createAxisElement() {\n      return this._renderer.path([], \"line\");\n    },\n    _updateAxisElementPosition: function _updateAxisElementPosition() {\n      var axisCoord = this._axisPosition;\n\n      var canvas = this._getCanvasStartEnd();\n\n      this._axisElement.attr({\n        points: this._isHorizontal ? [canvas.start, axisCoord, canvas.end, axisCoord] : [axisCoord, canvas.start, axisCoord, canvas.end]\n      });\n    },\n    _getTranslatedCoord: function _getTranslatedCoord(value, offset) {\n      return this._translator.translate(value, offset);\n    },\n    _initAxisPositions: function _initAxisPositions() {\n      var that = this;\n      var position = that._options.position;\n      that._axisPosition = that._orthogonalPositions[\"top\" === position || \"left\" === position ? \"start\" : \"end\"];\n    },\n    _getTickMarkPoints: function _getTickMarkPoints(coords, length, tickOptions) {\n      var isHorizontal = this._isHorizontal;\n      var options = this._options;\n      var tickStartCoord;\n\n      if ((0, _type.isDefined)(options.tickOrientation)) {\n        tickStartCoord = TICKS_CORRECTIONS[options.tickOrientation] * length;\n      } else {\n        var shift = tickOptions.shift || 0;\n\n        if (\"left\" === options.position || \"top\" === options.position) {\n          shift = -shift;\n        }\n\n        tickStartCoord = shift + this.getTickStartPositionShift(length);\n      }\n\n      return [coords.x + (isHorizontal ? 0 : tickStartCoord), coords.y + (isHorizontal ? tickStartCoord : 0), coords.x + (isHorizontal ? 0 : tickStartCoord + length), coords.y + (isHorizontal ? tickStartCoord + length : 0)];\n    },\n    getTickStartPositionShift: function getTickStartPositionShift(length) {\n      var options = this._options;\n      return length % 2 === 1 ? options.width % 2 === 0 && (\"left\" === options.position || \"top\" === options.position) || options.width % 2 === 1 && (\"right\" === options.position || \"bottom\" === options.position) ? Math.floor(-length / 2) : -Math.floor(length / 2) : -length / 2 + (options.width % 2 === 0 ? 0 : \"bottom\" === options.position || \"right\" === options.position ? -1 : 1);\n    },\n    _getTitleCoords: function _getTitleCoords() {\n      var that = this;\n      var horizontal = that._isHorizontal;\n      var x = that._axisPosition;\n      var y = that._axisPosition;\n      var align = that._options.title.alignment;\n\n      var canvas = that._getCanvasStartEnd();\n\n      var fromStartToEnd = horizontal || that._options.position === LEFT;\n      var canvasStart = fromStartToEnd ? canvas.start : canvas.end;\n      var canvasEnd = fromStartToEnd ? canvas.end : canvas.start;\n      var coord = align === LEFT ? canvasStart : align === RIGHT ? canvasEnd : canvas.start + (canvas.end - canvas.start) / 2;\n\n      if (horizontal) {\n        x = coord;\n      } else {\n        y = coord;\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    },\n    _drawTitleText: function _drawTitleText(group, coords) {\n      var options = this._options;\n      var titleOptions = options.title;\n      var attrs = {\n        opacity: titleOptions.opacity,\n        align: titleOptions.alignment,\n        \"class\": titleOptions.cssClass\n      };\n\n      if (!titleOptions.text || !group) {\n        return;\n      }\n\n      coords = coords || this._getTitleCoords();\n\n      if (!this._isHorizontal) {\n        attrs.rotate = options.position === LEFT ? 270 : 90;\n      }\n\n      var text = this._renderer.text(titleOptions.text, coords.x, coords.y).css(_utils2.default.patchFontOptions(titleOptions.font)).attr(attrs).append(group);\n\n      this._checkTitleOverflow(text);\n\n      return text;\n    },\n    _updateTitleCoords: function _updateTitleCoords() {\n      this._title && this._title.element.attr(this._getTitleCoords());\n    },\n    _drawTitle: function _drawTitle() {\n      var title = this._drawTitleText(this._axisTitleGroup);\n\n      if (title) {\n        this._title = {\n          element: title\n        };\n      }\n    },\n    _measureTitle: function _measureTitle() {\n      if (this._title) {\n        if (this._title.bBox && !this._title.originalSize) {\n          this._title.originalSize = this._title.bBox;\n        }\n\n        this._title.bBox = this._title.element.getBBox();\n      }\n    },\n    _drawDateMarker: function _drawDateMarker(date, options, range) {\n      var that = this;\n      var markerOptions = that._options.marker;\n\n      var invert = that._translator.getBusinessRange().invert;\n\n      var textIndent = markerOptions.width + markerOptions.textLeftIndent;\n      var text;\n      var pathElement;\n\n      if (null === options.x) {\n        return;\n      }\n\n      if (!options.withoutStick) {\n        pathElement = that._renderer.path([options.x, options.y, options.x, options.y + markerOptions.separatorHeight], \"line\").attr({\n          \"stroke-width\": markerOptions.width,\n          stroke: markerOptions.color,\n          \"stroke-opacity\": markerOptions.opacity,\n          sharp: \"h\"\n        }).append(that._axisElementsGroup);\n      }\n\n      text = String(that.formatLabel(date, options.labelOptions, range));\n      return {\n        date: date,\n        x: options.x,\n        y: options.y,\n        cropped: options.withoutStick,\n        label: that._renderer.text(text, options.x, options.y).css(_utils2.default.patchFontOptions(markerOptions.label.font)).append(that._axisElementsGroup),\n        line: pathElement,\n        getEnd: function getEnd() {\n          return this.x + (invert ? -1 : 1) * (textIndent + this.labelBBox.width);\n        },\n        setTitle: function setTitle() {\n          this.title = text;\n        },\n        hideLabel: function hideLabel() {\n          this.label.dispose();\n          this.label = null;\n          this.title = text;\n        },\n        hide: function hide() {\n          if (pathElement) {\n            pathElement.dispose();\n            pathElement = null;\n          }\n\n          this.label.dispose();\n          this.label = null;\n          this.hidden = true;\n        }\n      };\n    },\n    _drawDateMarkers: function _drawDateMarkers() {\n      var that = this;\n      var options = that._options;\n      var translator = that._translator;\n\n      var viewport = that._getViewportRange();\n\n      var minBound = viewport.minVisible;\n      var tickInterval;\n      var markerInterval;\n      var markerDates;\n      var dateMarkers = [];\n      var markersAreaTop;\n      var dateMarker;\n\n      function draw(markerDate, format, withoutStick) {\n        return that._drawDateMarker(markerDate, {\n          x: translator.translate(markerDate),\n          y: markersAreaTop,\n          labelOptions: that._getLabelFormatOptions(format),\n          withoutStick: withoutStick\n        }, viewport);\n      }\n\n      if (viewport.isEmpty() || !options.marker.visible || \"datetime\" !== options.argumentType || \"discrete\" === options.type || that._majorTicks.length <= 1) {\n        return [];\n      }\n\n      markersAreaTop = that._axisPosition + options.marker.topIndent;\n      tickInterval = _date2.default.getDateUnitInterval(this._tickInterval);\n      markerInterval = getMarkerInterval(tickInterval);\n      markerDates = getMarkerDates(minBound, viewport.maxVisible, markerInterval);\n\n      if (markerDates.length > 1 || 1 === markerDates.length && minBound < markerDates[0]) {\n        dateMarkers = markerDates.reduce(function (markers, curDate, i, dates) {\n          var marker = draw(curDate, getMarkerFormat(curDate, dates[i - 1] || minBound < curDate && minBound, tickInterval, markerInterval));\n          marker && markers.push(marker);\n          return markers;\n        }, []);\n\n        if (minBound < markerDates[0]) {\n          dateMarker = draw(minBound, getMarkerFormat(minBound, markerDates[0], tickInterval, markerInterval), true);\n          dateMarker && dateMarkers.unshift(dateMarker);\n        }\n      }\n\n      return dateMarkers;\n    },\n    _adjustDateMarkers: function _adjustDateMarkers(offset) {\n      offset = offset || 0;\n      var that = this;\n      var markerOptions = this._options.marker;\n      var textIndent = markerOptions.width + markerOptions.textLeftIndent;\n\n      var invert = this._translator.getBusinessRange().invert;\n\n      var canvas = that._getCanvasStartEnd();\n\n      var dateMarkers = this._dateMarkers;\n\n      if (!dateMarkers.length) {\n        return offset;\n      }\n\n      if (dateMarkers[0].cropped) {\n        if (!this._checkMarkersPosition(invert, dateMarkers[1], dateMarkers[0])) {\n          dateMarkers[0].hideLabel();\n        }\n      }\n\n      var prevDateMarker;\n      dateMarkers.forEach(function (marker, i, markers) {\n        if (marker.cropped) {\n          return;\n        }\n\n        if (invert ? marker.getEnd() < canvas.end : marker.getEnd() > canvas.end) {\n          marker.hideLabel();\n        } else {\n          if (that._checkMarkersPosition(invert, marker, prevDateMarker)) {\n            prevDateMarker = marker;\n          } else {\n            marker.hide();\n          }\n        }\n      });\n\n      this._dateMarkers.forEach(function (marker) {\n        if (marker.label) {\n          var labelBBox = marker.labelBBox;\n          var dy = marker.y + markerOptions.textTopIndent - labelBBox.y;\n          marker.label.attr({\n            translateX: invert ? marker.x - textIndent - labelBBox.x - labelBBox.width : marker.x + textIndent - labelBBox.x,\n            translateY: dy + offset\n          });\n        }\n\n        if (marker.line) {\n          marker.line.attr({\n            translateY: offset\n          });\n        }\n      });\n\n      that._initializeMarkersTrackers(offset);\n\n      return offset + markerOptions.topIndent + markerOptions.separatorHeight;\n    },\n    _checkMarkersPosition: function _checkMarkersPosition(invert, dateMarker, prevDateMarker) {\n      if (void 0 === prevDateMarker) {\n        return true;\n      }\n\n      return invert ? dateMarker.x < prevDateMarker.getEnd() : dateMarker.x > prevDateMarker.getEnd();\n    },\n    _initializeMarkersTrackers: function _initializeMarkersTrackers(offset) {\n      var that = this;\n      var separatorHeight = that._options.marker.separatorHeight;\n      var renderer = that._renderer;\n\n      var businessRange = this._translator.getBusinessRange();\n\n      var canvas = that._getCanvasStartEnd();\n\n      var group = that._axisElementsGroup;\n      that._markerTrackers = this._dateMarkers.filter(function (marker) {\n        return !marker.hidden;\n      }).map(function (marker, i, markers) {\n        var nextMarker = markers[i + 1] || {\n          x: canvas.end,\n          date: businessRange.max\n        };\n        var x = marker.x;\n        var y = marker.y + offset;\n        var markerTracker = renderer.path([x, y, x, y + separatorHeight, nextMarker.x, y + separatorHeight, nextMarker.x, y, x, y], \"area\").attr({\n          \"stroke-width\": 1,\n          stroke: \"grey\",\n          fill: \"grey\",\n          opacity: 1e-4\n        }).append(group);\n        markerTracker.data(\"range\", {\n          startValue: marker.date,\n          endValue: nextMarker.date\n        });\n\n        if (marker.title) {\n          markerTracker.setTitle(marker.title);\n        }\n\n        return markerTracker;\n      });\n    },\n    _getLabelFormatOptions: function _getLabelFormatOptions(formatString) {\n      var that = this;\n      var markerLabelOptions = that._markerLabelOptions;\n\n      if (!markerLabelOptions) {\n        that._markerLabelOptions = markerLabelOptions = (0, _extend.extend)(true, {}, that._options.marker.label);\n      }\n\n      if (!(0, _type.isDefined)(that._options.marker.label.format)) {\n        markerLabelOptions.format = formatString;\n      }\n\n      return markerLabelOptions;\n    },\n    _adjustConstantLineLabels: function _adjustConstantLineLabels(constantLines) {\n      var that = this;\n      var axisPosition = that._options.position;\n      var canvas = that.getCanvas();\n      var canvasLeft = canvas.left;\n      var canvasRight = canvas.width - canvas.right;\n      var canvasTop = canvas.top;\n      var canvasBottom = canvas.height - canvas.bottom;\n      var verticalCenter = canvasTop + (canvasBottom - canvasTop) / 2;\n      var horizontalCenter = canvasLeft + (canvasRight - canvasLeft) / 2;\n      var maxLabel = 0;\n      constantLines.forEach(function (item) {\n        var isHorizontal = that._isHorizontal;\n        var linesOptions = item.options;\n        var paddingTopBottom = linesOptions.paddingTopBottom;\n        var paddingLeftRight = linesOptions.paddingLeftRight;\n        var labelOptions = linesOptions.label;\n        var labelVerticalAlignment = labelOptions.verticalAlignment;\n        var labelHorizontalAlignment = labelOptions.horizontalAlignment;\n        var labelIsInside = \"inside\" === labelOptions.position;\n        var label = item.label;\n        var box = item.labelBBox;\n        var translateX;\n        var translateY;\n\n        if (null === label || box.isEmpty) {\n          return;\n        }\n\n        if (isHorizontal) {\n          if (labelIsInside) {\n            if (labelHorizontalAlignment === LEFT) {\n              translateX = item.coord - paddingLeftRight - box.x - box.width;\n            } else {\n              translateX = item.coord + paddingLeftRight - box.x;\n            }\n\n            switch (labelVerticalAlignment) {\n              case CENTER:\n                translateY = verticalCenter - box.y - box.height / 2;\n                break;\n\n              case BOTTOM:\n                translateY = canvasBottom - paddingTopBottom - box.y - box.height;\n                break;\n\n              default:\n                translateY = canvasTop + paddingTopBottom - box.y;\n            }\n          } else {\n            if (axisPosition === labelVerticalAlignment) {\n              maxLabel = _max(maxLabel, box.height + paddingTopBottom);\n            }\n\n            translateX = item.coord - box.x - box.width / 2;\n\n            if (labelVerticalAlignment === BOTTOM) {\n              translateY = canvasBottom + paddingTopBottom - box.y;\n            } else {\n              translateY = canvasTop - paddingTopBottom - box.y - box.height;\n            }\n          }\n        } else {\n          if (labelIsInside) {\n            if (labelVerticalAlignment === BOTTOM) {\n              translateY = item.coord + paddingTopBottom - box.y;\n            } else {\n              translateY = item.coord - paddingTopBottom - box.y - box.height;\n            }\n\n            switch (labelHorizontalAlignment) {\n              case CENTER:\n                translateX = horizontalCenter - box.x - box.width / 2;\n                break;\n\n              case RIGHT:\n                translateX = canvasRight - paddingLeftRight - box.x - box.width;\n                break;\n\n              default:\n                translateX = canvasLeft + paddingLeftRight - box.x;\n            }\n          } else {\n            if (axisPosition === labelHorizontalAlignment) {\n              maxLabel = _max(maxLabel, box.width + paddingLeftRight);\n            }\n\n            translateY = item.coord - box.y - box.height / 2;\n\n            if (labelHorizontalAlignment === RIGHT) {\n              translateX = canvasRight + paddingLeftRight - box.x;\n            } else {\n              translateX = canvasLeft - paddingLeftRight - box.x - box.width;\n            }\n          }\n        }\n\n        label.attr({\n          translateX: translateX,\n          translateY: translateY\n        });\n      });\n      return maxLabel;\n    },\n    _drawConstantLinesForEstimating: function _drawConstantLinesForEstimating(constantLines) {\n      var that = this;\n      var renderer = this._renderer;\n      var group = renderer.g();\n      constantLines.forEach(function (options) {\n        that._drawConstantLineLabelText(options.label.text, 0, 0, options.label, group).attr({\n          align: \"center\"\n        });\n      });\n      return group.append(renderer.root);\n    },\n    _estimateLabelHeight: function _estimateLabelHeight(bBox, labelOptions) {\n      var height = bBox.height;\n      var drawingType = labelOptions.drawingType;\n\n      if (\"stagger\" === this._validateDisplayMode(drawingType) || \"stagger\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\n        height = 2 * height + labelOptions.staggeringSpacing;\n      }\n\n      if (\"rotate\" === this._validateDisplayMode(drawingType) || \"rotate\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\n        var sinCos = _utils2.default.getCosAndSin(labelOptions.rotationAngle);\n\n        height = height * sinCos.cos + bBox.width * sinCos.sin;\n      }\n\n      return height && (height + labelOptions.indentFromAxis || 0) || 0;\n    },\n    estimateMargins: function estimateMargins(canvas) {\n      this.updateCanvas(canvas);\n      var that = this;\n\n      var range = that._getViewportRange();\n\n      var ticksData = this._createTicksAndLabelFormat(range);\n\n      var ticks = ticksData.ticks;\n      var tickInterval = ticksData.tickInterval;\n      var options = this._options;\n\n      var constantLineOptions = that._outsideConstantLines.filter(function (l) {\n        return l.labelOptions.visible;\n      }).map(function (l) {\n        return l.options;\n      });\n\n      var rootElement = that._renderer.root;\n      var labelIsVisible = options.label.visible && !range.isEmpty() && ticks.length;\n      var labelValue = labelIsVisible && that.formatLabel(ticks[ticks.length - 1], options.label, void 0, void 0, tickInterval, ticks);\n\n      var labelElement = labelIsVisible && that._renderer.text(labelValue, 0, 0).css(that._textFontStyles).attr(that._textOptions).append(rootElement);\n\n      var titleElement = that._drawTitleText(rootElement, {\n        x: 0,\n        y: 0\n      });\n\n      var constantLinesLabelsElement = that._drawConstantLinesForEstimating(constantLineOptions);\n\n      var labelBox = labelElement && labelElement.getBBox() || {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n      var titleBox = titleElement && titleElement.getBBox() || {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n      var constantLinesBox = constantLinesLabelsElement.getBBox();\n      var titleHeight = titleBox.height ? titleBox.height + options.title.margin : 0;\n\n      var labelHeight = that._estimateLabelHeight(labelBox, options.label);\n\n      var constantLinesHeight = constantLinesBox.height ? constantLinesBox.height + getMaxConstantLinePadding(constantLineOptions) : 0;\n      var height = labelHeight + titleHeight;\n      var margins = {\n        left: _max(getLeftMargin(labelBox), getLeftMargin(constantLinesBox)),\n        right: _max(getRightMargin(labelBox), getRightMargin(constantLinesBox)),\n        top: (\"top\" === options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"top\", constantLinesHeight),\n        bottom: (\"top\" !== options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"bottom\", constantLinesHeight)\n      };\n      labelElement && labelElement.remove();\n      titleElement && titleElement.remove();\n      constantLinesLabelsElement && constantLinesLabelsElement.remove();\n      return margins;\n    },\n    _checkAlignmentConstantLineLabels: function _checkAlignmentConstantLineLabels(labelOptions) {\n      var position = labelOptions.position;\n      var verticalAlignment = (labelOptions.verticalAlignment || \"\").toLowerCase();\n      var horizontalAlignment = (labelOptions.horizontalAlignment || \"\").toLowerCase();\n\n      if (this._isHorizontal) {\n        if (\"outside\" === position) {\n          verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\n          horizontalAlignment = CENTER;\n        } else {\n          verticalAlignment = verticalAlignment === CENTER ? CENTER : verticalAlignment === BOTTOM ? BOTTOM : TOP;\n          horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT;\n        }\n      } else {\n        if (\"outside\" === position) {\n          verticalAlignment = CENTER;\n          horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT;\n        } else {\n          verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\n          horizontalAlignment = horizontalAlignment === RIGHT ? RIGHT : horizontalAlignment === CENTER ? CENTER : LEFT;\n        }\n      }\n\n      labelOptions.verticalAlignment = verticalAlignment;\n      labelOptions.horizontalAlignment = horizontalAlignment;\n    },\n    _getConstantLineLabelsCoords: function _getConstantLineLabelsCoords(value, lineLabelOptions) {\n      var that = this;\n      var x = value;\n      var y = value;\n\n      if (that._isHorizontal) {\n        y = that._orthogonalPositions[\"top\" === lineLabelOptions.verticalAlignment ? \"start\" : \"end\"];\n      } else {\n        x = that._orthogonalPositions[\"right\" === lineLabelOptions.horizontalAlignment ? \"end\" : \"start\"];\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    },\n    _getAdjustedStripLabelCoords: function _getAdjustedStripLabelCoords(strip) {\n      var stripOptions = strip.options;\n      var paddingTopBottom = stripOptions.paddingTopBottom;\n      var paddingLeftRight = stripOptions.paddingLeftRight;\n      var horizontalAlignment = stripOptions.label.horizontalAlignment;\n      var verticalAlignment = stripOptions.label.verticalAlignment;\n      var box = strip.labelBBox;\n      var labelHeight = box.height;\n      var labelWidth = box.width;\n      var labelCoords = strip.labelCoords;\n      var y = labelCoords.y - box.y;\n      var x = labelCoords.x - box.x;\n\n      if (verticalAlignment === TOP) {\n        y += paddingTopBottom;\n      } else {\n        if (verticalAlignment === CENTER) {\n          y -= labelHeight / 2;\n        } else {\n          if (verticalAlignment === BOTTOM) {\n            y -= paddingTopBottom + labelHeight;\n          }\n        }\n      }\n\n      if (horizontalAlignment === LEFT) {\n        x += paddingLeftRight;\n      } else {\n        if (horizontalAlignment === CENTER) {\n          x -= labelWidth / 2;\n        } else {\n          if (horizontalAlignment === RIGHT) {\n            x -= paddingLeftRight + labelWidth;\n          }\n        }\n      }\n\n      return {\n        translateX: x,\n        translateY: y\n      };\n    },\n    _adjustTitle: function _adjustTitle(offset) {\n      offset = offset || 0;\n\n      if (!this._title) {\n        return;\n      }\n\n      var that = this;\n      var options = that._options;\n      var position = options.position;\n      var margin = options.title.margin;\n      var title = that._title;\n      var boxTitle = title.bBox;\n      var x = boxTitle.x;\n      var y = boxTitle.y;\n      var width = boxTitle.width;\n      var height = boxTitle.height;\n      var axisPosition = that._axisPosition;\n      var loCoord = axisPosition - margin - offset;\n      var hiCoord = axisPosition + margin + offset;\n      var params = {};\n\n      if (that._isHorizontal) {\n        if (position === TOP) {\n          params.translateY = loCoord - (y + height);\n        } else {\n          params.translateY = hiCoord - y;\n        }\n      } else {\n        if (position === LEFT) {\n          params.translateX = loCoord - (x + width);\n        } else {\n          params.translateX = hiCoord - x;\n        }\n      }\n\n      title.element.attr(params);\n    },\n    _checkTitleOverflow: function _checkTitleOverflow(titleElement) {\n      if (!this._title && !titleElement) {\n        return;\n      }\n\n      var canvasLength = this._getScreenDelta();\n\n      var title = titleElement ? {\n        bBox: titleElement.getBBox(),\n        element: titleElement\n      } : this._title;\n      var titleOptions = this._options.title;\n      var boxTitle = title.bBox;\n\n      if ((this._isHorizontal ? boxTitle.width : boxTitle.height) > canvasLength) {\n        title.element.setMaxSize(canvasLength, void 0, {\n          wordWrap: titleOptions.wordWrap || \"none\",\n          textOverflow: titleOptions.textOverflow || \"ellipsis\"\n        });\n        this._wrapped = titleOptions.wordWrap && \"none\" !== titleOptions.wordWrap;\n      } else {\n        var moreThanOriginalSize = title.originalSize && canvasLength > (this._isHorizontal ? title.originalSize.width : title.originalSize.height);\n        !this._wrapped && moreThanOriginalSize && title.element.restoreText();\n      }\n    },\n    coordsIn: function coordsIn(x, y) {\n      var canvas = this.getCanvas();\n      var isHorizontal = this._options.isHorizontal;\n      var position = this._options.position;\n      var coord = isHorizontal ? y : x;\n\n      if (isHorizontal && (x < canvas.left || x > canvas.width - canvas.right) || !isHorizontal && (y < canvas.top || y > canvas.height - canvas.bottom)) {\n        return false;\n      }\n\n      if (isHorizontal && position === _axes_constants2.default.top || !isHorizontal && position === _axes_constants2.default.left) {\n        return coord < canvas[position];\n      }\n\n      return coord > canvas[isHorizontal ? \"height\" : \"width\"] - canvas[position];\n    },\n    _boundaryTicksVisibility: {\n      min: true,\n      max: true\n    },\n    adjust: function adjust(alignToBounds) {\n      var that = this;\n      var seriesData = that._seriesData;\n      var viewport = {\n        min: seriesData.min,\n        max: seriesData.max\n      };\n\n      if (!alignToBounds) {\n        viewport = that._series.filter(function (s) {\n          return s.isVisible();\n        }).reduce(function (range, s) {\n          var seriesRange = s.getViewport();\n          range.min = (0, _type.isDefined)(seriesRange.min) ? range.min < seriesRange.min ? range.min : seriesRange.min : range.min;\n          range.max = (0, _type.isDefined)(seriesRange.max) ? range.max > seriesRange.max ? range.max : seriesRange.max : range.max;\n\n          if (s.showZero) {\n            range = new _range2.default.Range(range);\n            range.correctValueZeroLevel();\n          }\n\n          return range;\n        }, {});\n      }\n\n      if ((0, _type.isDefined)(viewport.min) && (0, _type.isDefined)(viewport.max)) {\n        seriesData.minVisible = viewport.min;\n        seriesData.maxVisible = viewport.max;\n      }\n\n      that._translator.updateBusinessRange(that.adjustViewport(seriesData));\n\n      that._breaks = that._getScaleBreaks(that._options, {\n        minVisible: seriesData.minVisible,\n        maxVisible: seriesData.maxVisible\n      }, that._series, that.isArgumentAxis);\n    },\n    hasWrap: function hasWrap() {\n      return this._wrapped;\n    },\n    getAxisPosition: function getAxisPosition() {\n      return this._axisPosition;\n    },\n    _getStick: function _getStick() {\n      return !this._options.valueMarginsEnabled;\n    },\n    _getStripLabelCoords: function _getStripLabelCoords(from, to, stripLabelOptions) {\n      var that = this;\n      var orthogonalPositions = that._orthogonalPositions;\n      var isHorizontal = that._isHorizontal;\n      var horizontalAlignment = stripLabelOptions.horizontalAlignment;\n      var verticalAlignment = stripLabelOptions.verticalAlignment;\n      var x;\n      var y;\n\n      if (isHorizontal) {\n        if (horizontalAlignment === CENTER) {\n          x = from + (to - from) / 2;\n        } else {\n          if (horizontalAlignment === LEFT) {\n            x = from;\n          } else {\n            if (horizontalAlignment === RIGHT) {\n              x = to;\n            }\n          }\n        }\n\n        y = orthogonalPositions[getStripVerticalAlignmentPosition(verticalAlignment)];\n      } else {\n        x = orthogonalPositions[getStripHorizontalAlignmentPosition(horizontalAlignment)];\n\n        if (verticalAlignment === TOP) {\n          y = from;\n        } else {\n          if (verticalAlignment === CENTER) {\n            y = to + (from - to) / 2;\n          } else {\n            if (verticalAlignment === BOTTOM) {\n              y = to;\n            }\n          }\n        }\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    },\n    _getTranslatedValue: function _getTranslatedValue(value, offset) {\n      var pos1 = this._translator.translate(value, offset, \"semidiscrete\" === this._options.type && this._options.tickInterval);\n\n      var pos2 = this._axisPosition;\n      var isHorizontal = this._isHorizontal;\n      return {\n        x: isHorizontal ? pos1 : pos2,\n        y: isHorizontal ? pos2 : pos1\n      };\n    },\n    areCoordsOutsideAxis: function areCoordsOutsideAxis(coords) {\n      var coord = this._isHorizontal ? coords.x : coords.y;\n      var visibleArea = this.getVisibleArea();\n\n      if (coord < visibleArea[0] || coord > visibleArea[1]) {\n        return true;\n      }\n\n      return false;\n    },\n    _getSkippedCategory: function _getSkippedCategory(ticks) {\n      var skippedCategory;\n\n      if (this._options.type === _axes_constants2.default.discrete && this._tickOffset && 0 !== ticks.length) {\n        skippedCategory = ticks[ticks.length - 1];\n      }\n\n      return skippedCategory;\n    },\n    _getScaleBreaks: function _getScaleBreaks(axisOptions, viewport, series, isArgumentAxis) {\n      var that = this;\n      var breaks = (axisOptions.breaks || []).map(function (b) {\n        return {\n          from: that.parser(b.startValue),\n          to: that.parser(b.endValue)\n        };\n      });\n\n      if (\"discrete\" !== axisOptions.type && \"datetime\" === axisOptions.dataType && axisOptions.workdaysOnly) {\n        breaks = breaks.concat((0, _datetime_breaks.generateDateBreaks)(viewport.minVisible, viewport.maxVisible, axisOptions.workWeek, axisOptions.singleWorkdays, axisOptions.holidays));\n      }\n\n      if (!isArgumentAxis && \"discrete\" !== axisOptions.type && \"datetime\" !== axisOptions.dataType && axisOptions.autoBreaksEnabled && 0 !== axisOptions.maxAutoBreakCount) {\n        breaks = breaks.concat(generateAutoBreaks(axisOptions, series, viewport));\n      }\n\n      return filterBreaks(sortingBreaks(breaks), viewport, axisOptions.breakStyle);\n    },\n    _drawBreak: function _drawBreak(translatedEnd, positionFrom, positionTo, width, options, group) {\n      var that = this;\n      var breakStart = translatedEnd - (!that._translator.isInverted() ? width + 1 : 0);\n      var attr = {\n        \"stroke-width\": 1,\n        stroke: options.borderColor,\n        sharp: !options.isWaved ? options.isHorizontal ? \"h\" : \"v\" : void 0\n      };\n      var spaceAttr = {\n        stroke: options.color,\n        \"stroke-width\": width\n      };\n      var getPoints = that._isHorizontal ? rotateLine : function (p) {\n        return p;\n      };\n      var drawer = getLineDrawer(that._renderer, group, getPoints, positionFrom, breakStart, positionTo, options.isWaved);\n      drawer(width / 2, spaceAttr);\n      drawer(0, attr);\n      drawer(width, attr);\n    },\n    _createBreakClipRect: function _createBreakClipRect(from, to) {\n      var that = this;\n      var canvas = that._canvas;\n      var clipWidth = to - from;\n      var clipRect;\n\n      if (that._isHorizontal) {\n        clipRect = that._renderer.clipRect(canvas.left, from, canvas.width, clipWidth);\n      } else {\n        clipRect = that._renderer.clipRect(from, canvas.top, clipWidth, canvas.height);\n      }\n\n      that._breaksElements = that._breaksElements || [];\n\n      that._breaksElements.push(clipRect);\n\n      return clipRect.id;\n    },\n    _createBreaksGroup: function _createBreaksGroup(clipFrom, clipTo) {\n      var that = this;\n\n      var group = that._renderer.g().attr({\n        \"class\": that._axisCssPrefix + \"breaks\",\n        \"clip-path\": that._createBreakClipRect(clipFrom, clipTo)\n      }).append(that._scaleBreaksGroup);\n\n      that._breaksElements = that._breaksElements || [];\n\n      that._breaksElements.push(group);\n\n      return group;\n    },\n    _disposeBreaksGroup: function _disposeBreaksGroup() {\n      (this._breaksElements || []).forEach(function (clipRect) {\n        clipRect.dispose();\n      });\n      this._breaksElements = null;\n    },\n    drawScaleBreaks: function drawScaleBreaks(customCanvas) {\n      var that = this;\n      var options = that._options;\n      var breakStyle = options.breakStyle;\n      var position = options.position;\n      var positionFrom;\n      var positionTo;\n      var breaks = that._translator.getBusinessRange().breaks || [];\n      var additionGroup;\n      var additionBreakFrom;\n      var additionBreakTo;\n      var mainGroup;\n      var breakOptions;\n\n      that._disposeBreaksGroup();\n\n      if (!(breaks && breaks.length)) {\n        return;\n      }\n\n      breakOptions = {\n        color: that._options.containerColor,\n        borderColor: breakStyle.color,\n        isHorizontal: that._isHorizontal,\n        isWaved: \"straight\" !== breakStyle.line.toLowerCase()\n      };\n\n      if (customCanvas) {\n        positionFrom = customCanvas.start;\n        positionTo = customCanvas.end;\n      } else {\n        positionFrom = that._orthogonalPositions.start - (options.visible && !that._axisShift && (\"left\" === position || \"top\" === position) ? SCALE_BREAK_OFFSET : 0);\n        positionTo = that._orthogonalPositions.end + (options.visible && (\"right\" === position || \"bottom\" === position) ? SCALE_BREAK_OFFSET : 0);\n      }\n\n      mainGroup = that._createBreaksGroup(positionFrom, positionTo);\n\n      if (that._axisShift && options.visible) {\n        additionBreakFrom = that._axisPosition - that._axisShift - SCALE_BREAK_OFFSET;\n        additionBreakTo = additionBreakFrom + 2 * SCALE_BREAK_OFFSET;\n        additionGroup = that._createBreaksGroup(additionBreakFrom, additionBreakTo);\n      }\n\n      breaks.forEach(function (br) {\n        if (!br.gapSize) {\n          var breakCoord = that._getTranslatedCoord(br.to);\n\n          that._drawBreak(breakCoord, positionFrom, positionTo, breakStyle.width, breakOptions, mainGroup);\n\n          if (that._axisShift && options.visible) {\n            that._drawBreak(breakCoord, additionBreakFrom, additionBreakTo, breakStyle.width, breakOptions, additionGroup);\n          }\n        }\n      });\n    },\n    _getSpiderCategoryOption: _common.noop,\n    shift: function shift(margins) {\n      var that = this;\n      var options = that._options;\n      var isHorizontal = options.isHorizontal;\n      var axesSpacing = that.getMultipleAxesSpacing();\n      var constantLinesGroups = that._axisConstantLineGroups;\n\n      function shiftGroup(side, group) {\n        var attr = {\n          translateX: 0,\n          translateY: 0\n        };\n        var shift = margins[side] ? margins[side] + axesSpacing : 0;\n        attr[isHorizontal ? \"translateY\" : \"translateX\"] = (\"left\" === side || \"top\" === side ? -1 : 1) * shift;\n        (group[side] || group).attr(attr);\n        return shift;\n      }\n\n      that._axisShift = shiftGroup(options.position, that._axisGroup);\n      (isHorizontal ? [\"top\", \"bottom\"] : [\"left\", \"right\"]).forEach(function (side) {\n        shiftGroup(side, constantLinesGroups.above);\n        shiftGroup(side, constantLinesGroups.under);\n      });\n    }\n  }\n};\n\nfunction getLineDrawer(renderer, root, rotatePoints, positionFrom, breakStart, positionTo, isWaved) {\n  var elementType = isWaved ? \"bezier\" : \"line\";\n  var group = renderer.g().append(root);\n  return function (offset, attr) {\n    renderer.path(rotatePoints(getPoints(positionFrom, breakStart, positionTo, offset, isWaved)), elementType).attr(attr).append(group);\n  };\n}\n\nfunction getPoints(positionFrom, breakStart, positionTo, offset, isWaved) {\n  if (!isWaved) {\n    return [positionFrom, breakStart + offset, positionTo, breakStart + offset];\n  }\n\n  breakStart += offset;\n  var currentPosition;\n  var topPoint = breakStart + WAVED_LINE_TOP;\n  var centerPoint = breakStart + WAVED_LINE_CENTER;\n  var bottomPoint = breakStart + WAVED_LINE_BOTTOM;\n  var points = [[positionFrom, centerPoint]];\n\n  for (currentPosition = positionFrom; currentPosition < positionTo + WAVED_LINE_LENGTH; currentPosition += WAVED_LINE_LENGTH) {\n    points.push([currentPosition + 6, topPoint, currentPosition + 6, topPoint, currentPosition + 12, centerPoint, currentPosition + 18, bottomPoint, currentPosition + 18, bottomPoint, currentPosition + 24, centerPoint]);\n  }\n\n  return [].concat.apply([], points);\n}\n\nfunction rotateLine(lineCoords) {\n  var points = [];\n  var i;\n\n  for (i = 0; i < lineCoords.length; i += 2) {\n    points.push(lineCoords[i + 1]);\n    points.push(lineCoords[i]);\n  }\n\n  return points;\n}","map":null,"metadata":{},"sourceType":"script"}