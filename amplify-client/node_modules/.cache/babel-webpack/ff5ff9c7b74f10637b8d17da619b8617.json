{"ast":null,"code":"/**\r\n * DevExtreme (viz/axes/xy_axes.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _range = require(\"../translators/range\");\n\nvar _range2 = _interopRequireDefault(_range);\n\nvar _format_helper = require(\"../../format_helper\");\n\nvar _date = require(\"../../core/utils/date\");\n\nvar _date2 = _interopRequireDefault(_date);\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _datetime_breaks = require(\"./datetime_breaks\");\n\nvar _common = require(\"../../core/utils/common\");\n\nvar _utils = require(\"../core/utils\");\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _axes_constants = require(\"./axes_constants\");\n\nvar _axes_constants2 = _interopRequireDefault(_axes_constants);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar getNextDateUnit = _date2.default.getNextDateUnit;\nvar correctDateWithUnitBeginning = _date2.default.correctDateWithUnitBeginning;\nvar _math = Math;\nvar _max = _math.max;\nvar TOP = _axes_constants2.default.top;\nvar BOTTOM = _axes_constants2.default.bottom;\nvar LEFT = _axes_constants2.default.left;\nvar RIGHT = _axes_constants2.default.right;\nvar CENTER = _axes_constants2.default.center;\nvar SCALE_BREAK_OFFSET = 3;\nvar RANGE_RATIO = .3;\nvar WAVED_LINE_CENTER = 2;\nvar WAVED_LINE_TOP = 0;\nvar WAVED_LINE_BOTTOM = 4;\nvar WAVED_LINE_LENGTH = 24;\nvar TICKS_CORRECTIONS = {\n  left: -1,\n  top: -1,\n  right: 0,\n  bottom: 0,\n  center: -.5\n};\n\nfunction prepareDatesDifferences(datesDifferences, tickInterval) {\n  var dateUnitInterval;\n  var i;\n\n  if (\"week\" === tickInterval) {\n    tickInterval = \"day\";\n  }\n\n  if (\"quarter\" === tickInterval) {\n    tickInterval = \"month\";\n  }\n\n  if (datesDifferences[tickInterval]) {\n    for (i = 0; i < _date2.default.dateUnitIntervals.length; i++) {\n      dateUnitInterval = _date2.default.dateUnitIntervals[i];\n\n      if (datesDifferences[dateUnitInterval]) {\n        datesDifferences[dateUnitInterval] = false;\n        datesDifferences.count--;\n      }\n\n      if (dateUnitInterval === tickInterval) {\n        break;\n      }\n    }\n  }\n}\n\nfunction sortingBreaks(breaks) {\n  return breaks.sort(function (a, b) {\n    return a.from - b.from;\n  });\n}\n\nfunction filterBreaks(breaks, viewport, breakStyle) {\n  var minVisible = viewport.minVisible;\n  var maxVisible = viewport.maxVisible;\n  var breakSize = breakStyle ? breakStyle.width : 0;\n  return breaks.reduce(function (result, currentBreak) {\n    var from = currentBreak.from;\n    var to = currentBreak.to;\n    var lastResult = result[result.length - 1];\n    var newBreak;\n\n    if (!(0, _type.isDefined)(from) || !(0, _type.isDefined)(to)) {\n      return result;\n    }\n\n    if (from > to) {\n      to = [from, from = to][0];\n    }\n\n    if (result.length && from < lastResult.to) {\n      if (to > lastResult.to) {\n        lastResult.to = to > maxVisible ? maxVisible : to;\n\n        if (lastResult.gapSize) {\n          lastResult.gapSize = void 0;\n          lastResult.cumulativeWidth += breakSize;\n        }\n      }\n    } else {\n      if ((from >= minVisible && from < maxVisible || to <= maxVisible && to > minVisible) && to - from < maxVisible - minVisible) {\n        from = from >= minVisible ? from : minVisible;\n        to = to <= maxVisible ? to : maxVisible;\n        newBreak = {\n          from: from,\n          to: to,\n          cumulativeWidth: (lastResult ? lastResult.cumulativeWidth : 0) + breakSize\n        };\n\n        if (currentBreak.gapSize) {\n          newBreak.gapSize = _date2.default.convertMillisecondsToDateUnits(to - from);\n          newBreak.cumulativeWidth = lastResult ? lastResult.cumulativeWidth : 0;\n        }\n\n        result.push(newBreak);\n      }\n    }\n\n    return result;\n  }, []);\n}\n\nfunction getMarkerDates(min, max, markerInterval) {\n  var origMin = min;\n  var dates;\n  min = correctDateWithUnitBeginning(min, markerInterval);\n  max = correctDateWithUnitBeginning(max, markerInterval);\n  dates = _date2.default.getSequenceByInterval(min, max, markerInterval);\n\n  if (dates.length && origMin > dates[0]) {\n    dates = dates.slice(1);\n  }\n\n  return dates;\n}\n\nfunction getStripHorizontalAlignmentPosition(alignment) {\n  var position = \"start\";\n\n  if (\"center\" === alignment) {\n    position = \"center\";\n  }\n\n  if (\"right\" === alignment) {\n    position = \"end\";\n  }\n\n  return position;\n}\n\nfunction getStripVerticalAlignmentPosition(alignment) {\n  var position = \"start\";\n\n  if (\"center\" === alignment) {\n    position = \"center\";\n  }\n\n  if (\"bottom\" === alignment) {\n    position = \"end\";\n  }\n\n  return position;\n}\n\nfunction getMarkerInterval(tickInterval) {\n  var markerInterval = getNextDateUnit(tickInterval);\n\n  if (\"quarter\" === markerInterval) {\n    markerInterval = getNextDateUnit(markerInterval);\n  }\n\n  return markerInterval;\n}\n\nfunction getMarkerFormat(curDate, prevDate, tickInterval, markerInterval) {\n  var format = markerInterval;\n\n  var datesDifferences = prevDate && _date2.default.getDatesDifferences(prevDate, curDate);\n\n  if (prevDate && \"year\" !== tickInterval) {\n    prepareDatesDifferences(datesDifferences, tickInterval);\n    format = (0, _format_helper.getDateFormatByDifferences)(datesDifferences);\n  }\n\n  return format;\n}\n\nfunction getMaxSide(act, boxes) {\n  return boxes.reduce(function (prevValue, box) {\n    return _max(prevValue, act(box));\n  }, 0);\n}\n\nfunction getDistanceByAngle(bBox, rotationAngle) {\n  rotationAngle = _math.abs(rotationAngle);\n  rotationAngle = rotationAngle % 180 >= 90 ? 90 - rotationAngle % 90 : rotationAngle % 90;\n  var a = rotationAngle * (_math.PI / 180);\n\n  if (a >= _math.atan(bBox.height / bBox.width)) {\n    return bBox.height / _math.abs(_math.sin(a));\n  } else {\n    return bBox.width;\n  }\n}\n\nfunction getMaxConstantLinePadding(constantLines) {\n  return constantLines.reduce(function (padding, options) {\n    return _max(padding, options.paddingTopBottom);\n  }, 0);\n}\n\nfunction getConstantLineLabelMarginForVerticalAlignment(constantLines, alignment, labelHeight) {\n  return constantLines.some(function (options) {\n    return options.label.verticalAlignment === alignment;\n  }) && labelHeight || 0;\n}\n\nfunction getLeftMargin(bBox) {\n  return _math.abs(bBox.x) || 0;\n}\n\nfunction getRightMargin(bBox) {\n  return _math.abs(bBox.width - _math.abs(bBox.x)) || 0;\n}\n\nfunction generateRangesOnPoints(points, edgePoints, getRange) {\n  var i;\n  var length;\n  var maxRange = null;\n  var ranges = [];\n  var curValue;\n  var prevValue;\n  var curRange;\n\n  for (i = 1, length = points.length; i < length; i++) {\n    curValue = points[i];\n    prevValue = points[i - 1];\n    curRange = getRange(curValue, prevValue);\n\n    if (edgePoints.indexOf(curValue) >= 0) {\n      if (!maxRange || curRange > maxRange.length) {\n        maxRange = {\n          start: curValue,\n          end: prevValue,\n          length: curRange\n        };\n      }\n    } else {\n      if (maxRange && curRange < maxRange.length) {\n        ranges.push(maxRange);\n      } else {\n        ranges.push({\n          start: curValue,\n          end: prevValue,\n          length: curRange\n        });\n      }\n\n      maxRange = null;\n    }\n  }\n\n  if (maxRange) {\n    ranges.push(maxRange);\n  }\n\n  return ranges;\n}\n\nfunction generateAutoBreaks(_ref, series, _ref2) {\n  var logarithmBase = _ref.logarithmBase,\n      type = _ref.type,\n      maxAutoBreakCount = _ref.maxAutoBreakCount;\n  var minVisible = _ref2.minVisible,\n      maxVisible = _ref2.maxVisible;\n  var breaks = [];\n  var getRange = \"logarithmic\" === type ? function (min, max) {\n    return _utils2.default.getLog(max / min, logarithmBase);\n  } : function (min, max) {\n    return max - min;\n  };\n  var visibleRange = getRange(minVisible, maxVisible);\n  var points = series.reduce(function (result, s) {\n    var points = s.getPointsInViewPort();\n    result[0] = result[0].concat(points[0]);\n    result[1] = result[1].concat(points[1]);\n    return result;\n  }, [[], []]);\n  var sortedAllPoints = points[0].concat(points[1]).sort(function (a, b) {\n    return b - a;\n  });\n  var edgePoints = points[1].filter(function (p) {\n    return points[0].indexOf(p) < 0;\n  });\n  var minDiff = RANGE_RATIO * visibleRange;\n  var ranges = generateRangesOnPoints(sortedAllPoints, edgePoints, getRange).sort(function (a, b) {\n    return b.length - a.length;\n  });\n  var epsilon = _math.min.apply(null, ranges.map(function (r) {\n    return r.length;\n  })) / 1e3;\n\n  var _maxAutoBreakCount = (0, _type.isDefined)(maxAutoBreakCount) ? _math.min(maxAutoBreakCount, ranges.length) : ranges.length;\n\n  for (var i = 0; i < _maxAutoBreakCount; i++) {\n    if (ranges[i].length >= minDiff) {\n      if (visibleRange <= ranges[i].length) {\n        break;\n      }\n\n      visibleRange -= ranges[i].length;\n\n      if (visibleRange > epsilon || visibleRange < -epsilon) {\n        breaks.push({\n          from: ranges[i].start,\n          to: ranges[i].end\n        });\n        minDiff = RANGE_RATIO * visibleRange;\n      }\n    } else {\n      break;\n    }\n  }\n\n  sortingBreaks(breaks);\n  return breaks;\n}\n\nmodule.exports = {\n  linear: {\n    _getStep: function _getStep(boxes, rotationAngle) {\n      var spacing = this._options.label.minSpacing;\n      var func = this._isHorizontal ? function (box) {\n        return box.width + spacing;\n      } : function (box) {\n        return box.height;\n      };\n      var maxLabelLength = getMaxSide(func, boxes);\n\n      if (rotationAngle) {\n        maxLabelLength = getDistanceByAngle({\n          width: maxLabelLength,\n          height: this._getMaxLabelHeight(boxes, 0)\n        }, rotationAngle);\n      }\n\n      return _axes_constants2.default.getTicksCountInRange(this._majorTicks, this._isHorizontal ? \"x\" : \"y\", maxLabelLength);\n    },\n    _getMaxLabelHeight: function _getMaxLabelHeight(boxes, spacing) {\n      return getMaxSide(function (box) {\n        return box.height;\n      }, boxes) + spacing;\n    },\n    _validateOverlappingMode: function _validateOverlappingMode(mode, displayMode) {\n      if (this._isHorizontal && (\"rotate\" === displayMode || \"stagger\" === displayMode) || !this._isHorizontal) {\n        return _axes_constants2.default.validateOverlappingMode(mode);\n      }\n\n      return mode;\n    },\n    _validateDisplayMode: function _validateDisplayMode(mode) {\n      return this._isHorizontal ? mode : \"standard\";\n    },\n    getMarkerTrackers: function getMarkerTrackers() {\n      return this._markerTrackers;\n    },\n    _getSharpParam: function _getSharpParam(opposite) {\n      return this._isHorizontal ^ opposite ? \"h\" : \"v\";\n    },\n    _createAxisElement: function _createAxisElement() {\n      return this._renderer.path([], \"line\");\n    },\n    _updateAxisElementPosition: function _updateAxisElementPosition() {\n      var axisCoord = this._axisPosition;\n\n      var canvas = this._getCanvasStartEnd();\n\n      this._axisElement.attr({\n        points: this._isHorizontal ? [canvas.start, axisCoord, canvas.end, axisCoord] : [axisCoord, canvas.start, axisCoord, canvas.end]\n      });\n    },\n    _getTranslatedCoord: function _getTranslatedCoord(value, offset) {\n      return this._translator.translate(value, offset);\n    },\n    _initAxisPositions: function _initAxisPositions() {\n      var that = this;\n      var position = that._options.position;\n      that._axisPosition = that._orthogonalPositions[\"top\" === position || \"left\" === position ? \"start\" : \"end\"];\n    },\n    _getTickMarkPoints: function _getTickMarkPoints(coords, length, tickOptions) {\n      var isHorizontal = this._isHorizontal;\n      var options = this._options;\n      var tickStartCoord;\n\n      if ((0, _type.isDefined)(options.tickOrientation)) {\n        tickStartCoord = TICKS_CORRECTIONS[options.tickOrientation] * length;\n      } else {\n        var shift = tickOptions.shift || 0;\n\n        if (\"left\" === options.position || \"top\" === options.position) {\n          shift = -shift;\n        }\n\n        tickStartCoord = shift + this.getTickStartPositionShift(length);\n      }\n\n      return [coords.x + (isHorizontal ? 0 : tickStartCoord), coords.y + (isHorizontal ? tickStartCoord : 0), coords.x + (isHorizontal ? 0 : tickStartCoord + length), coords.y + (isHorizontal ? tickStartCoord + length : 0)];\n    },\n    getTickStartPositionShift: function getTickStartPositionShift(length) {\n      var options = this._options;\n      return length % 2 === 1 ? options.width % 2 === 0 && (\"left\" === options.position || \"top\" === options.position) || options.width % 2 === 1 && (\"right\" === options.position || \"bottom\" === options.position) ? Math.floor(-length / 2) : -Math.floor(length / 2) : -length / 2 + (options.width % 2 === 0 ? 0 : \"bottom\" === options.position || \"right\" === options.position ? -1 : 1);\n    },\n    _getTitleCoords: function _getTitleCoords() {\n      var that = this;\n      var horizontal = that._isHorizontal;\n      var x = that._axisPosition;\n      var y = that._axisPosition;\n      var align = that._options.title.alignment;\n\n      var canvas = that._getCanvasStartEnd();\n\n      var fromStartToEnd = horizontal || that._options.position === LEFT;\n      var canvasStart = fromStartToEnd ? canvas.start : canvas.end;\n      var canvasEnd = fromStartToEnd ? canvas.end : canvas.start;\n      var coord = align === LEFT ? canvasStart : align === RIGHT ? canvasEnd : canvas.start + (canvas.end - canvas.start) / 2;\n\n      if (horizontal) {\n        x = coord;\n      } else {\n        y = coord;\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    },\n    _drawTitleText: function _drawTitleText(group, coords) {\n      var options = this._options;\n      var titleOptions = options.title;\n      var attrs = {\n        opacity: titleOptions.opacity,\n        align: titleOptions.alignment,\n        \"class\": titleOptions.cssClass\n      };\n\n      if (!titleOptions.text || !group) {\n        return;\n      }\n\n      coords = coords || this._getTitleCoords();\n\n      if (!this._isHorizontal) {\n        attrs.rotate = options.position === LEFT ? 270 : 90;\n      }\n\n      var text = this._renderer.text(titleOptions.text, coords.x, coords.y).css(_utils2.default.patchFontOptions(titleOptions.font)).attr(attrs).append(group);\n\n      this._checkTitleOverflow(text);\n\n      return text;\n    },\n    _updateTitleCoords: function _updateTitleCoords() {\n      this._title && this._title.element.attr(this._getTitleCoords());\n    },\n    _drawTitle: function _drawTitle() {\n      var title = this._drawTitleText(this._axisTitleGroup);\n\n      if (title) {\n        this._title = {\n          element: title\n        };\n      }\n    },\n    _measureTitle: function _measureTitle() {\n      if (this._title) {\n        if (this._title.bBox && !this._title.originalSize) {\n          this._title.originalSize = this._title.bBox;\n        }\n\n        this._title.bBox = this._title.element.getBBox();\n      }\n    },\n    _drawDateMarker: function _drawDateMarker(date, options, range) {\n      var that = this;\n      var markerOptions = that._options.marker;\n\n      var invert = that._translator.getBusinessRange().invert;\n\n      var textIndent = markerOptions.width + markerOptions.textLeftIndent;\n      var text;\n      var pathElement;\n\n      if (null === options.x) {\n        return;\n      }\n\n      if (!options.withoutStick) {\n        pathElement = that._renderer.path([options.x, options.y, options.x, options.y + markerOptions.separatorHeight], \"line\").attr({\n          \"stroke-width\": markerOptions.width,\n          stroke: markerOptions.color,\n          \"stroke-opacity\": markerOptions.opacity,\n          sharp: \"h\"\n        }).append(that._axisElementsGroup);\n      }\n\n      text = String(that.formatLabel(date, options.labelOptions, range));\n      return {\n        date: date,\n        x: options.x,\n        y: options.y,\n        cropped: options.withoutStick,\n        label: that._renderer.text(text, options.x, options.y).css(_utils2.default.patchFontOptions(markerOptions.label.font)).append(that._axisElementsGroup),\n        line: pathElement,\n        getEnd: function getEnd() {\n          return this.x + (invert ? -1 : 1) * (textIndent + this.labelBBox.width);\n        },\n        setTitle: function setTitle() {\n          this.title = text;\n        },\n        hideLabel: function hideLabel() {\n          this.label.dispose();\n          this.label = null;\n          this.title = text;\n        },\n        hide: function hide() {\n          if (pathElement) {\n            pathElement.dispose();\n            pathElement = null;\n          }\n\n          this.label.dispose();\n          this.label = null;\n          this.hidden = true;\n        }\n      };\n    },\n    _drawDateMarkers: function _drawDateMarkers() {\n      var that = this;\n      var options = that._options;\n      var translator = that._translator;\n\n      var viewport = that._getViewportRange();\n\n      var minBound = viewport.minVisible;\n      var tickInterval;\n      var markerInterval;\n      var markerDates;\n      var dateMarkers = [];\n      var markersAreaTop;\n      var dateMarker;\n\n      function draw(markerDate, format, withoutStick) {\n        return that._drawDateMarker(markerDate, {\n          x: translator.translate(markerDate),\n          y: markersAreaTop,\n          labelOptions: that._getLabelFormatOptions(format),\n          withoutStick: withoutStick\n        }, viewport);\n      }\n\n      if (viewport.isEmpty() || !options.marker.visible || \"datetime\" !== options.argumentType || \"discrete\" === options.type || that._majorTicks.length <= 1) {\n        return [];\n      }\n\n      markersAreaTop = that._axisPosition + options.marker.topIndent;\n      tickInterval = _date2.default.getDateUnitInterval(this._tickInterval);\n      markerInterval = getMarkerInterval(tickInterval);\n      markerDates = getMarkerDates(minBound, viewport.maxVisible, markerInterval);\n\n      if (markerDates.length > 1 || 1 === markerDates.length && minBound < markerDates[0]) {\n        dateMarkers = markerDates.reduce(function (markers, curDate, i, dates) {\n          var marker = draw(curDate, getMarkerFormat(curDate, dates[i - 1] || minBound < curDate && minBound, tickInterval, markerInterval));\n          marker && markers.push(marker);\n          return markers;\n        }, []);\n\n        if (minBound < markerDates[0]) {\n          dateMarker = draw(minBound, getMarkerFormat(minBound, markerDates[0], tickInterval, markerInterval), true);\n          dateMarker && dateMarkers.unshift(dateMarker);\n        }\n      }\n\n      return dateMarkers;\n    },\n    _adjustDateMarkers: function _adjustDateMarkers(offset) {\n      offset = offset || 0;\n      var that = this;\n      var markerOptions = this._options.marker;\n      var textIndent = markerOptions.width + markerOptions.textLeftIndent;\n\n      var invert = this._translator.getBusinessRange().invert;\n\n      var canvas = that._getCanvasStartEnd();\n\n      var dateMarkers = this._dateMarkers;\n\n      if (!dateMarkers.length) {\n        return offset;\n      }\n\n      if (dateMarkers[0].cropped) {\n        if (!this._checkMarkersPosition(invert, dateMarkers[1], dateMarkers[0])) {\n          dateMarkers[0].hideLabel();\n        }\n      }\n\n      var prevDateMarker;\n      dateMarkers.forEach(function (marker, i, markers) {\n        if (marker.cropped) {\n          return;\n        }\n\n        if (invert ? marker.getEnd() < canvas.end : marker.getEnd() > canvas.end) {\n          marker.hideLabel();\n        } else {\n          if (that._checkMarkersPosition(invert, marker, prevDateMarker)) {\n            prevDateMarker = marker;\n          } else {\n            marker.hide();\n          }\n        }\n      });\n\n      this._dateMarkers.forEach(function (marker) {\n        if (marker.label) {\n          var labelBBox = marker.labelBBox;\n          var dy = marker.y + markerOptions.textTopIndent - labelBBox.y;\n          marker.label.attr({\n            translateX: invert ? marker.x - textIndent - labelBBox.x - labelBBox.width : marker.x + textIndent - labelBBox.x,\n            translateY: dy + offset\n          });\n        }\n\n        if (marker.line) {\n          marker.line.attr({\n            translateY: offset\n          });\n        }\n      });\n\n      that._initializeMarkersTrackers(offset);\n\n      return offset + markerOptions.topIndent + markerOptions.separatorHeight;\n    },\n    _checkMarkersPosition: function _checkMarkersPosition(invert, dateMarker, prevDateMarker) {\n      if (void 0 === prevDateMarker) {\n        return true;\n      }\n\n      return invert ? dateMarker.x < prevDateMarker.getEnd() : dateMarker.x > prevDateMarker.getEnd();\n    },\n    _initializeMarkersTrackers: function _initializeMarkersTrackers(offset) {\n      var that = this;\n      var separatorHeight = that._options.marker.separatorHeight;\n      var renderer = that._renderer;\n\n      var businessRange = this._translator.getBusinessRange();\n\n      var canvas = that._getCanvasStartEnd();\n\n      var group = that._axisElementsGroup;\n      that._markerTrackers = this._dateMarkers.filter(function (marker) {\n        return !marker.hidden;\n      }).map(function (marker, i, markers) {\n        var nextMarker = markers[i + 1] || {\n          x: canvas.end,\n          date: businessRange.max\n        };\n        var x = marker.x;\n        var y = marker.y + offset;\n        var markerTracker = renderer.path([x, y, x, y + separatorHeight, nextMarker.x, y + separatorHeight, nextMarker.x, y, x, y], \"area\").attr({\n          \"stroke-width\": 1,\n          stroke: \"grey\",\n          fill: \"grey\",\n          opacity: 1e-4\n        }).append(group);\n        markerTracker.data(\"range\", {\n          startValue: marker.date,\n          endValue: nextMarker.date\n        });\n\n        if (marker.title) {\n          markerTracker.setTitle(marker.title);\n        }\n\n        return markerTracker;\n      });\n    },\n    _getLabelFormatOptions: function _getLabelFormatOptions(formatString) {\n      var that = this;\n      var markerLabelOptions = that._markerLabelOptions;\n\n      if (!markerLabelOptions) {\n        that._markerLabelOptions = markerLabelOptions = (0, _extend.extend)(true, {}, that._options.marker.label);\n      }\n\n      if (!(0, _type.isDefined)(that._options.marker.label.format)) {\n        markerLabelOptions.format = formatString;\n      }\n\n      return markerLabelOptions;\n    },\n    _adjustConstantLineLabels: function _adjustConstantLineLabels(constantLines) {\n      var that = this;\n      var axisPosition = that._options.position;\n      var canvas = that.getCanvas();\n      var canvasLeft = canvas.left;\n      var canvasRight = canvas.width - canvas.right;\n      var canvasTop = canvas.top;\n      var canvasBottom = canvas.height - canvas.bottom;\n      var verticalCenter = canvasTop + (canvasBottom - canvasTop) / 2;\n      var horizontalCenter = canvasLeft + (canvasRight - canvasLeft) / 2;\n      var maxLabel = 0;\n      constantLines.forEach(function (item) {\n        var isHorizontal = that._isHorizontal;\n        var linesOptions = item.options;\n        var paddingTopBottom = linesOptions.paddingTopBottom;\n        var paddingLeftRight = linesOptions.paddingLeftRight;\n        var labelOptions = linesOptions.label;\n        var labelVerticalAlignment = labelOptions.verticalAlignment;\n        var labelHorizontalAlignment = labelOptions.horizontalAlignment;\n        var labelIsInside = \"inside\" === labelOptions.position;\n        var label = item.label;\n        var box = item.labelBBox;\n        var translateX;\n        var translateY;\n\n        if (null === label || box.isEmpty) {\n          return;\n        }\n\n        if (isHorizontal) {\n          if (labelIsInside) {\n            if (labelHorizontalAlignment === LEFT) {\n              translateX = item.coord - paddingLeftRight - box.x - box.width;\n            } else {\n              translateX = item.coord + paddingLeftRight - box.x;\n            }\n\n            switch (labelVerticalAlignment) {\n              case CENTER:\n                translateY = verticalCenter - box.y - box.height / 2;\n                break;\n\n              case BOTTOM:\n                translateY = canvasBottom - paddingTopBottom - box.y - box.height;\n                break;\n\n              default:\n                translateY = canvasTop + paddingTopBottom - box.y;\n            }\n          } else {\n            if (axisPosition === labelVerticalAlignment) {\n              maxLabel = _max(maxLabel, box.height + paddingTopBottom);\n            }\n\n            translateX = item.coord - box.x - box.width / 2;\n\n            if (labelVerticalAlignment === BOTTOM) {\n              translateY = canvasBottom + paddingTopBottom - box.y;\n            } else {\n              translateY = canvasTop - paddingTopBottom - box.y - box.height;\n            }\n          }\n        } else {\n          if (labelIsInside) {\n            if (labelVerticalAlignment === BOTTOM) {\n              translateY = item.coord + paddingTopBottom - box.y;\n            } else {\n              translateY = item.coord - paddingTopBottom - box.y - box.height;\n            }\n\n            switch (labelHorizontalAlignment) {\n              case CENTER:\n                translateX = horizontalCenter - box.x - box.width / 2;\n                break;\n\n              case RIGHT:\n                translateX = canvasRight - paddingLeftRight - box.x - box.width;\n                break;\n\n              default:\n                translateX = canvasLeft + paddingLeftRight - box.x;\n            }\n          } else {\n            if (axisPosition === labelHorizontalAlignment) {\n              maxLabel = _max(maxLabel, box.width + paddingLeftRight);\n            }\n\n            translateY = item.coord - box.y - box.height / 2;\n\n            if (labelHorizontalAlignment === RIGHT) {\n              translateX = canvasRight + paddingLeftRight - box.x;\n            } else {\n              translateX = canvasLeft - paddingLeftRight - box.x - box.width;\n            }\n          }\n        }\n\n        label.attr({\n          translateX: translateX,\n          translateY: translateY\n        });\n      });\n      return maxLabel;\n    },\n    _drawConstantLinesForEstimating: function _drawConstantLinesForEstimating(constantLines) {\n      var that = this;\n      var renderer = this._renderer;\n      var group = renderer.g();\n      constantLines.forEach(function (options) {\n        that._drawConstantLineLabelText(options.label.text, 0, 0, options.label, group).attr({\n          align: \"center\"\n        });\n      });\n      return group.append(renderer.root);\n    },\n    _estimateLabelHeight: function _estimateLabelHeight(bBox, labelOptions) {\n      var height = bBox.height;\n      var drawingType = labelOptions.drawingType;\n\n      if (\"stagger\" === this._validateDisplayMode(drawingType) || \"stagger\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\n        height = 2 * height + labelOptions.staggeringSpacing;\n      }\n\n      if (\"rotate\" === this._validateDisplayMode(drawingType) || \"rotate\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\n        var sinCos = _utils2.default.getCosAndSin(labelOptions.rotationAngle);\n\n        height = height * sinCos.cos + bBox.width * sinCos.sin;\n      }\n\n      return height && (height + labelOptions.indentFromAxis || 0) || 0;\n    },\n    estimateMargins: function estimateMargins(canvas) {\n      this.updateCanvas(canvas);\n      var that = this;\n\n      var range = that._getViewportRange();\n\n      var ticksData = this._createTicksAndLabelFormat(range);\n\n      var ticks = ticksData.ticks;\n      var tickInterval = ticksData.tickInterval;\n      var options = this._options;\n\n      var constantLineOptions = that._outsideConstantLines.filter(function (l) {\n        return l.labelOptions.visible;\n      }).map(function (l) {\n        return l.options;\n      });\n\n      var rootElement = that._renderer.root;\n      var labelIsVisible = options.label.visible && !range.isEmpty() && ticks.length;\n      var labelValue = labelIsVisible && that.formatLabel(ticks[ticks.length - 1], options.label, void 0, void 0, tickInterval, ticks);\n\n      var labelElement = labelIsVisible && that._renderer.text(labelValue, 0, 0).css(that._textFontStyles).attr(that._textOptions).append(rootElement);\n\n      var titleElement = that._drawTitleText(rootElement, {\n        x: 0,\n        y: 0\n      });\n\n      var constantLinesLabelsElement = that._drawConstantLinesForEstimating(constantLineOptions);\n\n      var labelBox = labelElement && labelElement.getBBox() || {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n      var titleBox = titleElement && titleElement.getBBox() || {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n      var constantLinesBox = constantLinesLabelsElement.getBBox();\n      var titleHeight = titleBox.height ? titleBox.height + options.title.margin : 0;\n\n      var labelHeight = that._estimateLabelHeight(labelBox, options.label);\n\n      var constantLinesHeight = constantLinesBox.height ? constantLinesBox.height + getMaxConstantLinePadding(constantLineOptions) : 0;\n      var height = labelHeight + titleHeight;\n      var margins = {\n        left: _max(getLeftMargin(labelBox), getLeftMargin(constantLinesBox)),\n        right: _max(getRightMargin(labelBox), getRightMargin(constantLinesBox)),\n        top: (\"top\" === options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"top\", constantLinesHeight),\n        bottom: (\"top\" !== options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"bottom\", constantLinesHeight)\n      };\n      labelElement && labelElement.remove();\n      titleElement && titleElement.remove();\n      constantLinesLabelsElement && constantLinesLabelsElement.remove();\n      return margins;\n    },\n    _checkAlignmentConstantLineLabels: function _checkAlignmentConstantLineLabels(labelOptions) {\n      var position = labelOptions.position;\n      var verticalAlignment = (labelOptions.verticalAlignment || \"\").toLowerCase();\n      var horizontalAlignment = (labelOptions.horizontalAlignment || \"\").toLowerCase();\n\n      if (this._isHorizontal) {\n        if (\"outside\" === position) {\n          verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\n          horizontalAlignment = CENTER;\n        } else {\n          verticalAlignment = verticalAlignment === CENTER ? CENTER : verticalAlignment === BOTTOM ? BOTTOM : TOP;\n          horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT;\n        }\n      } else {\n        if (\"outside\" === position) {\n          verticalAlignment = CENTER;\n          horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT;\n        } else {\n          verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\n          horizontalAlignment = horizontalAlignment === RIGHT ? RIGHT : horizontalAlignment === CENTER ? CENTER : LEFT;\n        }\n      }\n\n      labelOptions.verticalAlignment = verticalAlignment;\n      labelOptions.horizontalAlignment = horizontalAlignment;\n    },\n    _getConstantLineLabelsCoords: function _getConstantLineLabelsCoords(value, lineLabelOptions) {\n      var that = this;\n      var x = value;\n      var y = value;\n\n      if (that._isHorizontal) {\n        y = that._orthogonalPositions[\"top\" === lineLabelOptions.verticalAlignment ? \"start\" : \"end\"];\n      } else {\n        x = that._orthogonalPositions[\"right\" === lineLabelOptions.horizontalAlignment ? \"end\" : \"start\"];\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    },\n    _getAdjustedStripLabelCoords: function _getAdjustedStripLabelCoords(strip) {\n      var stripOptions = strip.options;\n      var paddingTopBottom = stripOptions.paddingTopBottom;\n      var paddingLeftRight = stripOptions.paddingLeftRight;\n      var horizontalAlignment = stripOptions.label.horizontalAlignment;\n      var verticalAlignment = stripOptions.label.verticalAlignment;\n      var box = strip.labelBBox;\n      var labelHeight = box.height;\n      var labelWidth = box.width;\n      var labelCoords = strip.labelCoords;\n      var y = labelCoords.y - box.y;\n      var x = labelCoords.x - box.x;\n\n      if (verticalAlignment === TOP) {\n        y += paddingTopBottom;\n      } else {\n        if (verticalAlignment === CENTER) {\n          y -= labelHeight / 2;\n        } else {\n          if (verticalAlignment === BOTTOM) {\n            y -= paddingTopBottom + labelHeight;\n          }\n        }\n      }\n\n      if (horizontalAlignment === LEFT) {\n        x += paddingLeftRight;\n      } else {\n        if (horizontalAlignment === CENTER) {\n          x -= labelWidth / 2;\n        } else {\n          if (horizontalAlignment === RIGHT) {\n            x -= paddingLeftRight + labelWidth;\n          }\n        }\n      }\n\n      return {\n        translateX: x,\n        translateY: y\n      };\n    },\n    _adjustTitle: function _adjustTitle(offset) {\n      offset = offset || 0;\n\n      if (!this._title) {\n        return;\n      }\n\n      var that = this;\n      var options = that._options;\n      var position = options.position;\n      var margin = options.title.margin;\n      var title = that._title;\n      var boxTitle = title.bBox;\n      var x = boxTitle.x;\n      var y = boxTitle.y;\n      var width = boxTitle.width;\n      var height = boxTitle.height;\n      var axisPosition = that._axisPosition;\n      var loCoord = axisPosition - margin - offset;\n      var hiCoord = axisPosition + margin + offset;\n      var params = {};\n\n      if (that._isHorizontal) {\n        if (position === TOP) {\n          params.translateY = loCoord - (y + height);\n        } else {\n          params.translateY = hiCoord - y;\n        }\n      } else {\n        if (position === LEFT) {\n          params.translateX = loCoord - (x + width);\n        } else {\n          params.translateX = hiCoord - x;\n        }\n      }\n\n      title.element.attr(params);\n    },\n    _checkTitleOverflow: function _checkTitleOverflow(titleElement) {\n      if (!this._title && !titleElement) {\n        return;\n      }\n\n      var canvasLength = this._getScreenDelta();\n\n      var title = titleElement ? {\n        bBox: titleElement.getBBox(),\n        element: titleElement\n      } : this._title;\n      var titleOptions = this._options.title;\n      var boxTitle = title.bBox;\n\n      if ((this._isHorizontal ? boxTitle.width : boxTitle.height) > canvasLength) {\n        title.element.setMaxSize(canvasLength, void 0, {\n          wordWrap: titleOptions.wordWrap || \"none\",\n          textOverflow: titleOptions.textOverflow || \"ellipsis\"\n        });\n        this._wrapped = titleOptions.wordWrap && \"none\" !== titleOptions.wordWrap;\n      } else {\n        var moreThanOriginalSize = title.originalSize && canvasLength > (this._isHorizontal ? title.originalSize.width : title.originalSize.height);\n        !this._wrapped && moreThanOriginalSize && title.element.restoreText();\n      }\n    },\n    coordsIn: function coordsIn(x, y) {\n      var canvas = this.getCanvas();\n      var isHorizontal = this._options.isHorizontal;\n      var position = this._options.position;\n      var coord = isHorizontal ? y : x;\n\n      if (isHorizontal && (x < canvas.left || x > canvas.width - canvas.right) || !isHorizontal && (y < canvas.top || y > canvas.height - canvas.bottom)) {\n        return false;\n      }\n\n      if (isHorizontal && position === _axes_constants2.default.top || !isHorizontal && position === _axes_constants2.default.left) {\n        return coord < canvas[position];\n      }\n\n      return coord > canvas[isHorizontal ? \"height\" : \"width\"] - canvas[position];\n    },\n    _boundaryTicksVisibility: {\n      min: true,\n      max: true\n    },\n    adjust: function adjust(alignToBounds) {\n      var that = this;\n      var seriesData = that._seriesData;\n      var viewport = {\n        min: seriesData.min,\n        max: seriesData.max\n      };\n\n      if (!alignToBounds) {\n        viewport = that._series.filter(function (s) {\n          return s.isVisible();\n        }).reduce(function (range, s) {\n          var seriesRange = s.getViewport();\n          range.min = (0, _type.isDefined)(seriesRange.min) ? range.min < seriesRange.min ? range.min : seriesRange.min : range.min;\n          range.max = (0, _type.isDefined)(seriesRange.max) ? range.max > seriesRange.max ? range.max : seriesRange.max : range.max;\n\n          if (s.showZero) {\n            range = new _range2.default.Range(range);\n            range.correctValueZeroLevel();\n          }\n\n          return range;\n        }, {});\n      }\n\n      if ((0, _type.isDefined)(viewport.min) && (0, _type.isDefined)(viewport.max)) {\n        seriesData.minVisible = viewport.min;\n        seriesData.maxVisible = viewport.max;\n      }\n\n      that._translator.updateBusinessRange(that.adjustViewport(seriesData));\n\n      that._breaks = that._getScaleBreaks(that._options, {\n        minVisible: seriesData.minVisible,\n        maxVisible: seriesData.maxVisible\n      }, that._series, that.isArgumentAxis);\n    },\n    hasWrap: function hasWrap() {\n      return this._wrapped;\n    },\n    getAxisPosition: function getAxisPosition() {\n      return this._axisPosition;\n    },\n    _getStick: function _getStick() {\n      return !this._options.valueMarginsEnabled;\n    },\n    _getStripLabelCoords: function _getStripLabelCoords(from, to, stripLabelOptions) {\n      var that = this;\n      var orthogonalPositions = that._orthogonalPositions;\n      var isHorizontal = that._isHorizontal;\n      var horizontalAlignment = stripLabelOptions.horizontalAlignment;\n      var verticalAlignment = stripLabelOptions.verticalAlignment;\n      var x;\n      var y;\n\n      if (isHorizontal) {\n        if (horizontalAlignment === CENTER) {\n          x = from + (to - from) / 2;\n        } else {\n          if (horizontalAlignment === LEFT) {\n            x = from;\n          } else {\n            if (horizontalAlignment === RIGHT) {\n              x = to;\n            }\n          }\n        }\n\n        y = orthogonalPositions[getStripVerticalAlignmentPosition(verticalAlignment)];\n      } else {\n        x = orthogonalPositions[getStripHorizontalAlignmentPosition(horizontalAlignment)];\n\n        if (verticalAlignment === TOP) {\n          y = from;\n        } else {\n          if (verticalAlignment === CENTER) {\n            y = to + (from - to) / 2;\n          } else {\n            if (verticalAlignment === BOTTOM) {\n              y = to;\n            }\n          }\n        }\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    },\n    _getTranslatedValue: function _getTranslatedValue(value, offset) {\n      var pos1 = this._translator.translate(value, offset, \"semidiscrete\" === this._options.type && this._options.tickInterval);\n\n      var pos2 = this._axisPosition;\n      var isHorizontal = this._isHorizontal;\n      return {\n        x: isHorizontal ? pos1 : pos2,\n        y: isHorizontal ? pos2 : pos1\n      };\n    },\n    areCoordsOutsideAxis: function areCoordsOutsideAxis(coords) {\n      var coord = this._isHorizontal ? coords.x : coords.y;\n      var visibleArea = this.getVisibleArea();\n\n      if (coord < visibleArea[0] || coord > visibleArea[1]) {\n        return true;\n      }\n\n      return false;\n    },\n    _getSkippedCategory: function _getSkippedCategory(ticks) {\n      var skippedCategory;\n\n      if (this._options.type === _axes_constants2.default.discrete && this._tickOffset && 0 !== ticks.length) {\n        skippedCategory = ticks[ticks.length - 1];\n      }\n\n      return skippedCategory;\n    },\n    _getScaleBreaks: function _getScaleBreaks(axisOptions, viewport, series, isArgumentAxis) {\n      var that = this;\n      var breaks = (axisOptions.breaks || []).map(function (b) {\n        return {\n          from: that.parser(b.startValue),\n          to: that.parser(b.endValue)\n        };\n      });\n\n      if (\"discrete\" !== axisOptions.type && \"datetime\" === axisOptions.dataType && axisOptions.workdaysOnly) {\n        breaks = breaks.concat((0, _datetime_breaks.generateDateBreaks)(viewport.minVisible, viewport.maxVisible, axisOptions.workWeek, axisOptions.singleWorkdays, axisOptions.holidays));\n      }\n\n      if (!isArgumentAxis && \"discrete\" !== axisOptions.type && \"datetime\" !== axisOptions.dataType && axisOptions.autoBreaksEnabled && 0 !== axisOptions.maxAutoBreakCount) {\n        breaks = breaks.concat(generateAutoBreaks(axisOptions, series, viewport));\n      }\n\n      return filterBreaks(sortingBreaks(breaks), viewport, axisOptions.breakStyle);\n    },\n    _drawBreak: function _drawBreak(translatedEnd, positionFrom, positionTo, width, options, group) {\n      var that = this;\n      var breakStart = translatedEnd - (!that._translator.isInverted() ? width + 1 : 0);\n      var attr = {\n        \"stroke-width\": 1,\n        stroke: options.borderColor,\n        sharp: !options.isWaved ? options.isHorizontal ? \"h\" : \"v\" : void 0\n      };\n      var spaceAttr = {\n        stroke: options.color,\n        \"stroke-width\": width\n      };\n      var getPoints = that._isHorizontal ? rotateLine : function (p) {\n        return p;\n      };\n      var drawer = getLineDrawer(that._renderer, group, getPoints, positionFrom, breakStart, positionTo, options.isWaved);\n      drawer(width / 2, spaceAttr);\n      drawer(0, attr);\n      drawer(width, attr);\n    },\n    _createBreakClipRect: function _createBreakClipRect(from, to) {\n      var that = this;\n      var canvas = that._canvas;\n      var clipWidth = to - from;\n      var clipRect;\n\n      if (that._isHorizontal) {\n        clipRect = that._renderer.clipRect(canvas.left, from, canvas.width, clipWidth);\n      } else {\n        clipRect = that._renderer.clipRect(from, canvas.top, clipWidth, canvas.height);\n      }\n\n      that._breaksElements = that._breaksElements || [];\n\n      that._breaksElements.push(clipRect);\n\n      return clipRect.id;\n    },\n    _createBreaksGroup: function _createBreaksGroup(clipFrom, clipTo) {\n      var that = this;\n\n      var group = that._renderer.g().attr({\n        \"class\": that._axisCssPrefix + \"breaks\",\n        \"clip-path\": that._createBreakClipRect(clipFrom, clipTo)\n      }).append(that._scaleBreaksGroup);\n\n      that._breaksElements = that._breaksElements || [];\n\n      that._breaksElements.push(group);\n\n      return group;\n    },\n    _disposeBreaksGroup: function _disposeBreaksGroup() {\n      (this._breaksElements || []).forEach(function (clipRect) {\n        clipRect.dispose();\n      });\n      this._breaksElements = null;\n    },\n    drawScaleBreaks: function drawScaleBreaks(customCanvas) {\n      var that = this;\n      var options = that._options;\n      var breakStyle = options.breakStyle;\n      var position = options.position;\n      var positionFrom;\n      var positionTo;\n      var breaks = that._translator.getBusinessRange().breaks || [];\n      var additionGroup;\n      var additionBreakFrom;\n      var additionBreakTo;\n      var mainGroup;\n      var breakOptions;\n\n      that._disposeBreaksGroup();\n\n      if (!(breaks && breaks.length)) {\n        return;\n      }\n\n      breakOptions = {\n        color: that._options.containerColor,\n        borderColor: breakStyle.color,\n        isHorizontal: that._isHorizontal,\n        isWaved: \"straight\" !== breakStyle.line.toLowerCase()\n      };\n\n      if (customCanvas) {\n        positionFrom = customCanvas.start;\n        positionTo = customCanvas.end;\n      } else {\n        positionFrom = that._orthogonalPositions.start - (options.visible && !that._axisShift && (\"left\" === position || \"top\" === position) ? SCALE_BREAK_OFFSET : 0);\n        positionTo = that._orthogonalPositions.end + (options.visible && (\"right\" === position || \"bottom\" === position) ? SCALE_BREAK_OFFSET : 0);\n      }\n\n      mainGroup = that._createBreaksGroup(positionFrom, positionTo);\n\n      if (that._axisShift && options.visible) {\n        additionBreakFrom = that._axisPosition - that._axisShift - SCALE_BREAK_OFFSET;\n        additionBreakTo = additionBreakFrom + 2 * SCALE_BREAK_OFFSET;\n        additionGroup = that._createBreaksGroup(additionBreakFrom, additionBreakTo);\n      }\n\n      breaks.forEach(function (br) {\n        if (!br.gapSize) {\n          var breakCoord = that._getTranslatedCoord(br.to);\n\n          that._drawBreak(breakCoord, positionFrom, positionTo, breakStyle.width, breakOptions, mainGroup);\n\n          if (that._axisShift && options.visible) {\n            that._drawBreak(breakCoord, additionBreakFrom, additionBreakTo, breakStyle.width, breakOptions, additionGroup);\n          }\n        }\n      });\n    },\n    _getSpiderCategoryOption: _common.noop,\n    shift: function shift(margins) {\n      var that = this;\n      var options = that._options;\n      var isHorizontal = options.isHorizontal;\n      var axesSpacing = that.getMultipleAxesSpacing();\n      var constantLinesGroups = that._axisConstantLineGroups;\n\n      function shiftGroup(side, group) {\n        var attr = {\n          translateX: 0,\n          translateY: 0\n        };\n        var shift = margins[side] ? margins[side] + axesSpacing : 0;\n        attr[isHorizontal ? \"translateY\" : \"translateX\"] = (\"left\" === side || \"top\" === side ? -1 : 1) * shift;\n        (group[side] || group).attr(attr);\n        return shift;\n      }\n\n      that._axisShift = shiftGroup(options.position, that._axisGroup);\n      (isHorizontal ? [\"top\", \"bottom\"] : [\"left\", \"right\"]).forEach(function (side) {\n        shiftGroup(side, constantLinesGroups.above);\n        shiftGroup(side, constantLinesGroups.under);\n      });\n    }\n  }\n};\n\nfunction getLineDrawer(renderer, root, rotatePoints, positionFrom, breakStart, positionTo, isWaved) {\n  var elementType = isWaved ? \"bezier\" : \"line\";\n  var group = renderer.g().append(root);\n  return function (offset, attr) {\n    renderer.path(rotatePoints(getPoints(positionFrom, breakStart, positionTo, offset, isWaved)), elementType).attr(attr).append(group);\n  };\n}\n\nfunction getPoints(positionFrom, breakStart, positionTo, offset, isWaved) {\n  if (!isWaved) {\n    return [positionFrom, breakStart + offset, positionTo, breakStart + offset];\n  }\n\n  breakStart += offset;\n  var currentPosition;\n  var topPoint = breakStart + WAVED_LINE_TOP;\n  var centerPoint = breakStart + WAVED_LINE_CENTER;\n  var bottomPoint = breakStart + WAVED_LINE_BOTTOM;\n  var points = [[positionFrom, centerPoint]];\n\n  for (currentPosition = positionFrom; currentPosition < positionTo + WAVED_LINE_LENGTH; currentPosition += WAVED_LINE_LENGTH) {\n    points.push([currentPosition + 6, topPoint, currentPosition + 6, topPoint, currentPosition + 12, centerPoint, currentPosition + 18, bottomPoint, currentPosition + 18, bottomPoint, currentPosition + 24, centerPoint]);\n  }\n\n  return [].concat.apply([], points);\n}\n\nfunction rotateLine(lineCoords) {\n  var points = [];\n  var i;\n\n  for (i = 0; i < lineCoords.length; i += 2) {\n    points.push(lineCoords[i + 1]);\n    points.push(lineCoords[i]);\n  }\n\n  return points;\n}","map":{"version":3,"sources":["C:/Users/User/Documents/Templates/Angular/black-dashboard-pro-angular-v1.1.1/black-dashboard-pro-angular-v1.1.1/node_modules/devextreme/viz/axes/xy_axes.js"],"names":["_range","require","_range2","_interopRequireDefault","_format_helper","_date","_date2","_extend","_datetime_breaks","_common","_utils","_utils2","_type","_axes_constants","_axes_constants2","obj","__esModule","getNextDateUnit","default","correctDateWithUnitBeginning","_math","Math","_max","max","TOP","top","BOTTOM","bottom","LEFT","left","RIGHT","right","CENTER","center","SCALE_BREAK_OFFSET","RANGE_RATIO","WAVED_LINE_CENTER","WAVED_LINE_TOP","WAVED_LINE_BOTTOM","WAVED_LINE_LENGTH","TICKS_CORRECTIONS","prepareDatesDifferences","datesDifferences","tickInterval","dateUnitInterval","i","dateUnitIntervals","length","count","sortingBreaks","breaks","sort","a","b","from","filterBreaks","viewport","breakStyle","minVisible","maxVisible","breakSize","width","reduce","result","currentBreak","to","lastResult","newBreak","isDefined","gapSize","cumulativeWidth","convertMillisecondsToDateUnits","push","getMarkerDates","min","markerInterval","origMin","dates","getSequenceByInterval","slice","getStripHorizontalAlignmentPosition","alignment","position","getStripVerticalAlignmentPosition","getMarkerInterval","getMarkerFormat","curDate","prevDate","format","getDatesDifferences","getDateFormatByDifferences","getMaxSide","act","boxes","prevValue","box","getDistanceByAngle","bBox","rotationAngle","abs","PI","atan","height","sin","getMaxConstantLinePadding","constantLines","padding","options","paddingTopBottom","getConstantLineLabelMarginForVerticalAlignment","labelHeight","some","label","verticalAlignment","getLeftMargin","x","getRightMargin","generateRangesOnPoints","points","edgePoints","getRange","maxRange","ranges","curValue","curRange","indexOf","start","end","generateAutoBreaks","_ref","series","_ref2","logarithmBase","type","maxAutoBreakCount","getLog","visibleRange","s","getPointsInViewPort","concat","sortedAllPoints","filter","p","minDiff","epsilon","apply","map","r","_maxAutoBreakCount","module","exports","linear","_getStep","spacing","_options","minSpacing","func","_isHorizontal","maxLabelLength","_getMaxLabelHeight","getTicksCountInRange","_majorTicks","_validateOverlappingMode","mode","displayMode","validateOverlappingMode","_validateDisplayMode","getMarkerTrackers","_markerTrackers","_getSharpParam","opposite","_createAxisElement","_renderer","path","_updateAxisElementPosition","axisCoord","_axisPosition","canvas","_getCanvasStartEnd","_axisElement","attr","_getTranslatedCoord","value","offset","_translator","translate","_initAxisPositions","that","_orthogonalPositions","_getTickMarkPoints","coords","tickOptions","isHorizontal","tickStartCoord","tickOrientation","shift","getTickStartPositionShift","y","floor","_getTitleCoords","horizontal","align","title","fromStartToEnd","canvasStart","canvasEnd","coord","_drawTitleText","group","titleOptions","attrs","opacity","cssClass","text","rotate","css","patchFontOptions","font","append","_checkTitleOverflow","_updateTitleCoords","_title","element","_drawTitle","_axisTitleGroup","_measureTitle","originalSize","getBBox","_drawDateMarker","date","range","markerOptions","marker","invert","getBusinessRange","textIndent","textLeftIndent","pathElement","withoutStick","separatorHeight","stroke","color","sharp","_axisElementsGroup","String","formatLabel","labelOptions","cropped","line","getEnd","labelBBox","setTitle","hideLabel","dispose","hide","hidden","_drawDateMarkers","translator","_getViewportRange","minBound","markerDates","dateMarkers","markersAreaTop","dateMarker","draw","markerDate","_getLabelFormatOptions","isEmpty","visible","argumentType","topIndent","getDateUnitInterval","_tickInterval","markers","unshift","_adjustDateMarkers","_dateMarkers","_checkMarkersPosition","prevDateMarker","forEach","dy","textTopIndent","translateX","translateY","_initializeMarkersTrackers","renderer","businessRange","nextMarker","markerTracker","fill","data","startValue","endValue","formatString","markerLabelOptions","_markerLabelOptions","extend","_adjustConstantLineLabels","axisPosition","getCanvas","canvasLeft","canvasRight","canvasTop","canvasBottom","verticalCenter","horizontalCenter","maxLabel","item","linesOptions","paddingLeftRight","labelVerticalAlignment","labelHorizontalAlignment","horizontalAlignment","labelIsInside","_drawConstantLinesForEstimating","g","_drawConstantLineLabelText","root","_estimateLabelHeight","drawingType","overlappingBehavior","staggeringSpacing","sinCos","getCosAndSin","cos","indentFromAxis","estimateMargins","updateCanvas","ticksData","_createTicksAndLabelFormat","ticks","constantLineOptions","_outsideConstantLines","l","rootElement","labelIsVisible","labelValue","labelElement","_textFontStyles","_textOptions","titleElement","constantLinesLabelsElement","labelBox","titleBox","constantLinesBox","titleHeight","margin","constantLinesHeight","margins","remove","_checkAlignmentConstantLineLabels","toLowerCase","_getConstantLineLabelsCoords","lineLabelOptions","_getAdjustedStripLabelCoords","strip","stripOptions","labelWidth","labelCoords","_adjustTitle","boxTitle","loCoord","hiCoord","params","canvasLength","_getScreenDelta","setMaxSize","wordWrap","textOverflow","_wrapped","moreThanOriginalSize","restoreText","coordsIn","_boundaryTicksVisibility","adjust","alignToBounds","seriesData","_seriesData","_series","isVisible","seriesRange","getViewport","showZero","Range","correctValueZeroLevel","updateBusinessRange","adjustViewport","_breaks","_getScaleBreaks","isArgumentAxis","hasWrap","getAxisPosition","_getStick","valueMarginsEnabled","_getStripLabelCoords","stripLabelOptions","orthogonalPositions","_getTranslatedValue","pos1","pos2","areCoordsOutsideAxis","visibleArea","getVisibleArea","_getSkippedCategory","skippedCategory","discrete","_tickOffset","axisOptions","parser","dataType","workdaysOnly","generateDateBreaks","workWeek","singleWorkdays","holidays","autoBreaksEnabled","_drawBreak","translatedEnd","positionFrom","positionTo","breakStart","isInverted","borderColor","isWaved","spaceAttr","getPoints","rotateLine","drawer","getLineDrawer","_createBreakClipRect","_canvas","clipWidth","clipRect","_breaksElements","id","_createBreaksGroup","clipFrom","clipTo","_axisCssPrefix","_scaleBreaksGroup","_disposeBreaksGroup","drawScaleBreaks","customCanvas","additionGroup","additionBreakFrom","additionBreakTo","mainGroup","breakOptions","containerColor","_axisShift","br","breakCoord","_getSpiderCategoryOption","noop","axesSpacing","getMultipleAxesSpacing","constantLinesGroups","_axisConstantLineGroups","shiftGroup","side","_axisGroup","above","under","rotatePoints","elementType","currentPosition","topPoint","centerPoint","bottomPoint","lineCoords"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (viz/axes/xy_axes.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nvar _range = require(\"../translators/range\");\r\nvar _range2 = _interopRequireDefault(_range);\r\nvar _format_helper = require(\"../../format_helper\");\r\nvar _date = require(\"../../core/utils/date\");\r\nvar _date2 = _interopRequireDefault(_date);\r\nvar _extend = require(\"../../core/utils/extend\");\r\nvar _datetime_breaks = require(\"./datetime_breaks\");\r\nvar _common = require(\"../../core/utils/common\");\r\nvar _utils = require(\"../core/utils\");\r\nvar _utils2 = _interopRequireDefault(_utils);\r\nvar _type = require(\"../../core/utils/type\");\r\nvar _axes_constants = require(\"./axes_constants\");\r\nvar _axes_constants2 = _interopRequireDefault(_axes_constants);\r\n\r\nfunction _interopRequireDefault(obj) {\r\n    return obj && obj.__esModule ? obj : {\r\n        \"default\": obj\r\n    }\r\n}\r\nvar getNextDateUnit = _date2.default.getNextDateUnit;\r\nvar correctDateWithUnitBeginning = _date2.default.correctDateWithUnitBeginning;\r\nvar _math = Math;\r\nvar _max = _math.max;\r\nvar TOP = _axes_constants2.default.top;\r\nvar BOTTOM = _axes_constants2.default.bottom;\r\nvar LEFT = _axes_constants2.default.left;\r\nvar RIGHT = _axes_constants2.default.right;\r\nvar CENTER = _axes_constants2.default.center;\r\nvar SCALE_BREAK_OFFSET = 3;\r\nvar RANGE_RATIO = .3;\r\nvar WAVED_LINE_CENTER = 2;\r\nvar WAVED_LINE_TOP = 0;\r\nvar WAVED_LINE_BOTTOM = 4;\r\nvar WAVED_LINE_LENGTH = 24;\r\nvar TICKS_CORRECTIONS = {\r\n    left: -1,\r\n    top: -1,\r\n    right: 0,\r\n    bottom: 0,\r\n    center: -.5\r\n};\r\n\r\nfunction prepareDatesDifferences(datesDifferences, tickInterval) {\r\n    var dateUnitInterval;\r\n    var i;\r\n    if (\"week\" === tickInterval) {\r\n        tickInterval = \"day\"\r\n    }\r\n    if (\"quarter\" === tickInterval) {\r\n        tickInterval = \"month\"\r\n    }\r\n    if (datesDifferences[tickInterval]) {\r\n        for (i = 0; i < _date2.default.dateUnitIntervals.length; i++) {\r\n            dateUnitInterval = _date2.default.dateUnitIntervals[i];\r\n            if (datesDifferences[dateUnitInterval]) {\r\n                datesDifferences[dateUnitInterval] = false;\r\n                datesDifferences.count--\r\n            }\r\n            if (dateUnitInterval === tickInterval) {\r\n                break\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction sortingBreaks(breaks) {\r\n    return breaks.sort(function(a, b) {\r\n        return a.from - b.from\r\n    })\r\n}\r\n\r\nfunction filterBreaks(breaks, viewport, breakStyle) {\r\n    var minVisible = viewport.minVisible;\r\n    var maxVisible = viewport.maxVisible;\r\n    var breakSize = breakStyle ? breakStyle.width : 0;\r\n    return breaks.reduce(function(result, currentBreak) {\r\n        var from = currentBreak.from;\r\n        var to = currentBreak.to;\r\n        var lastResult = result[result.length - 1];\r\n        var newBreak;\r\n        if (!(0, _type.isDefined)(from) || !(0, _type.isDefined)(to)) {\r\n            return result\r\n        }\r\n        if (from > to) {\r\n            to = [from, from = to][0]\r\n        }\r\n        if (result.length && from < lastResult.to) {\r\n            if (to > lastResult.to) {\r\n                lastResult.to = to > maxVisible ? maxVisible : to;\r\n                if (lastResult.gapSize) {\r\n                    lastResult.gapSize = void 0;\r\n                    lastResult.cumulativeWidth += breakSize\r\n                }\r\n            }\r\n        } else {\r\n            if ((from >= minVisible && from < maxVisible || to <= maxVisible && to > minVisible) && to - from < maxVisible - minVisible) {\r\n                from = from >= minVisible ? from : minVisible;\r\n                to = to <= maxVisible ? to : maxVisible;\r\n                newBreak = {\r\n                    from: from,\r\n                    to: to,\r\n                    cumulativeWidth: (lastResult ? lastResult.cumulativeWidth : 0) + breakSize\r\n                };\r\n                if (currentBreak.gapSize) {\r\n                    newBreak.gapSize = _date2.default.convertMillisecondsToDateUnits(to - from);\r\n                    newBreak.cumulativeWidth = lastResult ? lastResult.cumulativeWidth : 0\r\n                }\r\n                result.push(newBreak)\r\n            }\r\n        }\r\n        return result\r\n    }, [])\r\n}\r\n\r\nfunction getMarkerDates(min, max, markerInterval) {\r\n    var origMin = min;\r\n    var dates;\r\n    min = correctDateWithUnitBeginning(min, markerInterval);\r\n    max = correctDateWithUnitBeginning(max, markerInterval);\r\n    dates = _date2.default.getSequenceByInterval(min, max, markerInterval);\r\n    if (dates.length && origMin > dates[0]) {\r\n        dates = dates.slice(1)\r\n    }\r\n    return dates\r\n}\r\n\r\nfunction getStripHorizontalAlignmentPosition(alignment) {\r\n    var position = \"start\";\r\n    if (\"center\" === alignment) {\r\n        position = \"center\"\r\n    }\r\n    if (\"right\" === alignment) {\r\n        position = \"end\"\r\n    }\r\n    return position\r\n}\r\n\r\nfunction getStripVerticalAlignmentPosition(alignment) {\r\n    var position = \"start\";\r\n    if (\"center\" === alignment) {\r\n        position = \"center\"\r\n    }\r\n    if (\"bottom\" === alignment) {\r\n        position = \"end\"\r\n    }\r\n    return position\r\n}\r\n\r\nfunction getMarkerInterval(tickInterval) {\r\n    var markerInterval = getNextDateUnit(tickInterval);\r\n    if (\"quarter\" === markerInterval) {\r\n        markerInterval = getNextDateUnit(markerInterval)\r\n    }\r\n    return markerInterval\r\n}\r\n\r\nfunction getMarkerFormat(curDate, prevDate, tickInterval, markerInterval) {\r\n    var format = markerInterval;\r\n    var datesDifferences = prevDate && _date2.default.getDatesDifferences(prevDate, curDate);\r\n    if (prevDate && \"year\" !== tickInterval) {\r\n        prepareDatesDifferences(datesDifferences, tickInterval);\r\n        format = (0, _format_helper.getDateFormatByDifferences)(datesDifferences)\r\n    }\r\n    return format\r\n}\r\n\r\nfunction getMaxSide(act, boxes) {\r\n    return boxes.reduce(function(prevValue, box) {\r\n        return _max(prevValue, act(box))\r\n    }, 0)\r\n}\r\n\r\nfunction getDistanceByAngle(bBox, rotationAngle) {\r\n    rotationAngle = _math.abs(rotationAngle);\r\n    rotationAngle = rotationAngle % 180 >= 90 ? 90 - rotationAngle % 90 : rotationAngle % 90;\r\n    var a = rotationAngle * (_math.PI / 180);\r\n    if (a >= _math.atan(bBox.height / bBox.width)) {\r\n        return bBox.height / _math.abs(_math.sin(a))\r\n    } else {\r\n        return bBox.width\r\n    }\r\n}\r\n\r\nfunction getMaxConstantLinePadding(constantLines) {\r\n    return constantLines.reduce(function(padding, options) {\r\n        return _max(padding, options.paddingTopBottom)\r\n    }, 0)\r\n}\r\n\r\nfunction getConstantLineLabelMarginForVerticalAlignment(constantLines, alignment, labelHeight) {\r\n    return constantLines.some(function(options) {\r\n        return options.label.verticalAlignment === alignment\r\n    }) && labelHeight || 0\r\n}\r\n\r\nfunction getLeftMargin(bBox) {\r\n    return _math.abs(bBox.x) || 0\r\n}\r\n\r\nfunction getRightMargin(bBox) {\r\n    return _math.abs(bBox.width - _math.abs(bBox.x)) || 0\r\n}\r\n\r\nfunction generateRangesOnPoints(points, edgePoints, getRange) {\r\n    var i;\r\n    var length;\r\n    var maxRange = null;\r\n    var ranges = [];\r\n    var curValue;\r\n    var prevValue;\r\n    var curRange;\r\n    for (i = 1, length = points.length; i < length; i++) {\r\n        curValue = points[i];\r\n        prevValue = points[i - 1];\r\n        curRange = getRange(curValue, prevValue);\r\n        if (edgePoints.indexOf(curValue) >= 0) {\r\n            if (!maxRange || curRange > maxRange.length) {\r\n                maxRange = {\r\n                    start: curValue,\r\n                    end: prevValue,\r\n                    length: curRange\r\n                }\r\n            }\r\n        } else {\r\n            if (maxRange && curRange < maxRange.length) {\r\n                ranges.push(maxRange)\r\n            } else {\r\n                ranges.push({\r\n                    start: curValue,\r\n                    end: prevValue,\r\n                    length: curRange\r\n                })\r\n            }\r\n            maxRange = null\r\n        }\r\n    }\r\n    if (maxRange) {\r\n        ranges.push(maxRange)\r\n    }\r\n    return ranges\r\n}\r\n\r\nfunction generateAutoBreaks(_ref, series, _ref2) {\r\n    var logarithmBase = _ref.logarithmBase,\r\n        type = _ref.type,\r\n        maxAutoBreakCount = _ref.maxAutoBreakCount;\r\n    var minVisible = _ref2.minVisible,\r\n        maxVisible = _ref2.maxVisible;\r\n    var breaks = [];\r\n    var getRange = \"logarithmic\" === type ? function(min, max) {\r\n        return _utils2.default.getLog(max / min, logarithmBase)\r\n    } : function(min, max) {\r\n        return max - min\r\n    };\r\n    var visibleRange = getRange(minVisible, maxVisible);\r\n    var points = series.reduce(function(result, s) {\r\n        var points = s.getPointsInViewPort();\r\n        result[0] = result[0].concat(points[0]);\r\n        result[1] = result[1].concat(points[1]);\r\n        return result\r\n    }, [\r\n        [],\r\n        []\r\n    ]);\r\n    var sortedAllPoints = points[0].concat(points[1]).sort(function(a, b) {\r\n        return b - a\r\n    });\r\n    var edgePoints = points[1].filter(function(p) {\r\n        return points[0].indexOf(p) < 0\r\n    });\r\n    var minDiff = RANGE_RATIO * visibleRange;\r\n    var ranges = generateRangesOnPoints(sortedAllPoints, edgePoints, getRange).sort(function(a, b) {\r\n        return b.length - a.length\r\n    });\r\n    var epsilon = _math.min.apply(null, ranges.map(function(r) {\r\n        return r.length\r\n    })) / 1e3;\r\n    var _maxAutoBreakCount = (0, _type.isDefined)(maxAutoBreakCount) ? _math.min(maxAutoBreakCount, ranges.length) : ranges.length;\r\n    for (var i = 0; i < _maxAutoBreakCount; i++) {\r\n        if (ranges[i].length >= minDiff) {\r\n            if (visibleRange <= ranges[i].length) {\r\n                break\r\n            }\r\n            visibleRange -= ranges[i].length;\r\n            if (visibleRange > epsilon || visibleRange < -epsilon) {\r\n                breaks.push({\r\n                    from: ranges[i].start,\r\n                    to: ranges[i].end\r\n                });\r\n                minDiff = RANGE_RATIO * visibleRange\r\n            }\r\n        } else {\r\n            break\r\n        }\r\n    }\r\n    sortingBreaks(breaks);\r\n    return breaks\r\n}\r\nmodule.exports = {\r\n    linear: {\r\n        _getStep: function(boxes, rotationAngle) {\r\n            var spacing = this._options.label.minSpacing;\r\n            var func = this._isHorizontal ? function(box) {\r\n                return box.width + spacing\r\n            } : function(box) {\r\n                return box.height\r\n            };\r\n            var maxLabelLength = getMaxSide(func, boxes);\r\n            if (rotationAngle) {\r\n                maxLabelLength = getDistanceByAngle({\r\n                    width: maxLabelLength,\r\n                    height: this._getMaxLabelHeight(boxes, 0)\r\n                }, rotationAngle)\r\n            }\r\n            return _axes_constants2.default.getTicksCountInRange(this._majorTicks, this._isHorizontal ? \"x\" : \"y\", maxLabelLength)\r\n        },\r\n        _getMaxLabelHeight: function(boxes, spacing) {\r\n            return getMaxSide(function(box) {\r\n                return box.height\r\n            }, boxes) + spacing\r\n        },\r\n        _validateOverlappingMode: function(mode, displayMode) {\r\n            if (this._isHorizontal && (\"rotate\" === displayMode || \"stagger\" === displayMode) || !this._isHorizontal) {\r\n                return _axes_constants2.default.validateOverlappingMode(mode)\r\n            }\r\n            return mode\r\n        },\r\n        _validateDisplayMode: function(mode) {\r\n            return this._isHorizontal ? mode : \"standard\"\r\n        },\r\n        getMarkerTrackers: function() {\r\n            return this._markerTrackers\r\n        },\r\n        _getSharpParam: function(opposite) {\r\n            return this._isHorizontal ^ opposite ? \"h\" : \"v\"\r\n        },\r\n        _createAxisElement: function() {\r\n            return this._renderer.path([], \"line\")\r\n        },\r\n        _updateAxisElementPosition: function() {\r\n            var axisCoord = this._axisPosition;\r\n            var canvas = this._getCanvasStartEnd();\r\n            this._axisElement.attr({\r\n                points: this._isHorizontal ? [canvas.start, axisCoord, canvas.end, axisCoord] : [axisCoord, canvas.start, axisCoord, canvas.end]\r\n            })\r\n        },\r\n        _getTranslatedCoord: function(value, offset) {\r\n            return this._translator.translate(value, offset)\r\n        },\r\n        _initAxisPositions: function() {\r\n            var that = this;\r\n            var position = that._options.position;\r\n            that._axisPosition = that._orthogonalPositions[\"top\" === position || \"left\" === position ? \"start\" : \"end\"]\r\n        },\r\n        _getTickMarkPoints: function(coords, length, tickOptions) {\r\n            var isHorizontal = this._isHorizontal;\r\n            var options = this._options;\r\n            var tickStartCoord;\r\n            if ((0, _type.isDefined)(options.tickOrientation)) {\r\n                tickStartCoord = TICKS_CORRECTIONS[options.tickOrientation] * length\r\n            } else {\r\n                var shift = tickOptions.shift || 0;\r\n                if (\"left\" === options.position || \"top\" === options.position) {\r\n                    shift = -shift\r\n                }\r\n                tickStartCoord = shift + this.getTickStartPositionShift(length)\r\n            }\r\n            return [coords.x + (isHorizontal ? 0 : tickStartCoord), coords.y + (isHorizontal ? tickStartCoord : 0), coords.x + (isHorizontal ? 0 : tickStartCoord + length), coords.y + (isHorizontal ? tickStartCoord + length : 0)]\r\n        },\r\n        getTickStartPositionShift: function(length) {\r\n            var options = this._options;\r\n            return length % 2 === 1 ? options.width % 2 === 0 && (\"left\" === options.position || \"top\" === options.position) || options.width % 2 === 1 && (\"right\" === options.position || \"bottom\" === options.position) ? Math.floor(-length / 2) : -Math.floor(length / 2) : -length / 2 + (options.width % 2 === 0 ? 0 : \"bottom\" === options.position || \"right\" === options.position ? -1 : 1)\r\n        },\r\n        _getTitleCoords: function() {\r\n            var that = this;\r\n            var horizontal = that._isHorizontal;\r\n            var x = that._axisPosition;\r\n            var y = that._axisPosition;\r\n            var align = that._options.title.alignment;\r\n            var canvas = that._getCanvasStartEnd();\r\n            var fromStartToEnd = horizontal || that._options.position === LEFT;\r\n            var canvasStart = fromStartToEnd ? canvas.start : canvas.end;\r\n            var canvasEnd = fromStartToEnd ? canvas.end : canvas.start;\r\n            var coord = align === LEFT ? canvasStart : align === RIGHT ? canvasEnd : canvas.start + (canvas.end - canvas.start) / 2;\r\n            if (horizontal) {\r\n                x = coord\r\n            } else {\r\n                y = coord\r\n            }\r\n            return {\r\n                x: x,\r\n                y: y\r\n            }\r\n        },\r\n        _drawTitleText: function(group, coords) {\r\n            var options = this._options;\r\n            var titleOptions = options.title;\r\n            var attrs = {\r\n                opacity: titleOptions.opacity,\r\n                align: titleOptions.alignment,\r\n                \"class\": titleOptions.cssClass\r\n            };\r\n            if (!titleOptions.text || !group) {\r\n                return\r\n            }\r\n            coords = coords || this._getTitleCoords();\r\n            if (!this._isHorizontal) {\r\n                attrs.rotate = options.position === LEFT ? 270 : 90\r\n            }\r\n            var text = this._renderer.text(titleOptions.text, coords.x, coords.y).css(_utils2.default.patchFontOptions(titleOptions.font)).attr(attrs).append(group);\r\n            this._checkTitleOverflow(text);\r\n            return text\r\n        },\r\n        _updateTitleCoords: function() {\r\n            this._title && this._title.element.attr(this._getTitleCoords())\r\n        },\r\n        _drawTitle: function() {\r\n            var title = this._drawTitleText(this._axisTitleGroup);\r\n            if (title) {\r\n                this._title = {\r\n                    element: title\r\n                }\r\n            }\r\n        },\r\n        _measureTitle: function() {\r\n            if (this._title) {\r\n                if (this._title.bBox && !this._title.originalSize) {\r\n                    this._title.originalSize = this._title.bBox\r\n                }\r\n                this._title.bBox = this._title.element.getBBox()\r\n            }\r\n        },\r\n        _drawDateMarker: function(date, options, range) {\r\n            var that = this;\r\n            var markerOptions = that._options.marker;\r\n            var invert = that._translator.getBusinessRange().invert;\r\n            var textIndent = markerOptions.width + markerOptions.textLeftIndent;\r\n            var text;\r\n            var pathElement;\r\n            if (null === options.x) {\r\n                return\r\n            }\r\n            if (!options.withoutStick) {\r\n                pathElement = that._renderer.path([options.x, options.y, options.x, options.y + markerOptions.separatorHeight], \"line\").attr({\r\n                    \"stroke-width\": markerOptions.width,\r\n                    stroke: markerOptions.color,\r\n                    \"stroke-opacity\": markerOptions.opacity,\r\n                    sharp: \"h\"\r\n                }).append(that._axisElementsGroup)\r\n            }\r\n            text = String(that.formatLabel(date, options.labelOptions, range));\r\n            return {\r\n                date: date,\r\n                x: options.x,\r\n                y: options.y,\r\n                cropped: options.withoutStick,\r\n                label: that._renderer.text(text, options.x, options.y).css(_utils2.default.patchFontOptions(markerOptions.label.font)).append(that._axisElementsGroup),\r\n                line: pathElement,\r\n                getEnd: function() {\r\n                    return this.x + (invert ? -1 : 1) * (textIndent + this.labelBBox.width)\r\n                },\r\n                setTitle: function() {\r\n                    this.title = text\r\n                },\r\n                hideLabel: function() {\r\n                    this.label.dispose();\r\n                    this.label = null;\r\n                    this.title = text\r\n                },\r\n                hide: function() {\r\n                    if (pathElement) {\r\n                        pathElement.dispose();\r\n                        pathElement = null\r\n                    }\r\n                    this.label.dispose();\r\n                    this.label = null;\r\n                    this.hidden = true\r\n                }\r\n            }\r\n        },\r\n        _drawDateMarkers: function() {\r\n            var that = this;\r\n            var options = that._options;\r\n            var translator = that._translator;\r\n            var viewport = that._getViewportRange();\r\n            var minBound = viewport.minVisible;\r\n            var tickInterval;\r\n            var markerInterval;\r\n            var markerDates;\r\n            var dateMarkers = [];\r\n            var markersAreaTop;\r\n            var dateMarker;\r\n\r\n            function draw(markerDate, format, withoutStick) {\r\n                return that._drawDateMarker(markerDate, {\r\n                    x: translator.translate(markerDate),\r\n                    y: markersAreaTop,\r\n                    labelOptions: that._getLabelFormatOptions(format),\r\n                    withoutStick: withoutStick\r\n                }, viewport)\r\n            }\r\n            if (viewport.isEmpty() || !options.marker.visible || \"datetime\" !== options.argumentType || \"discrete\" === options.type || that._majorTicks.length <= 1) {\r\n                return []\r\n            }\r\n            markersAreaTop = that._axisPosition + options.marker.topIndent;\r\n            tickInterval = _date2.default.getDateUnitInterval(this._tickInterval);\r\n            markerInterval = getMarkerInterval(tickInterval);\r\n            markerDates = getMarkerDates(minBound, viewport.maxVisible, markerInterval);\r\n            if (markerDates.length > 1 || 1 === markerDates.length && minBound < markerDates[0]) {\r\n                dateMarkers = markerDates.reduce(function(markers, curDate, i, dates) {\r\n                    var marker = draw(curDate, getMarkerFormat(curDate, dates[i - 1] || minBound < curDate && minBound, tickInterval, markerInterval));\r\n                    marker && markers.push(marker);\r\n                    return markers\r\n                }, []);\r\n                if (minBound < markerDates[0]) {\r\n                    dateMarker = draw(minBound, getMarkerFormat(minBound, markerDates[0], tickInterval, markerInterval), true);\r\n                    dateMarker && dateMarkers.unshift(dateMarker)\r\n                }\r\n            }\r\n            return dateMarkers\r\n        },\r\n        _adjustDateMarkers: function(offset) {\r\n            offset = offset || 0;\r\n            var that = this;\r\n            var markerOptions = this._options.marker;\r\n            var textIndent = markerOptions.width + markerOptions.textLeftIndent;\r\n            var invert = this._translator.getBusinessRange().invert;\r\n            var canvas = that._getCanvasStartEnd();\r\n            var dateMarkers = this._dateMarkers;\r\n            if (!dateMarkers.length) {\r\n                return offset\r\n            }\r\n            if (dateMarkers[0].cropped) {\r\n                if (!this._checkMarkersPosition(invert, dateMarkers[1], dateMarkers[0])) {\r\n                    dateMarkers[0].hideLabel()\r\n                }\r\n            }\r\n            var prevDateMarker;\r\n            dateMarkers.forEach(function(marker, i, markers) {\r\n                if (marker.cropped) {\r\n                    return\r\n                }\r\n                if (invert ? marker.getEnd() < canvas.end : marker.getEnd() > canvas.end) {\r\n                    marker.hideLabel()\r\n                } else {\r\n                    if (that._checkMarkersPosition(invert, marker, prevDateMarker)) {\r\n                        prevDateMarker = marker\r\n                    } else {\r\n                        marker.hide()\r\n                    }\r\n                }\r\n            });\r\n            this._dateMarkers.forEach(function(marker) {\r\n                if (marker.label) {\r\n                    var labelBBox = marker.labelBBox;\r\n                    var dy = marker.y + markerOptions.textTopIndent - labelBBox.y;\r\n                    marker.label.attr({\r\n                        translateX: invert ? marker.x - textIndent - labelBBox.x - labelBBox.width : marker.x + textIndent - labelBBox.x,\r\n                        translateY: dy + offset\r\n                    })\r\n                }\r\n                if (marker.line) {\r\n                    marker.line.attr({\r\n                        translateY: offset\r\n                    })\r\n                }\r\n            });\r\n            that._initializeMarkersTrackers(offset);\r\n            return offset + markerOptions.topIndent + markerOptions.separatorHeight\r\n        },\r\n        _checkMarkersPosition: function(invert, dateMarker, prevDateMarker) {\r\n            if (void 0 === prevDateMarker) {\r\n                return true\r\n            }\r\n            return invert ? dateMarker.x < prevDateMarker.getEnd() : dateMarker.x > prevDateMarker.getEnd()\r\n        },\r\n        _initializeMarkersTrackers: function(offset) {\r\n            var that = this;\r\n            var separatorHeight = that._options.marker.separatorHeight;\r\n            var renderer = that._renderer;\r\n            var businessRange = this._translator.getBusinessRange();\r\n            var canvas = that._getCanvasStartEnd();\r\n            var group = that._axisElementsGroup;\r\n            that._markerTrackers = this._dateMarkers.filter(function(marker) {\r\n                return !marker.hidden\r\n            }).map(function(marker, i, markers) {\r\n                var nextMarker = markers[i + 1] || {\r\n                    x: canvas.end,\r\n                    date: businessRange.max\r\n                };\r\n                var x = marker.x;\r\n                var y = marker.y + offset;\r\n                var markerTracker = renderer.path([x, y, x, y + separatorHeight, nextMarker.x, y + separatorHeight, nextMarker.x, y, x, y], \"area\").attr({\r\n                    \"stroke-width\": 1,\r\n                    stroke: \"grey\",\r\n                    fill: \"grey\",\r\n                    opacity: 1e-4\r\n                }).append(group);\r\n                markerTracker.data(\"range\", {\r\n                    startValue: marker.date,\r\n                    endValue: nextMarker.date\r\n                });\r\n                if (marker.title) {\r\n                    markerTracker.setTitle(marker.title)\r\n                }\r\n                return markerTracker\r\n            })\r\n        },\r\n        _getLabelFormatOptions: function(formatString) {\r\n            var that = this;\r\n            var markerLabelOptions = that._markerLabelOptions;\r\n            if (!markerLabelOptions) {\r\n                that._markerLabelOptions = markerLabelOptions = (0, _extend.extend)(true, {}, that._options.marker.label)\r\n            }\r\n            if (!(0, _type.isDefined)(that._options.marker.label.format)) {\r\n                markerLabelOptions.format = formatString\r\n            }\r\n            return markerLabelOptions\r\n        },\r\n        _adjustConstantLineLabels: function(constantLines) {\r\n            var that = this;\r\n            var axisPosition = that._options.position;\r\n            var canvas = that.getCanvas();\r\n            var canvasLeft = canvas.left;\r\n            var canvasRight = canvas.width - canvas.right;\r\n            var canvasTop = canvas.top;\r\n            var canvasBottom = canvas.height - canvas.bottom;\r\n            var verticalCenter = canvasTop + (canvasBottom - canvasTop) / 2;\r\n            var horizontalCenter = canvasLeft + (canvasRight - canvasLeft) / 2;\r\n            var maxLabel = 0;\r\n            constantLines.forEach(function(item) {\r\n                var isHorizontal = that._isHorizontal;\r\n                var linesOptions = item.options;\r\n                var paddingTopBottom = linesOptions.paddingTopBottom;\r\n                var paddingLeftRight = linesOptions.paddingLeftRight;\r\n                var labelOptions = linesOptions.label;\r\n                var labelVerticalAlignment = labelOptions.verticalAlignment;\r\n                var labelHorizontalAlignment = labelOptions.horizontalAlignment;\r\n                var labelIsInside = \"inside\" === labelOptions.position;\r\n                var label = item.label;\r\n                var box = item.labelBBox;\r\n                var translateX;\r\n                var translateY;\r\n                if (null === label || box.isEmpty) {\r\n                    return\r\n                }\r\n                if (isHorizontal) {\r\n                    if (labelIsInside) {\r\n                        if (labelHorizontalAlignment === LEFT) {\r\n                            translateX = item.coord - paddingLeftRight - box.x - box.width\r\n                        } else {\r\n                            translateX = item.coord + paddingLeftRight - box.x\r\n                        }\r\n                        switch (labelVerticalAlignment) {\r\n                            case CENTER:\r\n                                translateY = verticalCenter - box.y - box.height / 2;\r\n                                break;\r\n                            case BOTTOM:\r\n                                translateY = canvasBottom - paddingTopBottom - box.y - box.height;\r\n                                break;\r\n                            default:\r\n                                translateY = canvasTop + paddingTopBottom - box.y\r\n                        }\r\n                    } else {\r\n                        if (axisPosition === labelVerticalAlignment) {\r\n                            maxLabel = _max(maxLabel, box.height + paddingTopBottom)\r\n                        }\r\n                        translateX = item.coord - box.x - box.width / 2;\r\n                        if (labelVerticalAlignment === BOTTOM) {\r\n                            translateY = canvasBottom + paddingTopBottom - box.y\r\n                        } else {\r\n                            translateY = canvasTop - paddingTopBottom - box.y - box.height\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (labelIsInside) {\r\n                        if (labelVerticalAlignment === BOTTOM) {\r\n                            translateY = item.coord + paddingTopBottom - box.y\r\n                        } else {\r\n                            translateY = item.coord - paddingTopBottom - box.y - box.height\r\n                        }\r\n                        switch (labelHorizontalAlignment) {\r\n                            case CENTER:\r\n                                translateX = horizontalCenter - box.x - box.width / 2;\r\n                                break;\r\n                            case RIGHT:\r\n                                translateX = canvasRight - paddingLeftRight - box.x - box.width;\r\n                                break;\r\n                            default:\r\n                                translateX = canvasLeft + paddingLeftRight - box.x\r\n                        }\r\n                    } else {\r\n                        if (axisPosition === labelHorizontalAlignment) {\r\n                            maxLabel = _max(maxLabel, box.width + paddingLeftRight)\r\n                        }\r\n                        translateY = item.coord - box.y - box.height / 2;\r\n                        if (labelHorizontalAlignment === RIGHT) {\r\n                            translateX = canvasRight + paddingLeftRight - box.x\r\n                        } else {\r\n                            translateX = canvasLeft - paddingLeftRight - box.x - box.width\r\n                        }\r\n                    }\r\n                }\r\n                label.attr({\r\n                    translateX: translateX,\r\n                    translateY: translateY\r\n                })\r\n            });\r\n            return maxLabel\r\n        },\r\n        _drawConstantLinesForEstimating: function(constantLines) {\r\n            var that = this;\r\n            var renderer = this._renderer;\r\n            var group = renderer.g();\r\n            constantLines.forEach(function(options) {\r\n                that._drawConstantLineLabelText(options.label.text, 0, 0, options.label, group).attr({\r\n                    align: \"center\"\r\n                })\r\n            });\r\n            return group.append(renderer.root)\r\n        },\r\n        _estimateLabelHeight: function(bBox, labelOptions) {\r\n            var height = bBox.height;\r\n            var drawingType = labelOptions.drawingType;\r\n            if (\"stagger\" === this._validateDisplayMode(drawingType) || \"stagger\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\r\n                height = 2 * height + labelOptions.staggeringSpacing\r\n            }\r\n            if (\"rotate\" === this._validateDisplayMode(drawingType) || \"rotate\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\r\n                var sinCos = _utils2.default.getCosAndSin(labelOptions.rotationAngle);\r\n                height = height * sinCos.cos + bBox.width * sinCos.sin\r\n            }\r\n            return height && (height + labelOptions.indentFromAxis || 0) || 0\r\n        },\r\n        estimateMargins: function(canvas) {\r\n            this.updateCanvas(canvas);\r\n            var that = this;\r\n            var range = that._getViewportRange();\r\n            var ticksData = this._createTicksAndLabelFormat(range);\r\n            var ticks = ticksData.ticks;\r\n            var tickInterval = ticksData.tickInterval;\r\n            var options = this._options;\r\n            var constantLineOptions = that._outsideConstantLines.filter(function(l) {\r\n                return l.labelOptions.visible\r\n            }).map(function(l) {\r\n                return l.options\r\n            });\r\n            var rootElement = that._renderer.root;\r\n            var labelIsVisible = options.label.visible && !range.isEmpty() && ticks.length;\r\n            var labelValue = labelIsVisible && that.formatLabel(ticks[ticks.length - 1], options.label, void 0, void 0, tickInterval, ticks);\r\n            var labelElement = labelIsVisible && that._renderer.text(labelValue, 0, 0).css(that._textFontStyles).attr(that._textOptions).append(rootElement);\r\n            var titleElement = that._drawTitleText(rootElement, {\r\n                x: 0,\r\n                y: 0\r\n            });\r\n            var constantLinesLabelsElement = that._drawConstantLinesForEstimating(constantLineOptions);\r\n            var labelBox = labelElement && labelElement.getBBox() || {\r\n                x: 0,\r\n                y: 0,\r\n                width: 0,\r\n                height: 0\r\n            };\r\n            var titleBox = titleElement && titleElement.getBBox() || {\r\n                x: 0,\r\n                y: 0,\r\n                width: 0,\r\n                height: 0\r\n            };\r\n            var constantLinesBox = constantLinesLabelsElement.getBBox();\r\n            var titleHeight = titleBox.height ? titleBox.height + options.title.margin : 0;\r\n            var labelHeight = that._estimateLabelHeight(labelBox, options.label);\r\n            var constantLinesHeight = constantLinesBox.height ? constantLinesBox.height + getMaxConstantLinePadding(constantLineOptions) : 0;\r\n            var height = labelHeight + titleHeight;\r\n            var margins = {\r\n                left: _max(getLeftMargin(labelBox), getLeftMargin(constantLinesBox)),\r\n                right: _max(getRightMargin(labelBox), getRightMargin(constantLinesBox)),\r\n                top: (\"top\" === options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"top\", constantLinesHeight),\r\n                bottom: (\"top\" !== options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"bottom\", constantLinesHeight)\r\n            };\r\n            labelElement && labelElement.remove();\r\n            titleElement && titleElement.remove();\r\n            constantLinesLabelsElement && constantLinesLabelsElement.remove();\r\n            return margins\r\n        },\r\n        _checkAlignmentConstantLineLabels: function(labelOptions) {\r\n            var position = labelOptions.position;\r\n            var verticalAlignment = (labelOptions.verticalAlignment || \"\").toLowerCase();\r\n            var horizontalAlignment = (labelOptions.horizontalAlignment || \"\").toLowerCase();\r\n            if (this._isHorizontal) {\r\n                if (\"outside\" === position) {\r\n                    verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\r\n                    horizontalAlignment = CENTER\r\n                } else {\r\n                    verticalAlignment = verticalAlignment === CENTER ? CENTER : verticalAlignment === BOTTOM ? BOTTOM : TOP;\r\n                    horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT\r\n                }\r\n            } else {\r\n                if (\"outside\" === position) {\r\n                    verticalAlignment = CENTER;\r\n                    horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT\r\n                } else {\r\n                    verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\r\n                    horizontalAlignment = horizontalAlignment === RIGHT ? RIGHT : horizontalAlignment === CENTER ? CENTER : LEFT\r\n                }\r\n            }\r\n            labelOptions.verticalAlignment = verticalAlignment;\r\n            labelOptions.horizontalAlignment = horizontalAlignment\r\n        },\r\n        _getConstantLineLabelsCoords: function(value, lineLabelOptions) {\r\n            var that = this;\r\n            var x = value;\r\n            var y = value;\r\n            if (that._isHorizontal) {\r\n                y = that._orthogonalPositions[\"top\" === lineLabelOptions.verticalAlignment ? \"start\" : \"end\"]\r\n            } else {\r\n                x = that._orthogonalPositions[\"right\" === lineLabelOptions.horizontalAlignment ? \"end\" : \"start\"]\r\n            }\r\n            return {\r\n                x: x,\r\n                y: y\r\n            }\r\n        },\r\n        _getAdjustedStripLabelCoords: function(strip) {\r\n            var stripOptions = strip.options;\r\n            var paddingTopBottom = stripOptions.paddingTopBottom;\r\n            var paddingLeftRight = stripOptions.paddingLeftRight;\r\n            var horizontalAlignment = stripOptions.label.horizontalAlignment;\r\n            var verticalAlignment = stripOptions.label.verticalAlignment;\r\n            var box = strip.labelBBox;\r\n            var labelHeight = box.height;\r\n            var labelWidth = box.width;\r\n            var labelCoords = strip.labelCoords;\r\n            var y = labelCoords.y - box.y;\r\n            var x = labelCoords.x - box.x;\r\n            if (verticalAlignment === TOP) {\r\n                y += paddingTopBottom\r\n            } else {\r\n                if (verticalAlignment === CENTER) {\r\n                    y -= labelHeight / 2\r\n                } else {\r\n                    if (verticalAlignment === BOTTOM) {\r\n                        y -= paddingTopBottom + labelHeight\r\n                    }\r\n                }\r\n            }\r\n            if (horizontalAlignment === LEFT) {\r\n                x += paddingLeftRight\r\n            } else {\r\n                if (horizontalAlignment === CENTER) {\r\n                    x -= labelWidth / 2\r\n                } else {\r\n                    if (horizontalAlignment === RIGHT) {\r\n                        x -= paddingLeftRight + labelWidth\r\n                    }\r\n                }\r\n            }\r\n            return {\r\n                translateX: x,\r\n                translateY: y\r\n            }\r\n        },\r\n        _adjustTitle: function(offset) {\r\n            offset = offset || 0;\r\n            if (!this._title) {\r\n                return\r\n            }\r\n            var that = this;\r\n            var options = that._options;\r\n            var position = options.position;\r\n            var margin = options.title.margin;\r\n            var title = that._title;\r\n            var boxTitle = title.bBox;\r\n            var x = boxTitle.x;\r\n            var y = boxTitle.y;\r\n            var width = boxTitle.width;\r\n            var height = boxTitle.height;\r\n            var axisPosition = that._axisPosition;\r\n            var loCoord = axisPosition - margin - offset;\r\n            var hiCoord = axisPosition + margin + offset;\r\n            var params = {};\r\n            if (that._isHorizontal) {\r\n                if (position === TOP) {\r\n                    params.translateY = loCoord - (y + height)\r\n                } else {\r\n                    params.translateY = hiCoord - y\r\n                }\r\n            } else {\r\n                if (position === LEFT) {\r\n                    params.translateX = loCoord - (x + width)\r\n                } else {\r\n                    params.translateX = hiCoord - x\r\n                }\r\n            }\r\n            title.element.attr(params)\r\n        },\r\n        _checkTitleOverflow: function(titleElement) {\r\n            if (!this._title && !titleElement) {\r\n                return\r\n            }\r\n            var canvasLength = this._getScreenDelta();\r\n            var title = titleElement ? {\r\n                bBox: titleElement.getBBox(),\r\n                element: titleElement\r\n            } : this._title;\r\n            var titleOptions = this._options.title;\r\n            var boxTitle = title.bBox;\r\n            if ((this._isHorizontal ? boxTitle.width : boxTitle.height) > canvasLength) {\r\n                title.element.setMaxSize(canvasLength, void 0, {\r\n                    wordWrap: titleOptions.wordWrap || \"none\",\r\n                    textOverflow: titleOptions.textOverflow || \"ellipsis\"\r\n                });\r\n                this._wrapped = titleOptions.wordWrap && \"none\" !== titleOptions.wordWrap\r\n            } else {\r\n                var moreThanOriginalSize = title.originalSize && canvasLength > (this._isHorizontal ? title.originalSize.width : title.originalSize.height);\r\n                !this._wrapped && moreThanOriginalSize && title.element.restoreText()\r\n            }\r\n        },\r\n        coordsIn: function(x, y) {\r\n            var canvas = this.getCanvas();\r\n            var isHorizontal = this._options.isHorizontal;\r\n            var position = this._options.position;\r\n            var coord = isHorizontal ? y : x;\r\n            if (isHorizontal && (x < canvas.left || x > canvas.width - canvas.right) || !isHorizontal && (y < canvas.top || y > canvas.height - canvas.bottom)) {\r\n                return false\r\n            }\r\n            if (isHorizontal && position === _axes_constants2.default.top || !isHorizontal && position === _axes_constants2.default.left) {\r\n                return coord < canvas[position]\r\n            }\r\n            return coord > canvas[isHorizontal ? \"height\" : \"width\"] - canvas[position]\r\n        },\r\n        _boundaryTicksVisibility: {\r\n            min: true,\r\n            max: true\r\n        },\r\n        adjust: function(alignToBounds) {\r\n            var that = this;\r\n            var seriesData = that._seriesData;\r\n            var viewport = {\r\n                min: seriesData.min,\r\n                max: seriesData.max\r\n            };\r\n            if (!alignToBounds) {\r\n                viewport = that._series.filter(function(s) {\r\n                    return s.isVisible()\r\n                }).reduce(function(range, s) {\r\n                    var seriesRange = s.getViewport();\r\n                    range.min = (0, _type.isDefined)(seriesRange.min) ? range.min < seriesRange.min ? range.min : seriesRange.min : range.min;\r\n                    range.max = (0, _type.isDefined)(seriesRange.max) ? range.max > seriesRange.max ? range.max : seriesRange.max : range.max;\r\n                    if (s.showZero) {\r\n                        range = new _range2.default.Range(range);\r\n                        range.correctValueZeroLevel()\r\n                    }\r\n                    return range\r\n                }, {})\r\n            }\r\n            if ((0, _type.isDefined)(viewport.min) && (0, _type.isDefined)(viewport.max)) {\r\n                seriesData.minVisible = viewport.min;\r\n                seriesData.maxVisible = viewport.max\r\n            }\r\n            that._translator.updateBusinessRange(that.adjustViewport(seriesData));\r\n            that._breaks = that._getScaleBreaks(that._options, {\r\n                minVisible: seriesData.minVisible,\r\n                maxVisible: seriesData.maxVisible\r\n            }, that._series, that.isArgumentAxis)\r\n        },\r\n        hasWrap: function() {\r\n            return this._wrapped\r\n        },\r\n        getAxisPosition: function() {\r\n            return this._axisPosition\r\n        },\r\n        _getStick: function() {\r\n            return !this._options.valueMarginsEnabled\r\n        },\r\n        _getStripLabelCoords: function(from, to, stripLabelOptions) {\r\n            var that = this;\r\n            var orthogonalPositions = that._orthogonalPositions;\r\n            var isHorizontal = that._isHorizontal;\r\n            var horizontalAlignment = stripLabelOptions.horizontalAlignment;\r\n            var verticalAlignment = stripLabelOptions.verticalAlignment;\r\n            var x;\r\n            var y;\r\n            if (isHorizontal) {\r\n                if (horizontalAlignment === CENTER) {\r\n                    x = from + (to - from) / 2\r\n                } else {\r\n                    if (horizontalAlignment === LEFT) {\r\n                        x = from\r\n                    } else {\r\n                        if (horizontalAlignment === RIGHT) {\r\n                            x = to\r\n                        }\r\n                    }\r\n                }\r\n                y = orthogonalPositions[getStripVerticalAlignmentPosition(verticalAlignment)]\r\n            } else {\r\n                x = orthogonalPositions[getStripHorizontalAlignmentPosition(horizontalAlignment)];\r\n                if (verticalAlignment === TOP) {\r\n                    y = from\r\n                } else {\r\n                    if (verticalAlignment === CENTER) {\r\n                        y = to + (from - to) / 2\r\n                    } else {\r\n                        if (verticalAlignment === BOTTOM) {\r\n                            y = to\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return {\r\n                x: x,\r\n                y: y\r\n            }\r\n        },\r\n        _getTranslatedValue: function(value, offset) {\r\n            var pos1 = this._translator.translate(value, offset, \"semidiscrete\" === this._options.type && this._options.tickInterval);\r\n            var pos2 = this._axisPosition;\r\n            var isHorizontal = this._isHorizontal;\r\n            return {\r\n                x: isHorizontal ? pos1 : pos2,\r\n                y: isHorizontal ? pos2 : pos1\r\n            }\r\n        },\r\n        areCoordsOutsideAxis: function(coords) {\r\n            var coord = this._isHorizontal ? coords.x : coords.y;\r\n            var visibleArea = this.getVisibleArea();\r\n            if (coord < visibleArea[0] || coord > visibleArea[1]) {\r\n                return true\r\n            }\r\n            return false\r\n        },\r\n        _getSkippedCategory: function(ticks) {\r\n            var skippedCategory;\r\n            if (this._options.type === _axes_constants2.default.discrete && this._tickOffset && 0 !== ticks.length) {\r\n                skippedCategory = ticks[ticks.length - 1]\r\n            }\r\n            return skippedCategory\r\n        },\r\n        _getScaleBreaks: function(axisOptions, viewport, series, isArgumentAxis) {\r\n            var that = this;\r\n            var breaks = (axisOptions.breaks || []).map(function(b) {\r\n                return {\r\n                    from: that.parser(b.startValue),\r\n                    to: that.parser(b.endValue)\r\n                }\r\n            });\r\n            if (\"discrete\" !== axisOptions.type && \"datetime\" === axisOptions.dataType && axisOptions.workdaysOnly) {\r\n                breaks = breaks.concat((0, _datetime_breaks.generateDateBreaks)(viewport.minVisible, viewport.maxVisible, axisOptions.workWeek, axisOptions.singleWorkdays, axisOptions.holidays))\r\n            }\r\n            if (!isArgumentAxis && \"discrete\" !== axisOptions.type && \"datetime\" !== axisOptions.dataType && axisOptions.autoBreaksEnabled && 0 !== axisOptions.maxAutoBreakCount) {\r\n                breaks = breaks.concat(generateAutoBreaks(axisOptions, series, viewport))\r\n            }\r\n            return filterBreaks(sortingBreaks(breaks), viewport, axisOptions.breakStyle)\r\n        },\r\n        _drawBreak: function(translatedEnd, positionFrom, positionTo, width, options, group) {\r\n            var that = this;\r\n            var breakStart = translatedEnd - (!that._translator.isInverted() ? width + 1 : 0);\r\n            var attr = {\r\n                \"stroke-width\": 1,\r\n                stroke: options.borderColor,\r\n                sharp: !options.isWaved ? options.isHorizontal ? \"h\" : \"v\" : void 0\r\n            };\r\n            var spaceAttr = {\r\n                stroke: options.color,\r\n                \"stroke-width\": width\r\n            };\r\n            var getPoints = that._isHorizontal ? rotateLine : function(p) {\r\n                return p\r\n            };\r\n            var drawer = getLineDrawer(that._renderer, group, getPoints, positionFrom, breakStart, positionTo, options.isWaved);\r\n            drawer(width / 2, spaceAttr);\r\n            drawer(0, attr);\r\n            drawer(width, attr)\r\n        },\r\n        _createBreakClipRect: function(from, to) {\r\n            var that = this;\r\n            var canvas = that._canvas;\r\n            var clipWidth = to - from;\r\n            var clipRect;\r\n            if (that._isHorizontal) {\r\n                clipRect = that._renderer.clipRect(canvas.left, from, canvas.width, clipWidth)\r\n            } else {\r\n                clipRect = that._renderer.clipRect(from, canvas.top, clipWidth, canvas.height)\r\n            }\r\n            that._breaksElements = that._breaksElements || [];\r\n            that._breaksElements.push(clipRect);\r\n            return clipRect.id\r\n        },\r\n        _createBreaksGroup: function(clipFrom, clipTo) {\r\n            var that = this;\r\n            var group = that._renderer.g().attr({\r\n                \"class\": that._axisCssPrefix + \"breaks\",\r\n                \"clip-path\": that._createBreakClipRect(clipFrom, clipTo)\r\n            }).append(that._scaleBreaksGroup);\r\n            that._breaksElements = that._breaksElements || [];\r\n            that._breaksElements.push(group);\r\n            return group\r\n        },\r\n        _disposeBreaksGroup: function() {\r\n            (this._breaksElements || []).forEach(function(clipRect) {\r\n                clipRect.dispose()\r\n            });\r\n            this._breaksElements = null\r\n        },\r\n        drawScaleBreaks: function(customCanvas) {\r\n            var that = this;\r\n            var options = that._options;\r\n            var breakStyle = options.breakStyle;\r\n            var position = options.position;\r\n            var positionFrom;\r\n            var positionTo;\r\n            var breaks = that._translator.getBusinessRange().breaks || [];\r\n            var additionGroup;\r\n            var additionBreakFrom;\r\n            var additionBreakTo;\r\n            var mainGroup;\r\n            var breakOptions;\r\n            that._disposeBreaksGroup();\r\n            if (!(breaks && breaks.length)) {\r\n                return\r\n            }\r\n            breakOptions = {\r\n                color: that._options.containerColor,\r\n                borderColor: breakStyle.color,\r\n                isHorizontal: that._isHorizontal,\r\n                isWaved: \"straight\" !== breakStyle.line.toLowerCase()\r\n            };\r\n            if (customCanvas) {\r\n                positionFrom = customCanvas.start;\r\n                positionTo = customCanvas.end\r\n            } else {\r\n                positionFrom = that._orthogonalPositions.start - (options.visible && !that._axisShift && (\"left\" === position || \"top\" === position) ? SCALE_BREAK_OFFSET : 0);\r\n                positionTo = that._orthogonalPositions.end + (options.visible && (\"right\" === position || \"bottom\" === position) ? SCALE_BREAK_OFFSET : 0)\r\n            }\r\n            mainGroup = that._createBreaksGroup(positionFrom, positionTo);\r\n            if (that._axisShift && options.visible) {\r\n                additionBreakFrom = that._axisPosition - that._axisShift - SCALE_BREAK_OFFSET;\r\n                additionBreakTo = additionBreakFrom + 2 * SCALE_BREAK_OFFSET;\r\n                additionGroup = that._createBreaksGroup(additionBreakFrom, additionBreakTo)\r\n            }\r\n            breaks.forEach(function(br) {\r\n                if (!br.gapSize) {\r\n                    var breakCoord = that._getTranslatedCoord(br.to);\r\n                    that._drawBreak(breakCoord, positionFrom, positionTo, breakStyle.width, breakOptions, mainGroup);\r\n                    if (that._axisShift && options.visible) {\r\n                        that._drawBreak(breakCoord, additionBreakFrom, additionBreakTo, breakStyle.width, breakOptions, additionGroup)\r\n                    }\r\n                }\r\n            })\r\n        },\r\n        _getSpiderCategoryOption: _common.noop,\r\n        shift: function(margins) {\r\n            var that = this;\r\n            var options = that._options;\r\n            var isHorizontal = options.isHorizontal;\r\n            var axesSpacing = that.getMultipleAxesSpacing();\r\n            var constantLinesGroups = that._axisConstantLineGroups;\r\n\r\n            function shiftGroup(side, group) {\r\n                var attr = {\r\n                    translateX: 0,\r\n                    translateY: 0\r\n                };\r\n                var shift = margins[side] ? margins[side] + axesSpacing : 0;\r\n                attr[isHorizontal ? \"translateY\" : \"translateX\"] = (\"left\" === side || \"top\" === side ? -1 : 1) * shift;\r\n                (group[side] || group).attr(attr);\r\n                return shift\r\n            }\r\n            that._axisShift = shiftGroup(options.position, that._axisGroup);\r\n            (isHorizontal ? [\"top\", \"bottom\"] : [\"left\", \"right\"]).forEach(function(side) {\r\n                shiftGroup(side, constantLinesGroups.above);\r\n                shiftGroup(side, constantLinesGroups.under)\r\n            })\r\n        }\r\n    }\r\n};\r\n\r\nfunction getLineDrawer(renderer, root, rotatePoints, positionFrom, breakStart, positionTo, isWaved) {\r\n    var elementType = isWaved ? \"bezier\" : \"line\";\r\n    var group = renderer.g().append(root);\r\n    return function(offset, attr) {\r\n        renderer.path(rotatePoints(getPoints(positionFrom, breakStart, positionTo, offset, isWaved)), elementType).attr(attr).append(group)\r\n    }\r\n}\r\n\r\nfunction getPoints(positionFrom, breakStart, positionTo, offset, isWaved) {\r\n    if (!isWaved) {\r\n        return [positionFrom, breakStart + offset, positionTo, breakStart + offset]\r\n    }\r\n    breakStart += offset;\r\n    var currentPosition;\r\n    var topPoint = breakStart + WAVED_LINE_TOP;\r\n    var centerPoint = breakStart + WAVED_LINE_CENTER;\r\n    var bottomPoint = breakStart + WAVED_LINE_BOTTOM;\r\n    var points = [\r\n        [positionFrom, centerPoint]\r\n    ];\r\n    for (currentPosition = positionFrom; currentPosition < positionTo + WAVED_LINE_LENGTH; currentPosition += WAVED_LINE_LENGTH) {\r\n        points.push([currentPosition + 6, topPoint, currentPosition + 6, topPoint, currentPosition + 12, centerPoint, currentPosition + 18, bottomPoint, currentPosition + 18, bottomPoint, currentPosition + 24, centerPoint])\r\n    }\r\n    return [].concat.apply([], points)\r\n}\r\n\r\nfunction rotateLine(lineCoords) {\r\n    var points = [];\r\n    var i;\r\n    for (i = 0; i < lineCoords.length; i += 2) {\r\n        points.push(lineCoords[i + 1]);\r\n        points.push(lineCoords[i])\r\n    }\r\n    return points\r\n}\r\n"]},"metadata":{},"sourceType":"script"}