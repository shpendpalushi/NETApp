{"ast":null,"code":"/**\r\n * DevExtreme (viz/gauges/circular_indicators.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar baseIndicatorsModule = require(\"./base_indicators\");\n\nvar BaseIndicator = baseIndicatorsModule.BaseIndicator;\nvar BaseTextCloudMarker = baseIndicatorsModule.BaseTextCloudMarker;\nvar BaseRangeBar = baseIndicatorsModule.BaseRangeBar;\n\nvar vizUtils = require(\"../core/utils\");\n\nvar _Number = Number;\nvar _getCosAndSin = vizUtils.getCosAndSin;\nvar _convertAngleToRendererSpace = vizUtils.convertAngleToRendererSpace;\nvar SimpleIndicator = BaseIndicator.inherit({\n  _move: function _move() {\n    var that = this;\n    var options = that._options;\n\n    var angle = _convertAngleToRendererSpace(that._actualPosition);\n\n    that._rootElement.rotate(angle, options.x, options.y);\n\n    that._trackerElement && that._trackerElement.rotate(angle, options.x, options.y);\n  },\n  _isEnabled: function _isEnabled() {\n    return this._options.width > 0;\n  },\n  _isVisible: function _isVisible(layout) {\n    return layout.radius - _Number(this._options.indentFromCenter) > 0;\n  },\n  _getTrackerSettings: function _getTrackerSettings() {\n    var options = this._options;\n\n    var radius = this._getRadius();\n\n    var indentFromCenter = this._getIndentFromCenter();\n\n    var x = options.x;\n    var y = options.y - (radius + indentFromCenter) / 2;\n    var width = options.width / 2;\n    var length = (radius - indentFromCenter) / 2;\n    width > 10 || (width = 10);\n    length > 10 || (length = 10);\n    return {\n      points: [x - width, y - length, x - width, y + length, x + width, y + length, x + width, y - length]\n    };\n  },\n  _render: function _render() {\n    var that = this;\n\n    that._renderPointer();\n  },\n  _clearPointer: function _clearPointer() {\n    delete this._element;\n  },\n  _clear: function _clear() {\n    this._clearPointer();\n  },\n  _getIndentFromCenter: function _getIndentFromCenter(radius) {\n    return Number(this._options.indentFromCenter) || 0;\n  },\n  _getRadius: function _getRadius() {\n    return 0;\n  },\n  measure: function measure(layout) {\n    var result = {\n      max: layout.radius\n    };\n\n    if (this._options.indentFromCenter < 0) {\n      result.inverseHorizontalOffset = result.inverseVerticalOffset = -_Number(this._options.indentFromCenter);\n    }\n\n    return result;\n  },\n  getTooltipParameters: function getTooltipParameters() {\n    var options = this._options;\n\n    var cosSin = _getCosAndSin(this._actualPosition);\n\n    var r = (this._getRadius() + this._getIndentFromCenter()) / 2;\n    return {\n      x: options.x + cosSin.cos * r,\n      y: options.y - cosSin.sin * r,\n      value: this._currentValue,\n      color: options.color,\n      offset: options.width / 2\n    };\n  }\n});\nvar NeedleIndicator = SimpleIndicator.inherit({\n  _isVisible: function _isVisible(layout) {\n    var indentFromCenter = this._adjustOffset(Number(this._options.indentFromCenter), layout.radius);\n\n    var offset = this._adjustOffset(Number(this._options.offset), layout.radius);\n\n    return layout.radius - indentFromCenter - offset > 0;\n  },\n  getOffset: function getOffset() {\n    return 0;\n  },\n  _adjustOffset: function _adjustOffset(value, radius) {\n    var minRadius = Number(this._options.beginAdaptingAtRadius);\n    var diff = radius / minRadius;\n\n    if (diff < 1) {\n      value = Math.floor(value * diff);\n    }\n\n    return value || 0;\n  },\n  _getIndentFromCenter: function _getIndentFromCenter(radius) {\n    return this._adjustOffset(Number(this._options.indentFromCenter), this._options.radius);\n  },\n  _getRadius: function _getRadius() {\n    var options = this._options;\n    return options.radius - this._adjustOffset(Number(options.offset), options.radius);\n  },\n  _renderSpindle: function _renderSpindle() {\n    var that = this;\n    var options = that._options;\n    var radius = options.radius;\n\n    var spindleSize = 2 * this._adjustOffset(_Number(options.spindleSize) / 2, radius);\n\n    var gapSize;\n    gapSize = 2 * this._adjustOffset(_Number(options.spindleGapSize) / 2, radius) || 0;\n\n    if (gapSize > 0) {\n      gapSize = gapSize <= spindleSize ? gapSize : spindleSize;\n    }\n\n    if (spindleSize > 0) {\n      that._spindleOuter = that._spindleOuter || that._renderer.circle().append(that._rootElement);\n      that._spindleInner = that._spindleInner || that._renderer.circle().append(that._rootElement);\n\n      that._spindleOuter.attr({\n        \"class\": \"dxg-spindle-border\",\n        cx: options.x,\n        cy: options.y,\n        r: spindleSize / 2\n      });\n\n      that._spindleInner.attr({\n        \"class\": \"dxg-spindle-hole\",\n        cx: options.x,\n        cy: options.y,\n        r: gapSize / 2,\n        fill: options.containerBackgroundColor\n      });\n    }\n  },\n  _render: function _render() {\n    var that = this;\n    that.callBase();\n\n    that._renderSpindle();\n  },\n  _clear: function _clear() {\n    this.callBase();\n    delete this._spindleOuter;\n    delete this._spindleInner;\n  }\n});\nvar rectangleNeedle = NeedleIndicator.inherit({\n  _renderPointer: function _renderPointer() {\n    var that = this;\n    var options = that._options;\n\n    var y2 = options.y - this._getRadius();\n\n    var y1 = options.y - this._getIndentFromCenter();\n\n    var x1 = options.x - options.width / 2;\n\n    var x2 = x1 + _Number(options.width);\n\n    that._element = that._element || that._renderer.path([], \"area\").append(that._rootElement);\n\n    that._element.attr({\n      points: [x1, y1, x1, y2, x2, y2, x2, y1]\n    });\n  }\n});\nvar triangleNeedle = NeedleIndicator.inherit({\n  _renderPointer: function _renderPointer() {\n    var that = this;\n    var options = that._options;\n\n    var y2 = options.y - this._getRadius();\n\n    var y1 = options.y - this._getIndentFromCenter();\n\n    var x1 = options.x - options.width / 2;\n    var x2 = options.x + options.width / 2;\n    that._element = that._element || that._renderer.path([], \"area\").append(that._rootElement);\n\n    that._element.attr({\n      points: [x1, y1, options.x, y2, x2, y1]\n    });\n  }\n});\nvar twoColorNeedle = NeedleIndicator.inherit({\n  _renderPointer: function _renderPointer() {\n    var that = this;\n    var options = that._options;\n    var x1 = options.x - options.width / 2;\n    var x2 = options.x + options.width / 2;\n\n    var y4 = options.y - this._getRadius();\n\n    var y1 = options.y - this._getIndentFromCenter();\n\n    var fraction = _Number(options.secondFraction) || 0;\n    var y2;\n    var y3;\n\n    if (fraction >= 1) {\n      y2 = y3 = y1;\n    } else {\n      if (fraction <= 0) {\n        y2 = y3 = y4;\n      } else {\n        y3 = y4 + (y1 - y4) * fraction;\n        y2 = y3 + _Number(options.space);\n      }\n    }\n\n    that._firstElement = that._firstElement || that._renderer.path([], \"area\").append(that._rootElement);\n    that._spaceElement = that._spaceElement || that._renderer.path([], \"area\").append(that._rootElement);\n    that._secondElement = that._secondElement || that._renderer.path([], \"area\").append(that._rootElement);\n\n    that._firstElement.attr({\n      points: [x1, y1, x1, y2, x2, y2, x2, y1]\n    });\n\n    that._spaceElement.attr({\n      points: [x1, y2, x1, y3, x2, y3, x2, y2],\n      \"class\": \"dxg-hole\",\n      fill: options.containerBackgroundColor\n    });\n\n    that._secondElement.attr({\n      points: [x1, y3, x1, y4, x2, y4, x2, y3],\n      \"class\": \"dxg-part\",\n      fill: options.secondColor\n    });\n  },\n  _clearPointer: function _clearPointer() {\n    delete this._firstElement;\n    delete this._secondElement;\n    delete this._spaceElement;\n  }\n});\nvar triangleMarker = SimpleIndicator.inherit({\n  _isEnabled: function _isEnabled() {\n    return this._options.length > 0 && this._options.width > 0;\n  },\n  _isVisible: function _isVisible(layout) {\n    return layout.radius > 0;\n  },\n  _render: function _render() {\n    var that = this;\n    var options = that._options;\n    var x = options.x;\n    var y1 = options.y - options.radius;\n    var dx = options.width / 2 || 0;\n\n    var y2 = y1 - _Number(options.length);\n\n    var settings;\n    that._element = that._element || that._renderer.path([], \"area\").append(that._rootElement);\n    settings = {\n      points: [x, y1, x - dx, y2, x + dx, y2],\n      stroke: \"none\",\n      \"stroke-width\": 0,\n      \"stroke-linecap\": \"square\"\n    };\n\n    if (options.space > 0) {\n      settings[\"stroke-width\"] = Math.min(options.space, options.width / 4) || 0;\n      settings.stroke = settings[\"stroke-width\"] > 0 ? options.containerBackgroundColor || \"none\" : \"none\";\n    }\n\n    that._element.attr(settings).sharp();\n  },\n  _clear: function _clear() {\n    delete this._element;\n  },\n  _getTrackerSettings: function _getTrackerSettings() {\n    var options = this._options;\n    var x = options.x;\n    var y = options.y - options.radius - options.length / 2;\n    var width = options.width / 2;\n    var length = options.length / 2;\n    width > 10 || (width = 10);\n    length > 10 || (length = 10);\n    return {\n      points: [x - width, y - length, x - width, y + length, x + width, y + length, x + width, y - length]\n    };\n  },\n  measure: function measure(layout) {\n    return {\n      min: layout.radius,\n      max: layout.radius + _Number(this._options.length)\n    };\n  },\n  getTooltipParameters: function getTooltipParameters() {\n    var options = this._options;\n\n    var cosSin = _getCosAndSin(this._actualPosition);\n\n    var r = options.radius + options.length / 2;\n    var parameters = this.callBase();\n    parameters.x = options.x + cosSin.cos * r;\n    parameters.y = options.y - cosSin.sin * r;\n    parameters.offset = options.length / 2;\n    return parameters;\n  }\n});\nvar textCloud = BaseTextCloudMarker.inherit({\n  _isEnabled: function _isEnabled() {\n    return true;\n  },\n  _isVisible: function _isVisible(layout) {\n    return layout.radius > 0;\n  },\n  _getTextCloudOptions: function _getTextCloudOptions() {\n    var that = this;\n\n    var cosSin = _getCosAndSin(that._actualPosition);\n\n    var nAngle = vizUtils.normalizeAngle(that._actualPosition);\n    return {\n      x: that._options.x + cosSin.cos * that._options.radius,\n      y: that._options.y - cosSin.sin * that._options.radius,\n      type: nAngle > 270 ? \"left-top\" : nAngle > 180 ? \"top-right\" : nAngle > 90 ? \"right-bottom\" : \"bottom-left\"\n    };\n  },\n  measure: function measure(layout) {\n    var that = this;\n    var arrowLength = _Number(that._options.arrowLength) || 0;\n    var verticalOffset;\n    var horizontalOffset;\n\n    that._measureText();\n\n    verticalOffset = that._textFullHeight + arrowLength;\n    horizontalOffset = that._textFullWidth + arrowLength;\n    return {\n      min: layout.radius,\n      max: layout.radius,\n      horizontalOffset: horizontalOffset,\n      verticalOffset: verticalOffset,\n      inverseHorizontalOffset: horizontalOffset,\n      inverseVerticalOffset: verticalOffset\n    };\n  }\n});\nvar rangeBar = BaseRangeBar.inherit({\n  _isEnabled: function _isEnabled() {\n    return this._options.size > 0;\n  },\n  _isVisible: function _isVisible(layout) {\n    return layout.radius - _Number(this._options.size) > 0;\n  },\n  _createBarItem: function _createBarItem() {\n    return this._renderer.arc().attr({\n      \"stroke-linejoin\": \"round\"\n    }).append(this._rootElement);\n  },\n  _createTracker: function _createTracker() {\n    return this._renderer.arc().attr({\n      \"stroke-linejoin\": \"round\"\n    });\n  },\n  _setBarSides: function _setBarSides() {\n    var that = this;\n    that._maxSide = that._options.radius;\n    that._minSide = that._maxSide - _Number(that._options.size);\n  },\n  _getSpace: function _getSpace() {\n    var options = this._options;\n    return options.space > 0 ? 180 * options.space / options.radius / Math.PI : 0;\n  },\n  _isTextVisible: function _isTextVisible() {\n    var options = this._options.text || {};\n    return options.indent > 0;\n  },\n  _setTextItemsSides: function _setTextItemsSides() {\n    var that = this;\n    var options = that._options;\n\n    var indent = _Number(options.text.indent);\n\n    that._lineFrom = options.y - options.radius;\n    that._lineTo = that._lineFrom - indent;\n    that._textRadius = options.radius + indent;\n  },\n  _getPositions: function _getPositions() {\n    var that = this;\n    var basePosition = that._basePosition;\n    var actualPosition = that._actualPosition;\n    var mainPosition1;\n    var mainPosition2;\n\n    if (basePosition >= actualPosition) {\n      mainPosition1 = basePosition;\n      mainPosition2 = actualPosition;\n    } else {\n      mainPosition1 = actualPosition;\n      mainPosition2 = basePosition;\n    }\n\n    return {\n      start: that._startPosition,\n      end: that._endPosition,\n      main1: mainPosition1,\n      main2: mainPosition2,\n      back1: Math.min(mainPosition1 + that._space, that._startPosition),\n      back2: Math.max(mainPosition2 - that._space, that._endPosition)\n    };\n  },\n  _buildItemSettings: function _buildItemSettings(from, to) {\n    var that = this;\n    return {\n      x: that._options.x,\n      y: that._options.y,\n      innerRadius: that._minSide,\n      outerRadius: that._maxSide,\n      startAngle: to,\n      endAngle: from\n    };\n  },\n  _updateTextPosition: function _updateTextPosition() {\n    var that = this;\n\n    var cosSin = _getCosAndSin(that._actualPosition);\n\n    var x = that._options.x + that._textRadius * cosSin.cos;\n    var y = that._options.y - that._textRadius * cosSin.sin;\n    x += cosSin.cos * that._textWidth * .6;\n    y -= cosSin.sin * that._textHeight * .6;\n\n    that._text.attr({\n      x: x,\n      y: y + that._textVerticalOffset\n    });\n  },\n  _updateLinePosition: function _updateLinePosition() {\n    var that = this;\n    var x = that._options.x;\n    var x1;\n    var x2;\n\n    if (that._basePosition > that._actualPosition) {\n      x1 = x - 2;\n      x2 = x;\n    } else {\n      if (that._basePosition < that._actualPosition) {\n        x1 = x;\n        x2 = x + 2;\n      } else {\n        x1 = x - 1;\n        x2 = x + 1;\n      }\n    }\n\n    that._line.attr({\n      points: [x1, that._lineFrom, x1, that._lineTo, x2, that._lineTo, x2, that._lineFrom]\n    }).rotate(_convertAngleToRendererSpace(that._actualPosition), x, that._options.y).sharp();\n  },\n  _getTooltipPosition: function _getTooltipPosition() {\n    var that = this;\n\n    var cosSin = _getCosAndSin((that._basePosition + that._actualPosition) / 2);\n\n    var r = (that._minSide + that._maxSide) / 2;\n    return {\n      x: that._options.x + cosSin.cos * r,\n      y: that._options.y - cosSin.sin * r\n    };\n  },\n  measure: function measure(layout) {\n    var that = this;\n    var result = {\n      min: layout.radius - _Number(that._options.size),\n      max: layout.radius\n    };\n\n    that._measureText();\n\n    if (that._hasText) {\n      result.max += _Number(that._options.text.indent);\n      result.horizontalOffset = that._textWidth;\n      result.verticalOffset = that._textHeight;\n    }\n\n    return result;\n  }\n});\nexports._default = rectangleNeedle;\nexports.rectangleneedle = rectangleNeedle;\nexports.triangleneedle = triangleNeedle;\nexports.twocolorneedle = twoColorNeedle;\nexports.trianglemarker = triangleMarker;\nexports.textcloud = textCloud;\nexports.rangebar = rangeBar;","map":null,"metadata":{},"sourceType":"script"}