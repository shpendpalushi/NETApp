{"ast":null,"code":"/**\r\n * DevExtreme (viz/gauges/base_range_container.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar iterateUtils = require(\"../../core/utils/iterator\");\n\nvar BaseElement = require(\"./base_indicators\").BaseElement;\n\nvar _Number = Number;\nvar _abs = Math.abs;\n\nvar _isString = require(\"../../core/utils/type\").isString;\n\nvar _isArray = Array.isArray;\nvar _isFinite = isFinite;\nvar _each = iterateUtils.each;\nvar BaseRangeContainer = BaseElement.inherit({\n  _init: function _init() {\n    this._root = this._renderer.g().attr({\n      \"class\": \"dxg-range-container\"\n    }).linkOn(this._container, \"range-container\");\n  },\n  _dispose: function _dispose() {\n    this._root.linkOff();\n  },\n  clean: function clean() {\n    this._root.linkRemove().clear();\n\n    this._options = this.enabled = null;\n    return this;\n  },\n  _getRanges: function _getRanges() {\n    var that = this;\n    var options = that._options;\n    var translator = that._translator;\n    var totalStart = translator.getDomain()[0];\n    var totalEnd = translator.getDomain()[1];\n    var totalDelta = totalEnd - totalStart;\n    var isNotEmptySegment = totalDelta >= 0 ? isNotEmptySegmentAsc : isNotEmptySegmentDesc;\n    var subtractSegment = totalDelta >= 0 ? subtractSegmentAsc : subtractSegmentDesc;\n    var list = [];\n    var ranges = [];\n    var backgroundRanges = [{\n      start: totalStart,\n      end: totalEnd\n    }];\n    var threshold = _abs(totalDelta) / 1e4;\n    var palette;\n    var backgroundColor = _isString(options.backgroundColor) ? options.backgroundColor : \"none\";\n    var width = options.width || {};\n\n    var startWidth = _Number(width > 0 ? width : width.start);\n\n    var endWidth = _Number(width > 0 ? width : width.end);\n\n    var deltaWidth = endWidth - startWidth;\n\n    if (void 0 !== options.ranges && !_isArray(options.ranges)) {\n      return null;\n    }\n\n    if (!(startWidth >= 0 && endWidth >= 0 && startWidth + endWidth > 0)) {\n      return null;\n    }\n\n    list = (_isArray(options.ranges) ? options.ranges : []).reduce(function (result, rangeOptions, i) {\n      rangeOptions = rangeOptions || {};\n      var start = translator.adjust(rangeOptions.startValue);\n      var end = translator.adjust(rangeOptions.endValue);\n\n      if (_isFinite(start) && _isFinite(end) && isNotEmptySegment(start, end, threshold)) {\n        result.push({\n          start: start,\n          end: end,\n          color: rangeOptions.color,\n          classIndex: i\n        });\n      }\n\n      return result;\n    }, []);\n    palette = that._themeManager.createPalette(options.palette, {\n      type: \"indicatingSet\",\n      extensionMode: options.paletteExtensionMode,\n      keepLastColorInEnd: true,\n      count: list.length\n    });\n\n    _each(list, function (_, item) {\n      var paletteColor = palette.getNextColor();\n      item.color = _isString(item.color) && item.color || paletteColor || \"none\";\n      item.className = \"dxg-range dxg-range-\" + item.classIndex;\n      delete item.classIndex;\n    });\n\n    _each(list, function (_, item) {\n      var i;\n      var ii;\n      var sub;\n      var subs;\n      var range;\n      var newRanges = [];\n      var newBackgroundRanges = [];\n\n      for (i = 0, ii = ranges.length; i < ii; ++i) {\n        range = ranges[i];\n        subs = subtractSegment(range.start, range.end, item.start, item.end);\n        (sub = subs[0]) && (sub.color = range.color) && (sub.className = range.className) && newRanges.push(sub);\n        (sub = subs[1]) && (sub.color = range.color) && (sub.className = range.className) && newRanges.push(sub);\n      }\n\n      newRanges.push(item);\n      ranges = newRanges;\n\n      for (i = 0, ii = backgroundRanges.length; i < ii; ++i) {\n        range = backgroundRanges[i];\n        subs = subtractSegment(range.start, range.end, item.start, item.end);\n        (sub = subs[0]) && newBackgroundRanges.push(sub);\n        (sub = subs[1]) && newBackgroundRanges.push(sub);\n      }\n\n      backgroundRanges = newBackgroundRanges;\n    });\n\n    _each(backgroundRanges, function (_, range) {\n      range.color = backgroundColor;\n      range.className = \"dxg-range dxg-background-range\";\n      ranges.push(range);\n    });\n\n    _each(ranges, function (_, range) {\n      range.startWidth = (range.start - totalStart) / totalDelta * deltaWidth + startWidth;\n      range.endWidth = (range.end - totalStart) / totalDelta * deltaWidth + startWidth;\n    });\n\n    return ranges;\n  },\n  render: function render(options) {\n    var that = this;\n    that._options = options;\n\n    that._processOptions();\n\n    that._ranges = that._getRanges();\n\n    if (that._ranges) {\n      that.enabled = true;\n\n      that._root.linkAppend();\n    }\n\n    return that;\n  },\n  resize: function resize(layout) {\n    var that = this;\n\n    that._root.clear();\n\n    if (that._isVisible(layout)) {\n      _each(that._ranges, function (_, range) {\n        that._createRange(range, layout).attr({\n          fill: range.color,\n          \"class\": range.className\n        }).append(that._root);\n      });\n    }\n\n    return that;\n  },\n  _processOptions: null,\n  _isVisible: null,\n  _createRange: null,\n  getColorForValue: function getColorForValue(value) {\n    var color = null;\n\n    _each(this._ranges, function (_, range) {\n      if (range.start <= value && value <= range.end || range.start >= value && value >= range.end) {\n        color = range.color;\n        return false;\n      }\n    });\n\n    return color;\n  }\n});\n\nfunction subtractSegmentAsc(segmentStart, segmentEnd, otherStart, otherEnd) {\n  var result;\n\n  if (otherStart > segmentStart && otherEnd < segmentEnd) {\n    result = [{\n      start: segmentStart,\n      end: otherStart\n    }, {\n      start: otherEnd,\n      end: segmentEnd\n    }];\n  } else {\n    if (otherStart >= segmentEnd || otherEnd <= segmentStart) {\n      result = [{\n        start: segmentStart,\n        end: segmentEnd\n      }];\n    } else {\n      if (otherStart <= segmentStart && otherEnd >= segmentEnd) {\n        result = [];\n      } else {\n        if (otherStart > segmentStart) {\n          result = [{\n            start: segmentStart,\n            end: otherStart\n          }];\n        } else {\n          if (otherEnd < segmentEnd) {\n            result = [{\n              start: otherEnd,\n              end: segmentEnd\n            }];\n          }\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction subtractSegmentDesc(segmentStart, segmentEnd, otherStart, otherEnd) {\n  var result;\n\n  if (otherStart < segmentStart && otherEnd > segmentEnd) {\n    result = [{\n      start: segmentStart,\n      end: otherStart\n    }, {\n      start: otherEnd,\n      end: segmentEnd\n    }];\n  } else {\n    if (otherStart <= segmentEnd || otherEnd >= segmentStart) {\n      result = [{\n        start: segmentStart,\n        end: segmentEnd\n      }];\n    } else {\n      if (otherStart >= segmentStart && otherEnd <= segmentEnd) {\n        result = [];\n      } else {\n        if (otherStart < segmentStart) {\n          result = [{\n            start: segmentStart,\n            end: otherStart\n          }];\n        } else {\n          if (otherEnd > segmentEnd) {\n            result = [{\n              start: otherEnd,\n              end: segmentEnd\n            }];\n          }\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction isNotEmptySegmentAsc(start, end, threshold) {\n  return end - start >= threshold;\n}\n\nfunction isNotEmptySegmentDesc(start, end, threshold) {\n  return start - end >= threshold;\n}\n\nmodule.exports = BaseRangeContainer;","map":null,"metadata":{},"sourceType":"script"}