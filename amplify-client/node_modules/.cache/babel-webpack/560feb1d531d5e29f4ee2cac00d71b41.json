{"ast":null,"code":"/**\r\n * DevExtreme (viz/vector_map/projection.main.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.projection = exports.Projection = void 0;\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _event_emitter = require(\"./event_emitter\");\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || \"[object Arguments]\" === Object.prototype.toString.call(arr))) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _e = void 0;\n\n  try {\n    for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) {\n        break;\n      }\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && null != _i.return) {\n        _i.return();\n      }\n    } finally {\n      if (_d) {\n        throw _e;\n      }\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) {\n    return arr;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n\n    if (\"value\" in descriptor) {\n      descriptor.writable = true;\n    }\n\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) {\n    _defineProperties(Constructor.prototype, protoProps);\n  }\n\n  if (staticProps) {\n    _defineProperties(Constructor, staticProps);\n  }\n\n  return Constructor;\n}\n\nvar _Number = Number;\nvar _min = Math.min;\nvar _max = Math.max;\nvar _abs = Math.abs;\nvar _round = Math.round;\nvar _ln = Math.log;\nvar _pow = Math.pow;\nvar TWO_TO_LN2 = 2 / Math.LN2;\nvar MIN_BOUNDS_RANGE = 1 / 3600 / 180 / 10;\nvar DEFAULT_MIN_ZOOM = 1;\nvar DEFAULT_MAX_ZOOM = 256;\nvar DEFAULT_CENTER = [NaN, NaN];\nvar DEFAULT_ENGINE_NAME = \"mercator\";\n\nfunction floatsEqual(f1, f2) {\n  return _abs(f1 - f2) < 1e-8;\n}\n\nfunction arraysEqual(a1, a2) {\n  return floatsEqual(a1[0], a2[0]) && floatsEqual(a1[1], a2[1]);\n}\n\nfunction parseAndClamp(value, minValue, maxValue, defaultValue) {\n  var val = _Number(value);\n\n  return isFinite(val) ? _min(_max(val, minValue), maxValue) : defaultValue;\n}\n\nfunction parseAndClampArray(value, minValue, maxValue, defaultValue) {\n  return [parseAndClamp(value[0], minValue[0], maxValue[0], defaultValue[0]), parseAndClamp(value[1], minValue[1], maxValue[1], defaultValue[1])];\n}\n\nfunction getEngine(engine) {\n  return engine instanceof Engine && engine || projection.get(engine) || projection(engine) || projection.get(DEFAULT_ENGINE_NAME);\n}\n\nvar Projection = exports.Projection = function (parameters) {\n  var that = this;\n\n  that._initEvents();\n\n  that._params = parameters;\n  that._engine = getEngine();\n  that._center = that._engine.center();\n\n  that._adjustCenter();\n};\n\nProjection.prototype = {\n  constructor: Projection,\n  _minZoom: DEFAULT_MIN_ZOOM,\n  _maxZoom: DEFAULT_MAX_ZOOM,\n  _zoom: DEFAULT_MIN_ZOOM,\n  _center: DEFAULT_CENTER,\n  _canvas: {},\n  _scale: [],\n  dispose: function dispose() {\n    this._disposeEvents();\n  },\n  setEngine: function setEngine(value) {\n    var that = this;\n    var engine = getEngine(value);\n\n    if (that._engine !== engine) {\n      that._engine = engine;\n\n      that._fire(\"engine\");\n\n      if (that._changeCenter(engine.center())) {\n        that._triggerCenterChanged();\n      }\n\n      if (that._changeZoom(that._minZoom)) {\n        that._triggerZoomChanged();\n      }\n\n      that._adjustCenter();\n\n      that._setupScreen();\n    }\n  },\n  setBounds: function setBounds(bounds) {\n    if (void 0 !== bounds) {\n      this.setEngine(this._engine.original().bounds(bounds));\n    }\n  },\n  _setupScreen: function _setupScreen() {\n    var that = this;\n    var canvas = that._canvas;\n    var width = canvas.width;\n    var height = canvas.height;\n    var engine = that._engine;\n    var aspectRatio = engine.ar();\n    that._x0 = canvas.left + width / 2;\n    that._y0 = canvas.top + height / 2;\n    var min = [that.project([engine.min()[0], 0])[0], that.project([0, engine.min()[1]])[1]];\n    var max = [that.project([engine.max()[0], 0])[0], that.project([0, engine.max()[1]])[1]];\n    var screenAR = width / height;\n\n    var boundsAR = _abs(max[0] - min[0]) / _abs(max[1] - min[1]);\n\n    var correction;\n\n    if (isNaN(boundsAR) || 0 === boundsAR || _min(screenAR, aspectRatio) <= aspectRatio * boundsAR && aspectRatio * boundsAR <= _max(screenAR, aspectRatio)) {\n      correction = 1;\n    } else {\n      correction = boundsAR > 1 ? boundsAR : 1 / boundsAR;\n    }\n\n    if (aspectRatio * boundsAR >= screenAR) {\n      that._xRadius = width / 2 / correction;\n      that._yRadius = width / 2 / (aspectRatio * correction);\n    } else {\n      that._xRadius = height / 2 * (aspectRatio / correction);\n      that._yRadius = height / 2 / correction;\n    }\n\n    that._fire(\"screen\");\n  },\n  setSize: function setSize(canvas) {\n    this._canvas = canvas;\n\n    this._setupScreen();\n  },\n  _toScreen: function _toScreen(coordinates) {\n    return [this._x0 + this._xRadius * coordinates[0], this._y0 + this._yRadius * coordinates[1]];\n  },\n  _fromScreen: function _fromScreen(coordinates) {\n    return [(coordinates[0] - this._x0) / this._xRadius, (coordinates[1] - this._y0) / this._yRadius];\n  },\n  _toTransformed: function _toTransformed(coordinates) {\n    return [coordinates[0] * this._zoom + this._xCenter, coordinates[1] * this._zoom + this._yCenter];\n  },\n  _toTransformedFast: function _toTransformedFast(coordinates) {\n    return [coordinates[0] * this._zoom, coordinates[1] * this._zoom];\n  },\n  _fromTransformed: function _fromTransformed(coordinates) {\n    return [(coordinates[0] - this._xCenter) / this._zoom, (coordinates[1] - this._yCenter) / this._zoom];\n  },\n  _adjustCenter: function _adjustCenter() {\n    var that = this;\n\n    var center = that._engine.project(that._center);\n\n    that._xCenter = -center[0] * that._zoom || 0;\n    that._yCenter = -center[1] * that._zoom || 0;\n  },\n  project: function project(coordinates) {\n    return this._engine.project(coordinates);\n  },\n  transform: function transform(coordinates) {\n    return this._toScreen(this._toTransformedFast(coordinates));\n  },\n  isInvertible: function isInvertible() {\n    return this._engine.isInvertible();\n  },\n  getSquareSize: function getSquareSize(size) {\n    return [size[0] * this._zoom * this._xRadius, size[1] * this._zoom * this._yRadius];\n  },\n  getZoom: function getZoom() {\n    return this._zoom;\n  },\n  _changeZoom: function _changeZoom(value) {\n    var that = this;\n    var oldZoom = that._zoom;\n    var newZoom = that._zoom = parseAndClamp(value, that._minZoom, that._maxZoom, that._minZoom);\n    var isChanged = !floatsEqual(oldZoom, newZoom);\n\n    if (isChanged) {\n      that._adjustCenter();\n\n      that._fire(\"zoom\");\n    }\n\n    return isChanged;\n  },\n  setZoom: function setZoom(value) {\n    if (this._engine.isInvertible() && this._changeZoom(value)) {\n      this._triggerZoomChanged();\n    }\n  },\n  getScaledZoom: function getScaledZoom() {\n    return _round((this._scale.length - 1) * _ln(this._zoom) / _ln(this._maxZoom));\n  },\n  setScaledZoom: function setScaledZoom(scaledZoom) {\n    this.setZoom(this._scale[_round(scaledZoom)]);\n  },\n  changeScaledZoom: function changeScaledZoom(deltaZoom) {\n    this.setZoom(this._scale[_max(_min(_round(this.getScaledZoom() + deltaZoom), this._scale.length - 1), 0)]);\n  },\n  getZoomScalePartition: function getZoomScalePartition() {\n    return this._scale.length - 1;\n  },\n  _setupScaling: function _setupScaling() {\n    var that = this;\n\n    var k = _max(_round(TWO_TO_LN2 * _ln(that._maxZoom)), 4);\n\n    var step = _pow(that._maxZoom, 1 / k);\n\n    var zoom = that._minZoom;\n    that._scale = [zoom];\n\n    for (var i = 1; i <= k; ++i) {\n      that._scale.push(zoom *= step);\n    }\n  },\n  setMaxZoom: function setMaxZoom(maxZoom) {\n    var that = this;\n    that._minZoom = DEFAULT_MIN_ZOOM;\n    that._maxZoom = parseAndClamp(maxZoom, that._minZoom, _Number.MAX_VALUE, DEFAULT_MAX_ZOOM);\n\n    that._setupScaling();\n\n    if (that._zoom > that._maxZoom) {\n      that.setZoom(that._maxZoom);\n    }\n\n    that._fire(\"max-zoom\");\n  },\n  getCenter: function getCenter() {\n    return this._center.slice();\n  },\n  setCenter: function setCenter(value) {\n    if (this._engine.isInvertible() && this._changeCenter(value || [])) {\n      this._triggerCenterChanged();\n    }\n  },\n  _changeCenter: function _changeCenter(value) {\n    var that = this;\n    var engine = that._engine;\n    var oldCenter = that._center;\n    var newCenter = that._center = parseAndClampArray(value, engine.min(), engine.max(), engine.center());\n    var isChanged = !arraysEqual(oldCenter, newCenter);\n\n    if (isChanged) {\n      that._adjustCenter();\n\n      that._fire(\"center\");\n    }\n\n    return isChanged;\n  },\n  _triggerCenterChanged: function _triggerCenterChanged() {\n    this._params.centerChanged(this.getCenter());\n  },\n  _triggerZoomChanged: function _triggerZoomChanged() {\n    this._params.zoomChanged(this.getZoom());\n  },\n  setCenterByPoint: function setCenterByPoint(coordinates, screenPosition) {\n    var that = this;\n\n    var p = that._engine.project(coordinates);\n\n    var q = that._fromScreen(screenPosition);\n\n    that.setCenter(that._engine.unproject([-q[0] / that._zoom + p[0], -q[1] / that._zoom + p[1]]));\n  },\n  beginMoveCenter: function beginMoveCenter() {\n    if (this._engine.isInvertible()) {\n      this._moveCenter = this._center;\n    }\n  },\n  endMoveCenter: function endMoveCenter() {\n    var that = this;\n\n    if (that._moveCenter) {\n      if (!arraysEqual(that._moveCenter, that._center)) {\n        that._triggerCenterChanged();\n      }\n\n      that._moveCenter = null;\n    }\n  },\n  moveCenter: function moveCenter(shift) {\n    var that = this;\n\n    if (that._moveCenter) {\n      var current = that.toScreenPoint(that._center);\n\n      that._changeCenter(that.fromScreenPoint([current[0] + shift[0], current[1] + shift[1]]));\n    }\n  },\n  getViewport: function getViewport() {\n    var that = this;\n    var unproject = that._engine.unproject;\n    var lt = unproject(that._fromTransformed([-1, -1]));\n    var lb = unproject(that._fromTransformed([-1, 1]));\n    var rt = unproject(that._fromTransformed([1, -1]));\n    var rb = unproject(that._fromTransformed([1, 1]));\n    var minMax = findMinMax([selectFarthestPoint(lt[0], lb[0], rt[0], rb[0]), selectFarthestPoint(lt[1], rt[1], lb[1], rb[1])], [selectFarthestPoint(rt[0], rb[0], lt[0], lb[0]), selectFarthestPoint(lb[1], rb[1], lt[1], rt[1])]);\n    return [].concat(minMax.min, minMax.max);\n  },\n  setViewport: function setViewport(viewport) {\n    var engine = this._engine;\n    var data = viewport ? getZoomAndCenterFromViewport(engine.project, engine.unproject, viewport) : [this._minZoom, engine.center()];\n    this.setZoom(data[0]);\n    this.setCenter(data[1]);\n  },\n  getTransform: function getTransform() {\n    return {\n      translateX: this._xCenter * this._xRadius,\n      translateY: this._yCenter * this._yRadius\n    };\n  },\n  fromScreenPoint: function fromScreenPoint(coordinates) {\n    return this._engine.unproject(this._fromTransformed(this._fromScreen(coordinates)));\n  },\n  toScreenPoint: function toScreenPoint(coordinates) {\n    return this._toScreen(this._toTransformed(this._engine.project(coordinates)));\n  },\n  _eventNames: [\"engine\", \"screen\", \"center\", \"zoom\", \"max-zoom\"]\n};\n(0, _event_emitter.makeEventEmitter)(Projection);\n\nfunction selectFarthestPoint(point1, point2, basePoint1, basePoint2) {\n  var basePoint = (basePoint1 + basePoint2) / 2;\n  return _abs(point1 - basePoint) > _abs(point2 - basePoint) ? point1 : point2;\n}\n\nfunction selectClosestPoint(point1, point2, basePoint1, basePoint2) {\n  var basePoint = (basePoint1 + basePoint2) / 2;\n  return _abs(point1 - basePoint) < _abs(point2 - basePoint) ? point1 : point2;\n}\n\nfunction getZoomAndCenterFromViewport(project, unproject, viewport) {\n  var lt = project([viewport[0], viewport[3]]);\n  var lb = project([viewport[0], viewport[1]]);\n  var rt = project([viewport[2], viewport[3]]);\n  var rb = project([viewport[2], viewport[1]]);\n  var l = selectClosestPoint(lt[0], lb[0], rt[0], rb[0]);\n  var r = selectClosestPoint(rt[0], rb[0], lt[0], lb[0]);\n  var t = selectClosestPoint(lt[1], rt[1], lb[1], rb[1]);\n  var b = selectClosestPoint(lb[1], rb[1], lt[1], rt[1]);\n  return [2 / _max(_abs(l - r), _abs(t - b)), unproject([(l + r) / 2, (t + b) / 2])];\n}\n\nfunction setMinMax(engine, p1, p2) {\n  var _findMinMax = findMinMax(p1, p2),\n      min = _findMinMax.min,\n      max = _findMinMax.max;\n\n  engine.min = returnArray(min);\n  engine.max = returnArray(max);\n}\n\nvar Engine = function () {\n  function Engine(parameters) {\n    _classCallCheck(this, Engine);\n\n    var that = this;\n    var project = createProjectMethod(parameters.to);\n    var unproject = parameters.from ? createUnprojectMethod(parameters.from) : returnValue(DEFAULT_CENTER);\n    that.project = project;\n    that.unproject = unproject;\n    that.original = returnValue(that);\n\n    that.source = function () {\n      return (0, _extend.extend)({}, parameters);\n    };\n\n    that.isInvertible = returnValue(!!parameters.from);\n    that.ar = returnValue(parameters.aspectRatio > 0 ? _Number(parameters.aspectRatio) : 1);\n    that.center = returnArray(unproject([0, 0]));\n    setMinMax(that, [unproject([-1, 0])[0], unproject([0, 1])[1]], [unproject([1, 0])[0], unproject([0, -1])[1]]);\n  }\n\n  _createClass(Engine, [{\n    key: \"aspectRatio\",\n    value: function value(_aspectRatio) {\n      var engine = new Engine((0, _extend.extend)(this.source(), {\n        aspectRatio: _aspectRatio\n      }));\n      engine.original = this.original;\n      engine.min = this.min;\n      engine.max = this.max;\n      return engine;\n    }\n  }, {\n    key: \"bounds\",\n    value: function value(_bounds) {\n      _bounds = _bounds || [];\n      var parameters = this.source();\n      var min = this.min();\n      var max = this.max();\n      var b1 = parseAndClampArray([_bounds[0], _bounds[1]], min, max, min);\n      var b2 = parseAndClampArray([_bounds[2], _bounds[3]], min, max, max);\n      var p1 = parameters.to(b1);\n      var p2 = parameters.to(b2);\n\n      var delta = _min(_abs(p2[0] - p1[0]) > MIN_BOUNDS_RANGE ? _abs(p2[0] - p1[0]) : 2, _abs(p2[1] - p1[1]) > MIN_BOUNDS_RANGE ? _abs(p2[1] - p1[1]) : 2);\n\n      if (delta < 2) {\n        (0, _extend.extend)(parameters, createProjectUnprojectMethods(parameters.to, parameters.from, p1, p2, delta));\n      }\n\n      var engine = new Engine(parameters);\n      engine.original = this.original;\n      setMinMax(engine, b1, b2);\n      return engine;\n    }\n  }]);\n\n  return Engine;\n}();\n\nfunction invertVerticalAxis(pair) {\n  return [pair[0], -pair[1]];\n}\n\nfunction createProjectMethod(method) {\n  return function (arg) {\n    return invertVerticalAxis(method(arg));\n  };\n}\n\nfunction createUnprojectMethod(method) {\n  return function (arg) {\n    return method(invertVerticalAxis(arg));\n  };\n}\n\nfunction returnValue(value) {\n  return function () {\n    return value;\n  };\n}\n\nfunction returnArray(value) {\n  return function () {\n    return value.slice();\n  };\n}\n\nfunction findMinMax(p1, p2) {\n  return {\n    min: [_min(p1[0], p2[0]), _min(p1[1], p2[1])],\n    max: [_max(p1[0], p2[0]), _max(p1[1], p2[1])]\n  };\n}\n\nvar projection = exports.projection = function (parameters) {\n  return parameters && parameters.to ? new Engine(parameters) : null;\n};\n\nvar projectionsCache = {};\n\nprojection.get = function (name) {\n  return projectionsCache[name] || null;\n};\n\nprojection.add = function (name, engine) {\n  engine = engine instanceof Engine && engine || projection(engine);\n\n  if (!projectionsCache[name] && engine) {\n    projectionsCache[name] = engine;\n  }\n\n  return projection;\n};\n\nfunction createProjectUnprojectMethods(project, unproject, p1, p2, delta) {\n  var x0 = (p1[0] + p2[0]) / 2 - delta / 2;\n  var y0 = (p1[1] + p2[1]) / 2 - delta / 2;\n  var k = 2 / delta;\n  return {\n    to: function to(coordinates) {\n      var _project = project(coordinates),\n          _project2 = _slicedToArray(_project, 2),\n          p0 = _project2[0],\n          p1 = _project2[1];\n\n      return [-1 + (p0 - x0) * k, -1 + (p1 - y0) * k];\n    },\n    from: function from(coordinates) {\n      return unproject([x0 + (coordinates[0] + 1) / k, y0 + (coordinates[1] + 1) / k]);\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"script"}