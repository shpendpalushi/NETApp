{"ast":null,"code":"import { __assign } from 'tslib';\nimport { Injectable, NgZone, RendererFactory2, Inject, PLATFORM_ID, ElementRef } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Subject, merge, fromEvent, of, animationFrameScheduler } from 'rxjs';\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * Get CSS computed property of the given element\r\n * @param {?} element\r\n * @param {?=} property\r\n * @return {?}\r\n */\n\nimport * as Éµngcc0 from '@angular/core';\n\nfunction getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  } // NOTE: 1 DOM access here\n\n  /** @type {?} */\n\n\n  var window = element.ownerDocument.defaultView;\n  /** @type {?} */\n\n  var css = window.getComputedStyle(element, null);\n  return property ? css[\n  /** @type {?} */\n  property] : css;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * Returns the parentNode or the host of the element\r\n * @param {?} element\r\n * @return {?}\r\n */\n\n\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n\n  return element.parentNode || element.host;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} element\r\n * @return {?}\r\n */\n\n\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n\n    case '#document':\n      return element.body;\n\n    default:\n  } // Firefox want us to check `-x` and `-y` variations as well\n\n\n  var _a = getStyleComputedProperty(element),\n      overflow = _a.overflow,\n      overflowX = _a.overflowX,\n      overflowY = _a.overflowY;\n\n  if (/(auto|scroll|overlay)/.test(String(overflow) + String(overflowY) + String(overflowX))) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/** @type {?} */\n\n\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/** @type {?} */\n\nvar isIE11 = isBrowser && !!(\n/** @type {?} */\nwindow.MSInputMethodContext &&\n/** @type {?} */\ndocument.documentMode);\n/** @type {?} */\n\nvar isIE10 = isBrowser && !!(\n/** @type {?} */\nwindow.MSInputMethodContext && /MSIE 10/.test(\n/** @type {?} */\nnavigator.userAgent));\n/**\r\n * @param {?=} version\r\n * @return {?}\r\n */\n\nfunction isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n\n  if (version === 10) {\n    return isIE10;\n  }\n\n  return isIE11 || isIE10;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} element\r\n * @return {?}\r\n */\n\n\nfunction getOffsetParent(element) {\n  if (!element) {\n    return document.documentElement;\n  }\n  /** @type {?} */\n\n\n  var noOffsetParent = isIE(10) ? document.body : null; // NOTE: 1 DOM access here\n\n  /** @type {?} */\n\n  var offsetParent = element.offsetParent || null; // Skip hidden elements which don't have an offsetParent\n\n  /** @type {?} */\n\n  var sibling;\n\n  while (offsetParent === noOffsetParent && element.nextElementSibling && sibling !== element.nextElementSibling) {\n    sibling = element.nextElementSibling;\n    offsetParent = sibling.offsetParent;\n  }\n  /** @type {?} */\n\n\n  var nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return sibling ? sibling.ownerDocument.documentElement : document.documentElement;\n  } // .offsetParent will return the closest TH, TD or TABLE in case\n\n\n  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n    return getOffsetParent(offsetParent);\n  }\n\n  return offsetParent;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} element\r\n * @return {?}\r\n */\n\n\nfunction isOffsetContainer(element) {\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY') {\n    return false;\n  }\n\n  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * Finds the root node (document, shadowDOM root) of the given element\r\n * @param {?} node\r\n * @return {?}\r\n */\n\n\nfunction getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} element1\r\n * @param {?} element2\r\n * @return {?}\r\n */\n\n\nfunction findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  } // Here we make sure to give as \"start\" the element that comes first in the DOM\n\n  /* tslint:disable-next-line: no-bitwise */\n\n  /** @type {?} */\n\n\n  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n  /** @type {?} */\n\n  var start = order ? element1 : element2;\n  /** @type {?} */\n\n  var end = order ? element2 : element1; // Get common ancestor container\n\n  /** @type {?} */\n\n  var range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  var commonAncestorContainer = range.commonAncestorContainer; // Both nodes are inside #document\n\n  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  } // one of the nodes is inside shadowDOM, find which one\n\n  /** @type {?} */\n\n\n  var element1root = getRoot(element1);\n\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * Helper to detect borders of a given element\r\n */\n\n/**\r\n * @param {?} styles\r\n * @param {?} axis\r\n * @return {?}\r\n */\n\n\nfunction getBordersSize(styles, axis) {\n  /** @type {?} */\n  var sideA = axis === 'x' ? 'Left' : 'Top';\n  /** @type {?} */\n\n  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n  return parseFloat(styles[\n  /** @type {?} */\n  \"border\" + sideA + \"Width\"]) + parseFloat(styles[\n  /** @type {?} */\n  \"border\" + sideB + \"Width\"]);\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} axis\r\n * @param {?} body\r\n * @param {?} html\r\n * @param {?} computedStyle\r\n * @return {?}\r\n */\n\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(\n  /** @type {?} */\n  body[\"offset\" + axis],\n  /** @type {?} */\n  body[\"scroll\" + axis],\n  /** @type {?} */\n  html[\"client\" + axis],\n  /** @type {?} */\n  html[\"offset\" + axis],\n  /** @type {?} */\n  html[\"scroll\" + axis], isIE(10) ? parseInt(\n  /** @type {?} */\n  html[\"offset\" + axis], 10) + parseInt(computedStyle[\n  /** @type {?} */\n  \"margin\" + (axis === 'Height' ? 'Top' : 'Left')], 10) + parseInt(computedStyle[\n  /** @type {?} */\n  \"margin\" + (axis === 'Height' ? 'Bottom' : 'Right')], 10) : 0);\n}\n/**\r\n * @param {?} document\r\n * @return {?}\r\n */\n\n\nfunction getWindowSizes(document) {\n  /** @type {?} */\n  var body = document.body;\n  /** @type {?} */\n\n  var html = document.documentElement;\n  /** @type {?} */\n\n  var computedStyle = isIE(10) && getComputedStyle(html);\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * Gets the scroll value of the given element in the given side (top and left)\r\n * @param {?} element\r\n * @param {?=} side\r\n * @return {?}\r\n */\n\n\nfunction getScroll(element, side) {\n  if (side === void 0) {\n    side = 'top';\n  }\n  /** @type {?} */\n\n\n  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  /** @type {?} */\n\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    /** @type {?} */\n    var html = element.ownerDocument.documentElement;\n    /** @type {?} */\n\n    var scrollingElement = element.ownerDocument.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} offsets\r\n * @return {?}\r\n */\n\n\nfunction getClientRect(offsets) {\n  return __assign({}, offsets, {\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  });\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} element\r\n * @return {?}\r\n */\n\n\nfunction getBoundingClientRect(element) {\n  /** @type {?} */\n  var rect = {}; // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      /** @type {?} */\n\n      var scrollTop = getScroll(element, 'top');\n      /** @type {?} */\n\n      var scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } else {\n      rect = element.getBoundingClientRect();\n    }\n  } catch (e) {\n    return undefined;\n  }\n  /** @type {?} */\n\n\n  var result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  }; // subtract scrollbar size from sizes\n\n  /** @type {?} */\n\n  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n  /** @type {?} */\n\n  var width = sizes.width || element.clientWidth || result.right - result.left;\n  /** @type {?} */\n\n  var height = sizes.height || element.clientHeight || result.bottom - result.top;\n  /** @type {?} */\n\n  var horizScrollbar = element.offsetWidth - width;\n  /** @type {?} */\n\n  var vertScrollbar = element.offsetHeight - height; // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n\n  if (horizScrollbar || vertScrollbar) {\n    /** @type {?} */\n    var styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} rect\r\n * @param {?} element\r\n * @param {?=} subtract\r\n * @return {?}\r\n */\n\n\nfunction includeScroll(rect, element, subtract) {\n  if (subtract === void 0) {\n    subtract = false;\n  }\n  /** @type {?} */\n\n\n  var scrollTop = getScroll(element, 'top');\n  /** @type {?} */\n\n  var scrollLeft = getScroll(element, 'left');\n  /** @type {?} */\n\n  var modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} children\r\n * @param {?} parent\r\n * @param {?=} fixedPosition\r\n * @return {?}\r\n */\n\n\nfunction getOffsetRectRelativeToArbitraryNode(children, parent, fixedPosition) {\n  if (fixedPosition === void 0) {\n    fixedPosition = false;\n  }\n  /** @type {?} */\n\n\n  var isIE10 = isIE(10);\n  /** @type {?} */\n\n  var isHTML = parent.nodeName === 'HTML';\n  /** @type {?} */\n\n  var childrenRect = getBoundingClientRect(children);\n  /** @type {?} */\n\n  var parentRect = getBoundingClientRect(parent);\n  /** @type {?} */\n\n  var scrollParent = getScrollParent(children);\n  /** @type {?} */\n\n  var styles = getStyleComputedProperty(parent);\n  /** @type {?} */\n\n  var borderTopWidth = parseFloat(styles.borderTopWidth);\n  /** @type {?} */\n\n  var borderLeftWidth = parseFloat(styles.borderLeftWidth); // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n\n  if (fixedPosition && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left = Math.max(parentRect.left, 0);\n  }\n  /** @type {?} */\n\n\n  var offsets = getClientRect({\n    top: childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0; // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n\n  if (!isIE10 && isHTML) {\n    /** @type {?} */\n    var marginTop = parseFloat(styles.marginTop);\n    /** @type {?} */\n\n    var marginLeft = parseFloat(styles.marginLeft);\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft; // Attach marginTop and marginLeft because in some circumstances we may need them\n\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} element\r\n * @param {?=} excludeScroll\r\n * @return {?}\r\n */\n\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element, excludeScroll) {\n  if (excludeScroll === void 0) {\n    excludeScroll = false;\n  }\n  /** @type {?} */\n\n\n  var html = element.ownerDocument.documentElement;\n  /** @type {?} */\n\n  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  /** @type {?} */\n\n  var width = Math.max(html.clientWidth, window.innerWidth || 0);\n  /** @type {?} */\n\n  var height = Math.max(html.clientHeight, window.innerHeight || 0);\n  /** @type {?} */\n\n  var scrollTop = !excludeScroll ? getScroll(html) : 0;\n  /** @type {?} */\n\n  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n  /** @type {?} */\n\n  var offset = {\n    top: scrollTop - Number(relativeOffset.top) + Number(relativeOffset.marginTop),\n    left: scrollLeft - Number(relativeOffset.left) + Number(relativeOffset.marginLeft),\n    width: width,\n    height: height\n  };\n  return getClientRect(offset);\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} element\r\n * @return {?}\r\n */\n\n\nfunction isFixed(element) {\n  /** @type {?} */\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n\n  return isFixed(getParentNode(element));\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} element\r\n * @return {?}\r\n */\n\n\nfunction getFixedPositionOffsetParent(element) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  /** @type {?} */\n\n\n  var el = element.parentElement;\n\n  while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n\n  return el || document.documentElement;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} target\r\n * @param {?} host\r\n * @param {?=} padding\r\n * @param {?=} boundariesElement\r\n * @param {?=} fixedPosition\r\n * @return {?}\r\n */\n\n\nfunction getBoundaries(target, host, padding, boundariesElement, fixedPosition) {\n  // NOTE: 1 DOM access here\n  if (padding === void 0) {\n    padding = 0;\n  }\n\n  if (fixedPosition === void 0) {\n    fixedPosition = false;\n  } // NOTE: 1 DOM access here\n\n  /** @type {?} */\n\n\n  var boundaries = {\n    top: 0,\n    left: 0\n  };\n  /** @type {?} */\n\n  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host); // Handle viewport case\n\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n\n    /** @type {?} */\n    var boundariesNode = void 0;\n\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(host));\n\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = target.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = target.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n    /** @type {?} */\n\n\n    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition); // In case of HTML, we need a different computation\n\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      var _a = getWindowSizes(target.ownerDocument),\n          height = _a.height,\n          width = _a.width;\n\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = Number(height) + Number(offsets.top);\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = Number(width) + Number(offsets.left);\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  } // Add paddings\n\n\n  boundaries.left += padding;\n  boundaries.top += padding;\n  boundaries.right -= padding;\n  boundaries.bottom -= padding;\n  return boundaries;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} __0\r\n * @return {?}\r\n */\n\n\nfunction getArea(_a) {\n  var width = _a.width,\n      height = _a.height;\n  return width * height;\n}\n/**\r\n * @param {?} placement\r\n * @param {?} refRect\r\n * @param {?} target\r\n * @param {?} host\r\n * @param {?=} allowedPositions\r\n * @param {?=} boundariesElement\r\n * @param {?=} padding\r\n * @return {?}\r\n */\n\n\nfunction computeAutoPlacement(placement, refRect, target, host, allowedPositions, boundariesElement, padding) {\n  if (allowedPositions === void 0) {\n    allowedPositions = ['top', 'bottom', 'right', 'left'];\n  }\n\n  if (boundariesElement === void 0) {\n    boundariesElement = 'viewport';\n  }\n\n  if (padding === void 0) {\n    padding = 0;\n  }\n\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n  /** @type {?} */\n\n\n  var boundaries = getBoundaries(target, host, padding, boundariesElement);\n  /** @type {?} */\n\n  var rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n  /** @type {?} */\n\n  var sortedAreas = Object.keys(rects).map(\n  /**\r\n  * @param {?} key\r\n  * @return {?}\r\n  */\n  function (key) {\n    return __assign({\n      key: key\n    }, rects[key], {\n      area: getArea(rects[key])\n    });\n  }).sort(\n  /**\r\n  * @param {?} a\r\n  * @param {?} b\r\n  * @return {?}\r\n  */\n  function (a, b) {\n    return b.area - a.area;\n  });\n  /** @type {?} */\n\n  var filteredAreas = sortedAreas.filter(\n  /**\r\n  * @param {?} __0\r\n  * @return {?}\r\n  */\n  function (_a) {\n    var width = _a.width,\n        height = _a.height;\n    return width >= target.clientWidth && height >= target.clientHeight;\n  });\n  filteredAreas = filteredAreas.filter(\n  /**\r\n  * @param {?} position\r\n  * @return {?}\r\n  */\n  function (position) {\n    return allowedPositions.some(\n    /**\r\n    * @param {?} allowedPosition\r\n    * @return {?}\r\n    */\n    function (allowedPosition) {\n      return allowedPosition === position.key;\n    });\n  });\n  /** @type {?} */\n\n  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n  /** @type {?} */\n\n  var variation = placement.split(' ')[1]; // for tooltip on auto position\n\n  target.className = target.className.replace(/bs-tooltip-auto/g, \"bs-tooltip-\" + computedPlacement);\n  return computedPlacement + (variation ? \"-\" + variation : '');\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} data\r\n * @return {?}\r\n */\n\n\nfunction getOffsets(data) {\n  return {\n    width: data.offsets.target.width,\n    height: data.offsets.target.height,\n    left: Math.floor(data.offsets.target.left),\n    top: Math.round(data.offsets.target.top),\n    bottom: Math.round(data.offsets.target.bottom),\n    right: Math.floor(data.offsets.target.right)\n  };\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * Get the opposite placement of the given one\r\n * @param {?} placement\r\n * @return {?}\r\n */\n\n\nfunction getOppositePlacement(placement) {\n  /** @type {?} */\n  var hash = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n  return placement.replace(/left|right|bottom|top/g,\n  /**\r\n  * @param {?} matched\r\n  * @return {?}\r\n  */\n  function (matched) {\n    return (\n      /** @type {?} */\n      hash[matched]\n    );\n  });\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * Get the opposite placement variation of the given one\r\n * @param {?} variation\r\n * @return {?}\r\n */\n\n\nfunction getOppositeVariation(variation) {\n  if (variation === 'right') {\n    return 'left';\n  } else if (variation === 'left') {\n    return 'right';\n  }\n\n  return variation;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * Get the outer sizes of the given element (offset size + margins)\r\n * @param {?} element\r\n * @return {?}\r\n */\n\n\nfunction getOuterSizes(element) {\n  /** @type {?} */\n  var window = element.ownerDocument.defaultView;\n  /** @type {?} */\n\n  var styles = window.getComputedStyle(element);\n  /** @type {?} */\n\n  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n  /** @type {?} */\n\n  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n  return {\n    width: Number(element.offsetWidth) + y,\n    height: Number(element.offsetHeight) + x\n  };\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} target\r\n * @param {?} host\r\n * @param {?=} fixedPosition\r\n * @return {?}\r\n */\n\n\nfunction getReferenceOffsets(target, host, fixedPosition) {\n  if (fixedPosition === void 0) {\n    fixedPosition = null;\n  }\n  /** @type {?} */\n\n\n  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host);\n  return getOffsetRectRelativeToArbitraryNode(host, commonOffsetParent, fixedPosition);\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} target\r\n * @param {?} hostOffsets\r\n * @param {?} position\r\n * @return {?}\r\n */\n\n\nfunction getTargetOffsets(target, hostOffsets, position) {\n  /** @type {?} */\n  var placement = position.split(' ')[0]; // Get target node sizes\n\n  /** @type {?} */\n\n  var targetRect = getOuterSizes(target); // Add position, width and height to our offsets object\n\n  /** @type {?} */\n\n  var targetOffsets = {\n    width: targetRect.width,\n    height: targetRect.height\n  }; // depending by the target placement we have to compute its offsets slightly differently\n\n  /** @type {?} */\n\n  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  /** @type {?} */\n\n  var mainSide = isHoriz ? 'top' : 'left';\n  /** @type {?} */\n\n  var secondarySide = isHoriz ? 'left' : 'top';\n  /** @type {?} */\n\n  var measurement = isHoriz ? 'height' : 'width';\n  /** @type {?} */\n\n  var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n  /** @type {?} */\n  targetOffsets[mainSide] = hostOffsets[mainSide] + hostOffsets[measurement] / 2 - targetRect[measurement] / 2;\n\n  /** @type {?} */\n  targetOffsets[secondarySide] = placement === secondarySide ? hostOffsets[secondarySide] - targetRect[secondaryMeasurement] :\n  /** @type {?} */\n  hostOffsets[getOppositePlacement(secondarySide)];\n  return targetOffsets;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * Helper used to know if the given modifier is enabled.\r\n * @param {?} options\r\n * @param {?} modifierName\r\n * @return {?}\r\n */\n\n\nfunction isModifierEnabled(options, modifierName) {\n  return options && options.modifiers && options.modifiers[modifierName] && options.modifiers[modifierName].enabled;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * Tells if a given input is a number\r\n * @param {?} n\r\n * @return {?}\r\n */\n\n\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} data\r\n * @param {?=} renderer\r\n * @return {?}\r\n */\n\n\nfunction updateContainerClass(data, renderer) {\n  /** @type {?} */\n  var target = data.instance.target;\n  /** @type {?} */\n\n  var containerClass = target.className;\n\n  if (data.placementAuto) {\n    containerClass = containerClass.replace(/bs-popover-auto/g, \"bs-popover-\" + data.placement);\n    containerClass = containerClass.replace(/bs-tooltip-auto/g, \"bs-tooltip-\" + data.placement);\n    containerClass = containerClass.replace(/\\sauto/g, \" \" + data.placement);\n\n    if (containerClass.indexOf('popover') !== -1 && containerClass.indexOf('popover-auto') === -1) {\n      containerClass += ' popover-auto';\n    }\n\n    if (containerClass.indexOf('tooltip') !== -1 && containerClass.indexOf('tooltip-auto') === -1) {\n      containerClass += ' tooltip-auto';\n    }\n  }\n\n  containerClass = containerClass.replace(/left|right|top|bottom/g, \"\" + data.placement.split(' ')[0]);\n\n  if (renderer) {\n    renderer.setAttribute(target, 'class', containerClass);\n    return;\n  }\n\n  target.className = containerClass;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} element\r\n * @param {?} styles\r\n * @param {?=} renderer\r\n * @return {?}\r\n */\n\n\nfunction setStyles(element, styles, renderer) {\n  Object.keys(styles).forEach(\n  /**\r\n  * @param {?} prop\r\n  * @return {?}\r\n  */\n  function (prop) {\n    /** @type {?} */\n    var unit = ''; // add unit if the value is numeric and is one of the following\n\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n\n    if (renderer) {\n      renderer.setStyle(element, prop, \"\" + String(styles[prop]) + unit);\n      return;\n    }\n\n    element.style[prop] = String(styles[prop]) + unit;\n  });\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} data\r\n * @return {?}\r\n */\n\n\nfunction arrow(data) {\n  var _a;\n  /** @type {?} */\n\n\n  var targetOffsets = data.offsets.target; // if arrowElement is a string, suppose it's a CSS selector\n\n  /** @type {?} */\n\n  var arrowElement = data.instance.target.querySelector('.arrow'); // if arrowElement is not found, don't run the modifier\n\n  if (!arrowElement) {\n    return data;\n  }\n  /** @type {?} */\n\n\n  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;\n  /** @type {?} */\n\n  var len = isVertical ? 'height' : 'width';\n  /** @type {?} */\n\n  var sideCapitalized = isVertical ? 'Top' : 'Left';\n  /** @type {?} */\n\n  var side = sideCapitalized.toLowerCase();\n  /** @type {?} */\n\n  var altSide = isVertical ? 'left' : 'top';\n  /** @type {?} */\n\n  var opSide = isVertical ? 'bottom' : 'right';\n  /** @type {?} */\n\n  var arrowElementSize = getOuterSizes(arrowElement)[len]; // top/left side\n\n  if (data.offsets.host[opSide] - arrowElementSize <\n  /** @type {?} */\n  targetOffsets[side]) {\n    /** @type {?} */\n    targetOffsets[side] -=\n    /** @type {?} */\n    targetOffsets[side] - (data.offsets.host[opSide] - arrowElementSize);\n  } // bottom/right side\n\n\n  if (Number(\n  /** @type {?} */\n  data.offsets.host[side]) + Number(arrowElementSize) >\n  /** @type {?} */\n  targetOffsets[opSide]) {\n    /** @type {?} */\n    targetOffsets[side] += Number(\n    /** @type {?} */\n    data.offsets.host[side]) + Number(arrowElementSize) - Number(\n    /** @type {?} */\n    targetOffsets[opSide]);\n  }\n\n  targetOffsets = getClientRect(targetOffsets); // compute center of the target\n\n  /** @type {?} */\n\n  var center = Number(\n  /** @type {?} */\n  data.offsets.host[side]) + Number(data.offsets.host[len] / 2 - arrowElementSize / 2); // Compute the sideValue using the updated target offsets\n  // take target margin in account because we don't have this info available\n\n  /** @type {?} */\n\n  var css = getStyleComputedProperty(data.instance.target);\n  /** @type {?} */\n\n  var targetMarginSide = parseFloat(css[\"margin\" + sideCapitalized]);\n  /** @type {?} */\n\n  var targetBorderSide = parseFloat(css[\"border\" + sideCapitalized + \"Width\"]);\n  /** @type {?} */\n\n  var sideValue = center -\n  /** @type {?} */\n  targetOffsets[side] - targetMarginSide - targetBorderSide; // prevent arrowElement from being placed not contiguously to its target\n\n  sideValue = Math.max(Math.min(targetOffsets[len] - arrowElementSize, sideValue), 0);\n  data.offsets.arrow = (_a = {}, _a[side] = Math.round(sideValue), _a[altSide] = '' // make sure to unset any eventual altSide value from the DOM node\n  , _a);\n  data.instance.arrow = arrowElement;\n  return data;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} data\r\n * @return {?}\r\n */\n\n\nfunction flip(data) {\n  data.offsets.target = getClientRect(data.offsets.target);\n\n  if (!isModifierEnabled(data.options, 'flip')) {\n    data.offsets.target = __assign({}, data.offsets.target, getTargetOffsets(data.instance.target, data.offsets.host, data.placement));\n    return data;\n  }\n  /** @type {?} */\n\n\n  var boundaries = getBoundaries(data.instance.target, data.instance.host, 0, // padding\n  'viewport', false // positionFixed\n  );\n  /** @type {?} */\n\n  var placement = data.placement.split(' ')[0];\n  /** @type {?} */\n\n  var variation = data.placement.split(' ')[1] || '';\n  /** @type {?} */\n\n  var offsetsHost = data.offsets.host;\n  /** @type {?} */\n\n  var target = data.instance.target;\n  /** @type {?} */\n\n  var host = data.instance.host;\n  /** @type {?} */\n\n  var adaptivePosition = computeAutoPlacement('auto', offsetsHost, target, host, data.options.allowedPositions);\n  /** @type {?} */\n\n  var flipOrder = [placement, adaptivePosition];\n  /* tslint:disable-next-line: cyclomatic-complexity */\n\n  flipOrder.forEach(\n  /**\r\n  * @param {?} step\r\n  * @param {?} index\r\n  * @return {?}\r\n  */\n  function (step, index) {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n\n    placement = data.placement.split(' ')[0]; // using floor because the host offsets may contain decimals we are not going to consider here\n\n    /** @type {?} */\n\n    var overlapsRef = placement === 'left' && Math.floor(data.offsets.target.right) > Math.floor(data.offsets.host.left) || placement === 'right' && Math.floor(data.offsets.target.left) < Math.floor(data.offsets.host.right) || placement === 'top' && Math.floor(data.offsets.target.bottom) > Math.floor(data.offsets.host.top) || placement === 'bottom' && Math.floor(data.offsets.target.top) < Math.floor(data.offsets.host.bottom);\n    /** @type {?} */\n\n    var overflowsLeft = Math.floor(data.offsets.target.left) < Math.floor(boundaries.left);\n    /** @type {?} */\n\n    var overflowsRight = Math.floor(data.offsets.target.right) > Math.floor(boundaries.right);\n    /** @type {?} */\n\n    var overflowsTop = Math.floor(data.offsets.target.top) < Math.floor(boundaries.top);\n    /** @type {?} */\n\n    var overflowsBottom = Math.floor(data.offsets.target.bottom) > Math.floor(boundaries.bottom);\n    /** @type {?} */\n\n    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom; // flip the variation if required\n\n    /** @type {?} */\n\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    /** @type {?} */\n\n    var flippedVariation = isVertical && variation === 'left' && overflowsLeft || isVertical && variation === 'right' && overflowsRight || !isVertical && variation === 'left' && overflowsTop || !isVertical && variation === 'right' && overflowsBottom;\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? \" \" + variation : '');\n      data.offsets.target = __assign({}, data.offsets.target, getTargetOffsets(data.instance.target, data.offsets.host, data.placement));\n    }\n  });\n  return data;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} targetElement\r\n * @param {?} hostElement\r\n * @param {?} position\r\n * @param {?} options\r\n * @return {?}\r\n */\n\n\nfunction initData(targetElement, hostElement, position, options) {\n  /** @type {?} */\n  var hostElPosition = getReferenceOffsets(targetElement, hostElement);\n\n  if (!position.match(/^(auto)*\\s*(left|right|top|bottom)*$/) && !position.match(/^(left|right|top|bottom)*\\s*(start|end)*$/)) {\n    /* tslint:disable-next-line: no-parameter-reassignment */\n    position = 'auto';\n  }\n  /** @type {?} */\n\n\n  var placementAuto = !!position.match(/auto/g); // support old placements 'auto left|right|top|bottom'\n\n  /** @type {?} */\n\n  var placement = position.match(/auto\\s(left|right|top|bottom)/) ? position.split(' ')[1] || 'auto' : position;\n  /** @type {?} */\n\n  var targetOffset = getTargetOffsets(targetElement, hostElPosition, placement);\n  placement = computeAutoPlacement(placement, hostElPosition, targetElement, hostElement, options ? options.allowedPositions : undefined);\n  return {\n    options: options,\n    instance: {\n      target: targetElement,\n      host: hostElement,\n      arrow: null\n    },\n    offsets: {\n      target: targetOffset,\n      host: hostElPosition,\n      arrow: null\n    },\n    positionFixed: false,\n    placement: placement,\n    placementAuto: placementAuto\n  };\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} data\r\n * @return {?}\r\n */\n\n\nfunction preventOverflow(data) {\n  if (!isModifierEnabled(data.options, 'preventOverflow')) {\n    return data;\n  } // NOTE: DOM access here\n  // resets the targetOffsets's position so that the document size can be calculated excluding\n  // the size of the targetOffsets element itself\n\n  /** @type {?} */\n\n\n  var transformProp = 'transform';\n  /** @type {?} */\n\n  var targetStyles = data.instance.target.style; // assignment to help minification\n\n  var top = targetStyles.top,\n      left = targetStyles.left,\n      _a = transformProp,\n      transform = targetStyles[_a];\n  targetStyles.top = '';\n  targetStyles.left = '';\n  targetStyles[transformProp] = '';\n  /** @type {?} */\n\n  var boundaries = getBoundaries(data.instance.target, data.instance.host, 0, // padding\n  'scrollParent', false // positionFixed\n  ); // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n\n  targetStyles.top = top;\n  targetStyles.left = left;\n  targetStyles[transformProp] = transform;\n  /** @type {?} */\n\n  var order = ['left', 'right', 'top', 'bottom'];\n  /** @type {?} */\n\n  var check = {\n    primary:\n    /**\r\n    * @param {?} placement\r\n    * @return {?}\r\n    */\n    function primary(placement) {\n      var _a;\n      /** @type {?} */\n\n\n      var value =\n      /** @type {?} */\n      data.offsets.target[placement];\n\n      if (\n      /** @type {?} */\n      data.offsets.target[placement] < boundaries[placement] && !false // options.escapeWithReference\n      ) {\n          value = Math.max(\n          /** @type {?} */\n          data.offsets.target[placement], boundaries[placement]);\n        }\n\n      return _a = {}, _a[placement] = value, _a;\n    },\n    secondary:\n    /**\r\n    * @param {?} placement\r\n    * @return {?}\r\n    */\n    function secondary(placement) {\n      var _a;\n      /** @type {?} */\n\n\n      var mainSide = placement === 'right' ? 'left' : 'top';\n      /** @type {?} */\n\n      var value = data.offsets.target[mainSide];\n\n      if (\n      /** @type {?} */\n      data.offsets.target[placement] > boundaries[placement] && !false // escapeWithReference\n      ) {\n          value = Math.min(data.offsets.target[mainSide], boundaries[placement] - (placement === 'right' ? data.offsets.target.width : data.offsets.target.height));\n        }\n\n      return _a = {}, _a[mainSide] = value, _a;\n    }\n  };\n  /** @type {?} */\n\n  var side;\n  order.forEach(\n  /**\r\n  * @param {?} placement\r\n  * @return {?}\r\n  */\n  function (placement) {\n    side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n    data.offsets.target = __assign({}, data.offsets.target,\n    /** @type {?} */\n    check[side](placement));\n  });\n  return data;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @param {?} data\r\n * @return {?}\r\n */\n\n\nfunction shift(data) {\n  var _a, _b;\n  /** @type {?} */\n\n\n  var placement = data.placement;\n  /** @type {?} */\n\n  var basePlacement = placement.split(' ')[0];\n  /** @type {?} */\n\n  var shiftvariation = placement.split(' ')[1];\n\n  if (shiftvariation) {\n    var _c = data.offsets,\n        host = _c.host,\n        target = _c.target;\n    /** @type {?} */\n\n    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    /** @type {?} */\n\n    var side = isVertical ? 'left' : 'top';\n    /** @type {?} */\n\n    var measurement = isVertical ? 'width' : 'height';\n    /** @type {?} */\n\n    var shiftOffsets = {\n      start: (_a = {}, _a[side] = host[side], _a),\n      end: (_b = {}, _b[side] = host[side] + host[measurement] - target[measurement], _b)\n    };\n    data.offsets.target = __assign({}, target,\n    /** @type {?} */\n    shiftOffsets[shiftvariation]);\n  }\n\n  return data;\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nvar Positioning =\n/** @class */\nfunction () {\n  function Positioning() {}\n  /**\r\n   * @param {?} hostElement\r\n   * @param {?} targetElement\r\n   * @param {?=} round\r\n   * @return {?}\r\n   */\n\n\n  Positioning.prototype.position =\n  /**\r\n  * @param {?} hostElement\r\n  * @param {?} targetElement\r\n  * @param {?=} round\r\n  * @return {?}\r\n  */\n  function (hostElement, targetElement, round) {\n    return this.offset(hostElement, targetElement, false);\n  };\n  /**\r\n   * @param {?} hostElement\r\n   * @param {?} targetElement\r\n   * @param {?=} round\r\n   * @return {?}\r\n   */\n\n\n  Positioning.prototype.offset =\n  /**\r\n  * @param {?} hostElement\r\n  * @param {?} targetElement\r\n  * @param {?=} round\r\n  * @return {?}\r\n  */\n  function (hostElement, targetElement, round) {\n    return getReferenceOffsets(targetElement, hostElement);\n  };\n  /**\r\n   * @param {?} hostElement\r\n   * @param {?} targetElement\r\n   * @param {?} position\r\n   * @param {?=} appendToBody\r\n   * @param {?=} options\r\n   * @return {?}\r\n   */\n\n\n  Positioning.prototype.positionElements =\n  /**\r\n  * @param {?} hostElement\r\n  * @param {?} targetElement\r\n  * @param {?} position\r\n  * @param {?=} appendToBody\r\n  * @param {?=} options\r\n  * @return {?}\r\n  */\n  function (hostElement, targetElement, position, appendToBody, options) {\n    /** @type {?} */\n    var chainOfModifiers = [flip, shift, preventOverflow, arrow];\n    return chainOfModifiers.reduce(\n    /**\r\n    * @param {?} modifiedData\r\n    * @param {?} modifier\r\n    * @return {?}\r\n    */\n    function (modifiedData, modifier) {\n      return modifier(modifiedData);\n    }, initData(targetElement, hostElement, position, options));\n  };\n\n  return Positioning;\n}();\n/** @type {?} */\n\n\nvar positionService = new Positioning();\n/**\r\n * @param {?} hostElement\r\n * @param {?} targetElement\r\n * @param {?} placement\r\n * @param {?=} appendToBody\r\n * @param {?=} options\r\n * @param {?=} renderer\r\n * @return {?}\r\n */\n\nfunction positionElements(hostElement, targetElement, placement, appendToBody, options, renderer) {\n  /** @type {?} */\n  var data = positionService.positionElements(hostElement, targetElement, placement, appendToBody, options);\n  /** @type {?} */\n\n  var offsets = getOffsets(data);\n  setStyles(targetElement, {\n    'will-change': 'transform',\n    top: '0px',\n    left: '0px',\n    transform: \"translate3d(\" + offsets.left + \"px, \" + offsets.top + \"px, 0px)\"\n  }, renderer);\n\n  if (data.instance.arrow) {\n    setStyles(data.instance.arrow, data.offsets.arrow, renderer);\n  }\n\n  updateContainerClass(data, renderer);\n}\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nvar PositioningService =\n/** @class */\nfunction () {\n  function PositioningService(ngZone, rendererFactory, platformId) {\n    var _this = this;\n\n    this.update$$ = new Subject();\n    this.positionElements = new Map();\n    this.isDisabled = false;\n\n    if (isPlatformBrowser(platformId)) {\n      ngZone.runOutsideAngular(\n      /**\r\n      * @return {?}\r\n      */\n      function () {\n        _this.triggerEvent$ = merge(fromEvent(window, 'scroll', {\n          passive: true\n        }), fromEvent(window, 'resize', {\n          passive: true\n        }),\n        /* tslint:disable-next-line: deprecation */\n        of(0, animationFrameScheduler), _this.update$$);\n\n        _this.triggerEvent$.subscribe(\n        /**\r\n        * @return {?}\r\n        */\n        function () {\n          if (_this.isDisabled) {\n            return;\n          }\n\n          _this.positionElements\n          /* tslint:disable-next-line: no-any */\n          .forEach(\n          /**\r\n          * @param {?} positionElement\r\n          * @return {?}\r\n          */\n          function (positionElement) {\n            positionElements(_getHtmlElement(positionElement.target), _getHtmlElement(positionElement.element), positionElement.attachment, positionElement.appendToBody, _this.options, rendererFactory.createRenderer(null, null));\n          });\n        });\n      });\n    }\n  }\n  /**\r\n   * @param {?} options\r\n   * @return {?}\r\n   */\n\n\n  PositioningService.prototype.position =\n  /**\r\n  * @param {?} options\r\n  * @return {?}\r\n  */\n  function (options) {\n    this.addPositionElement(options);\n  };\n\n  Object.defineProperty(PositioningService.prototype, \"event$\", {\n    get:\n    /**\r\n    * @return {?}\r\n    */\n    function get() {\n      return this.triggerEvent$;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @return {?}\r\n   */\n\n  PositioningService.prototype.disable =\n  /**\r\n  * @return {?}\r\n  */\n  function () {\n    this.isDisabled = true;\n  };\n  /**\r\n   * @return {?}\r\n   */\n\n\n  PositioningService.prototype.enable =\n  /**\r\n  * @return {?}\r\n  */\n  function () {\n    this.isDisabled = false;\n  };\n  /**\r\n   * @param {?} options\r\n   * @return {?}\r\n   */\n\n\n  PositioningService.prototype.addPositionElement =\n  /**\r\n  * @param {?} options\r\n  * @return {?}\r\n  */\n  function (options) {\n    this.positionElements.set(_getHtmlElement(options.element), options);\n  };\n  /**\r\n   * @return {?}\r\n   */\n\n\n  PositioningService.prototype.calcPosition =\n  /**\r\n  * @return {?}\r\n  */\n  function () {\n    this.update$$.next();\n  };\n  /**\r\n   * @param {?} elRef\r\n   * @return {?}\r\n   */\n\n\n  PositioningService.prototype.deletePositionElement =\n  /**\r\n  * @param {?} elRef\r\n  * @return {?}\r\n  */\n  function (elRef) {\n    this.positionElements.delete(_getHtmlElement(elRef));\n  };\n  /**\r\n   * @param {?} options\r\n   * @return {?}\r\n   */\n\n\n  PositioningService.prototype.setOptions =\n  /**\r\n  * @param {?} options\r\n  * @return {?}\r\n  */\n  function (options) {\n    this.options = options;\n  };\n  /** @nocollapse */\n\n\n  PositioningService.ctorParameters = function () {\n    return [{\n      type: NgZone\n    }, {\n      type: RendererFactory2\n    }, {\n      type: Number,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  };\n\n  PositioningService.Éµfac = function PositioningService_Factory(t) {\n    return new (t || PositioningService)(Éµngcc0.ÉµÉµinject(Éµngcc0.NgZone), Éµngcc0.ÉµÉµinject(Éµngcc0.RendererFactory2), Éµngcc0.ÉµÉµinject(PLATFORM_ID));\n  };\n\n  PositioningService.Éµprov = Éµngcc0.ÉµÉµdefineInjectable({\n    token: PositioningService,\n    factory: function factory(t) {\n      return PositioningService.Éµfac(t);\n    }\n  });\n  /*@__PURE__*/\n\n  (function () {\n    Éµngcc0.ÉµsetClassMetadata(PositioningService, [{\n      type: Injectable\n    }], function () {\n      return [{\n        type: Éµngcc0.NgZone\n      }, {\n        type: Éµngcc0.RendererFactory2\n      }, {\n        type: Number,\n        decorators: [{\n          type: Inject,\n          args: [PLATFORM_ID]\n        }]\n      }];\n    }, null);\n  })();\n\n  return PositioningService;\n}();\n/**\r\n * @param {?} element\r\n * @return {?}\r\n */\n\n\nfunction _getHtmlElement(element) {\n  // it means that we got a selector\n  if (typeof element === 'string') {\n    return document.querySelector(element);\n  }\n\n  if (element instanceof ElementRef) {\n    return element.nativeElement;\n  }\n\n  return element;\n}\n\nexport { Positioning, PositioningService, positionElements };","map":null,"metadata":{},"sourceType":"module"}