{"ast":null,"code":"/**\r\n * DevExtreme (viz/gauges/bar_gauge.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar PI_DIV_180 = Math.PI / 180;\nvar _abs = Math.abs;\nvar _round = Math.round;\nvar _floor = Math.floor;\nvar _min = Math.min;\nvar _max = Math.max;\n\nvar registerComponent = require(\"../../core/component_registrator\");\n\nvar objectUtils = require(\"../../core/utils/object\");\n\nvar commonUtils = require(\"../../core/utils/common\");\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar _normalizeEnum = require(\"../core/utils\").normalizeEnum;\n\nvar baseGaugeModule = require(\"./base_gauge\");\n\nvar dxBaseGauge = baseGaugeModule.dxBaseGauge;\nvar _getSampleText = baseGaugeModule.getSampleText;\nvar _formatValue = baseGaugeModule.formatValue;\nvar _compareArrays = baseGaugeModule.compareArrays;\n\nvar dxCircularGauge = require(\"./circular_gauge\");\n\nvar _isArray = Array.isArray;\n\nvar vizUtils = require(\"../core/utils\");\n\nvar _convertAngleToRendererSpace = vizUtils.convertAngleToRendererSpace;\nvar _getCosAndSin = vizUtils.getCosAndSin;\nvar _patchFontOptions = vizUtils.patchFontOptions;\nvar _Number = Number;\nvar _isFinite = isFinite;\nvar _noop = commonUtils.noop;\nvar _extend = extend;\nvar OPTION_VALUES = \"values\";\nvar dxBarGauge = dxBaseGauge.inherit({\n  _rootClass: \"dxbg-bar-gauge\",\n  _themeSection: \"barGauge\",\n  _fontFields: [\"label.font\", \"legend.font\", \"legend.title.font\", \"legend.title.subtitle.font\"],\n  _initCore: function _initCore() {\n    var that = this;\n    that.callBase.apply(that, arguments);\n    that._barsGroup = that._renderer.g().attr({\n      \"class\": \"dxbg-bars\"\n    }).linkOn(that._renderer.root, \"bars\");\n    that._values = [];\n    that._context = {\n      renderer: that._renderer,\n      translator: that._translator,\n      tracker: that._tracker,\n      group: that._barsGroup\n    };\n\n    that._animateStep = function (pos) {\n      var bars = that._bars;\n      var i;\n      var ii;\n\n      for (i = 0, ii = bars.length; i < ii; ++i) {\n        bars[i].animate(pos);\n      }\n    };\n\n    that._animateComplete = function () {\n      that._bars.forEach(function (bar) {\n        return bar.endAnimation();\n      });\n\n      that._checkOverlap();\n    };\n  },\n  _disposeCore: function _disposeCore() {\n    var that = this;\n\n    that._barsGroup.linkOff();\n\n    that._barsGroup = that._values = that._context = that._animateStep = that._animateComplete = null;\n    that.callBase.apply(that, arguments);\n  },\n  _setupDomainCore: function _setupDomainCore() {\n    var that = this;\n    var startValue = that.option(\"startValue\");\n    var endValue = that.option(\"endValue\");\n    _isFinite(startValue) || (startValue = 0);\n    _isFinite(endValue) || (endValue = 100);\n\n    that._translator.setDomain(startValue, endValue);\n\n    that._baseValue = that._translator.adjust(that.option(\"baseValue\"));\n    _isFinite(that._baseValue) || (that._baseValue = startValue < endValue ? startValue : endValue);\n  },\n  _getDefaultSize: function _getDefaultSize() {\n    return {\n      width: 300,\n      height: 300\n    };\n  },\n  _setupCodomain: dxCircularGauge.prototype._setupCodomain,\n  _getApproximateScreenRange: function _getApproximateScreenRange() {\n    var that = this;\n    var sides = that._area.sides;\n    var width = that._canvas.width / (sides.right - sides.left);\n    var height = that._canvas.height / (sides.down - sides.up);\n    var r = width < height ? width : height;\n    return -that._translator.getCodomainRange() * r * PI_DIV_180;\n  },\n  _setupAnimationSettings: function _setupAnimationSettings() {\n    var that = this;\n    that.callBase.apply(that, arguments);\n\n    if (that._animationSettings) {\n      that._animationSettings.step = that._animateStep;\n      that._animationSettings.complete = that._animateComplete;\n    }\n  },\n  _cleanContent: function _cleanContent() {\n    var that = this;\n\n    that._barsGroup.linkRemove();\n\n    that._animationSettings && that._barsGroup.stopAnimation();\n\n    that._barsGroup.clear();\n  },\n  _renderContent: function _renderContent() {\n    var that = this;\n    var labelOptions = that.option(\"label\");\n    var text;\n    var bBox;\n    var context = that._context;\n\n    that._barsGroup.linkAppend();\n\n    context.textEnabled = void 0 === labelOptions || labelOptions && (!(\"visible\" in labelOptions) || labelOptions.visible);\n\n    if (context.textEnabled) {\n      context.textColor = labelOptions && labelOptions.font && labelOptions.font.color || null;\n      labelOptions = _extend(true, {}, that._themeManager.theme().label, labelOptions);\n      context.formatOptions = {\n        format: void 0 !== labelOptions.format ? labelOptions.format : that._defaultFormatOptions,\n        customizeText: labelOptions.customizeText\n      };\n      context.textOptions = {\n        align: \"center\"\n      };\n      context.fontStyles = _patchFontOptions(_extend({}, that._themeManager.theme().label.font, labelOptions.font, {\n        color: null\n      }));\n      that._textIndent = labelOptions.indent > 0 ? _Number(labelOptions.indent) : 0;\n      context.lineWidth = labelOptions.connectorWidth > 0 ? _Number(labelOptions.connectorWidth) : 0;\n      context.lineColor = labelOptions.connectorColor || null;\n      text = that._renderer.text(_getSampleText(that._translator, context.formatOptions), 0, 0).attr(context.textOptions).css(context.fontStyles).append(that._barsGroup);\n      bBox = text.getBBox();\n      text.remove();\n      context.textY = bBox.y;\n      context.textWidth = bBox.width;\n      context.textHeight = bBox.height;\n    }\n\n    dxCircularGauge.prototype._applyMainLayout.call(that);\n\n    that._renderBars();\n  },\n  _measureMainElements: function _measureMainElements() {\n    var result = {\n      maxRadius: this._area.radius\n    };\n\n    if (this._context.textEnabled) {\n      result.horizontalMargin = this._context.textWidth;\n      result.verticalMargin = this._context.textHeight;\n      result.inverseHorizontalMargin = this._context.textWidth / 2;\n      result.inverseVerticalMargin = this._context.textHeight / 2;\n    }\n\n    return result;\n  },\n  _renderBars: function _renderBars() {\n    var that = this;\n\n    var options = _extend({}, that._themeManager.theme(), that.option());\n\n    var relativeInnerRadius;\n    var radius;\n    var area = that._area;\n    relativeInnerRadius = options.relativeInnerRadius > 0 && options.relativeInnerRadius < 1 ? _Number(options.relativeInnerRadius) : .1;\n    radius = area.radius;\n\n    if (that._context.textEnabled) {\n      that._textIndent = _round(_min(that._textIndent, radius / 2));\n      radius -= that._textIndent;\n    }\n\n    that._outerRadius = _floor(radius);\n    that._innerRadius = _floor(radius * relativeInnerRadius);\n    that._barSpacing = options.barSpacing > 0 ? _Number(options.barSpacing) : 0;\n\n    _extend(that._context, {\n      backgroundColor: options.backgroundColor,\n      x: area.x,\n      y: area.y,\n      startAngle: area.startCoord,\n      endAngle: area.endCoord,\n      baseAngle: that._translator.translate(that._baseValue)\n    });\n\n    that._arrangeBars();\n  },\n  _arrangeBars: function _arrangeBars() {\n    var that = this;\n    var radius = that._outerRadius - that._innerRadius;\n    var context = that._context;\n    var spacing;\n    var colors;\n    var unitOffset;\n    var i;\n    var count = that._bars.length;\n\n    that._beginValueChanging();\n\n    context.barSize = count > 0 ? _max((radius - (count - 1) * that._barSpacing) / count, 1) : 0;\n    spacing = count > 1 ? _max(_min((radius - count * context.barSize) / (count - 1), that._barSpacing), 0) : 0;\n\n    var _count = _min(_floor((radius + spacing) / context.barSize), count);\n\n    that._setBarsCount(count);\n\n    radius = that._outerRadius;\n    context.textRadius = radius;\n    context.textIndent = that._textIndent;\n\n    that._palette.reset();\n\n    unitOffset = context.barSize + spacing;\n    colors = that._palette.generateColors(_count);\n\n    for (i = 0; i < _count; ++i, radius -= unitOffset) {\n      that._bars[i].arrange({\n        radius: radius,\n        color: colors[i]\n      });\n    }\n\n    for (var _i = _count; _i < count; _i++) {\n      that._bars[_i].hide();\n    }\n\n    if (that._animationSettings && !that._noAnimation) {\n      that._animateBars();\n    } else {\n      that._updateBars();\n    }\n\n    that._endValueChanging();\n  },\n  _setBarsCount: function _setBarsCount() {\n    var that = this;\n\n    if (that._bars.length > 0) {\n      if (that._dummyBackground) {\n        that._dummyBackground.dispose();\n\n        that._dummyBackground = null;\n      }\n    } else {\n      if (!that._dummyBackground) {\n        that._dummyBackground = that._renderer.arc().attr({\n          \"stroke-linejoin\": \"round\"\n        });\n      }\n\n      that._dummyBackground.attr({\n        x: that._context.x,\n        y: that._context.y,\n        outerRadius: that._outerRadius,\n        innerRadius: that._innerRadius,\n        startAngle: that._context.endAngle,\n        endAngle: that._context.startAngle,\n        fill: that._context.backgroundColor\n      }).append(that._barsGroup);\n    }\n  },\n  _updateBars: function _updateBars() {\n    this._bars.forEach(function (bar) {\n      return bar.applyValue();\n    });\n\n    this._checkOverlap();\n  },\n  _checkOverlap: function _checkOverlap() {\n    var that = this;\n    var bars = that._bars;\n\n    var overlapStrategy = _normalizeEnum(that._getOption(\"resolveLabelOverlapping\", true));\n\n    if (\"none\" === overlapStrategy) {\n      return;\n    }\n\n    var sortedBars = bars.concat().sort(function (a, b) {\n      return a.getValue() - b.getValue();\n    });\n    var currentIndex = 0;\n    var nextIndex = 1;\n\n    while (currentIndex < sortedBars.length && nextIndex < sortedBars.length) {\n      var current = sortedBars[currentIndex];\n      var next = sortedBars[nextIndex];\n\n      if (current.checkIntersect(next)) {\n        next.hideLabel();\n        nextIndex++;\n      } else {\n        currentIndex = nextIndex;\n        nextIndex = currentIndex + 1;\n      }\n    }\n  },\n  _animateBars: function _animateBars() {\n    var that = this;\n    var i;\n    var ii = that._bars.length;\n\n    if (ii > 0) {\n      for (i = 0; i < ii; ++i) {\n        that._bars[i].beginAnimation();\n      }\n\n      that._barsGroup.animate({\n        _: 0\n      }, that._animationSettings);\n    }\n  },\n  _buildNodes: function _buildNodes() {\n    var that = this;\n    var options = that._options;\n    that._palette = that._themeManager.createPalette(options.palette, {\n      useHighlight: true,\n      extensionMode: options.paletteExtensionMode\n    });\n\n    that._palette.reset();\n\n    that._bars = that._bars || [];\n    that._animationSettings && that._barsGroup.stopAnimation();\n\n    var barValues = that._values.filter(_isFinite);\n\n    var count = barValues.length;\n\n    if (that._bars.length > count) {\n      var ii = that._bars.length;\n\n      for (var i = count; i < ii; ++i) {\n        that._bars[i].dispose();\n      }\n\n      that._bars.splice(count, ii - count);\n    } else {\n      if (that._bars.length < count) {\n        for (var _i2 = that._bars.length; _i2 < count; ++_i2) {\n          that._bars.push(new BarWrapper(_i2, that._context));\n        }\n      }\n    }\n\n    that._bars.forEach(function (bar, index) {\n      bar.update({\n        color: that._palette.getNextColor(count),\n        value: barValues[index]\n      });\n    });\n  },\n  _updateValues: function _updateValues(values) {\n    var that = this;\n    var list = _isArray(values) && values || _isFinite(values) && [values] || [];\n    var i;\n    var ii = list.length;\n    var value;\n    that._values.length = ii;\n\n    for (i = 0; i < ii; ++i) {\n      value = list[i];\n      that._values[i] = value = _Number(_isFinite(value) ? value : that._values[i]);\n    }\n\n    if (!that._resizing) {\n      if (!_compareArrays(that._values, that.option(OPTION_VALUES))) {\n        that.option(OPTION_VALUES, that._values.slice());\n      }\n    }\n\n    this._change([\"NODES\"]);\n  },\n  values: function values(arg) {\n    if (void 0 !== arg) {\n      this._updateValues(arg);\n\n      return this;\n    } else {\n      return this._values.slice(0);\n    }\n  },\n  _optionChangesMap: {\n    backgroundColor: \"MOSTLY_TOTAL\",\n    relativeInnerRadius: \"MOSTLY_TOTAL\",\n    barSpacing: \"MOSTLY_TOTAL\",\n    label: \"MOSTLY_TOTAL\",\n    resolveLabelOverlapping: \"MOSTLY_TOTAL\",\n    palette: \"MOSTLY_TOTAL\",\n    paletteExtensionMode: \"MOSTLY_TOTAL\",\n    values: \"VALUES\"\n  },\n  _change_VALUES: function _change_VALUES() {\n    this._updateValues(this.option(OPTION_VALUES));\n  },\n  _factory: objectUtils.clone(dxBaseGauge.prototype._factory),\n  _optionChangesOrder: [\"VALUES\", \"NODES\"],\n  _initialChanges: [\"VALUES\"],\n  _change_NODES: function _change_NODES() {\n    this._buildNodes();\n  },\n  _change_MOSTLY_TOTAL: function _change_MOSTLY_TOTAL() {\n    this._change([\"NODES\"]);\n\n    this.callBase();\n  },\n  _proxyData: [],\n  _getLegendData: function _getLegendData() {\n    var that = this;\n    var formatOptions = {};\n    var options = that._options;\n    var labelFormatOptions = (options.label || {}).format;\n    var legendFormatOptions = (options.legend || {}).itemTextFormat;\n\n    if (legendFormatOptions) {\n      formatOptions.format = legendFormatOptions;\n    } else {\n      formatOptions.format = labelFormatOptions || that._defaultFormatOptions;\n    }\n\n    return (this._bars || []).map(function (b) {\n      return {\n        id: b.index,\n        item: {\n          value: b.getValue(),\n          color: b.getColor(),\n          index: b.index\n        },\n        text: _formatValue(b.getValue(), formatOptions),\n        visible: true,\n        states: {\n          normal: {\n            fill: b.getColor()\n          }\n        }\n      };\n    });\n  }\n});\n\nvar BarWrapper = function BarWrapper(index, context) {\n  var that = this;\n  that._context = context;\n  that._tracker = context.renderer.arc().attr({\n    \"stroke-linejoin\": \"round\"\n  });\n  that.index = index;\n};\n\n_extend(BarWrapper.prototype, {\n  dispose: function dispose() {\n    var that = this;\n\n    that._background.dispose();\n\n    that._bar.dispose();\n\n    if (that._context.textEnabled) {\n      that._line.dispose();\n\n      that._text.dispose();\n    }\n\n    that._context.tracker.detach(that._tracker);\n\n    that._context = that._settings = that._background = that._bar = that._line = that._text = that._tracker = null;\n    return that;\n  },\n  arrange: function arrange(options) {\n    var that = this;\n    var context = that._context;\n    this._visible = true;\n    context.tracker.attach(that._tracker, that, {\n      index: that.index\n    });\n    that._background = context.renderer.arc().attr({\n      \"stroke-linejoin\": \"round\",\n      fill: context.backgroundColor\n    }).append(context.group);\n    that._settings = that._settings || {\n      x: context.x,\n      y: context.y,\n      startAngle: context.baseAngle,\n      endAngle: context.baseAngle\n    };\n    that._bar = context.renderer.arc().attr(_extend({\n      \"stroke-linejoin\": \"round\"\n    }, that._settings)).append(context.group);\n\n    if (context.textEnabled) {\n      that._line = context.renderer.path([], \"line\").attr({\n        \"stroke-width\": context.lineWidth\n      }).append(context.group);\n      that._text = context.renderer.text().css(context.fontStyles).attr(context.textOptions).append(context.group);\n    }\n\n    that._angle = isFinite(that._angle) ? that._angle : context.baseAngle;\n    that._settings.outerRadius = options.radius;\n    that._settings.innerRadius = options.radius - context.barSize;\n    that._settings.x = context.x;\n    that._settings.y = context.y;\n\n    that._background.attr(_extend({}, that._settings, {\n      startAngle: context.endAngle,\n      endAngle: context.startAngle,\n      fill: that._context.backgroundColor\n    }));\n\n    that._bar.attr({\n      x: context.x,\n      y: context.y,\n      outerRadius: that._settings.outerRadius,\n      innerRadius: that._settings.innerRadius,\n      fill: that._color\n    });\n\n    that._tracker.attr(that._settings);\n\n    if (context.textEnabled) {\n      that._line.attr({\n        points: [context.x, context.y - that._settings.innerRadius, context.x, context.y - context.textRadius - context.textIndent],\n        stroke: context.lineColor || that._color\n      }).sharp();\n\n      that._text.css({\n        fill: context.textColor || that._color\n      });\n    }\n\n    return that;\n  },\n  getTooltipParameters: function getTooltipParameters() {\n    var that = this;\n\n    var cosSin = _getCosAndSin((that._angle + that._context.baseAngle) / 2);\n\n    return {\n      x: _round(that._context.x + (that._settings.outerRadius + that._settings.innerRadius) / 2 * cosSin.cos),\n      y: _round(that._context.y - (that._settings.outerRadius + that._settings.innerRadius) / 2 * cosSin.sin),\n      offset: 0,\n      color: that._color,\n      value: that._value\n    };\n  },\n  setAngle: function setAngle(angle) {\n    var that = this;\n    var context = that._context;\n    var settings = that._settings;\n    var cosSin;\n    that._angle = angle;\n    setAngles(settings, context.baseAngle, angle);\n\n    that._bar.attr(settings);\n\n    that._tracker.attr(settings);\n\n    if (context.textEnabled) {\n      cosSin = _getCosAndSin(angle);\n      var indent = context.textIndent;\n      var radius = context.textRadius + indent;\n      var x = context.x + radius * cosSin.cos;\n      var y = context.y - radius * cosSin.sin;\n      var halfWidth = .5 * context.textWidth;\n      var textHeight = context.textHeight;\n      var textY = context.textY;\n\n      if (_abs(x - context.x) > indent) {\n        x += x < context.x ? -halfWidth : halfWidth;\n      }\n\n      if (_abs(y - context.y) <= indent) {\n        y -= textY + .5 * textHeight;\n      } else {\n        y -= y < context.y ? textY + textHeight : textY;\n      }\n\n      var text = _formatValue(that._value, context.formatOptions, {\n        index: that.index\n      });\n\n      var visibility = \"\" === text ? \"hidden\" : null;\n\n      that._text.attr({\n        text: text,\n        x: x,\n        y: y,\n        visibility: visibility\n      });\n\n      that._line.attr({\n        visibility: visibility\n      });\n\n      that._line.rotate(_convertAngleToRendererSpace(angle), context.x, context.y);\n    }\n\n    return that;\n  },\n  hideLabel: function hideLabel() {\n    this._text.attr({\n      visibility: \"hidden\"\n    });\n\n    this._line.attr({\n      visibility: \"hidden\"\n    });\n  },\n  checkIntersect: function checkIntersect(anotherBar) {\n    var coords = this.calculateLabelCoords();\n    var anotherCoords = anotherBar.calculateLabelCoords();\n\n    if (!coords || !anotherCoords) {\n      return false;\n    }\n\n    var width = Math.max(0, Math.min(coords.bottomRight.x, anotherCoords.bottomRight.x) - Math.max(coords.topLeft.x, anotherCoords.topLeft.x));\n    var height = Math.max(0, Math.min(coords.bottomRight.y, anotherCoords.bottomRight.y) - Math.max(coords.topLeft.y, anotherCoords.topLeft.y));\n    return width * height !== 0;\n  },\n  calculateLabelCoords: function calculateLabelCoords() {\n    if (!this._text) {\n      return;\n    }\n\n    var box = this._text.getBBox();\n\n    return {\n      topLeft: {\n        x: box.x,\n        y: box.y\n      },\n      bottomRight: {\n        x: box.x + box.width,\n        y: box.y + box.height\n      }\n    };\n  },\n  _processValue: function _processValue(value) {\n    return this._context.translator.translate(this._context.translator.adjust(value));\n  },\n  applyValue: function applyValue() {\n    if (!this._visible) {\n      return this;\n    }\n\n    return this.setAngle(this._processValue(this.getValue()));\n  },\n  update: function update(_ref) {\n    var color = _ref.color,\n        value = _ref.value;\n    this._color = color;\n    this._value = value;\n  },\n  hide: function hide() {\n    this._visible = false;\n  },\n  getColor: function getColor() {\n    return this._color;\n  },\n  getValue: function getValue() {\n    return this._value;\n  },\n  beginAnimation: function beginAnimation() {\n    if (!this._visible) {\n      return this;\n    }\n\n    var that = this;\n\n    var angle = this._processValue(this.getValue());\n\n    if (!compareFloats(that._angle, angle)) {\n      that._start = that._angle;\n      that._delta = angle - that._angle;\n\n      that._tracker.attr({\n        visibility: \"hidden\"\n      });\n\n      if (that._context.textEnabled) {\n        that._line.attr({\n          visibility: \"hidden\"\n        });\n\n        that._text.attr({\n          visibility: \"hidden\"\n        });\n      }\n    } else {\n      that.animate = _noop;\n      that.setAngle(that._angle);\n    }\n  },\n  animate: function animate(pos) {\n    if (!this._visible) {\n      return this;\n    }\n\n    var that = this;\n    that._angle = that._start + that._delta * pos;\n    setAngles(that._settings, that._context.baseAngle, that._angle);\n\n    that._bar.attr(that._settings);\n  },\n  endAnimation: function endAnimation() {\n    var that = this;\n\n    if (void 0 !== that._delta) {\n      if (compareFloats(that._angle, that._start + that._delta)) {\n        that._tracker.attr({\n          visibility: null\n        });\n\n        that.setAngle(that._angle);\n      }\n    } else {\n      delete that.animate;\n    }\n\n    delete that._start;\n    delete that._delta;\n  }\n});\n\nfunction setAngles(target, angle1, angle2) {\n  target.startAngle = angle1 < angle2 ? angle1 : angle2;\n  target.endAngle = angle1 < angle2 ? angle2 : angle1;\n}\n\nfunction compareFloats(value1, value2) {\n  return _abs(value1 - value2) < 1e-4;\n}\n\nregisterComponent(\"dxBarGauge\", dxBarGauge);\nexports.dxBarGauge = dxBarGauge;\ndxBarGauge.addPlugin(require(\"../components/legend\").plugin);","map":null,"metadata":{},"sourceType":"script"}