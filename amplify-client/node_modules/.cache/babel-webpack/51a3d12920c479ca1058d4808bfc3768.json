{"ast":null,"code":"/**\r\n * DevExtreme (viz/sankey/graph.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar WHITE = \"white\";\nvar GRAY = \"gray\";\nvar BLACK = \"black\";\nvar routines = {\n  maxOfArray: function maxOfArray(arr, callback) {\n    var m = 0;\n\n    var callback_function = function callback_function(v) {\n      return v;\n    };\n\n    if (callback) {\n      callback_function = callback;\n    }\n\n    for (var i = 0; i < arr.length; i++) {\n      if (callback_function(arr[i]) > m) {\n        m = callback_function(arr[i]);\n      }\n    }\n\n    return m;\n  }\n};\n\nvar getVertices = function getVertices(links) {\n  var vert = [];\n  links.forEach(function (link) {\n    if (vert.indexOf(link[0]) === -1) {\n      vert.push(link[0]);\n    }\n\n    if (vert.indexOf(link[1]) === -1) {\n      vert.push(link[1]);\n    }\n  });\n  return vert;\n};\n\nvar getAdjacentVertices = function getAdjacentVertices(links, vertex) {\n  var avert = [];\n  links.forEach(function (link) {\n    if (link[0] === vertex && avert.indexOf(link[1]) === -1) {\n      avert.push(link[1]);\n    }\n  });\n  return avert;\n};\n\nvar getReverseAdjacentVertices = function getReverseAdjacentVertices(links, vertex) {\n  var avert = [];\n  links.forEach(function (link) {\n    if (link[1] === vertex && avert.indexOf(link[0]) === -1) {\n      avert.push(link[0]);\n    }\n  });\n  return avert;\n};\n\nvar struct = {\n  _hasCycle: false,\n  _sortedList: [],\n  hasCycle: function hasCycle(links) {\n    var _this = this;\n\n    this._hasCycle = false;\n    this._sortedList = [];\n    var vertices = {};\n    var allVertices = getVertices(links);\n    allVertices.forEach(function (vertex) {\n      vertices[vertex] = {\n        color: WHITE\n      };\n    });\n    allVertices.forEach(function (vertex) {\n      if (vertices[vertex].color === WHITE) {\n        _this._depthFirstSearch(links, vertices, vertex);\n      }\n    });\n\n    this._sortedList.reverse();\n\n    return this._hasCycle;\n  },\n  _depthFirstSearch: function _depthFirstSearch(links, vertices, vertex) {\n    vertices[vertex].color = GRAY;\n    var averts = getAdjacentVertices(links, vertex);\n\n    for (var a = 0; a < averts.length; a++) {\n      if (vertices[averts[a]].color === WHITE) {\n        this._depthFirstSearch(links, vertices, averts[a]);\n      } else {\n        if (vertices[averts[a]].color === GRAY) {\n          this._hasCycle = true;\n        }\n      }\n    }\n\n    this._sortedList.push({\n      name: vertex,\n      lp: null,\n      incoming: getReverseAdjacentVertices(links, vertex),\n      outgoing: getAdjacentVertices(links, vertex)\n    });\n\n    vertices[vertex].color = BLACK;\n  },\n  computeLongestPaths: function computeLongestPaths(links) {\n    var sortedVertices = this._sortedList;\n    sortedVertices.forEach(function (vertex) {\n      var averts = getReverseAdjacentVertices(links, vertex.name);\n\n      if (0 === averts.length) {\n        vertex.lp = 0;\n      } else {\n        var maxLP = [];\n        averts.forEach(function (adjacentVertex) {\n          maxLP.push(sortedVertices.filter(function (sv) {\n            return sv.name === adjacentVertex;\n          })[0].lp);\n        });\n        vertex.lp = routines.maxOfArray(maxLP) + 1;\n      }\n    });\n    return this._sortedList;\n  }\n};\nmodule.exports = {\n  struct: struct,\n  routines: routines,\n  getVertices: getVertices,\n  getAdjacentVertices: getAdjacentVertices,\n  getReverseAdjacentVertices: getReverseAdjacentVertices\n};","map":{"version":3,"sources":["C:/Users/User/Documents/Templates/Angular/black-dashboard-pro-angular-v1.1.1/black-dashboard-pro-angular-v1.1.1/node_modules/devextreme/viz/sankey/graph.js"],"names":["WHITE","GRAY","BLACK","routines","maxOfArray","arr","callback","m","callback_function","v","i","length","getVertices","links","vert","forEach","link","indexOf","push","getAdjacentVertices","vertex","avert","getReverseAdjacentVertices","struct","_hasCycle","_sortedList","hasCycle","_this","vertices","allVertices","color","_depthFirstSearch","reverse","averts","a","name","lp","incoming","outgoing","computeLongestPaths","sortedVertices","maxLP","adjacentVertex","filter","sv","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (viz/sankey/graph.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nvar WHITE = \"white\";\r\nvar GRAY = \"gray\";\r\nvar BLACK = \"black\";\r\nvar routines = {\r\n    maxOfArray: function(arr, callback) {\r\n        var m = 0;\r\n        var callback_function = function(v) {\r\n            return v\r\n        };\r\n        if (callback) {\r\n            callback_function = callback\r\n        }\r\n        for (var i = 0; i < arr.length; i++) {\r\n            if (callback_function(arr[i]) > m) {\r\n                m = callback_function(arr[i])\r\n            }\r\n        }\r\n        return m\r\n    }\r\n};\r\nvar getVertices = function(links) {\r\n    var vert = [];\r\n    links.forEach(function(link) {\r\n        if (vert.indexOf(link[0]) === -1) {\r\n            vert.push(link[0])\r\n        }\r\n        if (vert.indexOf(link[1]) === -1) {\r\n            vert.push(link[1])\r\n        }\r\n    });\r\n    return vert\r\n};\r\nvar getAdjacentVertices = function(links, vertex) {\r\n    var avert = [];\r\n    links.forEach(function(link) {\r\n        if (link[0] === vertex && avert.indexOf(link[1]) === -1) {\r\n            avert.push(link[1])\r\n        }\r\n    });\r\n    return avert\r\n};\r\nvar getReverseAdjacentVertices = function(links, vertex) {\r\n    var avert = [];\r\n    links.forEach(function(link) {\r\n        if (link[1] === vertex && avert.indexOf(link[0]) === -1) {\r\n            avert.push(link[0])\r\n        }\r\n    });\r\n    return avert\r\n};\r\nvar struct = {\r\n    _hasCycle: false,\r\n    _sortedList: [],\r\n    hasCycle: function(links) {\r\n        var _this = this;\r\n        this._hasCycle = false;\r\n        this._sortedList = [];\r\n        var vertices = {};\r\n        var allVertices = getVertices(links);\r\n        allVertices.forEach(function(vertex) {\r\n            vertices[vertex] = {\r\n                color: WHITE\r\n            }\r\n        });\r\n        allVertices.forEach(function(vertex) {\r\n            if (vertices[vertex].color === WHITE) {\r\n                _this._depthFirstSearch(links, vertices, vertex)\r\n            }\r\n        });\r\n        this._sortedList.reverse();\r\n        return this._hasCycle\r\n    },\r\n    _depthFirstSearch: function(links, vertices, vertex) {\r\n        vertices[vertex].color = GRAY;\r\n        var averts = getAdjacentVertices(links, vertex);\r\n        for (var a = 0; a < averts.length; a++) {\r\n            if (vertices[averts[a]].color === WHITE) {\r\n                this._depthFirstSearch(links, vertices, averts[a])\r\n            } else {\r\n                if (vertices[averts[a]].color === GRAY) {\r\n                    this._hasCycle = true\r\n                }\r\n            }\r\n        }\r\n        this._sortedList.push({\r\n            name: vertex,\r\n            lp: null,\r\n            incoming: getReverseAdjacentVertices(links, vertex),\r\n            outgoing: getAdjacentVertices(links, vertex)\r\n        });\r\n        vertices[vertex].color = BLACK\r\n    },\r\n    computeLongestPaths: function(links) {\r\n        var sortedVertices = this._sortedList;\r\n        sortedVertices.forEach(function(vertex) {\r\n            var averts = getReverseAdjacentVertices(links, vertex.name);\r\n            if (0 === averts.length) {\r\n                vertex.lp = 0\r\n            } else {\r\n                var maxLP = [];\r\n                averts.forEach(function(adjacentVertex) {\r\n                    maxLP.push(sortedVertices.filter(function(sv) {\r\n                        return sv.name === adjacentVertex\r\n                    })[0].lp)\r\n                });\r\n                vertex.lp = routines.maxOfArray(maxLP) + 1\r\n            }\r\n        });\r\n        return this._sortedList\r\n    }\r\n};\r\nmodule.exports = {\r\n    struct: struct,\r\n    routines: routines,\r\n    getVertices: getVertices,\r\n    getAdjacentVertices: getAdjacentVertices,\r\n    getReverseAdjacentVertices: getReverseAdjacentVertices\r\n};\r\n"]},"metadata":{},"sourceType":"script"}