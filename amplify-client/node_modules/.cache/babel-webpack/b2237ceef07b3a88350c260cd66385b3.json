{"ast":null,"code":"/**\r\n * DevExtreme (ui/scheduler/rendering_strategies/ui.scheduler.appointments.strategy.vertical.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _uiSchedulerAppointmentsStrategy = require(\"./ui.scheduler.appointments.strategy.base\");\n\nvar _uiSchedulerAppointmentsStrategy2 = _interopRequireDefault(_uiSchedulerAppointmentsStrategy);\n\nvar _extend = require(\"../../../core/utils/extend\");\n\nvar _type = require(\"../../../core/utils/type\");\n\nvar _devices = require(\"../../../core/devices\");\n\nvar _devices2 = _interopRequireDefault(_devices);\n\nvar _date = require(\"../../../core/utils/date\");\n\nvar _date2 = _interopRequireDefault(_date);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  if (\"function\" === typeof Symbol && \"symbol\" === typeof Symbol.iterator) {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && \"function\" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n\n    if (\"value\" in descriptor) {\n      descriptor.writable = true;\n    }\n\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) {\n    _defineProperties(Constructor.prototype, protoProps);\n  }\n\n  if (staticProps) {\n    _defineProperties(Constructor, staticProps);\n  }\n\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (\"object\" === _typeof(call) || \"function\" === typeof call)) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (void 0 === self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _get(target, property, receiver) {\n  if (\"undefined\" !== typeof Reflect && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) {\n        return;\n      }\n\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n\n    if (null === object) {\n      break;\n    }\n  }\n\n  return object;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function (o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (\"function\" !== typeof superClass && null !== superClass) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  if (superClass) {\n    _setPrototypeOf(subClass, superClass);\n  }\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function (o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nvar WEEK_APPOINTMENT_DEFAULT_OFFSET = 25;\nvar WEEK_APPOINTMENT_MOBILE_OFFSET = 50;\nvar APPOINTMENT_MIN_WIDTH = 5;\nvar ALLDAY_APPOINTMENT_MIN_VERTICAL_OFFSET = 5;\nvar ALLDAY_APPOINTMENT_MAX_VERTICAL_OFFSET = 20;\nvar toMs = _date2.default.dateToMilliseconds;\n\nvar VerticalRenderingStrategy = function (_BaseAppointmentsStra) {\n  _inherits(VerticalRenderingStrategy, _BaseAppointmentsStra);\n\n  function VerticalRenderingStrategy() {\n    _classCallCheck(this, VerticalRenderingStrategy);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(VerticalRenderingStrategy).apply(this, arguments));\n  }\n\n  _createClass(VerticalRenderingStrategy, [{\n    key: \"getDeltaTime\",\n    value: function value(args, initialSize, appointment) {\n      var deltaTime = 0;\n\n      if (this.isAllDay(appointment)) {\n        deltaTime = this._getDeltaWidth(args, initialSize) * toMs(\"day\");\n      } else {\n        var deltaHeight = args.height - initialSize.height;\n        deltaTime = toMs(\"minute\") * Math.round(deltaHeight / this.getDefaultCellHeight() * this.instance.getAppointmentDurationInMinutes());\n      }\n\n      return deltaTime;\n    }\n  }, {\n    key: \"_correctCompactAppointmentCoordinatesInAdaptive\",\n    value: function value(coordinates, isAllDay) {\n      if (isAllDay) {\n        _get(_getPrototypeOf(VerticalRenderingStrategy.prototype), \"_correctCompactAppointmentCoordinatesInAdaptive\", this).call(this, coordinates, isAllDay);\n      } else {\n        if (0 === this._getMaxAppointmentCountPerCellByType()) {\n          var cellHeight = this.getDefaultCellHeight();\n          var cellWidth = this.getDefaultCellWidth();\n          coordinates.top += (cellHeight - this.getDropDownButtonAdaptiveSize()) / 2;\n          coordinates.left += (cellWidth - this.getDropDownButtonAdaptiveSize()) / 2;\n        }\n      }\n    }\n  }, {\n    key: \"getAppointmentGeometry\",\n    value: function value(coordinates) {\n      var geometry = null;\n\n      if (coordinates.allDay) {\n        geometry = this._getAllDayAppointmentGeometry(coordinates);\n      } else {\n        geometry = this._isAdaptive() && coordinates.isCompact ? this._getAdaptiveGeometry(coordinates) : this._getVerticalAppointmentGeometry(coordinates);\n      }\n\n      return _get(_getPrototypeOf(VerticalRenderingStrategy.prototype), \"getAppointmentGeometry\", this).call(this, geometry);\n    }\n  }, {\n    key: \"_getAdaptiveGeometry\",\n    value: function value(coordinates) {\n      var config = this._calculateGeometryConfig(coordinates);\n\n      return this._customizeCoordinates(coordinates, config.height, config.appointmentCountPerCell, config.offset);\n    }\n  }, {\n    key: \"_getItemPosition\",\n    value: function value(item) {\n      var allDay = this.isAllDay(item);\n      var isRecurring = !!this.instance.fire(\"getField\", \"recurrenceRule\", item);\n\n      if (allDay) {\n        return _get(_getPrototypeOf(VerticalRenderingStrategy.prototype), \"_getItemPosition\", this).call(this, item);\n      }\n\n      var position = this._getAppointmentCoordinates(item);\n\n      var result = [];\n\n      for (var j = 0; j < position.length; j++) {\n        var height = this.calculateAppointmentHeight(item, position[j], isRecurring);\n        var width = this.calculateAppointmentWidth(item, position[j], isRecurring);\n        var resultHeight = height;\n        var appointmentReduced = null;\n        var multiDaysAppointmentParts = [];\n        var currentMaxAllowedPosition = position[j].vMax;\n\n        if (this._isMultiDayAppointment(position[j], height)) {\n          appointmentReduced = \"head\";\n          resultHeight = this._reduceMultiDayAppointment(height, {\n            top: position[j].top,\n            bottom: currentMaxAllowedPosition\n          });\n          multiDaysAppointmentParts = this._getAppointmentParts({\n            sourceAppointmentHeight: height,\n            reducedHeight: resultHeight,\n            width: width\n          }, position[j]);\n        }\n\n        (0, _extend.extend)(position[j], {\n          height: resultHeight,\n          width: width,\n          allDay: allDay,\n          appointmentReduced: appointmentReduced\n        });\n        result = this._getAppointmentPartsPosition(multiDaysAppointmentParts, position[j], result);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_isMultiDayAppointment\",\n    value: function value(position, height) {\n      var maxTop = position.vMax;\n      var result = height > maxTop - position.top;\n      return result;\n    }\n  }, {\n    key: \"_reduceMultiDayAppointment\",\n    value: function value(sourceAppointmentHeight, bound) {\n      sourceAppointmentHeight = bound.bottom - Math.floor(bound.top);\n      return sourceAppointmentHeight;\n    }\n  }, {\n    key: \"_getAppointmentParts\",\n    value: function value(appointmentGeometry, appointmentSettings) {\n      var tailHeight = appointmentGeometry.sourceAppointmentHeight - appointmentGeometry.reducedHeight;\n      var width = appointmentGeometry.width;\n      var result = [];\n      var currentPartTop = this.instance.fire(\"getGroupTop\", appointmentSettings.groupIndex);\n      var offset = this.instance.fire(\"isGroupedByDate\") ? this.getDefaultCellWidth() * this.instance.fire(\"getGroupCount\") : this.getDefaultCellWidth();\n      var left = appointmentSettings.left + offset;\n\n      if (tailHeight) {\n        var minHeight = this.getAppointmentMinSize();\n\n        if (tailHeight < minHeight) {\n          tailHeight = minHeight;\n        }\n\n        currentPartTop += this.instance.fire(\"getOffsetByAllDayPanel\", appointmentSettings.groupIndex);\n        result.push((0, _extend.extend)(true, {}, appointmentSettings, {\n          top: currentPartTop,\n          left: left,\n          height: tailHeight,\n          width: width,\n          appointmentReduced: \"tail\",\n          rowIndex: ++appointmentSettings.rowIndex\n        }));\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getMinuteHeight\",\n    value: function value() {\n      return this.getDefaultCellHeight() / this.instance.getAppointmentDurationInMinutes();\n    }\n  }, {\n    key: \"_getCompactLeftCoordinate\",\n    value: function value(itemLeft, index) {\n      var cellBorderSize = 1;\n      var cellWidth = this.getDefaultCellWidth() || this.getAppointmentMinSize();\n      return itemLeft + (cellBorderSize + cellWidth) * index;\n    }\n  }, {\n    key: \"_checkLongCompactAppointment\",\n    value: function value(item, result) {\n      this._splitLongCompactAppointment(item, result);\n\n      return result;\n    }\n  }, {\n    key: \"_getVerticalAppointmentGeometry\",\n    value: function value(coordinates) {\n      var overlappingMode = this.instance.fire(\"getMaxAppointmentsPerCell\");\n\n      if (overlappingMode) {\n        var config = this._calculateVerticalGeometryConfig(coordinates);\n\n        return this._customizeVerticalCoordinates(coordinates, config.width, config.appointmentCountPerCell, config.offset);\n      } else {\n        var width = this._getAppointmentMaxWidth() / coordinates.count;\n        var height = coordinates.height;\n        var top = coordinates.top;\n        var left = coordinates.left + coordinates.index * width;\n\n        if (width < APPOINTMENT_MIN_WIDTH) {\n          width = APPOINTMENT_MIN_WIDTH;\n        }\n\n        return {\n          height: height,\n          width: width,\n          top: top,\n          left: left,\n          empty: this._isAppointmentEmpty(height, width)\n        };\n      }\n    }\n  }, {\n    key: \"_customizeVerticalCoordinates\",\n    value: function value(coordinates, width, appointmentCountPerCell, topOffset, isAllDay) {\n      var index = coordinates.index;\n      var appointmentWidth = Math.max(width / appointmentCountPerCell, width / coordinates.count);\n      var height = coordinates.height;\n      var appointmentLeft = coordinates.left + coordinates.index * appointmentWidth;\n      var top = coordinates.top;\n      var compactAppointmentDefaultSize;\n      var compactAppointmentDefaultOffset;\n\n      if (coordinates.isCompact) {\n        compactAppointmentDefaultSize = this.getCompactAppointmentDefaultWidth();\n        compactAppointmentDefaultOffset = this.getCompactAppointmentLeftOffset();\n        top = coordinates.top + compactAppointmentDefaultOffset;\n        appointmentLeft = coordinates.left + (index - appointmentCountPerCell) * (compactAppointmentDefaultSize + compactAppointmentDefaultOffset) + compactAppointmentDefaultOffset;\n        appointmentWidth = compactAppointmentDefaultSize;\n        width = compactAppointmentDefaultSize;\n\n        this._markAppointmentAsVirtual(coordinates, isAllDay);\n      }\n\n      return {\n        height: height,\n        width: appointmentWidth,\n        top: top,\n        left: appointmentLeft,\n        empty: this._isAppointmentEmpty(height, width)\n      };\n    }\n  }, {\n    key: \"_calculateVerticalGeometryConfig\",\n    value: function value(coordinates) {\n      var overlappingMode = this.instance.fire(\"getMaxAppointmentsPerCell\");\n\n      var offsets = this._getOffsets();\n\n      var appointmentDefaultOffset = this._getAppointmentDefaultOffset();\n\n      var appointmentCountPerCell = this._getAppointmentCount(overlappingMode, coordinates);\n\n      var ratio = this._getDefaultRatio(coordinates, appointmentCountPerCell);\n\n      var maxWidth = this._getMaxWidth();\n\n      if (!appointmentCountPerCell) {\n        appointmentCountPerCell = coordinates.count;\n        ratio = (maxWidth - offsets.unlimited) / maxWidth;\n      }\n\n      var topOffset = (1 - ratio) * maxWidth;\n\n      if (\"auto\" === overlappingMode || (0, _type.isNumeric)(overlappingMode)) {\n        ratio = 1;\n        maxWidth -= appointmentDefaultOffset;\n        topOffset = 0;\n      }\n\n      return {\n        width: ratio * maxWidth,\n        appointmentCountPerCell: appointmentCountPerCell,\n        offset: topOffset\n      };\n    }\n  }, {\n    key: \"_getMaxWidth\",\n    value: function value() {\n      return this.getDefaultCellWidth() || this.invoke(\"getCellWidth\");\n    }\n  }, {\n    key: \"isAllDay\",\n    value: function value(appointmentData) {\n      var allDay = this.instance.fire(\"getField\", \"allDay\", appointmentData);\n\n      if (allDay) {\n        return true;\n      }\n\n      return this.instance.appointmentTakesAllDay(appointmentData);\n    }\n  }, {\n    key: \"_getAppointmentMaxWidth\",\n    value: function value() {\n      var offset = \"desktop\" === _devices2.default.current().deviceType && !this.instance.fire(\"isAdaptive\") ? WEEK_APPOINTMENT_DEFAULT_OFFSET : WEEK_APPOINTMENT_MOBILE_OFFSET;\n      var width = this.getDefaultCellWidth() - offset;\n      return width > 0 ? width : this.getAppointmentMinSize();\n    }\n  }, {\n    key: \"calculateAppointmentWidth\",\n    value: function value(appointment, position, isRecurring) {\n      if (!this.isAllDay(appointment)) {\n        return 0;\n      }\n\n      var startDate = new Date(this.startDate(appointment, false, position));\n      var endDate = this.endDate(appointment, position, isRecurring);\n      var cellWidth = this.getDefaultCellWidth() || this.getAppointmentMinSize();\n      startDate = _date2.default.trimTime(startDate);\n      var durationInHours = (endDate.getTime() - startDate.getTime()) / toMs(\"hour\");\n      var width = Math.ceil(durationInHours / 24) * cellWidth;\n      width = this.cropAppointmentWidth(width, cellWidth);\n      return width;\n    }\n  }, {\n    key: \"calculateAppointmentHeight\",\n    value: function value(appointment, position, isRecurring) {\n      var endDate = this.endDate(appointment, position, isRecurring);\n      var startDate = this.startDate(appointment, false, position);\n      var allDay = this.instance.fire(\"getField\", \"allDay\", appointment);\n\n      if (this.isAllDay(appointment)) {\n        return 0;\n      }\n\n      var fullDuration = this._getAppointmentDurationInMs(startDate, endDate, allDay);\n\n      var durationInMinutes = this._adjustDurationByDaylightDiff(fullDuration, startDate, endDate) / toMs(\"minute\");\n\n      var height = durationInMinutes * this._getMinuteHeight();\n\n      return height;\n    }\n  }, {\n    key: \"getDirection\",\n    value: function value() {\n      return \"vertical\";\n    }\n  }, {\n    key: \"_sortCondition\",\n    value: function value(a, b) {\n      var allDayCondition = a.allDay - b.allDay;\n      var isAllDay = a.allDay && b.allDay;\n      var condition = \"vertical\" === this.instance._groupOrientation && isAllDay ? this._columnCondition(a, b) : this._rowCondition(a, b);\n      return allDayCondition ? allDayCondition : condition;\n    }\n  }, {\n    key: \"hasAllDayAppointments\",\n    value: function value() {\n      return true;\n    }\n  }, {\n    key: \"_getAllDayAppointmentGeometry\",\n    value: function value(coordinates) {\n      var config = this._calculateGeometryConfig(coordinates);\n\n      return this._customizeCoordinates(coordinates, config.height, config.appointmentCountPerCell, config.offset, true);\n    }\n  }, {\n    key: \"_calculateGeometryConfig\",\n    value: function value(coordinates) {\n      if (!this.instance._allowResizing() || !this.instance._allowAllDayResizing()) {\n        coordinates.skipResizing = true;\n      }\n\n      var config = _get(_getPrototypeOf(VerticalRenderingStrategy.prototype), \"_calculateGeometryConfig\", this).call(this, coordinates);\n\n      if (coordinates.count <= this._getDynamicAppointmentCountPerCell().allDay) {\n        config.offset = 0;\n      }\n\n      return config;\n    }\n  }, {\n    key: \"_getAppointmentCount\",\n    value: function value(overlappingMode, coordinates) {\n      return \"auto\" !== overlappingMode && 1 === coordinates.count && !(0, _type.isNumeric)(overlappingMode) ? coordinates.count : this._getMaxAppointmentCountPerCellByType(coordinates.allDay);\n    }\n  }, {\n    key: \"_getDefaultRatio\",\n    value: function value(coordinates, appointmentCountPerCell) {\n      return coordinates.count > this.instance.option(\"_appointmentCountPerCell\") ? .65 : 1;\n    }\n  }, {\n    key: \"_getOffsets\",\n    value: function value() {\n      return {\n        unlimited: ALLDAY_APPOINTMENT_MIN_VERTICAL_OFFSET,\n        auto: ALLDAY_APPOINTMENT_MAX_VERTICAL_OFFSET\n      };\n    }\n  }, {\n    key: \"_getMaxHeight\",\n    value: function value() {\n      return this.getDefaultAllDayCellHeight() || this.getAppointmentMinSize();\n    }\n  }, {\n    key: \"_needVerticalGroupBounds\",\n    value: function value(allDay) {\n      return !allDay;\n    }\n  }, {\n    key: \"_needHorizontalGroupBounds\",\n    value: function value() {\n      return false;\n    }\n  }]);\n\n  return VerticalRenderingStrategy;\n}(_uiSchedulerAppointmentsStrategy2.default);\n\nmodule.exports = VerticalRenderingStrategy;","map":null,"metadata":{},"sourceType":"script"}