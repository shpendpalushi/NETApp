{"ast":null,"code":"/**\r\n * DevExtreme (viz/gauges/linear_indicators.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar baseIndicatorsModule = require(\"./base_indicators\");\n\nvar BaseIndicator = baseIndicatorsModule.BaseIndicator;\nvar BaseTextCloudMarker = baseIndicatorsModule.BaseTextCloudMarker;\nvar BaseRangeBar = baseIndicatorsModule.BaseRangeBar;\nvar _Number = Number;\n\nvar _normalizeEnum = require(\"../core/utils\").normalizeEnum;\n\nvar SimpleIndicator = BaseIndicator.inherit({\n  _move: function _move() {\n    var that = this;\n    var delta = that._actualPosition - that._zeroPosition;\n\n    that._rootElement.move(that.vertical ? 0 : delta, that.vertical ? delta : 0);\n\n    that._trackerElement && that._trackerElement.move(that.vertical ? 0 : delta, that.vertical ? delta : 0);\n  },\n  _isEnabled: function _isEnabled() {\n    this.vertical = this._options.vertical;\n    return this._options.length > 0 && this._options.width > 0;\n  },\n  _isVisible: function _isVisible() {\n    return true;\n  },\n  _getTrackerSettings: function _getTrackerSettings() {\n    var options = this._options;\n    var x1;\n    var x2;\n    var y1;\n    var y2;\n    var width = options.width / 2;\n    var length = options.length / 2;\n    var p = this._zeroPosition;\n    width > 10 || (width = 10);\n    length > 10 || (length = 10);\n\n    if (this.vertical) {\n      x1 = options.x - length;\n      x2 = options.x + length;\n      y1 = p + width;\n      y2 = p - width;\n    } else {\n      x1 = p - width;\n      x2 = p + width;\n      y1 = options.y + length;\n      y2 = options.y - length;\n    }\n\n    return {\n      points: [x1, y1, x1, y2, x2, y2, x2, y1]\n    };\n  },\n  _render: function _render() {\n    var that = this;\n    that._zeroPosition = that._translator.getCodomainStart();\n  },\n  _clear: function _clear() {\n    delete this._element;\n  },\n  measure: function measure(layout) {\n    var p = this.vertical ? layout.x : layout.y;\n    return {\n      min: p - this._options.length / 2,\n      max: p + this._options.length / 2\n    };\n  },\n  getTooltipParameters: function getTooltipParameters() {\n    var that = this;\n    var options = that._options;\n    var p = that._actualPosition;\n    var parameters = {\n      x: p,\n      y: p,\n      value: that._currentValue,\n      color: options.color,\n      offset: options.width / 2\n    };\n    that.vertical ? parameters.x = options.x : parameters.y = options.y;\n    return parameters;\n  }\n});\nvar rectangle = SimpleIndicator.inherit({\n  _render: function _render() {\n    var that = this;\n    var options = that._options;\n    var p;\n    var x1;\n    var x2;\n    var y1;\n    var y2;\n    that.callBase();\n    p = that._zeroPosition;\n\n    if (that.vertical) {\n      x1 = options.x - options.length / 2;\n      x2 = options.x + options.length / 2;\n      y1 = p + options.width / 2;\n      y2 = p - options.width / 2;\n    } else {\n      x1 = p - options.width / 2;\n      x2 = p + options.width / 2;\n      y1 = options.y + options.length / 2;\n      y2 = options.y - options.length / 2;\n    }\n\n    that._element = that._element || that._renderer.path([], \"area\").append(that._rootElement);\n\n    that._element.attr({\n      points: [x1, y1, x1, y2, x2, y2, x2, y1]\n    });\n  }\n});\nvar rhombus = SimpleIndicator.inherit({\n  _render: function _render() {\n    var that = this;\n    var options = that._options;\n    var x;\n    var y;\n    var dx;\n    var dy;\n    that.callBase();\n\n    if (that.vertical) {\n      x = options.x;\n      y = that._zeroPosition;\n      dx = options.length / 2 || 0;\n      dy = options.width / 2 || 0;\n    } else {\n      x = that._zeroPosition;\n      y = options.y;\n      dx = options.width / 2 || 0;\n      dy = options.length / 2 || 0;\n    }\n\n    that._element = that._element || that._renderer.path([], \"area\").append(that._rootElement);\n\n    that._element.attr({\n      points: [x - dx, y, x, y - dy, x + dx, y, x, y + dy]\n    });\n  }\n});\nvar circle = SimpleIndicator.inherit({\n  _render: function _render() {\n    var that = this;\n    var options = that._options;\n    var x;\n    var y;\n    var r;\n    that.callBase();\n\n    if (that.vertical) {\n      x = options.x;\n      y = that._zeroPosition;\n    } else {\n      x = that._zeroPosition;\n      y = options.y;\n    }\n\n    r = options.length / 2 || 0;\n    that._element = that._element || that._renderer.circle().append(that._rootElement);\n\n    that._element.attr({\n      cx: x,\n      cy: y,\n      r: r\n    });\n  }\n});\nvar triangleMarker = SimpleIndicator.inherit({\n  _isEnabled: function _isEnabled() {\n    var that = this;\n    that.vertical = that._options.vertical;\n    that._inverted = that.vertical ? \"right\" === _normalizeEnum(that._options.horizontalOrientation) : \"bottom\" === _normalizeEnum(that._options.verticalOrientation);\n    return that._options.length > 0 && that._options.width > 0;\n  },\n  _isVisible: function _isVisible() {\n    return true;\n  },\n  _render: function _render() {\n    var that = this;\n    var options = that._options;\n    var x1;\n    var x2;\n    var y1;\n    var y2;\n    var settings = {\n      stroke: \"none\",\n      \"stroke-width\": 0,\n      \"stroke-linecap\": \"square\"\n    };\n    that.callBase();\n\n    if (that.vertical) {\n      x1 = options.x;\n      y1 = that._zeroPosition;\n      x2 = x1 + _Number(that._inverted ? options.length : -options.length);\n      settings.points = [x1, y1, x2, y1 - options.width / 2, x2, y1 + options.width / 2];\n    } else {\n      y1 = options.y;\n      x1 = that._zeroPosition;\n      y2 = y1 + _Number(that._inverted ? options.length : -options.length);\n      settings.points = [x1, y1, x1 - options.width / 2, y2, x1 + options.width / 2, y2];\n    }\n\n    if (options.space > 0) {\n      settings[\"stroke-width\"] = Math.min(options.space, options.width / 4) || 0;\n      settings.stroke = settings[\"stroke-width\"] > 0 ? options.containerBackgroundColor || \"none\" : \"none\";\n    }\n\n    that._element = that._element || that._renderer.path([], \"area\").append(that._rootElement);\n\n    that._element.attr(settings).sharp();\n  },\n  _getTrackerSettings: function _getTrackerSettings() {\n    var that = this;\n    var options = that._options;\n    var width = options.width / 2;\n\n    var length = _Number(options.length);\n\n    var x1;\n    var x2;\n    var y1;\n    var y2;\n    var result;\n    width > 10 || (width = 10);\n    length > 20 || (length = 20);\n\n    if (that.vertical) {\n      x1 = x2 = options.x;\n      x2 = x1 + (that._inverted ? length : -length);\n      y1 = that._zeroPosition + width;\n      y2 = that._zeroPosition - width;\n      result = [x1, y1, x2, y1, x2, y2, x1, y2];\n    } else {\n      y1 = options.y;\n      y2 = y1 + (that._inverted ? length : -length);\n      x1 = that._zeroPosition - width;\n      x2 = that._zeroPosition + width;\n      result = [x1, y1, x1, y2, x2, y2, x2, y1];\n    }\n\n    return {\n      points: result\n    };\n  },\n  measure: function measure(layout) {\n    var that = this;\n\n    var length = _Number(that._options.length);\n\n    var minBound;\n    var maxBound;\n\n    if (that.vertical) {\n      minBound = maxBound = layout.x;\n\n      if (that._inverted) {\n        maxBound = minBound + length;\n      } else {\n        minBound = maxBound - length;\n      }\n    } else {\n      minBound = maxBound = layout.y;\n\n      if (that._inverted) {\n        maxBound = minBound + length;\n      } else {\n        minBound = maxBound - length;\n      }\n    }\n\n    return {\n      min: minBound,\n      max: maxBound,\n      indent: that._options.width / 2\n    };\n  },\n  getTooltipParameters: function getTooltipParameters() {\n    var that = this;\n    var options = that._options;\n    var s = (that._inverted ? options.length : -options.length) / 2;\n    var parameters = that.callBase();\n    that.vertical ? parameters.x += s : parameters.y += s;\n    parameters.offset = options.length / 2;\n    return parameters;\n  }\n});\nvar textCloud = BaseTextCloudMarker.inherit({\n  _isEnabled: function _isEnabled() {\n    var that = this;\n    that.vertical = that._options.vertical;\n    that._inverted = that.vertical ? \"right\" === _normalizeEnum(that._options.horizontalOrientation) : \"bottom\" === _normalizeEnum(that._options.verticalOrientation);\n    return true;\n  },\n  _isVisible: function _isVisible() {\n    return true;\n  },\n  _getTextCloudOptions: function _getTextCloudOptions() {\n    var that = this;\n    var x = that._actualPosition;\n    var y = that._actualPosition;\n    var type;\n\n    if (that.vertical) {\n      x = that._options.x;\n      type = that._inverted ? \"top-left\" : \"top-right\";\n    } else {\n      y = that._options.y;\n      type = that._inverted ? \"right-top\" : \"right-bottom\";\n    }\n\n    return {\n      x: x,\n      y: y,\n      type: type\n    };\n  },\n  measure: function measure(layout) {\n    var that = this;\n    var minBound;\n    var maxBound;\n    var arrowLength = _Number(that._options.arrowLength) || 0;\n    var indent;\n\n    that._measureText();\n\n    if (that.vertical) {\n      indent = that._textFullHeight;\n\n      if (that._inverted) {\n        minBound = layout.x;\n        maxBound = layout.x + arrowLength + that._textFullWidth;\n      } else {\n        minBound = layout.x - arrowLength - that._textFullWidth;\n        maxBound = layout.x;\n      }\n    } else {\n      indent = that._textFullWidth;\n\n      if (that._inverted) {\n        minBound = layout.y;\n        maxBound = layout.y + arrowLength + that._textFullHeight;\n      } else {\n        minBound = layout.y - arrowLength - that._textFullHeight;\n        maxBound = layout.y;\n      }\n    }\n\n    return {\n      min: minBound,\n      max: maxBound,\n      indent: indent\n    };\n  }\n});\nvar rangeBar = BaseRangeBar.inherit({\n  _isEnabled: function _isEnabled() {\n    var that = this;\n    that.vertical = that._options.vertical;\n    that._inverted = that.vertical ? \"right\" === _normalizeEnum(that._options.horizontalOrientation) : \"bottom\" === _normalizeEnum(that._options.verticalOrientation);\n    return that._options.size > 0;\n  },\n  _isVisible: function _isVisible() {\n    return true;\n  },\n  _createBarItem: function _createBarItem() {\n    return this._renderer.path([], \"area\").append(this._rootElement);\n  },\n  _createTracker: function _createTracker() {\n    return this._renderer.path([], \"area\");\n  },\n  _setBarSides: function _setBarSides() {\n    var that = this;\n    var options = that._options;\n\n    var size = _Number(options.size);\n\n    var minSide;\n    var maxSide;\n\n    if (that.vertical) {\n      if (that._inverted) {\n        minSide = options.x;\n        maxSide = options.x + size;\n      } else {\n        minSide = options.x - size;\n        maxSide = options.x;\n      }\n    } else {\n      if (that._inverted) {\n        minSide = options.y;\n        maxSide = options.y + size;\n      } else {\n        minSide = options.y - size;\n        maxSide = options.y;\n      }\n    }\n\n    that._minSide = minSide;\n    that._maxSide = maxSide;\n    that._minBound = minSide;\n    that._maxBound = maxSide;\n  },\n  _getSpace: function _getSpace() {\n    var options = this._options;\n    return options.space > 0 ? _Number(options.space) : 0;\n  },\n  _isTextVisible: function _isTextVisible() {\n    var textOptions = this._options.text || {};\n    return textOptions.indent > 0 || textOptions.indent < 0;\n  },\n  _getTextAlign: function _getTextAlign() {\n    return this.vertical ? this._options.text.indent > 0 ? \"left\" : \"right\" : \"center\";\n  },\n  _setTextItemsSides: function _setTextItemsSides() {\n    var that = this;\n\n    var indent = _Number(that._options.text.indent);\n\n    if (indent > 0) {\n      that._lineStart = that._maxSide;\n      that._lineEnd = that._maxSide + indent;\n      that._textPosition = that._lineEnd + (that.vertical ? 2 : that._textHeight / 2);\n      that._maxBound = that._textPosition + (that.vertical ? that._textWidth : that._textHeight / 2);\n    } else {\n      if (indent < 0) {\n        that._lineStart = that._minSide;\n        that._lineEnd = that._minSide + indent;\n        that._textPosition = that._lineEnd - (that.vertical ? 2 : that._textHeight / 2);\n        that._minBound = that._textPosition - (that.vertical ? that._textWidth : that._textHeight / 2);\n      }\n    }\n  },\n  _getPositions: function _getPositions() {\n    var that = this;\n    var startPosition = that._startPosition;\n    var endPosition = that._endPosition;\n    var space = that._space;\n    var basePosition = that._basePosition;\n    var actualPosition = that._actualPosition;\n    var mainPosition1;\n    var mainPosition2;\n    var backPosition1;\n    var backPosition2;\n\n    if (startPosition < endPosition) {\n      if (basePosition < actualPosition) {\n        mainPosition1 = basePosition;\n        mainPosition2 = actualPosition;\n      } else {\n        mainPosition1 = actualPosition;\n        mainPosition2 = basePosition;\n      }\n\n      backPosition1 = mainPosition1 - space;\n      backPosition2 = mainPosition2 + space;\n    } else {\n      if (basePosition > actualPosition) {\n        mainPosition1 = basePosition;\n        mainPosition2 = actualPosition;\n      } else {\n        mainPosition1 = actualPosition;\n        mainPosition2 = basePosition;\n      }\n\n      backPosition1 = mainPosition1 + space;\n      backPosition2 = mainPosition2 - space;\n    }\n\n    return {\n      start: startPosition,\n      end: endPosition,\n      main1: mainPosition1,\n      main2: mainPosition2,\n      back1: backPosition1,\n      back2: backPosition2\n    };\n  },\n  _buildItemSettings: function _buildItemSettings(from, to) {\n    var that = this;\n    var side1 = that._minSide;\n    var side2 = that._maxSide;\n    var points = that.vertical ? [side1, from, side1, to, side2, to, side2, from] : [from, side1, from, side2, to, side2, to, side1];\n    return {\n      points: points\n    };\n  },\n  _updateTextPosition: function _updateTextPosition() {\n    var that = this;\n\n    that._text.attr(that.vertical ? {\n      x: that._textPosition,\n      y: that._actualPosition + that._textVerticalOffset\n    } : {\n      x: that._actualPosition,\n      y: that._textPosition + that._textVerticalOffset\n    });\n  },\n  _updateLinePosition: function _updateLinePosition() {\n    var that = this;\n    var actualPosition = that._actualPosition;\n    var side1;\n    var side2;\n    var points;\n\n    if (that.vertical) {\n      if (that._basePosition >= actualPosition) {\n        side1 = actualPosition;\n        side2 = actualPosition + 2;\n      } else {\n        side1 = actualPosition - 2;\n        side2 = actualPosition;\n      }\n\n      points = [that._lineStart, side1, that._lineStart, side2, that._lineEnd, side2, that._lineEnd, side1];\n    } else {\n      if (that._basePosition <= actualPosition) {\n        side1 = actualPosition - 2;\n        side2 = actualPosition;\n      } else {\n        side1 = actualPosition;\n        side2 = actualPosition + 2;\n      }\n\n      points = [side1, that._lineStart, side1, that._lineEnd, side2, that._lineEnd, side2, that._lineStart];\n    }\n\n    that._line.attr({\n      points: points\n    }).sharp();\n  },\n  _getTooltipPosition: function _getTooltipPosition() {\n    var that = this;\n    var crossCenter = (that._minSide + that._maxSide) / 2;\n    var alongCenter = (that._basePosition + that._actualPosition) / 2;\n    return that.vertical ? {\n      x: crossCenter,\n      y: alongCenter\n    } : {\n      x: alongCenter,\n      y: crossCenter\n    };\n  },\n  measure: function measure(layout) {\n    var that = this;\n\n    var size = _Number(that._options.size);\n\n    var textIndent = _Number(that._options.text.indent);\n\n    var minBound;\n    var maxBound;\n    var indent;\n\n    that._measureText();\n\n    if (that.vertical) {\n      minBound = maxBound = layout.x;\n\n      if (that._inverted) {\n        maxBound += size;\n      } else {\n        minBound -= size;\n      }\n\n      if (that._hasText) {\n        indent = that._textHeight / 2;\n\n        if (textIndent > 0) {\n          maxBound += textIndent + that._textWidth;\n        }\n\n        if (textIndent < 0) {\n          minBound += textIndent - that._textWidth;\n        }\n      }\n    } else {\n      minBound = maxBound = layout.y;\n\n      if (that._inverted) {\n        maxBound += size;\n      } else {\n        minBound -= size;\n      }\n\n      if (that._hasText) {\n        indent = that._textWidth / 2;\n\n        if (textIndent > 0) {\n          maxBound += textIndent + that._textHeight;\n        }\n\n        if (textIndent < 0) {\n          minBound += textIndent - that._textHeight;\n        }\n      }\n    }\n\n    return {\n      min: minBound,\n      max: maxBound,\n      indent: indent\n    };\n  }\n});\nexports._default = rangeBar;\nexports.rectangle = rectangle;\nexports.rhombus = rhombus;\nexports.circle = circle;\nexports.trianglemarker = triangleMarker;\nexports.textcloud = textCloud;\nexports.rangebar = rangeBar;","map":null,"metadata":{},"sourceType":"script"}