{"ast":null,"code":"/**\r\n * DevExtreme (viz/chart.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _common = require(\"../core/utils/common\");\n\nvar _extend2 = require(\"../core/utils/extend\");\n\nvar _array = require(\"../core/utils/array\");\n\nvar _iterator = require(\"../core/utils/iterator\");\n\nvar _component_registrator = require(\"../core/component_registrator\");\n\nvar _component_registrator2 = _interopRequireDefault(_component_registrator);\n\nvar _utils = require(\"./core/utils\");\n\nvar _type = require(\"../core/utils/type\");\n\nvar _math = require(\"../core/utils/math\");\n\nvar _base_chart = require(\"./chart_components/base_chart\");\n\nvar _layout_manager = require(\"./chart_components/layout_manager\");\n\nvar _layout_manager2 = _interopRequireDefault(_layout_manager);\n\nvar _multi_axes_synchronizer = require(\"./chart_components/multi_axes_synchronizer\");\n\nvar _multi_axes_synchronizer2 = _interopRequireDefault(_multi_axes_synchronizer);\n\nvar _advanced_chart = require(\"./chart_components/advanced_chart\");\n\nvar _scroll_bar = require(\"./chart_components/scroll_bar\");\n\nvar _scroll_bar2 = _interopRequireDefault(_scroll_bar);\n\nvar _crosshair = require(\"./chart_components/crosshair\");\n\nvar _crosshair2 = _interopRequireDefault(_crosshair);\n\nvar _range_data_calculator = require(\"./series/helpers/range_data_calculator\");\n\nvar _range_data_calculator2 = _interopRequireDefault(_range_data_calculator);\n\nvar _range = require(\"./translators/range\");\n\nvar _range2 = _interopRequireDefault(_range);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar DEFAULT_PANE_NAME = \"default\";\nvar VISUAL_RANGE = \"VISUAL_RANGE\";\nvar DEFAULT_PANES = [{\n  name: DEFAULT_PANE_NAME,\n  border: {}\n}];\nvar _isArray = Array.isArray;\n\nfunction getFirstAxisNameForPane(axes, paneName, defaultPane) {\n  var result;\n\n  for (var i = 0; i < axes.length; i++) {\n    if (axes[i].pane === paneName || void 0 === axes[i].pane && paneName === defaultPane) {\n      result = axes[i].name;\n      break;\n    }\n  }\n\n  if (!result) {\n    result = axes[0].name;\n  }\n\n  return result;\n}\n\nfunction changeVisibilityAxisGrids(axis, gridVisibility, minorGridVisibility) {\n  var gridOpt = axis.getOptions().grid;\n  var minorGridOpt = axis.getOptions().minorGrid;\n  gridOpt.visible = gridVisibility;\n  minorGridOpt && (minorGridOpt.visible = minorGridVisibility);\n}\n\nfunction hideGridsOnNonFirstValueAxisForPane(axesForPane) {\n  var axisShown = false;\n  var hiddenStubAxis = [];\n  var minorGridVisibility = axesForPane.some(function (axis) {\n    var minorGridOptions = axis.getOptions().minorGrid;\n    return minorGridOptions && minorGridOptions.visible;\n  });\n  var gridVisibility = axesForPane.some(function (axis) {\n    var gridOptions = axis.getOptions().grid;\n    return gridOptions && gridOptions.visible;\n  });\n\n  if (axesForPane.length > 1) {\n    axesForPane.forEach(function (axis) {\n      var gridOpt = axis.getOptions().grid;\n\n      if (axisShown) {\n        changeVisibilityAxisGrids(axis, false, false);\n      } else {\n        if (gridOpt && gridOpt.visible) {\n          if (axis.getTranslator().getBusinessRange().isEmpty()) {\n            changeVisibilityAxisGrids(axis, false, false);\n            hiddenStubAxis.push(axis);\n          } else {\n            axisShown = true;\n            changeVisibilityAxisGrids(axis, gridVisibility, minorGridVisibility);\n          }\n        }\n      }\n    });\n    !axisShown && hiddenStubAxis.length && changeVisibilityAxisGrids(hiddenStubAxis[0], gridVisibility, minorGridVisibility);\n  }\n}\n\nfunction findAxisOptions(valueAxes, valueAxesOptions, axisName) {\n  var result;\n  var axInd;\n\n  for (axInd = 0; axInd < valueAxesOptions.length; axInd++) {\n    if (valueAxesOptions[axInd].name === axisName) {\n      result = valueAxesOptions[axInd];\n      result.priority = axInd;\n      break;\n    }\n  }\n\n  if (!result) {\n    for (axInd = 0; axInd < valueAxes.length; axInd++) {\n      if (valueAxes[axInd].name === axisName) {\n        result = valueAxes[axInd].getOptions();\n        result.priority = valueAxes[axInd].priority;\n        break;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction findAxis(paneName, axisName, axes) {\n  var axis;\n  var i;\n\n  for (i = 0; i < axes.length; i++) {\n    axis = axes[i];\n\n    if (axis.name === axisName && axis.pane === paneName) {\n      return axis;\n    }\n  }\n\n  if (paneName) {\n    return findAxis(void 0, axisName, axes);\n  }\n}\n\nfunction compareAxes(a, b) {\n  return a.priority - b.priority;\n}\n\nfunction doesPaneExist(panes, paneName) {\n  var found = false;\n  (0, _iterator.each)(panes, function (_, pane) {\n    if (pane.name === paneName) {\n      found = true;\n      return false;\n    }\n  });\n  return found;\n}\n\nvar prepareSegmentRectPoints = function prepareSegmentRectPoints(left, top, width, height, borderOptions) {\n  var maxSW = ~~((width < height ? width : height) / 2);\n  var sw = borderOptions.width || 0;\n  var newSW = sw < maxSW ? sw : maxSW;\n  left += newSW / 2;\n  top += newSW / 2;\n  width -= newSW;\n  height -= newSW;\n  var right = left + width;\n  var bottom = top + height;\n  var points = [];\n  var segments = [];\n  var segmentSequence;\n  var visiblyOpt = 0;\n  var prevSegmentVisibility = 0;\n  var allSegment = {\n    top: [[left, top], [right, top]],\n    right: [[right, top], [right, bottom]],\n    bottom: [[right, bottom], [left, bottom]],\n    left: [[left, bottom], [left, top]]\n  };\n  (0, _iterator.each)(allSegment, function (seg) {\n    var visibility = !!borderOptions[seg];\n    visiblyOpt = 2 * visiblyOpt + ~~visibility;\n  });\n\n  switch (visiblyOpt) {\n    case 13:\n    case 9:\n      segmentSequence = [\"left\", \"top\", \"right\", \"bottom\"];\n      break;\n\n    case 11:\n      segmentSequence = [\"bottom\", \"left\", \"top\", \"right\"];\n      break;\n\n    default:\n      segmentSequence = [\"top\", \"right\", \"bottom\", \"left\"];\n  }\n\n  (0, _iterator.each)(segmentSequence, function (_, seg) {\n    var segmentVisibility = !!borderOptions[seg];\n\n    if (!prevSegmentVisibility && segments.length) {\n      points.push(segments);\n      segments = [];\n    }\n\n    if (segmentVisibility) {\n      (0, _iterator.each)(allSegment[seg].slice(prevSegmentVisibility), function (_, segment) {\n        segments = segments.concat(segment);\n      });\n    }\n\n    prevSegmentVisibility = ~~segmentVisibility;\n  });\n  segments.length && points.push(segments);\n  1 === points.length && (points = points[0]);\n  return {\n    points: points,\n    pathType: 15 === visiblyOpt ? \"area\" : \"line\"\n  };\n};\n\nfunction accumulate(field, src1, src2, auxSpacing) {\n  var val1 = src1[field] || 0;\n  var val2 = src2[field] || 0;\n  return val1 + val2 + (val1 && val2 ? auxSpacing : 0);\n}\n\nfunction pickMax(field, src1, src2) {\n  return pickMaxValue(src1[field], src2[field]);\n}\n\nfunction pickMaxValue(val1, val2) {\n  return Math.max(val1 || 0, val2 || 0);\n}\n\nfunction getAxisMargins(axis) {\n  return axis.getMargins();\n}\n\nfunction getHorizontalAxesMargins(axes, getMarginsFunc) {\n  return axes.reduce(function (margins, axis) {\n    var axisMargins = getMarginsFunc(axis);\n    var paneMargins = margins.panes[axis.pane] = margins.panes[axis.pane] || {};\n    var spacing = axis.getMultipleAxesSpacing();\n    paneMargins.top = accumulate(\"top\", paneMargins, axisMargins, spacing);\n    paneMargins.bottom = accumulate(\"bottom\", paneMargins, axisMargins, spacing);\n    paneMargins.left = pickMax(\"left\", paneMargins, axisMargins);\n    paneMargins.right = pickMax(\"right\", paneMargins, axisMargins);\n    margins.top = pickMax(\"top\", paneMargins, margins);\n    margins.bottom = pickMax(\"bottom\", paneMargins, margins);\n    margins.left = pickMax(\"left\", paneMargins, margins);\n    margins.right = pickMax(\"right\", paneMargins, margins);\n    return margins;\n  }, {\n    panes: {}\n  });\n}\n\nfunction getVerticalAxesMargins(axes) {\n  return axes.reduce(function (margins, axis) {\n    var axisMargins = axis.getMargins();\n    var paneMargins = margins.panes[axis.pane] = margins.panes[axis.pane] || {};\n    var spacing = axis.getMultipleAxesSpacing();\n    paneMargins.top = pickMax(\"top\", paneMargins, axisMargins);\n    paneMargins.bottom = pickMax(\"bottom\", paneMargins, axisMargins);\n    paneMargins.left = accumulate(\"left\", paneMargins, axisMargins, spacing);\n    paneMargins.right = accumulate(\"right\", paneMargins, axisMargins, spacing);\n    margins.top = pickMax(\"top\", paneMargins, margins);\n    margins.bottom = pickMax(\"bottom\", paneMargins, margins);\n    margins.left = pickMax(\"left\", paneMargins, margins);\n    margins.right = pickMax(\"right\", paneMargins, margins);\n    return margins;\n  }, {\n    panes: {}\n  });\n}\n\nfunction performActionOnAxes(axes, action, actionArgument1, actionArgument2, actionArgument3) {\n  axes.forEach(function (axis) {\n    axis[action](actionArgument1 && actionArgument1[axis.pane], actionArgument2 && actionArgument2[axis.pane] || actionArgument2, actionArgument3);\n  });\n}\n\nfunction shrinkCanvases(isRotated, canvases, sizes, verticalMargins, horizontalMargins) {\n  function getMargin(side, margins, pane) {\n    var m = (isRotated ? [\"left\", \"right\"] : [\"top\", \"bottom\"]).indexOf(side) === -1 ? margins : margins.panes[pane] || {};\n    return m[side];\n  }\n\n  function getMaxMargin(side, margins1, margins2, pane) {\n    return pickMaxValue(getMargin(side, margins1, pane), getMargin(side, margins2, pane));\n  }\n\n  var getOriginalField = function getOriginalField(field) {\n    return \"original\".concat(field[0].toUpperCase()).concat(field.slice(1));\n  };\n\n  function shrink(canvases, paneNames, sizeField, startMargin, endMargin, oppositeMargins) {\n    paneNames = paneNames.sort(function (p1, p2) {\n      return canvases[p2][startMargin] - canvases[p1][startMargin];\n    });\n    paneNames.forEach(function (pane) {\n      var canvas = canvases[pane];\n      oppositeMargins.forEach(function (margin) {\n        canvas[margin] = canvas[getOriginalField(margin)] + getMaxMargin(margin, verticalMargins, horizontalMargins, pane);\n      });\n    });\n    var firstPane = canvases[paneNames[0]];\n    var emptySpace = paneNames.reduce(function (space, paneName) {\n      space -= getMaxMargin(startMargin, verticalMargins, horizontalMargins, paneName) + getMaxMargin(endMargin, verticalMargins, horizontalMargins, paneName);\n      return space;\n    }, firstPane[sizeField] - firstPane[getOriginalField(endMargin)] - canvases[paneNames[paneNames.length - 1]][getOriginalField(startMargin)]) - _utils.PANE_PADDING * (paneNames.length - 1);\n    var totalCustomSpace = Object.keys(sizes).reduce(function (prev, key) {\n      return prev + (sizes[key].unit ? sizes[key].height : 0);\n    }, 0);\n    emptySpace -= totalCustomSpace;\n    paneNames.reduce(function (offset, pane) {\n      var canvas = canvases[pane];\n      var paneSize = sizes[pane];\n      offset -= getMaxMargin(endMargin, verticalMargins, horizontalMargins, pane);\n      canvas[endMargin] = firstPane[sizeField] - offset;\n      offset -= paneSize.unit ? paneSize.height : Math.floor(emptySpace * paneSize.height);\n      canvas[startMargin] = offset;\n      offset -= getMaxMargin(startMargin, verticalMargins, horizontalMargins, pane) + _utils.PANE_PADDING;\n      return offset;\n    }, firstPane[sizeField] - firstPane[getOriginalField(endMargin)] - (emptySpace < 0 ? emptySpace : 0));\n  }\n\n  var paneNames = Object.keys(canvases);\n\n  if (!isRotated) {\n    shrink(canvases, paneNames, \"height\", \"top\", \"bottom\", [\"left\", \"right\"]);\n  } else {\n    shrink(canvases, paneNames, \"width\", \"left\", \"right\", [\"top\", \"bottom\"]);\n  }\n\n  return canvases;\n}\n\nfunction drawAxesWithTicks(axes, condition, canvases, panesBorderOptions) {\n  if (condition) {\n    performActionOnAxes(axes, \"createTicks\", canvases);\n\n    _multi_axes_synchronizer2.default.synchronize(axes);\n  }\n\n  performActionOnAxes(axes, \"draw\", !condition && canvases, panesBorderOptions);\n}\n\nfunction shiftAxis(side1, side2) {\n  var shifts = {};\n  return function (axis) {\n    var shift = shifts[axis.pane] = shifts[axis.pane] || {\n      top: 0,\n      left: 0,\n      bottom: 0,\n      right: 0\n    };\n    var spacing = axis.getMultipleAxesSpacing();\n    var margins = axis.getMargins();\n    axis.shift(shift);\n    shift[side1] = accumulate(side1, shift, margins, spacing);\n    shift[side2] = accumulate(side2, shift, margins, spacing);\n  };\n}\n\nfunction getCommonSize(side, margins) {\n  var size = 0;\n  var pane;\n  var paneMargins;\n\n  for (pane in margins.panes) {\n    paneMargins = margins.panes[pane];\n    size += \"height\" === side ? paneMargins.top + paneMargins.bottom : paneMargins.left + paneMargins.right;\n  }\n\n  return size;\n}\n\nfunction checkUsedSpace(sizeShortage, side, axes, getMarginFunc) {\n  var size = 0;\n\n  if (sizeShortage[side] > 0) {\n    size = getCommonSize(side, getMarginFunc(axes, getAxisMargins));\n    performActionOnAxes(axes, \"hideTitle\");\n    sizeShortage[side] -= size - getCommonSize(side, getMarginFunc(axes, getAxisMargins));\n  }\n\n  if (sizeShortage[side] > 0) {\n    performActionOnAxes(axes, \"hideOuterElements\");\n  }\n}\n\nfunction axisAnimationEnabled(drawOptions, series) {\n  var pointsCount = series.reduce(function (sum, s) {\n    return sum += s.getPoints().length;\n  }, 0) / series.length;\n  return drawOptions.animate && pointsCount <= drawOptions.animationPointsLimit;\n}\n\nvar dxChart = _advanced_chart.AdvancedChart.inherit({\n  _themeSection: \"chart\",\n  _fontFields: [\"crosshair.label.font\"],\n  _setDeprecatedOptions: function _setDeprecatedOptions() {\n    this.callBase.apply(this, arguments);\n    (0, _extend2.extend)(this._deprecatedOptions, {\n      useAggregation: {\n        since: \"18.1\",\n        message: \"Use the 'commonSeriesSettings.aggregation.enabled' or 'series.aggregation.enabled' option instead\"\n      },\n      \"argumentAxis.min\": {\n        since: \"18.2\",\n        message: \"Use the 'argumentAxis.visualRange' option instead\"\n      },\n      \"argumentAxis.max\": {\n        since: \"18.2\",\n        message: \"Use the 'argumentAxis.visualRange' option instead\"\n      },\n      \"valueAxis.min\": {\n        since: \"18.2\",\n        message: \"Use the 'valueAxis.visualRange' option instead\"\n      },\n      \"valueAxis.max\": {\n        since: \"18.2\",\n        message: \"Use the 'valueAxis.visualRange' option instead\"\n      },\n      zoomingMode: {\n        since: \"18.2\",\n        message: \"Use the 'zoomAndPan' option instead\"\n      },\n      scrollingMode: {\n        since: \"18.2\",\n        message: \"Use the 'zoomAndPan' option instead\"\n      }\n    });\n  },\n  _initCore: function _initCore() {\n    this.paneAxis = {};\n    this.callBase();\n  },\n  _correctAxes: function _correctAxes() {\n    this._correctValueAxes(true);\n  },\n  _getExtraOptions: _common.noop,\n  _createPanes: function _createPanes() {\n    var that = this;\n    var panes = that.option(\"panes\");\n    var panesNameCounter = 0;\n    var defaultPane;\n\n    if (!panes || _isArray(panes) && !panes.length) {\n      panes = DEFAULT_PANES;\n    }\n\n    that.callBase();\n    defaultPane = that.option(\"defaultPane\");\n    panes = (0, _extend2.extend)(true, [], _isArray(panes) ? panes : [panes]);\n    (0, _iterator.each)(panes, function (_, pane) {\n      pane.name = !(0, _type.isDefined)(pane.name) ? DEFAULT_PANE_NAME + panesNameCounter++ : pane.name;\n    });\n\n    if ((0, _type.isDefined)(defaultPane)) {\n      if (!doesPaneExist(panes, defaultPane)) {\n        that._incidentOccurred(\"W2101\", [defaultPane]);\n\n        defaultPane = panes[panes.length - 1].name;\n      }\n    } else {\n      defaultPane = panes[panes.length - 1].name;\n    }\n\n    that.defaultPane = defaultPane;\n    panes = that._isRotated() ? panes.reverse() : panes;\n    return panes;\n  },\n  _getAxisRenderingOptions: function _getAxisRenderingOptions() {\n    return {\n      axisType: \"xyAxes\",\n      drawingType: \"linear\"\n    };\n  },\n  _prepareAxisOptions: function _prepareAxisOptions(typeSelector, userOptions, rotated) {\n    return {\n      isHorizontal: \"argumentAxis\" === typeSelector !== rotated,\n      containerColor: this._themeManager.getOptions(\"containerBackgroundColor\")\n    };\n  },\n  _checkPaneName: function _checkPaneName(seriesTheme) {\n    var paneList = (0, _utils.map)(this.panes, function (pane) {\n      return pane.name;\n    });\n    seriesTheme.pane = seriesTheme.pane || this.defaultPane;\n    return (0, _array.inArray)(seriesTheme.pane, paneList) !== -1;\n  },\n  _getValueAxis: function _getValueAxis(paneName, axisName) {\n    var that = this;\n    var valueAxes = that._valueAxes;\n    var valueAxisOptions = that.option(\"valueAxis\") || {};\n    var valueAxesOptions = _isArray(valueAxisOptions) ? valueAxisOptions : [valueAxisOptions];\n\n    var rotated = that._isRotated();\n\n    var crosshairMargins = that._getCrosshairMargins();\n\n    var axisOptions;\n    var axis;\n    axisName = axisName || getFirstAxisNameForPane(valueAxes, paneName, that.defaultPane);\n    axis = findAxis(paneName, axisName, valueAxes);\n\n    if (!axis) {\n      axisOptions = findAxisOptions(valueAxes, valueAxesOptions, axisName);\n\n      if (!axisOptions) {\n        that._incidentOccurred(\"W2102\", [axisName]);\n\n        axisOptions = {\n          name: axisName,\n          priority: valueAxes.length\n        };\n      }\n\n      axis = that._createAxis(false, that._populateAxesOptions(\"valueAxis\", axisOptions, {\n        pane: paneName,\n        name: axisName,\n        optionPath: _isArray(valueAxisOptions) ? \"valueAxis[\".concat(axisOptions.priority, \"]\") : \"valueAxis\",\n        crosshairMargin: rotated ? crosshairMargins.y : crosshairMargins.x\n      }, rotated));\n      axis.applyVisualRangeSetter(that._getVisualRangeSetter());\n      valueAxes.push(axis);\n    }\n\n    axis.setPane(paneName);\n    return axis;\n  },\n  _correctValueAxes: function _correctValueAxes(needHideGrids) {\n    var that = this;\n\n    var synchronizeMultiAxes = that._themeManager.getOptions(\"synchronizeMultiAxes\");\n\n    var valueAxes = that._valueAxes;\n    var paneWithAxis = {};\n    that.series.forEach(function (series) {\n      var axis = series.getValueAxis();\n      paneWithAxis[axis.pane] = true;\n    });\n    that.panes.forEach(function (pane) {\n      var paneName = pane.name;\n\n      if (!paneWithAxis[paneName]) {\n        that._getValueAxis(paneName);\n      }\n\n      if (needHideGrids && synchronizeMultiAxes) {\n        hideGridsOnNonFirstValueAxisForPane(valueAxes.filter(function (axis) {\n          return axis.pane === paneName;\n        }));\n      }\n    });\n    that._valueAxes = valueAxes.filter(function (axis) {\n      if (!axis.pane) {\n        axis.setPane(that.defaultPane);\n      }\n\n      return doesPaneExist(that.panes, axis.pane);\n    }).sort(compareAxes);\n    var defaultAxis = this.getValueAxis();\n\n    that._valueAxes.forEach(function (axis) {\n      var optionPath = axis.getOptions().optionPath;\n\n      if (optionPath) {\n        var axesWithSamePath = that._valueAxes.filter(function (a) {\n          return a.getOptions().optionPath === optionPath;\n        });\n\n        if (axesWithSamePath.length > 1) {\n          if (axesWithSamePath.some(function (a) {\n            return a === defaultAxis;\n          })) {\n            axesWithSamePath.forEach(function (a) {\n              if (a !== defaultAxis) {\n                a.getOptions().optionPath = null;\n              }\n            });\n          } else {\n            axesWithSamePath.forEach(function (a, i) {\n              if (0 !== i) {\n                a.getOptions().optionPath = null;\n              }\n            });\n          }\n        }\n      }\n    });\n  },\n  _getSeriesForPane: function _getSeriesForPane(paneName) {\n    var paneSeries = [];\n    (0, _iterator.each)(this.series, function (_, oneSeries) {\n      if (oneSeries.pane === paneName) {\n        paneSeries.push(oneSeries);\n      }\n    });\n    return paneSeries;\n  },\n  _createPanesBorderOptions: function _createPanesBorderOptions() {\n    var commonBorderOptions = this._themeManager.getOptions(\"commonPaneSettings\").border;\n\n    var panesBorderOptions = {};\n    this.panes.forEach(function (pane) {\n      return panesBorderOptions[pane.name] = (0, _extend2.extend)(true, {}, commonBorderOptions, pane.border);\n    });\n    return panesBorderOptions;\n  },\n  _createScrollBar: function _createScrollBar() {\n    var that = this;\n    var scrollBarOptions = that._themeManager.getOptions(\"scrollBar\") || {};\n    var scrollBarGroup = that._scrollBarGroup;\n\n    if (scrollBarOptions.visible) {\n      scrollBarOptions.rotated = that._isRotated();\n      that._scrollBar = (that._scrollBar || new _scroll_bar2.default.ScrollBar(that._renderer, scrollBarGroup)).update(scrollBarOptions);\n    } else {\n      scrollBarGroup.linkRemove();\n      that._scrollBar && that._scrollBar.dispose();\n      that._scrollBar = null;\n    }\n  },\n  _prepareToRender: function _prepareToRender(drawOptions) {\n    var panesBorderOptions = this._createPanesBorderOptions();\n\n    this._createPanesBackground();\n\n    this._appendAxesGroups();\n\n    this._adjustViewport();\n\n    return panesBorderOptions;\n  },\n  _adjustViewport: function _adjustViewport() {\n    var that = this;\n\n    var series = that._getVisibleSeries();\n\n    var argumentAxis = that.getArgumentAxis();\n    var useAggregation = series.some(function (s) {\n      return s.useAggregation();\n    });\n\n    var adjustOnZoom = that._themeManager.getOptions(\"adjustOnZoom\");\n\n    var alignToBounds = !argumentAxis.dataVisualRangeIsReduced();\n\n    if (!useAggregation && !adjustOnZoom) {\n      return;\n    }\n\n    that._valueAxes.forEach(function (axis) {\n      return axis.adjust(alignToBounds);\n    });\n  },\n  _recreateSizeDependentObjects: function _recreateSizeDependentObjects(isCanvasChanged) {\n    var that = this;\n\n    var series = that._getVisibleSeries();\n\n    var useAggregation = series.some(function (s) {\n      return s.useAggregation();\n    });\n\n    var zoomChanged = that._isZooming();\n\n    if (!useAggregation) {\n      return;\n    }\n\n    that._argumentAxes.forEach(function (axis) {\n      axis.updateCanvas(that._canvas);\n    });\n\n    series.forEach(function (series) {\n      if (series.useAggregation() && (isCanvasChanged || zoomChanged || !series._useAllAggregatedPoints)) {\n        series.createPoints();\n      }\n    });\n\n    that._processSeriesFamilies();\n  },\n  _isZooming: function _isZooming() {\n    var that = this;\n    var argumentAxis = that.getArgumentAxis();\n\n    if (!argumentAxis || !argumentAxis.getTranslator()) {\n      return false;\n    }\n\n    var businessRange = argumentAxis.getTranslator().getBusinessRange();\n    var zoomRange = argumentAxis.getViewport();\n    var min = zoomRange ? zoomRange.min : 0;\n    var max = zoomRange ? zoomRange.max : 0;\n\n    if (\"logarithmic\" === businessRange.axisType) {\n      min = (0, _utils.getLog)(min, businessRange.base);\n      max = (0, _utils.getLog)(max, businessRange.base);\n    }\n\n    var viewportDistance = \"discrete\" === businessRange.axisType ? (0, _utils.getCategoriesInfo)(businessRange.categories, min, max).categories.length : Math.abs(max - min);\n    var precision = (0, _math.getPrecision)(viewportDistance);\n    precision = precision > 1 ? Math.pow(10, precision - 2) : 1;\n    var zoomChanged = Math.round((that._zoomLength - viewportDistance) * precision) / precision !== 0;\n    that._zoomLength = viewportDistance;\n    return zoomChanged;\n  },\n  _handleSeriesDataUpdated: function _handleSeriesDataUpdated() {\n    var that = this;\n    var viewport = new _range2.default.Range();\n    that.series.forEach(function (s) {\n      viewport.addRange(s.getArgumentRange());\n    });\n\n    that._argumentAxes.forEach(function (axis) {\n      axis.updateCanvas(that._canvas);\n      axis.setBusinessRange(viewport, that._axesReinitialized);\n    });\n\n    that.callBase();\n  },\n  _isLegendInside: function _isLegendInside() {\n    return this._legend && \"inside\" === this._legend.getPosition();\n  },\n  _isRotated: function _isRotated() {\n    return this._themeManager.getOptions(\"rotated\");\n  },\n  _getLayoutTargets: function _getLayoutTargets() {\n    return this.panes;\n  },\n  _applyClipRects: function _applyClipRects(panesBorderOptions) {\n    var that = this;\n\n    var canvasClipRectID = that._getCanvasClipRectID();\n\n    var i;\n\n    that._drawPanesBorders(panesBorderOptions);\n\n    that._createClipRectsForPanes();\n\n    for (i = 0; i < that._argumentAxes.length; i++) {\n      that._argumentAxes[i].applyClipRects(that._getElementsClipRectID(that._argumentAxes[i].pane), canvasClipRectID);\n    }\n\n    for (i = 0; i < that._valueAxes.length; i++) {\n      that._valueAxes[i].applyClipRects(that._getElementsClipRectID(that._valueAxes[i].pane), canvasClipRectID);\n    }\n\n    that._fillPanesBackground();\n  },\n  _updateLegendPosition: function _updateLegendPosition(drawOptions, legendHasInsidePosition) {\n    var that = this;\n\n    if (drawOptions.drawLegend && that._legend && legendHasInsidePosition) {\n      var panes = that.panes;\n      var newCanvas = (0, _extend2.extend)({}, panes[0].canvas);\n      var layoutManager = new _layout_manager2.default.LayoutManager();\n      newCanvas.right = panes[panes.length - 1].canvas.right;\n      newCanvas.bottom = panes[panes.length - 1].canvas.bottom;\n      layoutManager.setOptions({\n        width: 0,\n        height: 0\n      });\n      layoutManager.layoutElements([that._legend], newCanvas, _common.noop, [{\n        canvas: newCanvas\n      }], void 0);\n    }\n  },\n  _allowLegendInsidePosition: function _allowLegendInsidePosition() {\n    return true;\n  },\n  _applyExtraSettings: function _applyExtraSettings(series) {\n    var that = this;\n\n    var paneIndex = that._getPaneIndex(series.pane);\n\n    var panesClipRects = that._panesClipRects;\n    var wideClipRect = panesClipRects.wide[paneIndex];\n    series.setClippingParams(panesClipRects.base[paneIndex].id, wideClipRect && wideClipRect.id, that._getPaneBorderVisibility(paneIndex));\n  },\n  _updatePanesCanvases: function _updatePanesCanvases(drawOptions) {\n    if (!drawOptions.recreateCanvas) {\n      return;\n    }\n\n    (0, _utils.updatePanesCanvases)(this.panes, this._canvas, this._isRotated());\n  },\n  _normalizePanesHeight: function _normalizePanesHeight() {\n    (0, _utils.normalizePanesHeight)(this.panes);\n  },\n  _renderScaleBreaks: function _renderScaleBreaks() {\n    this._valueAxes.concat(this._argumentAxes).forEach(function (axis) {\n      axis.drawScaleBreaks();\n    });\n  },\n  _applyPointMarkersAutoHiding: function _applyPointMarkersAutoHiding() {\n    var that = this;\n\n    if (!that._themeManager.getOptions(\"autoHidePointMarkers\")) {\n      that.series.forEach(function (s) {\n        return s.autoHidePointMarkers = false;\n      });\n      return;\n    }\n\n    that.panes.forEach(function (pane) {\n      var series = that.series.filter(function (s) {\n        return s.pane === pane.name && s.usePointsToDefineAutoHiding();\n      });\n      var argAxis = that.getArgumentAxis();\n      var argVisualRange = argAxis.visualRange();\n      var argTranslator = argAxis.getTranslator();\n      var argAxisType = argAxis.getOptions().type;\n\n      var argViewPortFilter = _range_data_calculator2.default.getViewPortFilter(argVisualRange || {});\n\n      var points = [];\n      var overloadedSeries = {};\n      series.forEach(function (s) {\n        var valAxis = s.getValueAxis();\n        var valVisualRange = valAxis.visualRange();\n        var valTranslator = valAxis.getTranslator();\n        var seriesIndex = that.series.indexOf(s);\n\n        var valViewPortFilter = _range_data_calculator2.default.getViewPortFilter(valVisualRange || {});\n\n        overloadedSeries[seriesIndex] = {};\n        series.forEach(function (sr) {\n          return overloadedSeries[seriesIndex][that.series.indexOf(sr)] = 0;\n        });\n        var seriesPoints = [];\n        s.getPoints().filter(function (p) {\n          return p.getOptions().visible && argViewPortFilter(p.argument) && (valViewPortFilter(p.getMinValue(true)) || valViewPortFilter(p.getMaxValue(true)));\n        }).forEach(function (p) {\n          var tp = {\n            seriesIndex: seriesIndex,\n            argument: p.argument,\n            value: p.getMaxValue(true),\n            size: p.bubbleSize || p.getOptions().size\n          };\n\n          if (p.getMinValue(true) !== p.getMaxValue(true)) {\n            var mp = (0, _extend2.extend)({}, tp);\n            mp.value = p.getMinValue(true);\n            mp.x = argTranslator.to(mp.argument, 1);\n            mp.y = valTranslator.to(mp.value, 1);\n            seriesPoints.push(mp);\n          }\n\n          tp.x = argTranslator.to(tp.argument, 1);\n          tp.y = valTranslator.to(tp.value, 1);\n          seriesPoints.push(tp);\n        });\n        overloadedSeries[seriesIndex].pointsCount = seriesPoints.length;\n        overloadedSeries[seriesIndex].total = 0;\n        overloadedSeries[seriesIndex].continuousSeries = 0;\n        points = points.concat(seriesPoints);\n      });\n      var sortingCallback = \"discrete\" === argAxisType ? function (p1, p2) {\n        return argVisualRange.categories.indexOf(p1.argument) - argVisualRange.categories.indexOf(p2.argument);\n      } : function (p1, p2) {\n        return p1.argument - p2.argument;\n      };\n      points.sort(sortingCallback);\n      var isContinuousSeries = false;\n\n      for (var i = 0; i < points.length - 1; i++) {\n        var curPoint = points[i];\n        var size = curPoint.size;\n\n        if ((0, _type.isDefined)(curPoint.x) && (0, _type.isDefined)(curPoint.y)) {\n          for (var j = i + 1; j < points.length; j++) {\n            var nextPoint = points[j];\n            var next_x = (0, _type.isDefined)(nextPoint) ? nextPoint.x : null;\n            var next_y = (0, _type.isDefined)(nextPoint) ? nextPoint.y : null;\n\n            if (!(0, _type.isDefined)(next_x) || Math.abs(curPoint.x - next_x) >= size) {\n              isContinuousSeries &= j !== i + 1;\n              break;\n            } else {\n              var distance = (0, _type.isDefined)(next_x) && (0, _type.isDefined)(next_y) && Math.sqrt(Math.pow(curPoint.x - next_x, 2) + Math.pow(curPoint.y - next_y, 2));\n\n              if (distance && distance < size) {\n                overloadedSeries[curPoint.seriesIndex][nextPoint.seriesIndex]++;\n                overloadedSeries[curPoint.seriesIndex].total++;\n\n                if (!isContinuousSeries) {\n                  overloadedSeries[curPoint.seriesIndex].continuousSeries++;\n                  isContinuousSeries = true;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      series.forEach(function (s) {\n        var seriesIndex = that.series.indexOf(s);\n        s.autoHidePointMarkers = false;\n        var tickCount = argAxis.getTicksValues().majorTicksValues.length;\n\n        if (s.autoHidePointMarkersEnabled() && (\"discrete\" === argAxisType || overloadedSeries[seriesIndex].pointsCount > tickCount)) {\n          for (var index in overloadedSeries[seriesIndex]) {\n            var _i = parseInt(index);\n\n            if (isNaN(_i) || overloadedSeries[seriesIndex].total / overloadedSeries[seriesIndex].continuousSeries < 3) {\n              continue;\n            }\n\n            if (_i === seriesIndex) {\n              if (2 * overloadedSeries[_i][_i] >= overloadedSeries[_i].pointsCount) {\n                s.autoHidePointMarkers = true;\n                break;\n              }\n            } else {\n              if (overloadedSeries[seriesIndex].total >= overloadedSeries[seriesIndex].pointsCount) {\n                s.autoHidePointMarkers = true;\n                break;\n              }\n            }\n          }\n        }\n      });\n    });\n  },\n  _renderAxes: function _renderAxes(drawOptions, panesBorderOptions) {\n    function calculateTitlesWidth(axes) {\n      return axes.map(function (axis) {\n        if (!axis.getTitle) {\n          return 0;\n        }\n\n        var title = axis.getTitle();\n        return title ? title.bBox.width : 0;\n      });\n    }\n\n    var that = this;\n\n    var rotated = that._isRotated();\n\n    var synchronizeMultiAxes = that._themeManager.getOptions(\"synchronizeMultiAxes\");\n\n    var extendedArgAxes = (that._scrollBar ? [that._scrollBar] : []).concat(that._argumentAxes);\n    var verticalAxes = rotated ? extendedArgAxes : that._valueAxes;\n    var horizontalAxes = rotated ? that._valueAxes : extendedArgAxes;\n    var allAxes = verticalAxes.concat(horizontalAxes);\n\n    that._normalizePanesHeight();\n\n    that._updatePanesCanvases(drawOptions);\n\n    var panesCanvases = that.panes.reduce(function (canvases, pane) {\n      canvases[pane.name] = (0, _extend2.extend)({}, pane.canvas);\n      return canvases;\n    }, {});\n    var paneSizes = that.panes.reduce(function (sizes, pane) {\n      sizes[pane.name] = {\n        height: pane.height,\n        unit: pane.unit\n      };\n      return sizes;\n    }, {});\n    var cleanPanesCanvases = (0, _extend2.extend)(true, {}, panesCanvases);\n\n    if (!drawOptions.adjustAxes) {\n      drawAxesWithTicks(verticalAxes, !rotated && synchronizeMultiAxes, panesCanvases, panesBorderOptions);\n      drawAxesWithTicks(horizontalAxes, rotated && synchronizeMultiAxes, panesCanvases, panesBorderOptions);\n      performActionOnAxes(allAxes, \"prepareAnimation\");\n\n      that._renderScaleBreaks();\n\n      return false;\n    }\n\n    if (that._scrollBar) {\n      that._scrollBar.setPane(that.panes);\n    }\n\n    var vAxesMargins = {\n      panes: {}\n    };\n    var hAxesMargins = getHorizontalAxesMargins(horizontalAxes, function (axis) {\n      return axis.estimateMargins(panesCanvases[axis.pane]);\n    });\n    panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, vAxesMargins, hAxesMargins);\n    drawAxesWithTicks(verticalAxes, !rotated && synchronizeMultiAxes, panesCanvases, panesBorderOptions);\n    vAxesMargins = getVerticalAxesMargins(verticalAxes);\n    panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, vAxesMargins, hAxesMargins);\n    drawAxesWithTicks(horizontalAxes, rotated && synchronizeMultiAxes, panesCanvases, panesBorderOptions);\n    hAxesMargins = getHorizontalAxesMargins(horizontalAxes, getAxisMargins);\n    panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, vAxesMargins, hAxesMargins);\n    var oldTitlesWidth = calculateTitlesWidth(verticalAxes);\n    performActionOnAxes(allAxes, \"updateSize\", panesCanvases, axisAnimationEnabled(drawOptions, that._getVisibleSeries()));\n    horizontalAxes.forEach(shiftAxis(\"top\", \"bottom\"));\n    verticalAxes.forEach(shiftAxis(\"left\", \"right\"));\n\n    that._renderScaleBreaks();\n\n    that.panes.forEach(function (pane) {\n      (0, _extend2.extend)(pane.canvas, panesCanvases[pane.name]);\n    });\n\n    that._valueAxes.forEach(function (axis) {\n      axis.setInitRange();\n    });\n\n    verticalAxes.forEach(function (axis, i) {\n      if (axis.hasWrap && axis.hasWrap()) {\n        var title = axis.getTitle();\n        var newTitleWidth = title ? title.bBox.width : 0;\n        var offset = newTitleWidth - oldTitlesWidth[i];\n\n        if (\"right\" === axis.getOptions().position) {\n          vAxesMargins.right += offset;\n        } else {\n          vAxesMargins.left += offset;\n          that.panes.forEach(function (_ref) {\n            var name = _ref.name;\n            return vAxesMargins.panes[name].left += offset;\n          });\n        }\n\n        panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, vAxesMargins, hAxesMargins);\n        performActionOnAxes(allAxes, \"updateSize\", panesCanvases, false, false);\n        oldTitlesWidth = calculateTitlesWidth(verticalAxes);\n      }\n    });\n    return cleanPanesCanvases;\n  },\n  checkForMoreSpaceForPanesCanvas: function checkForMoreSpaceForPanesCanvas() {\n    var that = this;\n\n    var rotated = that._isRotated();\n\n    var panesAreCustomSized = that.panes.filter(function (p) {\n      return p.unit;\n    }).length === that.panes.length;\n    var needSpace = false;\n\n    if (panesAreCustomSized) {\n      var needHorizontalSpace = 0;\n      var needVerticalSpace = 0;\n\n      if (rotated) {\n        var argAxisRightMargin = that.getArgumentAxis().getMargins().right;\n        var rightPanesIndent = Math.min.apply(Math, that.panes.map(function (p) {\n          return p.canvas.right;\n        }));\n        needHorizontalSpace = that._canvas.right + argAxisRightMargin - rightPanesIndent;\n      } else {\n        var argAxisBottomMargin = that.getArgumentAxis().getMargins().bottom;\n        var bottomPanesIndent = Math.min.apply(Math, that.panes.map(function (p) {\n          return p.canvas.bottom;\n        }));\n        needVerticalSpace = that._canvas.bottom + argAxisBottomMargin - bottomPanesIndent;\n      }\n\n      needSpace = needHorizontalSpace > 0 || needVerticalSpace > 0 ? {\n        width: needHorizontalSpace,\n        height: needVerticalSpace\n      } : false;\n\n      if (0 !== needVerticalSpace) {\n        var realSize = that.getSize();\n        var customSize = that.option(\"size\");\n        var container = that._$element[0];\n        var containerHasStyledHeight = !!container.style.height || (0, _utils.checkElementHasPropertyFromStyleSheet)(container, \"height\");\n\n        if (!rotated && !(customSize && customSize.height) && !containerHasStyledHeight) {\n          that._forceResize(realSize.width, realSize.height + needVerticalSpace);\n\n          needSpace = false;\n        }\n      }\n    } else {\n      needSpace = that.layoutManager.needMoreSpaceForPanesCanvas(that._getLayoutTargets(), rotated, function (pane) {\n        return {\n          width: rotated && !!pane.unit,\n          height: !rotated && !!pane.unit\n        };\n      });\n    }\n\n    return needSpace;\n  },\n  _forceResize: function _forceResize(width, height) {\n    this._renderer.resize(width, height);\n\n    this._updateSize();\n\n    this._setContentSize();\n\n    this._preserveOriginalCanvas();\n\n    this._updateCanvasClipRect(this._canvas);\n  },\n  _shrinkAxes: function _shrinkAxes(sizeShortage, panesCanvases) {\n    if (!sizeShortage || !panesCanvases) {\n      return;\n    }\n\n    this._renderer.stopAllAnimations(true);\n\n    var that = this;\n\n    var rotated = that._isRotated();\n\n    var extendedArgAxes = (that._scrollBar ? [that._scrollBar] : []).concat(that._argumentAxes);\n    var verticalAxes = rotated ? extendedArgAxes : that._valueAxes;\n    var horizontalAxes = rotated ? that._valueAxes : extendedArgAxes;\n    var allAxes = verticalAxes.concat(horizontalAxes);\n\n    if (sizeShortage.width || sizeShortage.height) {\n      checkUsedSpace(sizeShortage, \"height\", horizontalAxes, getHorizontalAxesMargins);\n      checkUsedSpace(sizeShortage, \"width\", verticalAxes, getVerticalAxesMargins);\n      performActionOnAxes(allAxes, \"updateSize\", panesCanvases);\n      var paneSizes = that.panes.reduce(function (sizes, pane) {\n        sizes[pane.name] = {\n          height: pane.height,\n          unit: pane.unit\n        };\n        return sizes;\n      }, {});\n      panesCanvases = shrinkCanvases(rotated, panesCanvases, paneSizes, getVerticalAxesMargins(verticalAxes), getHorizontalAxesMargins(horizontalAxes, getAxisMargins));\n      performActionOnAxes(allAxes, \"updateSize\", panesCanvases);\n      horizontalAxes.forEach(shiftAxis(\"top\", \"bottom\"));\n      verticalAxes.forEach(shiftAxis(\"left\", \"right\"));\n      that.panes.forEach(function (pane) {\n        return (0, _extend2.extend)(pane.canvas, panesCanvases[pane.name]);\n      });\n    }\n  },\n  _getPanesParameters: function _getPanesParameters() {\n    var that = this;\n    var panes = that.panes;\n    var i;\n    var params = [];\n\n    for (i = 0; i < panes.length; i++) {\n      if (that._getPaneBorderVisibility(i)) {\n        params.push({\n          coords: panes[i].borderCoords,\n          clipRect: that._panesClipRects.fixed[i]\n        });\n      }\n    }\n\n    return params;\n  },\n  _createCrosshairCursor: function _createCrosshairCursor() {\n    var that = this;\n    var options = that._themeManager.getOptions(\"crosshair\") || {};\n    var argumentAxis = that.getArgumentAxis();\n    var axes = !that._isRotated() ? [[argumentAxis], that._valueAxes] : [that._valueAxes, [argumentAxis]];\n    var parameters = {\n      canvas: that._getCommonCanvas(),\n      panes: that._getPanesParameters(),\n      axes: axes\n    };\n\n    if (!options || !options.enabled) {\n      return;\n    }\n\n    if (!that._crosshair) {\n      that._crosshair = new _crosshair2.default.Crosshair(that._renderer, options, parameters, that._crosshairCursorGroup);\n    } else {\n      that._crosshair.update(options, parameters);\n    }\n\n    that._crosshair.render();\n  },\n  _getCommonCanvas: function _getCommonCanvas() {\n    var i;\n    var canvas;\n    var commonCanvas;\n    var panes = this.panes;\n\n    for (i = 0; i < panes.length; i++) {\n      canvas = panes[i].canvas;\n\n      if (!commonCanvas) {\n        commonCanvas = (0, _extend2.extend)({}, canvas);\n      } else {\n        commonCanvas.right = canvas.right;\n        commonCanvas.bottom = canvas.bottom;\n      }\n    }\n\n    return commonCanvas;\n  },\n  _createPanesBackground: function _createPanesBackground() {\n    var that = this;\n\n    var defaultBackgroundColor = that._themeManager.getOptions(\"commonPaneSettings\").backgroundColor;\n\n    var backgroundColor;\n    var renderer = that._renderer;\n    var rect;\n    var i;\n    var rects = [];\n\n    that._panesBackgroundGroup.clear();\n\n    for (i = 0; i < that.panes.length; i++) {\n      backgroundColor = that.panes[i].backgroundColor || defaultBackgroundColor;\n\n      if (!backgroundColor || \"none\" === backgroundColor) {\n        rects.push(null);\n        continue;\n      }\n\n      rect = renderer.rect(0, 0, 0, 0).attr({\n        fill: backgroundColor,\n        \"stroke-width\": 0\n      }).append(that._panesBackgroundGroup);\n      rects.push(rect);\n    }\n\n    that.panesBackground = rects;\n  },\n  _fillPanesBackground: function _fillPanesBackground() {\n    var that = this;\n    var bc;\n    (0, _iterator.each)(that.panes, function (i, pane) {\n      bc = pane.borderCoords;\n\n      if (null !== that.panesBackground[i]) {\n        that.panesBackground[i].attr({\n          x: bc.left,\n          y: bc.top,\n          width: bc.width,\n          height: bc.height\n        });\n      }\n    });\n  },\n  _calcPaneBorderCoords: function _calcPaneBorderCoords(pane) {\n    var canvas = pane.canvas;\n    var bc = pane.borderCoords = pane.borderCoords || {};\n    bc.left = canvas.left;\n    bc.top = canvas.top;\n    bc.right = canvas.width - canvas.right;\n    bc.bottom = canvas.height - canvas.bottom;\n    bc.width = Math.max(bc.right - bc.left, 0);\n    bc.height = Math.max(bc.bottom - bc.top, 0);\n  },\n  _drawPanesBorders: function _drawPanesBorders(panesBorderOptions) {\n    var that = this;\n\n    var rotated = that._isRotated();\n\n    that._panesBorderGroup.linkRemove().clear();\n\n    (0, _iterator.each)(that.panes, function (i, pane) {\n      var bc;\n      var borderOptions = panesBorderOptions[pane.name];\n      var segmentRectParams;\n      var attr = {\n        fill: \"none\",\n        stroke: borderOptions.color,\n        \"stroke-opacity\": borderOptions.opacity,\n        \"stroke-width\": borderOptions.width,\n        dashStyle: borderOptions.dashStyle,\n        \"stroke-linecap\": \"square\"\n      };\n\n      that._calcPaneBorderCoords(pane, rotated);\n\n      if (!borderOptions.visible) {\n        return;\n      }\n\n      bc = pane.borderCoords;\n      segmentRectParams = prepareSegmentRectPoints(bc.left, bc.top, bc.width, bc.height, borderOptions);\n\n      that._renderer.path(segmentRectParams.points, segmentRectParams.pathType).attr(attr).append(that._panesBorderGroup);\n    });\n\n    that._panesBorderGroup.linkAppend();\n  },\n  _createClipRect: function _createClipRect(clipArray, index, left, top, width, height) {\n    var that = this;\n    var clipRect = clipArray[index];\n\n    if (!clipRect) {\n      clipRect = that._renderer.clipRect(left, top, width, height);\n      clipArray[index] = clipRect;\n    } else {\n      clipRect.attr({\n        x: left,\n        y: top,\n        width: width,\n        height: height\n      });\n    }\n  },\n  _createClipRectsForPanes: function _createClipRectsForPanes() {\n    var that = this;\n    var canvas = that._canvas;\n    (0, _iterator.each)(that.panes, function (i, pane) {\n      var needWideClipRect = false;\n      var bc = pane.borderCoords;\n      var left = bc.left;\n      var top = bc.top;\n      var width = bc.width;\n      var height = bc.height;\n      var panesClipRects = that._panesClipRects;\n\n      that._createClipRect(panesClipRects.fixed, i, left, top, width, height);\n\n      that._createClipRect(panesClipRects.base, i, left, top, width, height);\n\n      (0, _iterator.each)(that.series, function (_, series) {\n        if (series.pane === pane.name && (series.isFinancialSeries() || series.areErrorBarsVisible())) {\n          needWideClipRect = true;\n        }\n      });\n\n      if (needWideClipRect) {\n        if (that._isRotated()) {\n          top = 0;\n          height = canvas.height;\n        } else {\n          left = 0;\n          width = canvas.width;\n        }\n\n        that._createClipRect(panesClipRects.wide, i, left, top, width, height);\n      } else {\n        panesClipRects.wide[i] = null;\n      }\n    });\n  },\n  _getPaneBorderVisibility: function _getPaneBorderVisibility(paneIndex) {\n    var commonPaneBorderVisible = this._themeManager.getOptions(\"commonPaneSettings\").border.visible;\n\n    var pane = this.panes[paneIndex] || {};\n    var paneBorder = pane.border || {};\n    return \"visible\" in paneBorder ? paneBorder.visible : commonPaneBorderVisible;\n  },\n  _getCanvasForPane: function _getCanvasForPane(paneName) {\n    var panes = this.panes;\n    var panesNumber = panes.length;\n    var i;\n\n    for (i = 0; i < panesNumber; i++) {\n      if (panes[i].name === paneName) {\n        return panes[i].canvas;\n      }\n    }\n  },\n  _getTrackerSettings: function _getTrackerSettings() {\n    var that = this;\n    var themeManager = that._themeManager;\n    return (0, _extend2.extend)(this.callBase(), {\n      chart: that,\n      rotated: that._isRotated(),\n      crosshair: that._getCrosshairOptions().enabled ? that._crosshair : null,\n      stickyHovering: themeManager.getOptions(\"stickyHovering\")\n    });\n  },\n  _resolveLabelOverlappingStack: function _resolveLabelOverlappingStack() {\n    var that = this;\n\n    var isRotated = that._isRotated();\n\n    var shiftDirection = isRotated ? function (box, length) {\n      return {\n        x: box.x - length,\n        y: box.y\n      };\n    } : function (box, length) {\n      return {\n        x: box.x,\n        y: box.y - length\n      };\n    };\n    (0, _iterator.each)(that._getStackPoints(), function (_, stacks) {\n      (0, _iterator.each)(stacks, function (_, points) {\n        _base_chart.overlapping.resolveLabelOverlappingInOneDirection(points, that._getCommonCanvas(), isRotated, shiftDirection, function (a, b) {\n          var coordPosition = isRotated ? 1 : 0;\n          var figureCenter1 = a.labels[0].getFigureCenter()[coordPosition];\n          var figureCenter12 = b.labels[0].getFigureCenter()[coordPosition];\n\n          if (figureCenter1 - figureCenter12 === 0) {\n            return (a.value() - b.value()) * (a.labels[0].getPoint().series.getValueAxis().getTranslator().isInverted() ? -1 : 1);\n          }\n\n          return 0;\n        });\n      });\n    });\n  },\n  _getStackPoints: function _getStackPoints() {\n    var stackPoints = {};\n\n    var visibleSeries = this._getVisibleSeries();\n\n    (0, _iterator.each)(visibleSeries, function (_, singleSeries) {\n      var points = singleSeries.getPoints();\n      var stackName = singleSeries.getStackName() || null;\n      (0, _iterator.each)(points, function (_, point) {\n        var argument = point.argument;\n\n        if (!stackPoints[argument]) {\n          stackPoints[argument] = {};\n        }\n\n        if (!stackPoints[argument][stackName]) {\n          stackPoints[argument][stackName] = [];\n        }\n\n        stackPoints[argument][stackName].push(point);\n      });\n    });\n    return stackPoints;\n  },\n  _getCrosshairOptions: function _getCrosshairOptions() {\n    return this._getOption(\"crosshair\");\n  },\n  zoomArgument: function zoomArgument(min, max) {\n    var that = this;\n\n    if (!that._initialized || !(0, _type.isDefined)(min) && !(0, _type.isDefined)(max)) {\n      return;\n    }\n\n    that.getArgumentAxis().visualRange([min, max]);\n  },\n  resetVisualRange: function resetVisualRange() {\n    var that = this;\n    var axes = that._argumentAxes;\n    var nonVirtualArgumentAxis = that.getArgumentAxis();\n    axes.forEach(function (axis) {\n      axis.resetVisualRange(nonVirtualArgumentAxis !== axis);\n\n      that._applyCustomVisualRangeOption(axis);\n    });\n    that.callBase();\n  },\n  getVisibleArgumentBounds: function getVisibleArgumentBounds() {\n    var translator = this._argumentAxes[0].getTranslator();\n\n    var range = translator.getBusinessRange();\n    var isDiscrete = \"discrete\" === range.axisType;\n    var categories = range.categories;\n    return {\n      minVisible: isDiscrete ? range.minVisible || categories[0] : range.minVisible,\n      maxVisible: isDiscrete ? range.maxVisible || categories[categories.length - 1] : range.maxVisible\n    };\n  },\n  _change_FULL_RENDER: function _change_FULL_RENDER() {\n    this.callBase();\n\n    if (this._changes.has(VISUAL_RANGE)) {\n      this._raiseZoomEndHandlers();\n    }\n  },\n  _getAxesForScaling: function _getAxesForScaling() {\n    return [this.getArgumentAxis()].concat(this._valueAxes);\n  },\n  _applyVisualRangeByVirtualAxes: function _applyVisualRangeByVirtualAxes(axis, range) {\n    var that = this;\n\n    if (axis.isArgumentAxis) {\n      if (axis !== that.getArgumentAxis()) {\n        return true;\n      }\n\n      that._argumentAxes.filter(function (a) {\n        return a !== axis;\n      }).forEach(function (a) {\n        return a.visualRange(range, {\n          start: true,\n          end: true\n        });\n      });\n    }\n\n    return false;\n  },\n  _raiseZoomEndHandlers: function _raiseZoomEndHandlers() {\n    this._argumentAxes.forEach(function (axis) {\n      return axis.handleZoomEnd();\n    });\n\n    this.callBase();\n  },\n  _setOptionsByReference: function _setOptionsByReference() {\n    this.callBase();\n    (0, _extend2.extend)(this._optionsByReference, {\n      \"argumentAxis.visualRange\": true\n    });\n  },\n  option: function option() {\n    var option = this.callBase.apply(this, arguments);\n\n    if (\"array\" === (0, _type.type)(this._options.valueAxis)) {\n      for (var i = 0; i < this._options.valueAxis.length; i++) {\n        var optionPath = \"valueAxis[\".concat(i, \"].visualRange\");\n        this._optionsByReference[optionPath] = true;\n      }\n    }\n\n    return option;\n  },\n  _notifyVisualRange: function _notifyVisualRange() {\n    var that = this;\n    var argAxis = that._argumentAxes[0];\n    var argumentVisualRange = (0, _utils.convertVisualRangeObject)(argAxis.visualRange(), !_isArray(that.option(\"argumentAxis.visualRange\")));\n\n    if (!argAxis.skipEventRising || !(0, _utils.rangesAreEqual)(argumentVisualRange, that.option(\"argumentAxis.visualRange\"))) {\n      that.option(\"argumentAxis.visualRange\", argumentVisualRange);\n    } else {\n      argAxis.skipEventRising = null;\n    }\n\n    that.callBase();\n  }\n});\n\ndxChart.addPlugin(require(\"./chart_components/shutter_zoom\"));\ndxChart.addPlugin(require(\"./chart_components/zoom_and_pan\"));\ndxChart.addPlugin(require(\"./core/annotations\").plugins.core);\ndxChart.addPlugin(require(\"./core/annotations\").plugins.chart);\n(0, _component_registrator2.default)(\"dxChart\", dxChart);\nmodule.exports = dxChart;\nmodule.exports.default = module.exports;","map":null,"metadata":{},"sourceType":"script"}