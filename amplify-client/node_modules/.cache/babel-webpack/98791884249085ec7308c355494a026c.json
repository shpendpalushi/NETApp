{"ast":null,"code":"/**\r\n * DevExtreme (ui/pivot_grid/xmla_store/xmla_store.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _renderer = require(\"../../../core/renderer\");\n\nvar _renderer2 = _interopRequireDefault(_renderer);\n\nvar _window = require(\"../../../core/utils/window\");\n\nvar _class = require(\"../../../core/class\");\n\nvar _class2 = _interopRequireDefault(_class);\n\nvar _string = require(\"../../../core/utils/string\");\n\nvar _errors = require(\"../../../data/errors\");\n\nvar _common = require(\"../../../core/utils/common\");\n\nvar _extend = require(\"../../../core/utils/extend\");\n\nvar _type = require(\"../../../core/utils/type\");\n\nvar _iterator = require(\"../../../core/utils/iterator\");\n\nvar _array = require(\"../../../core/utils/array\");\n\nvar _uiPivot_grid = require(\"../ui.pivot_grid.utils\");\n\nvar _deferred = require(\"../../../core/utils/deferred\");\n\nvar _language_codes = require(\"../../../localization/language_codes\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || \"[object Arguments]\" === Object.prototype.toString.call(iter)) {\n    return Array.from(iter);\n  }\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nvar window = (0, _window.getWindow)();\nexports.XmlaStore = _class2.default.inherit(function () {\n  var discover = '<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\"><Body><Discover xmlns=\"urn:schemas-microsoft-com:xml-analysis\"><RequestType>{2}</RequestType><Restrictions><RestrictionList><CATALOG_NAME>{0}</CATALOG_NAME><CUBE_NAME>{1}</CUBE_NAME></RestrictionList></Restrictions><Properties><PropertyList><Catalog>{0}</Catalog>{3}</PropertyList></Properties></Discover></Body></Envelope>';\n  var execute = '<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\"><Body><Execute xmlns=\"urn:schemas-microsoft-com:xml-analysis\"><Command><Statement>{0}</Statement></Command><Properties><PropertyList><Catalog>{1}</Catalog><ShowHiddenCubes>True</ShowHiddenCubes><SspropInitAppName>Microsoft SQL Server Management Studio</SspropInitAppName><Timeout>3600</Timeout>{2}</PropertyList></Properties></Execute></Body></Envelope>';\n  var mdx = \"SELECT {2} FROM {0} {1} CELL PROPERTIES VALUE, FORMAT_STRING, LANGUAGE, BACK_COLOR, FORE_COLOR, FONT_FLAGS\";\n  var mdxFilterSelect = \"(SELECT {0} FROM {1})\";\n  var mdxSubset = \"Subset({0}, {1}, {2})\";\n  var mdxOrder = \"Order({0}, {1}, {2})\";\n  var mdxWith = \"{0} {1} as {2}\";\n  var mdxSlice = \"WHERE ({0})\";\n  var mdxNonEmpty = \"NonEmpty({0}, {1})\";\n  var mdxAxis = \"{0} DIMENSION PROPERTIES PARENT_UNIQUE_NAME,HIERARCHY_UNIQUE_NAME, MEMBER_VALUE ON {1}\";\n  var mdxCrossJoin = \"CrossJoin({0})\";\n  var mdxSet = \"{{0}}\";\n  var MEASURE_DEMENSION_KEY = \"DX_MEASURES\";\n  var MD_DIMTYPE_MEASURE = \"2\";\n\n  function execXMLA(requestOptions, data) {\n    var deferred = new _deferred.Deferred();\n    var beforeSend = requestOptions.beforeSend;\n    var ajaxSettings = {\n      url: requestOptions.url,\n      dataType: \"text\",\n      data: data,\n      headers: {\n        \"Content-Type\": \"text/xml\"\n      },\n      xhrFields: {},\n      method: \"POST\"\n    };\n\n    if ((0, _type.isFunction)(beforeSend)) {\n      beforeSend(ajaxSettings);\n    }\n\n    (0, _uiPivot_grid.sendRequest)(ajaxSettings).fail(function () {\n      deferred.reject(arguments);\n    }).done(function (text) {\n      var parser = new window.DOMParser();\n      var xml;\n\n      try {\n        try {\n          xml = parser.parseFromString(text, \"text/xml\");\n        } catch (e) {\n          xml = void 0;\n        }\n\n        if (!xml || xml.getElementsByTagName(\"parsererror\").length || 0 === xml.childNodes.length) {\n          throw new _errors.errors.Error(\"E4023\", text);\n        }\n      } catch (e) {\n        deferred.reject({\n          statusText: e.message,\n          stack: e.stack,\n          responseText: text\n        });\n      }\n\n      deferred.resolve(xml);\n    });\n    return deferred;\n  }\n\n  function getLocaleIdProperty() {\n    var languageId = (0, _language_codes.getLanguageId)();\n\n    if (void 0 !== languageId) {\n      return (0, _string.format)(\"<LocaleIdentifier>{0}</LocaleIdentifier>\", languageId);\n    }\n\n    return \"\";\n  }\n\n  function mdxDescendants(level, levelMember, nextLevel) {\n    var memberExpression = levelMember ? levelMember : level;\n    return \"Descendants({\" + memberExpression + \"}, \" + nextLevel + \", SELF_AND_BEFORE)\";\n  }\n\n  function getAllMember(dimension) {\n    return (dimension.hierarchyName || dimension.dataField) + \".[All]\";\n  }\n\n  function getAllMembers(field) {\n    var result = field.dataField + \".allMembers\";\n    var searchValue = field.searchValue;\n\n    if (searchValue) {\n      searchValue = searchValue.replace(/'/g, \"''\");\n      result = \"Filter(\" + result + \", instr(\" + field.dataField + \".currentmember.member_caption,'\" + searchValue + \"') > 0)\";\n    }\n\n    return result;\n  }\n\n  function crossJoinElements(elements) {\n    var elementsString = elements.join(\",\");\n    return elements.length > 1 ? (0, _string.format)(mdxCrossJoin, elementsString) : elementsString;\n  }\n\n  function union(elements) {\n    var elementsString = elements.join(\",\");\n    return elements.length > 1 ? \"Union(\" + elementsString + \")\" : elementsString;\n  }\n\n  function generateCrossJoin(path, expandLevel, expandAllCount, expandIndex, slicePath, options, axisName, take) {\n    var crossJoinArgs = [];\n    var dimensions = options[axisName];\n    var dataField;\n    var allMember;\n    var fields = [];\n    var hierarchyName;\n    var arg;\n    var prevDimension;\n    var prevHierarchyName;\n    var isLastDimensionInGroup;\n    var isFirstDimensionInGroup;\n    var expandAllIndex;\n    var field;\n    var member;\n    var i;\n\n    for (i = expandIndex; i <= expandLevel; i++) {\n      field = dimensions[i];\n      dataField = field.dataField;\n      prevHierarchyName = dimensions[i - 1] && dimensions[i - 1].hierarchyName;\n      hierarchyName = field.hierarchyName;\n      isLastDimensionInGroup = !hierarchyName || !dimensions[i + 1] || dimensions[i + 1].hierarchyName !== hierarchyName;\n      expandAllIndex = path.length + expandAllCount + expandIndex;\n      arg = null;\n      fields.push(field);\n\n      if (i < path.length) {\n        if (isLastDimensionInGroup) {\n          arg = \"(\" + dataField + \".\" + preparePathValue(path[i], dataField) + \")\";\n        }\n      } else {\n        if (i <= expandAllIndex) {\n          if (0 === i && 0 === expandAllCount) {\n            allMember = getAllMember(dimensions[expandIndex]);\n\n            if (!hierarchyName) {\n              arg = getAllMembers(dimensions[expandIndex]);\n            } else {\n              arg = allMember + \",\" + dimensions[expandIndex].dataField;\n            }\n          } else {\n            if (hierarchyName) {\n              member = preparePathValue(slicePath[slicePath.length - 1]);\n\n              if (isLastDimensionInGroup || i === expandAllIndex) {\n                if (prevHierarchyName === hierarchyName) {\n                  if (slicePath.length) {\n                    prevDimension = dimensions[slicePath.length - 1];\n                  }\n\n                  if (!prevDimension || prevDimension.hierarchyName !== hierarchyName) {\n                    prevDimension = dimensions[i - 1];\n                    member = \"\";\n                  }\n\n                  arg = mdxDescendants(prevDimension.dataField, member, dataField);\n                } else {\n                  arg = getAllMembers(field);\n                }\n              }\n            } else {\n              arg = getAllMembers(field);\n            }\n          }\n        } else {\n          isFirstDimensionInGroup = !hierarchyName || prevHierarchyName !== hierarchyName;\n\n          if (isFirstDimensionInGroup) {\n            arg = \"(\" + getAllMember(field) + \")\";\n          }\n        }\n      }\n\n      if (arg) {\n        arg = (0, _string.format)(mdxSet, arg);\n\n        if (take) {\n          var sortBy = (field.hierarchyName || field.dataField) + (\"displayText\" === field.sortBy ? \".MEMBER_CAPTION\" : \".MEMBER_VALUE\");\n          arg = (0, _string.format)(mdxOrder, arg, sortBy, \"desc\" === field.sortOrder ? \"DESC\" : \"ASC\");\n        }\n\n        crossJoinArgs.push(arg);\n      }\n    }\n\n    return crossJoinElements(crossJoinArgs);\n  }\n\n  function fillCrossJoins(crossJoins, path, expandLevel, expandIndex, slicePath, options, axisName, cellsString, take, totalsOnly) {\n    var expandAllCount = -1;\n    var dimensions = options[axisName];\n    var dimensionIndex;\n\n    do {\n      expandAllCount++;\n      dimensionIndex = path.length + expandAllCount + expandIndex;\n      var crossJoin = generateCrossJoin(path, expandLevel, expandAllCount, expandIndex, slicePath, options, axisName, take);\n\n      if (!take && !totalsOnly) {\n        crossJoin = (0, _string.format)(mdxNonEmpty, crossJoin, cellsString);\n      }\n\n      crossJoins.push(crossJoin);\n    } while (dimensions[dimensionIndex] && dimensions[dimensionIndex + 1] && dimensions[dimensionIndex].expanded);\n  }\n\n  function declare(expression, withArray, name, type) {\n    name = name || \"[DX_Set_\" + withArray.length + \"]\";\n    type = type || \"set\";\n    withArray.push((0, _string.format)(mdxWith, type, name, expression));\n    return name;\n  }\n\n  function generateAxisMdx(options, axisName, cells, withArray, parseOptions) {\n    var dimensions = options[axisName];\n    var crossJoins = [];\n    var path = [];\n    var expandedPaths = [];\n    var expandIndex = 0;\n    var expandLevel = 0;\n    var result = [];\n    var cellsString = (0, _string.format)(mdxSet, cells.join(\",\"));\n\n    if (dimensions && dimensions.length) {\n      if (options.headerName === axisName) {\n        path = options.path;\n        expandIndex = path.length;\n      } else {\n        if (options.headerName && options.oppositePath) {\n          path = options.oppositePath;\n          expandIndex = path.length;\n        } else {\n          expandedPaths = (\"columns\" === axisName ? options.columnExpandedPaths : options.rowExpandedPaths) || expandedPaths;\n        }\n      }\n\n      expandLevel = (0, _uiPivot_grid.getExpandedLevel)(options, axisName);\n      fillCrossJoins(crossJoins, [], expandLevel, expandIndex, path, options, axisName, cellsString, \"rows\" === axisName ? options.rowTake : options.columnTake, options.totalsOnly);\n      (0, _iterator.each)(expandedPaths, function (_, expandedPath) {\n        fillCrossJoins(crossJoins, expandedPath, expandLevel, expandIndex, expandedPath, options, axisName, cellsString);\n      });\n\n      for (var i = expandLevel; i >= path.length; i--) {\n        if (dimensions[i].hierarchyName) {\n          parseOptions.visibleLevels[dimensions[i].hierarchyName] = parseOptions.visibleLevels[dimensions[i].hierarchyName] || [];\n          parseOptions.visibleLevels[dimensions[i].hierarchyName].push(dimensions[i].dataField);\n        }\n      }\n    }\n\n    if (crossJoins.length) {\n      var expression = union(crossJoins);\n\n      if (\"rows\" === axisName && options.rowTake) {\n        expression = (0, _string.format)(mdxSubset, expression, options.rowSkip > 0 ? options.rowSkip + 1 : 0, options.rowSkip > 0 ? options.rowTake : options.rowTake + 1);\n      }\n\n      if (\"columns\" === axisName && options.columnTake) {\n        expression = (0, _string.format)(mdxSubset, expression, options.columnSkip > 0 ? options.columnSkip + 1 : 0, options.columnSkip > 0 ? options.columnTake : options.columnTake + 1);\n      }\n\n      var axisSet = \"[DX_\".concat(axisName, \"]\");\n      result.push(declare(expression, withArray, axisSet));\n\n      if (options.totalsOnly) {\n        result.push(declare(\"COUNT(\".concat(axisSet, \")\"), withArray, \"[DX_\".concat(axisName, \"_count]\"), \"member\"));\n      }\n    }\n\n    if (\"columns\" === axisName && cells.length && !options.skipValues) {\n      result.push(cellsString);\n    }\n\n    return (0, _string.format)(mdxAxis, crossJoinElements(result), axisName);\n  }\n\n  function generateAxisFieldsFilter(fields) {\n    var filterMembers = [];\n    (0, _iterator.each)(fields, function (_, field) {\n      var dataField = field.dataField;\n      var filterExpression = [];\n      var filterValues = field.filterValues || [];\n      var filterStringExpression;\n\n      if (field.hierarchyName && (0, _type.isNumeric)(field.groupIndex)) {\n        return;\n      }\n\n      (0, _iterator.each)(filterValues, function (_, filterValue) {\n        var filterMdx = dataField + \".\" + preparePathValue(Array.isArray(filterValue) ? filterValue[filterValue.length - 1] : filterValue, dataField);\n\n        if (\"exclude\" === field.filterType) {\n          filterExpression.push(filterMdx + \".parent\");\n          filterMdx = \"Descendants(\" + filterMdx + \")\";\n        }\n\n        filterExpression.push(filterMdx);\n      });\n\n      if (filterValues.length) {\n        filterStringExpression = (0, _string.format)(mdxSet, filterExpression.join(\",\"));\n\n        if (\"exclude\" === field.filterType) {\n          filterStringExpression = \"Except(\" + getAllMembers(field) + \",\" + filterStringExpression + \")\";\n        }\n\n        filterMembers.push(filterStringExpression);\n      }\n    });\n    return filterMembers.length ? crossJoinElements(filterMembers) : \"\";\n  }\n\n  function generateFrom(columnsFilter, rowsFilter, filter, cubeName) {\n    var from = \"[\" + cubeName + \"]\";\n    (0, _iterator.each)([columnsFilter, rowsFilter, filter], function (_, filter) {\n      if (filter) {\n        from = (0, _string.format)(mdxFilterSelect, filter + \"on 0\", from);\n      }\n    });\n    return from;\n  }\n\n  function generateMdxCore(axisStrings, withArray, columns, rows, filters, slice, cubeName) {\n    var options = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : {};\n    var mdxString = \"\";\n    var withString = (withArray.length ? \"with \" + withArray.join(\" \") : \"\") + \" \";\n\n    if (axisStrings.length) {\n      var select;\n\n      if (options.totalsOnly) {\n        var countMembers = [];\n\n        if (rows.length) {\n          countMembers.push(\"[DX_rows_count]\");\n        }\n\n        if (columns.length) {\n          countMembers.push(\"[DX_columns_count]\");\n        }\n\n        select = \"{\".concat(countMembers.join(\",\"), \"} on columns\");\n      } else {\n        select = axisStrings.join(\",\");\n      }\n\n      mdxString = withString + (0, _string.format)(mdx, generateFrom(generateAxisFieldsFilter(columns), generateAxisFieldsFilter(rows), generateAxisFieldsFilter(filters || []), cubeName), slice.length ? (0, _string.format)(mdxSlice, slice.join(\",\")) : \"\", select);\n    }\n\n    return mdxString;\n  }\n\n  function prepareDataFields(withArray, valueFields) {\n    return (0, _iterator.map)(valueFields, function (cell) {\n      if ((0, _type.isString)(cell.expression)) {\n        declare(cell.expression, withArray, cell.dataField, \"member\");\n      }\n\n      return cell.dataField;\n    });\n  }\n\n  function addSlices(slices, options, headerName, path) {\n    (0, _iterator.each)(path, function (index, value) {\n      var dimension = options[headerName][index];\n\n      if (!dimension.hierarchyName || dimension.hierarchyName !== options[headerName][index + 1].hierarchyName) {\n        slices.push(dimension.dataField + \".\" + preparePathValue(value, dimension.dataField));\n      }\n    });\n  }\n\n  function generateMDX(options, cubeName, parseOptions) {\n    var columns = options.columns || [];\n    var rows = options.rows || [];\n    var values = options.values && options.values.length ? options.values : [{\n      dataField: \"[Measures]\"\n    }];\n    var slice = [];\n    var withArray = [];\n    var axisStrings = [];\n    var dataFields = prepareDataFields(withArray, values);\n    parseOptions.measureCount = options.skipValues ? 1 : values.length;\n    parseOptions.visibleLevels = {};\n\n    if (options.headerName && options.path) {\n      addSlices(slice, options, options.headerName, options.path);\n    }\n\n    if (options.headerName && options.oppositePath) {\n      addSlices(slice, options, \"rows\" === options.headerName ? \"columns\" : \"rows\", options.oppositePath);\n    }\n\n    if (columns.length || dataFields.length) {\n      axisStrings.push(generateAxisMdx(options, \"columns\", dataFields, withArray, parseOptions));\n    }\n\n    if (rows.length) {\n      axisStrings.push(generateAxisMdx(options, \"rows\", dataFields, withArray, parseOptions));\n    }\n\n    return generateMdxCore(axisStrings, withArray, columns, rows, options.filters, slice, cubeName, options);\n  }\n\n  function createDrillDownAxisSlice(slice, fields, path) {\n    (0, _iterator.each)(path, function (index, value) {\n      var field = fields[index];\n\n      if (field.hierarchyName && (fields[index + 1] || {}).hierarchyName === field.hierarchyName) {\n        return;\n      }\n\n      slice.push(field.dataField + \".\" + preparePathValue(value, field.dataField));\n    });\n  }\n\n  function generateDrillDownMDX(options, cubeName, params) {\n    var columns = options.columns || [];\n    var rows = options.rows || [];\n    var values = options.values && options.values.length ? options.values : [{\n      dataField: \"[Measures]\"\n    }];\n    var slice = [];\n    var withArray = [];\n    var axisStrings = [];\n    var dataFields = prepareDataFields(withArray, values);\n    var maxRowCount = params.maxRowCount;\n    var customColumns = params.customColumns || [];\n    var customColumnsString = customColumns.length > 0 ? \" return \" + customColumns.join(\",\") : \"\";\n    createDrillDownAxisSlice(slice, columns, params.columnPath || []);\n    createDrillDownAxisSlice(slice, rows, params.rowPath || []);\n\n    if (columns.length || columns.length || dataFields.length) {\n      axisStrings.push([(dataFields[params.dataIndex] || dataFields[0]) + \" on 0\"]);\n    }\n\n    var coreMDX = generateMdxCore(axisStrings, withArray, columns, rows, options.filters, slice, cubeName);\n    return coreMDX ? \"drillthrough\" + (maxRowCount > 0 ? \" maxrows \" + maxRowCount : \"\") + coreMDX + customColumnsString : coreMDX;\n  }\n\n  function getNumber(str) {\n    return parseInt(str, 10);\n  }\n\n  function parseValue(valueText) {\n    return (0, _type.isNumeric)(valueText) ? parseFloat(valueText) : valueText;\n  }\n\n  function getFirstChild(node, tagName) {\n    return (node.getElementsByTagName(tagName) || [])[0];\n  }\n\n  function getFirstChildText(node, childTagName) {\n    return getNodeText(getFirstChild(node, childTagName));\n  }\n\n  function parseAxes(xml, skipValues) {\n    var axes = [];\n    (0, _iterator.each)(xml.getElementsByTagName(\"Axis\"), function (_, axisElement) {\n      var name = axisElement.getAttribute(\"name\");\n      var axis = [];\n      var index = 0;\n\n      if (0 === name.indexOf(\"Axis\") && (0, _type.isNumeric)(getNumber(name.substr(4)))) {\n        axes.push(axis);\n        (0, _iterator.each)(axisElement.getElementsByTagName(\"Tuple\"), function (_, tupleElement) {\n          var tupleMembers = tupleElement.childNodes;\n          var tuple;\n          var levelSum = 0;\n          var members = [];\n          var level;\n          var membersCount = skipValues ? tupleMembers.length : tupleMembers.length - 1;\n          var isAxisWithMeasure = 1 === axes.length;\n          var i;\n\n          if (isAxisWithMeasure) {\n            membersCount--;\n          }\n\n          axis.push(members);\n\n          for (i = membersCount; i >= 0; i--) {\n            tuple = tupleMembers[i];\n            level = getNumber(getFirstChildText(tuple, \"LNum\"));\n            members[i] = {\n              caption: getFirstChildText(tuple, \"Caption\"),\n              value: parseValue(getFirstChildText(tuple, \"MEMBER_VALUE\")),\n              level: level,\n              index: index++,\n              hasValue: !levelSum && (!!level || 0 === i),\n              name: getFirstChildText(tuple, \"UName\"),\n              hierarchyName: tupleMembers[i].getAttribute(\"Hierarchy\"),\n              parentName: getFirstChildText(tuple, \"PARENT_UNIQUE_NAME\"),\n              levelName: getFirstChildText(tuple, \"LName\")\n            };\n            levelSum += level;\n          }\n        });\n      }\n    });\n\n    while (axes.length < 2) {\n      axes.push([[{\n        level: 0\n      }]]);\n    }\n\n    return axes;\n  }\n\n  function getNodeText(node) {\n    return node && node && (node.textContent || node.text || node.innerHTML) || \"\";\n  }\n\n  function parseCells(xml, axes, measureCount) {\n    var cells = [];\n    var cell = [];\n    var index = 0;\n    var measureIndex;\n    var cellsOriginal = [];\n    var cellElements = xml.getElementsByTagName(\"Cell\");\n    var errorDictionary = {};\n    var row;\n\n    for (var i = 0; i < cellElements.length; i++) {\n      var xmlCell = cellElements[i];\n      var valueElement = xmlCell.getElementsByTagName(\"Value\")[0];\n      var errorElements = valueElement && valueElement.getElementsByTagName(\"Error\") || [];\n      var text = 0 === errorElements.length ? getNodeText(valueElement) : \"#N/A\";\n      var value = parseFloat(text);\n\n      var _isNumeric = text - value + 1 > 0;\n\n      var cellOrdinal = getNumber(xmlCell.getAttribute(\"CellOrdinal\"));\n\n      if (errorElements.length) {\n        errorDictionary[getNodeText(errorElements[0].getElementsByTagName(\"ErrorCode\")[0])] = getNodeText(errorElements[0].getElementsByTagName(\"Description\")[0]);\n      }\n\n      cellsOriginal[cellOrdinal] = {\n        value: _isNumeric ? value : text || null\n      };\n    }\n\n    (0, _iterator.each)(axes[1], function () {\n      row = [];\n      cells.push(row);\n      (0, _iterator.each)(axes[0], function () {\n        measureIndex = index % measureCount;\n\n        if (0 === measureIndex) {\n          cell = [];\n          row.push(cell);\n        }\n\n        cell.push(cellsOriginal[index] ? cellsOriginal[index].value : null);\n        index++;\n      });\n    });\n    Object.keys(errorDictionary).forEach(function (key) {\n      _errors.errors.log(\"W4002\", errorDictionary[key]);\n    });\n    return cells;\n  }\n\n  function preparePathValue(pathValue, dataField) {\n    if (pathValue) {\n      pathValue = (0, _type.isString)(pathValue) && pathValue.indexOf(\"&\") !== -1 ? pathValue : \"[\" + pathValue + \"]\";\n\n      if (dataField && 0 === pathValue.indexOf(dataField + \".\")) {\n        pathValue = pathValue.slice(dataField.length + 1, pathValue.length);\n      }\n    }\n\n    return pathValue;\n  }\n\n  function getItem(hash, name, member, index) {\n    var item = hash[name];\n\n    if (!item) {\n      item = {};\n      hash[name] = item;\n    }\n\n    if (!(0, _type.isDefined)(item.value) && member) {\n      item.text = member.caption;\n      item.value = member.value;\n      item.key = name ? name : \"\";\n      item.levelName = member.levelName;\n      item.hierarchyName = member.hierarchyName;\n      item.parentName = member.parentName;\n      item.index = index;\n      item.level = member.level;\n    }\n\n    return item;\n  }\n\n  function getVisibleChildren(item, visibleLevels) {\n    var result = [];\n    var children = item.children && (item.children.length ? item.children : Object.keys(item.children.grandTotalHash || {}).reduce(function (result, name) {\n      return result.concat(item.children.grandTotalHash[name].children);\n    }, []));\n    var firstChild = children && children[0];\n\n    if (firstChild && (visibleLevels[firstChild.hierarchyName] && (0, _array.inArray)(firstChild.levelName, visibleLevels[firstChild.hierarchyName]) !== -1 || !visibleLevels[firstChild.hierarchyName] || 0 === firstChild.level)) {\n      var newChildren = children.filter(function (child) {\n        return child.hierarchyName === firstChild.hierarchyName;\n      });\n      newChildren.grandTotalHash = children.grandTotalHash;\n      return newChildren;\n    } else {\n      if (firstChild) {\n        for (var i = 0; i < children.length; i++) {\n          if (children[i].hierarchyName === firstChild.hierarchyName) {\n            result.push.apply(result, getVisibleChildren(children[i], visibleLevels));\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function processMember(dataIndex, member, parentItem) {\n    var children = parentItem.children = parentItem.children || [];\n    var hash = children.hash = children.hash || {};\n    var grandTotalHash = children.grandTotalHash = children.grandTotalHash || {};\n\n    if (member.parentName) {\n      parentItem = getItem(hash, member.parentName);\n      children = parentItem.children = parentItem.children || [];\n    }\n\n    var currentItem = getItem(hash, member.name, member, dataIndex);\n\n    if (member.hasValue && !currentItem.added) {\n      currentItem.index = dataIndex;\n      currentItem.added = true;\n      children.push(currentItem);\n    }\n\n    if ((!parentItem.value || !parentItem.parentName) && member.parentName) {\n      grandTotalHash[member.parentName] = parentItem;\n    } else {\n      if (grandTotalHash[parentItem.name]) {\n        delete grandTotalHash[member.parentName];\n      }\n    }\n\n    return currentItem;\n  }\n\n  function getGrandTotalIndex(parentItem, visibleLevels) {\n    var grandTotalIndex;\n\n    if (1 === parentItem.children.length && \"\" === parentItem.children[0].parentName) {\n      grandTotalIndex = parentItem.children[0].index;\n      var grandTotalHash = parentItem.children.grandTotalHash;\n      parentItem.children = parentItem.children[0].children || [];\n      parentItem.children.grandTotalHash = grandTotalHash;\n      parentItem.children = getVisibleChildren(parentItem, visibleLevels);\n    } else {\n      if (0 === parentItem.children.length) {\n        grandTotalIndex = 0;\n      }\n    }\n\n    return grandTotalIndex;\n  }\n\n  function fillDataSourceAxes(dataSourceAxis, axisTuples, measureCount, visibleLevels) {\n    var result = [];\n    (0, _iterator.each)(axisTuples, function (tupleIndex, members) {\n      var parentItem = {\n        children: result\n      };\n      var dataIndex = (0, _type.isDefined)(measureCount) ? Math.floor(tupleIndex / measureCount) : tupleIndex;\n      (0, _iterator.each)(members, function (_, member) {\n        parentItem = processMember(dataIndex, member, parentItem);\n      });\n    });\n    var parentItem = {\n      children: result\n    };\n    parentItem.children = getVisibleChildren(parentItem, visibleLevels);\n    var grandTotalIndex = getGrandTotalIndex(parentItem, visibleLevels);\n    (0, _uiPivot_grid.foreachTree)(parentItem.children, function (items) {\n      var item = items[0];\n      var children = getVisibleChildren(item, visibleLevels);\n\n      if (children.length) {\n        item.children = children;\n      } else {\n        delete item.children;\n      }\n\n      delete item.levelName;\n      delete item.hierarchyName;\n      delete item.added;\n      delete item.parentName;\n      delete item.level;\n    }, true);\n    (0, _iterator.each)(parentItem.children || [], function (_, e) {\n      dataSourceAxis.push(e);\n    });\n    return grandTotalIndex;\n  }\n\n  function checkError(xml) {\n    var faultElementNS = xml.getElementsByTagName(\"soap:Fault\");\n    var faultElement = xml.getElementsByTagName(\"Fault\");\n    var errorElement = (0, _renderer2.default)([].slice.call(faultElement.length ? faultElement : faultElementNS)).find(\"Error\");\n    var description;\n    var error;\n\n    if (errorElement.length) {\n      description = errorElement.attr(\"Description\");\n      error = new _errors.errors.Error(\"E4000\", description);\n\n      _errors.errors.log(\"E4000\", description);\n\n      return error;\n    }\n\n    return null;\n  }\n\n  function parseResult(xml, parseOptions) {\n    var dataSource = {\n      columns: [],\n      rows: []\n    };\n    var measureCount = parseOptions.measureCount;\n    var axes = parseAxes(xml, parseOptions.skipValues);\n    dataSource.grandTotalColumnIndex = fillDataSourceAxes(dataSource.columns, axes[0], measureCount, parseOptions.visibleLevels);\n    dataSource.grandTotalRowIndex = fillDataSourceAxes(dataSource.rows, axes[1], void 0, parseOptions.visibleLevels);\n    dataSource.values = parseCells(xml, axes, measureCount);\n    return dataSource;\n  }\n\n  function parseDiscoverRowSet(xml, schema, dimensions, translatedDisplayFolders) {\n    var result = [];\n    var isMeasure = \"MEASURE\" === schema;\n    var displayFolderField = isMeasure ? \"MEASUREGROUP_NAME\" : schema + \"_DISPLAY_FOLDER\";\n    (0, _iterator.each)(xml.getElementsByTagName(\"row\"), function (_, row) {\n      var hierarchyName = \"LEVEL\" === schema ? getFirstChildText(row, \"HIERARCHY_UNIQUE_NAME\") : void 0;\n      var levelNumber = getFirstChildText(row, \"LEVEL_NUMBER\");\n      var displayFolder = getFirstChildText(row, displayFolderField);\n\n      if (isMeasure) {\n        displayFolder = translatedDisplayFolders[displayFolder] || displayFolder;\n      }\n\n      if ((\"0\" !== levelNumber || \"true\" !== getFirstChildText(row, schema + \"_IS_VISIBLE\")) && getFirstChildText(row, \"DIMENSION_TYPE\") !== MD_DIMTYPE_MEASURE) {\n        var dimension = isMeasure ? MEASURE_DEMENSION_KEY : getFirstChildText(row, \"DIMENSION_UNIQUE_NAME\");\n        var dataField = getFirstChildText(row, schema + \"_UNIQUE_NAME\");\n        result.push({\n          dimension: dimensions.names[dimension] || dimension,\n          groupIndex: levelNumber ? getNumber(levelNumber) - 1 : void 0,\n          dataField: dataField,\n          caption: getFirstChildText(row, schema + \"_CAPTION\"),\n          hierarchyName: hierarchyName,\n          groupName: hierarchyName,\n          displayFolder: displayFolder,\n          isMeasure: isMeasure,\n          isDefault: !!dimensions.defaultHierarchies[dataField]\n        });\n      }\n    });\n    return result;\n  }\n\n  function parseMeasureGroupDiscoverRowSet(xml) {\n    var measureGroups = {};\n    (0, _iterator.each)(xml.getElementsByTagName(\"row\"), function (_, row) {\n      measureGroups[getFirstChildText(row, \"MEASUREGROUP_NAME\")] = getFirstChildText(row, \"MEASUREGROUP_CAPTION\");\n    });\n    return measureGroups;\n  }\n\n  function parseDimensionsDiscoverRowSet(xml) {\n    var result = {\n      names: {},\n      defaultHierarchies: {}\n    };\n    (0, _iterator.each)((0, _renderer2.default)(xml).find(\"row\"), function () {\n      var $row = (0, _renderer2.default)(this);\n      var type = $row.children(\"DIMENSION_TYPE\").text();\n      var dimensionName = type === MD_DIMTYPE_MEASURE ? MEASURE_DEMENSION_KEY : $row.children(\"DIMENSION_UNIQUE_NAME\").text();\n      result.names[dimensionName] = $row.children(\"DIMENSION_CAPTION\").text();\n      result.defaultHierarchies[$row.children(\"DEFAULT_HIERARCHY\").text()] = true;\n    });\n    return result;\n  }\n\n  function parseStringWithUnicodeSymbols(str) {\n    str = str.replace(/_x(....)_/g, function (whole, group1) {\n      return String.fromCharCode(parseInt(group1, 16));\n    });\n    var stringArray = str.match(/\\[.+?\\]/gi);\n\n    if (stringArray && stringArray.length) {\n      str = stringArray[stringArray.length - 1];\n    }\n\n    return str.replace(/\\[/gi, \"\").replace(/\\]/gi, \"\").replace(/\\$/gi, \"\").replace(/\\./gi, \" \");\n  }\n\n  function parseDrillDownRowSet(xml) {\n    var rows = xml.getElementsByTagName(\"row\");\n    var result = [];\n    var columnNames = {};\n\n    for (var i = 0; i < rows.length; i++) {\n      var children = rows[i].childNodes;\n      var item = {};\n\n      for (var j = 0; j < children.length; j++) {\n        var tagName = children[j].tagName;\n        var name = columnNames[tagName] = columnNames[tagName] || parseStringWithUnicodeSymbols(tagName);\n        item[name] = getNodeText(children[j]);\n      }\n\n      result.push(item);\n    }\n\n    return result;\n  }\n\n  function sendQuery(storeOptions, mdxString) {\n    mdxString = (0, _renderer2.default)(\"<div>\").text(mdxString).html();\n    return execXMLA(storeOptions, (0, _string.format)(execute, mdxString, storeOptions.catalog, getLocaleIdProperty()));\n  }\n\n  function processTotalCount(data, options, totalCountXml) {\n    var axes = [];\n    var columnOptions = options.columns || [];\n    var rowOptions = options.rows || [];\n\n    if (columnOptions.length) {\n      axes.push({});\n    }\n\n    if (rowOptions.length) {\n      axes.push({});\n    }\n\n    var cells = parseCells(totalCountXml, [[{}], [{}, {}]], 1);\n\n    if (!columnOptions.length && rowOptions.length) {\n      data.rowCount = Math.max(cells[0][0][0] - 1, 0);\n    }\n\n    if (!rowOptions.length && columnOptions.length) {\n      data.columnCount = Math.max(cells[0][0][0] - 1, 0);\n    }\n\n    if (rowOptions.length && columnOptions.length) {\n      data.rowCount = Math.max(cells[0][0][0] - 1, 0);\n      data.columnCount = Math.max(cells[1][0][0] - 1, 0);\n    }\n\n    if (void 0 !== data.rowCount && options.rowTake) {\n      data.rows = _toConsumableArray(Array(options.rowSkip)).concat(data.rows);\n      data.rows.length = data.rowCount;\n\n      for (var i = 0; i < data.rows.length; i++) {\n        data.rows[i] = data.rows[i] || {};\n      }\n    }\n\n    if (void 0 !== data.columnCount && options.columnTake) {\n      data.columns = _toConsumableArray(Array(options.columnSkip)).concat(data.columns);\n      data.columns.length = data.columnCount;\n\n      for (var _i = 0; _i < data.columns.length; _i++) {\n        data.columns[_i] = data.columns[_i] || {};\n      }\n    }\n  }\n\n  return {\n    ctor: function ctor(options) {\n      this._options = options;\n    },\n    getFields: function getFields() {\n      var options = this._options;\n      var catalog = options.catalog;\n      var cube = options.cube;\n      var localeIdProperty = getLocaleIdProperty();\n      var dimensionsRequest = execXMLA(options, (0, _string.format)(discover, catalog, cube, \"MDSCHEMA_DIMENSIONS\", localeIdProperty));\n      var measuresRequest = execXMLA(options, (0, _string.format)(discover, catalog, cube, \"MDSCHEMA_MEASURES\", localeIdProperty));\n      var hierarchiesRequest = execXMLA(options, (0, _string.format)(discover, catalog, cube, \"MDSCHEMA_HIERARCHIES\", localeIdProperty));\n      var levelsRequest = execXMLA(options, (0, _string.format)(discover, catalog, cube, \"MDSCHEMA_LEVELS\", localeIdProperty));\n      var result = new _deferred.Deferred();\n      (0, _deferred.when)(dimensionsRequest, measuresRequest, hierarchiesRequest, levelsRequest).then(function (dimensionsResponse, measuresResponse, hierarchiesResponse, levelsResponse) {\n        execXMLA(options, (0, _string.format)(discover, catalog, cube, \"MDSCHEMA_MEASUREGROUPS\", localeIdProperty)).done(function (measureGroupsResponse) {\n          var dimensions = parseDimensionsDiscoverRowSet(dimensionsResponse);\n          var hierarchies = parseDiscoverRowSet(hierarchiesResponse, \"HIERARCHY\", dimensions);\n          var levels = parseDiscoverRowSet(levelsResponse, \"LEVEL\", dimensions);\n          var measureGroups = parseMeasureGroupDiscoverRowSet(measureGroupsResponse);\n          var fields = parseDiscoverRowSet(measuresResponse, \"MEASURE\", dimensions, measureGroups).concat(hierarchies);\n          var levelsByHierarchy = {};\n          (0, _iterator.each)(levels, function (_, level) {\n            levelsByHierarchy[level.hierarchyName] = levelsByHierarchy[level.hierarchyName] || [];\n            levelsByHierarchy[level.hierarchyName].push(level);\n          });\n          (0, _iterator.each)(hierarchies, function (_, hierarchy) {\n            if (levelsByHierarchy[hierarchy.dataField] && levelsByHierarchy[hierarchy.dataField].length > 1) {\n              hierarchy.groupName = hierarchy.hierarchyName = hierarchy.dataField;\n              fields.push.apply(fields, levelsByHierarchy[hierarchy.hierarchyName]);\n            }\n          });\n          result.resolve(fields);\n        }).fail(result.reject);\n      }).fail(result.reject);\n      return result;\n    },\n    load: function load(options) {\n      var result = new _deferred.Deferred();\n      var storeOptions = this._options;\n      var parseOptions = {\n        skipValues: options.skipValues\n      };\n      var mdxString = generateMDX(options, storeOptions.cube, parseOptions);\n      var rowCountMdx;\n\n      if (options.rowSkip || options.rowTake || options.columnTake || options.columnSkip) {\n        rowCountMdx = generateMDX((0, _extend.extend)({}, options, {\n          totalsOnly: true,\n          rowSkip: null,\n          rowTake: null,\n          columnSkip: null,\n          columnTake: null\n        }), storeOptions.cube, {});\n      }\n\n      var load = function load() {\n        if (mdxString) {\n          (0, _deferred.when)(sendQuery(storeOptions, mdxString), rowCountMdx && sendQuery(storeOptions, rowCountMdx)).done(function (executeXml, rowCountXml) {\n            var error = checkError(executeXml) || rowCountXml && checkError(rowCountXml);\n\n            if (!error) {\n              var response = parseResult(executeXml, parseOptions);\n\n              if (rowCountXml) {\n                processTotalCount(response, options, rowCountXml);\n              }\n\n              result.resolve(response);\n            } else {\n              result.reject(error);\n            }\n          }).fail(result.reject);\n        } else {\n          result.resolve({\n            columns: [],\n            rows: [],\n            values: [],\n            grandTotalColumnIndex: 0,\n            grandTotalRowIndex: 0\n          });\n        }\n      };\n\n      if (options.delay) {\n        setTimeout(load, options.delay);\n      } else {\n        load();\n      }\n\n      return result;\n    },\n    supportPaging: function supportPaging() {\n      return true;\n    },\n    getDrillDownItems: function getDrillDownItems(options, params) {\n      var result = new _deferred.Deferred();\n      var storeOptions = this._options;\n      var mdxString = generateDrillDownMDX(options, storeOptions.cube, params);\n\n      if (mdxString) {\n        (0, _deferred.when)(sendQuery(storeOptions, mdxString)).done(function (executeXml) {\n          var error = checkError(executeXml);\n\n          if (!error) {\n            result.resolve(parseDrillDownRowSet(executeXml));\n          } else {\n            result.reject(error);\n          }\n        }).fail(result.reject);\n      } else {\n        result.resolve([]);\n      }\n\n      return result;\n    },\n    key: _common.noop,\n    filter: _common.noop\n  };\n}()).include(_uiPivot_grid.storeDrillDownMixin);","map":null,"metadata":{},"sourceType":"script"}