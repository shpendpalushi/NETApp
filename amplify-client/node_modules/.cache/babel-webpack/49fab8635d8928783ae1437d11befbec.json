{"ast":null,"code":"/**\r\n * DevExtreme (viz/series/pie_series.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar noop = require(\"../../core/utils/common\").noop;\n\nvar each = require(\"../../core/utils/iterator\").each;\n\nvar scatterSeries = require(\"./scatter_series\");\n\nvar vizUtils = require(\"../core/utils\");\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar chartScatterSeries = scatterSeries.chart;\n\nvar barSeries = require(\"./bar_series\").chart.bar;\n\nvar _extend = extend;\nvar _each = each;\nvar _noop = noop;\nvar _map = vizUtils.map;\nvar _isFinite = isFinite;\nvar _max = Math.max;\nvar ANIMATION_DURATION = .7;\nvar INSIDE = \"inside\";\nexports.pie = _extend({}, barSeries, {\n  _setGroupsSettings: function _setGroupsSettings() {\n    chartScatterSeries._setGroupsSettings.apply(this, arguments);\n\n    this._labelsGroup.attr({\n      \"pointer-events\": null\n    });\n  },\n  _createErrorBarGroup: _noop,\n  _drawPoint: function _drawPoint(options) {\n    var point = options.point;\n    var legendCallback = this._legendCallback;\n\n    chartScatterSeries._drawPoint.call(this, options);\n\n    !point.isVisible() && point.setInvisibility();\n    point.isSelected() && legendCallback();\n  },\n  _getOldPoint: function _getOldPoint(data, oldPointsByArgument, index) {\n    var point = (this._points || [])[index];\n\n    if (point) {\n      oldPointsByArgument[point.argument.valueOf()] = oldPointsByArgument[point.argument.valueOf()].filter(function (p) {\n        return p !== point;\n      });\n    }\n\n    return point;\n  },\n  adjustLabels: function adjustLabels(moveLabelsFromCenter) {\n    return (this._points || []).reduce(function (r, p) {\n      if (p._label.isVisible()) {\n        p.setLabelTrackerData();\n        r = p.applyWordWrap(moveLabelsFromCenter) || r;\n        p.updateLabelCoord(moveLabelsFromCenter);\n        return r;\n      }\n    }, false);\n  },\n  _applyElementsClipRect: _noop,\n  getColor: _noop,\n  areErrorBarsVisible: _noop,\n  drawLabelsWOPoints: function drawLabelsWOPoints() {\n    var that = this;\n\n    if (that._options.label.position === INSIDE) {\n      return false;\n    }\n\n    that._labelsGroup.append(that._extGroups.labelsGroup);\n\n    (that._points || []).forEach(function (point) {\n      point.drawLabel();\n    });\n    return true;\n  },\n  getPointsCount: function getPointsCount() {\n    var _this = this;\n\n    return this._data.filter(function (d) {\n      return _this._checkData(d);\n    }).length;\n  },\n  setMaxPointsCount: function setMaxPointsCount(count) {\n    this._pointsCount = count;\n  },\n  _getCreatingPointOptions: function _getCreatingPointOptions(data, dataIndex) {\n    return this._getPointOptions(data, dataIndex);\n  },\n  _updateOptions: function _updateOptions(options) {\n    this.labelSpace = 0;\n    this.innerRadius = \"pie\" === this.type ? 0 : options.innerRadius;\n  },\n  _checkData: function _checkData(data, skippedFields) {\n    var base = barSeries._checkData.call(this, data, skippedFields, {\n      value: this.getValueFields()[0]\n    });\n\n    return this._options.paintNullPoints ? base : base && null !== data.value;\n  },\n  _createGroups: chartScatterSeries._createGroups,\n  _setMarkerGroupSettings: function _setMarkerGroupSettings() {\n    this._markersGroup.attr({\n      \"class\": \"dxc-markers\"\n    });\n  },\n  _getMainColor: function _getMainColor(data, point) {\n    var pointsByArg = this.getPointsByArg(data.argument);\n    var argumentIndex = point ? pointsByArg.indexOf(point) : pointsByArg.length;\n    return this._options.mainSeriesColor(data.argument, argumentIndex, this._pointsCount);\n  },\n  _getPointOptions: function _getPointOptions(data) {\n    return this._parsePointOptions(this._preparePointOptions(), this._options.label, data);\n  },\n  _getRangeData: function _getRangeData() {\n    return this._rangeData;\n  },\n  _createPointStyles: function _createPointStyles(pointOptions, data, point) {\n    var that = this;\n\n    var mainColor = pointOptions.color || that._getMainColor(data, point);\n\n    return {\n      normal: that._parsePointStyle(pointOptions, mainColor, mainColor),\n      hover: that._parsePointStyle(pointOptions.hoverStyle, mainColor, mainColor),\n      selection: that._parsePointStyle(pointOptions.selectionStyle, mainColor, mainColor),\n      legendStyles: {\n        normal: that._createLegendState(pointOptions, mainColor),\n        hover: that._createLegendState(pointOptions.hoverStyle, mainColor),\n        selection: that._createLegendState(pointOptions.selectionStyle, mainColor)\n      }\n    };\n  },\n  _getArrangeMinShownValue: function _getArrangeMinShownValue(points, total) {\n    var minSegmentSize = this._options.minSegmentSize;\n    var totalMinSegmentSize = 0;\n    var totalNotMinValues = 0;\n    total = total || points.length;\n\n    _each(points, function (_, point) {\n      if (point.isVisible()) {\n        if (point.normalInitialValue < minSegmentSize * total / 360) {\n          totalMinSegmentSize += minSegmentSize;\n        } else {\n          totalNotMinValues += point.normalInitialValue;\n        }\n      }\n    });\n\n    return totalMinSegmentSize < 360 ? minSegmentSize * totalNotMinValues / (360 - totalMinSegmentSize) : 0;\n  },\n  _applyArrangeCorrection: function _applyArrangeCorrection(points, minShownValue, total) {\n    var options = this._options;\n    var isClockWise = \"anticlockwise\" !== options.segmentsDirection;\n    var shiftedAngle = _isFinite(options.startAngle) ? vizUtils.normalizeAngle(options.startAngle) : 0;\n    var minSegmentSize = options.minSegmentSize;\n    var percent;\n    var correction = 0;\n    var zeroTotalCorrection = 0;\n\n    if (0 === total) {\n      total = points.filter(function (el) {\n        return el.isVisible();\n      }).length;\n      zeroTotalCorrection = 1;\n    }\n\n    _each(isClockWise ? points : points.concat([]).reverse(), function (_, point) {\n      var val = point.isVisible() ? zeroTotalCorrection || point.normalInitialValue : 0;\n      var updatedZeroValue;\n\n      if (minSegmentSize && point.isVisible() && val < minShownValue) {\n        updatedZeroValue = minShownValue;\n      }\n\n      percent = val / total;\n      point.correctValue(correction, percent, zeroTotalCorrection + (updatedZeroValue || 0));\n      point.shiftedAngle = shiftedAngle;\n      correction += updatedZeroValue || val;\n    });\n\n    this._rangeData = {\n      val: {\n        min: 0,\n        max: correction\n      }\n    };\n  },\n  _removePoint: function _removePoint(point) {\n    var points = this.getPointsByArg(point.argument);\n    points.splice(points.indexOf(point), 1);\n    point.dispose();\n  },\n  arrangePoints: function arrangePoints() {\n    var that = this;\n    var originalPoints = that._points || [];\n    var minSegmentSize = that._options.minSegmentSize;\n    var minShownValue;\n    var total;\n    var isAllPointsNegative = true;\n    var points;\n    var i = 0;\n    var len = originalPoints.length;\n    var maxValue;\n\n    while (i < len && isAllPointsNegative) {\n      isAllPointsNegative = originalPoints[i].value <= 0;\n      i++;\n    }\n\n    points = that._points = _map(originalPoints, function (point) {\n      if (null === point.value || !isAllPointsNegative && point.value < 0) {\n        that._removePoint(point);\n\n        return null;\n      } else {\n        return point;\n      }\n    });\n    maxValue = points.reduce(function (max, p) {\n      return _max(max, Math.abs(p.initialValue));\n    }, 0);\n    points.forEach(function (p) {\n      p.normalInitialValue = p.initialValue / (0 !== maxValue ? maxValue : 1);\n    });\n    total = points.reduce(function (total, point) {\n      return total + (point.isVisible() ? point.normalInitialValue : 0);\n    }, 0);\n\n    if (minSegmentSize) {\n      minShownValue = this._getArrangeMinShownValue(points, total);\n    }\n\n    that._applyArrangeCorrection(points, minShownValue, total);\n  },\n  correctPosition: function correctPosition(correction, canvas) {\n    _each(this._points, function (_, point) {\n      point.correctPosition(correction);\n    });\n\n    this.setVisibleArea(canvas);\n  },\n  correctRadius: function correctRadius(correction) {\n    this._points.forEach(function (point) {\n      point.correctRadius(correction);\n    });\n  },\n  correctLabelRadius: function correctLabelRadius(labelRadius) {\n    this._points.forEach(function (point) {\n      point.correctLabelRadius(labelRadius);\n    });\n  },\n  setVisibleArea: function setVisibleArea(canvas) {\n    this._visibleArea = {\n      minX: canvas.left,\n      maxX: canvas.width - canvas.right,\n      minY: canvas.top,\n      maxY: canvas.height - canvas.bottom\n    };\n  },\n  _applyVisibleArea: _noop,\n  _animate: function _animate(firstDrawing) {\n    var that = this;\n    var points = that._points;\n    var pointsCount = points && points.length;\n\n    var completeFunc = function completeFunc() {\n      that._animateComplete();\n    };\n\n    var animatePoint;\n\n    if (firstDrawing) {\n      animatePoint = function animatePoint(p, i) {\n        p.animate(i === pointsCount - 1 ? completeFunc : void 0, ANIMATION_DURATION, (1 - ANIMATION_DURATION) * i / (pointsCount - 1));\n      };\n    } else {\n      animatePoint = function animatePoint(p, i) {\n        p.animate(i === pointsCount - 1 ? completeFunc : void 0);\n      };\n    }\n\n    points.forEach(animatePoint);\n  },\n  getVisiblePoints: function getVisiblePoints() {\n    return _map(this._points, function (p) {\n      return p.isVisible() ? p : null;\n    });\n  },\n  getPointsByKeys: function getPointsByKeys(arg, argumentIndex) {\n    var pointsByArg = this.getPointsByArg(arg);\n    return pointsByArg[argumentIndex] && [pointsByArg[argumentIndex]] || [];\n  }\n});\nexports.doughnut = exports.donut = exports.pie;","map":{"version":3,"sources":["C:/Users/User/Documents/Templates/Angular/black-dashboard-pro-angular-v1.1.1/black-dashboard-pro-angular-v1.1.1/node_modules/devextreme/viz/series/pie_series.js"],"names":["noop","require","each","scatterSeries","vizUtils","extend","chartScatterSeries","chart","barSeries","bar","_extend","_each","_noop","_map","map","_isFinite","isFinite","_max","Math","max","ANIMATION_DURATION","INSIDE","exports","pie","_setGroupsSettings","apply","arguments","_labelsGroup","attr","_createErrorBarGroup","_drawPoint","options","point","legendCallback","_legendCallback","call","isVisible","setInvisibility","isSelected","_getOldPoint","data","oldPointsByArgument","index","_points","argument","valueOf","filter","p","adjustLabels","moveLabelsFromCenter","reduce","r","_label","setLabelTrackerData","applyWordWrap","updateLabelCoord","_applyElementsClipRect","getColor","areErrorBarsVisible","drawLabelsWOPoints","that","_options","label","position","append","_extGroups","labelsGroup","forEach","drawLabel","getPointsCount","_this","_data","d","_checkData","length","setMaxPointsCount","count","_pointsCount","_getCreatingPointOptions","dataIndex","_getPointOptions","_updateOptions","labelSpace","innerRadius","type","skippedFields","base","value","getValueFields","paintNullPoints","_createGroups","_setMarkerGroupSettings","_markersGroup","_getMainColor","pointsByArg","getPointsByArg","argumentIndex","indexOf","mainSeriesColor","_parsePointOptions","_preparePointOptions","_getRangeData","_rangeData","_createPointStyles","pointOptions","mainColor","color","normal","_parsePointStyle","hover","hoverStyle","selection","selectionStyle","legendStyles","_createLegendState","_getArrangeMinShownValue","points","total","minSegmentSize","totalMinSegmentSize","totalNotMinValues","_","normalInitialValue","_applyArrangeCorrection","minShownValue","isClockWise","segmentsDirection","shiftedAngle","startAngle","normalizeAngle","percent","correction","zeroTotalCorrection","el","concat","reverse","val","updatedZeroValue","correctValue","min","_removePoint","splice","dispose","arrangePoints","originalPoints","isAllPointsNegative","i","len","maxValue","abs","initialValue","correctPosition","canvas","setVisibleArea","correctRadius","correctLabelRadius","labelRadius","_visibleArea","minX","left","maxX","width","right","minY","top","maxY","height","bottom","_applyVisibleArea","_animate","firstDrawing","pointsCount","completeFunc","_animateComplete","animatePoint","animate","getVisiblePoints","getPointsByKeys","arg","doughnut","donut"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (viz/series/pie_series.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nvar noop = require(\"../../core/utils/common\").noop;\r\nvar each = require(\"../../core/utils/iterator\").each;\r\nvar scatterSeries = require(\"./scatter_series\");\r\nvar vizUtils = require(\"../core/utils\");\r\nvar extend = require(\"../../core/utils/extend\").extend;\r\nvar chartScatterSeries = scatterSeries.chart;\r\nvar barSeries = require(\"./bar_series\").chart.bar;\r\nvar _extend = extend;\r\nvar _each = each;\r\nvar _noop = noop;\r\nvar _map = vizUtils.map;\r\nvar _isFinite = isFinite;\r\nvar _max = Math.max;\r\nvar ANIMATION_DURATION = .7;\r\nvar INSIDE = \"inside\";\r\nexports.pie = _extend({}, barSeries, {\r\n    _setGroupsSettings: function() {\r\n        chartScatterSeries._setGroupsSettings.apply(this, arguments);\r\n        this._labelsGroup.attr({\r\n            \"pointer-events\": null\r\n        })\r\n    },\r\n    _createErrorBarGroup: _noop,\r\n    _drawPoint: function(options) {\r\n        var point = options.point;\r\n        var legendCallback = this._legendCallback;\r\n        chartScatterSeries._drawPoint.call(this, options);\r\n        !point.isVisible() && point.setInvisibility();\r\n        point.isSelected() && legendCallback()\r\n    },\r\n    _getOldPoint: function(data, oldPointsByArgument, index) {\r\n        var point = (this._points || [])[index];\r\n        if (point) {\r\n            oldPointsByArgument[point.argument.valueOf()] = oldPointsByArgument[point.argument.valueOf()].filter(function(p) {\r\n                return p !== point\r\n            })\r\n        }\r\n        return point\r\n    },\r\n    adjustLabels: function(moveLabelsFromCenter) {\r\n        return (this._points || []).reduce(function(r, p) {\r\n            if (p._label.isVisible()) {\r\n                p.setLabelTrackerData();\r\n                r = p.applyWordWrap(moveLabelsFromCenter) || r;\r\n                p.updateLabelCoord(moveLabelsFromCenter);\r\n                return r\r\n            }\r\n        }, false)\r\n    },\r\n    _applyElementsClipRect: _noop,\r\n    getColor: _noop,\r\n    areErrorBarsVisible: _noop,\r\n    drawLabelsWOPoints: function() {\r\n        var that = this;\r\n        if (that._options.label.position === INSIDE) {\r\n            return false\r\n        }\r\n        that._labelsGroup.append(that._extGroups.labelsGroup);\r\n        (that._points || []).forEach(function(point) {\r\n            point.drawLabel()\r\n        });\r\n        return true\r\n    },\r\n    getPointsCount: function() {\r\n        var _this = this;\r\n        return this._data.filter(function(d) {\r\n            return _this._checkData(d)\r\n        }).length\r\n    },\r\n    setMaxPointsCount: function(count) {\r\n        this._pointsCount = count\r\n    },\r\n    _getCreatingPointOptions: function(data, dataIndex) {\r\n        return this._getPointOptions(data, dataIndex)\r\n    },\r\n    _updateOptions: function(options) {\r\n        this.labelSpace = 0;\r\n        this.innerRadius = \"pie\" === this.type ? 0 : options.innerRadius\r\n    },\r\n    _checkData: function(data, skippedFields) {\r\n        var base = barSeries._checkData.call(this, data, skippedFields, {\r\n            value: this.getValueFields()[0]\r\n        });\r\n        return this._options.paintNullPoints ? base : base && null !== data.value\r\n    },\r\n    _createGroups: chartScatterSeries._createGroups,\r\n    _setMarkerGroupSettings: function() {\r\n        this._markersGroup.attr({\r\n            \"class\": \"dxc-markers\"\r\n        })\r\n    },\r\n    _getMainColor: function(data, point) {\r\n        var pointsByArg = this.getPointsByArg(data.argument);\r\n        var argumentIndex = point ? pointsByArg.indexOf(point) : pointsByArg.length;\r\n        return this._options.mainSeriesColor(data.argument, argumentIndex, this._pointsCount)\r\n    },\r\n    _getPointOptions: function(data) {\r\n        return this._parsePointOptions(this._preparePointOptions(), this._options.label, data)\r\n    },\r\n    _getRangeData: function() {\r\n        return this._rangeData\r\n    },\r\n    _createPointStyles: function(pointOptions, data, point) {\r\n        var that = this;\r\n        var mainColor = pointOptions.color || that._getMainColor(data, point);\r\n        return {\r\n            normal: that._parsePointStyle(pointOptions, mainColor, mainColor),\r\n            hover: that._parsePointStyle(pointOptions.hoverStyle, mainColor, mainColor),\r\n            selection: that._parsePointStyle(pointOptions.selectionStyle, mainColor, mainColor),\r\n            legendStyles: {\r\n                normal: that._createLegendState(pointOptions, mainColor),\r\n                hover: that._createLegendState(pointOptions.hoverStyle, mainColor),\r\n                selection: that._createLegendState(pointOptions.selectionStyle, mainColor)\r\n            }\r\n        }\r\n    },\r\n    _getArrangeMinShownValue: function(points, total) {\r\n        var minSegmentSize = this._options.minSegmentSize;\r\n        var totalMinSegmentSize = 0;\r\n        var totalNotMinValues = 0;\r\n        total = total || points.length;\r\n        _each(points, function(_, point) {\r\n            if (point.isVisible()) {\r\n                if (point.normalInitialValue < minSegmentSize * total / 360) {\r\n                    totalMinSegmentSize += minSegmentSize\r\n                } else {\r\n                    totalNotMinValues += point.normalInitialValue\r\n                }\r\n            }\r\n        });\r\n        return totalMinSegmentSize < 360 ? minSegmentSize * totalNotMinValues / (360 - totalMinSegmentSize) : 0\r\n    },\r\n    _applyArrangeCorrection: function(points, minShownValue, total) {\r\n        var options = this._options;\r\n        var isClockWise = \"anticlockwise\" !== options.segmentsDirection;\r\n        var shiftedAngle = _isFinite(options.startAngle) ? vizUtils.normalizeAngle(options.startAngle) : 0;\r\n        var minSegmentSize = options.minSegmentSize;\r\n        var percent;\r\n        var correction = 0;\r\n        var zeroTotalCorrection = 0;\r\n        if (0 === total) {\r\n            total = points.filter(function(el) {\r\n                return el.isVisible()\r\n            }).length;\r\n            zeroTotalCorrection = 1\r\n        }\r\n        _each(isClockWise ? points : points.concat([]).reverse(), function(_, point) {\r\n            var val = point.isVisible() ? zeroTotalCorrection || point.normalInitialValue : 0;\r\n            var updatedZeroValue;\r\n            if (minSegmentSize && point.isVisible() && val < minShownValue) {\r\n                updatedZeroValue = minShownValue\r\n            }\r\n            percent = val / total;\r\n            point.correctValue(correction, percent, zeroTotalCorrection + (updatedZeroValue || 0));\r\n            point.shiftedAngle = shiftedAngle;\r\n            correction += updatedZeroValue || val\r\n        });\r\n        this._rangeData = {\r\n            val: {\r\n                min: 0,\r\n                max: correction\r\n            }\r\n        }\r\n    },\r\n    _removePoint: function(point) {\r\n        var points = this.getPointsByArg(point.argument);\r\n        points.splice(points.indexOf(point), 1);\r\n        point.dispose()\r\n    },\r\n    arrangePoints: function() {\r\n        var that = this;\r\n        var originalPoints = that._points || [];\r\n        var minSegmentSize = that._options.minSegmentSize;\r\n        var minShownValue;\r\n        var total;\r\n        var isAllPointsNegative = true;\r\n        var points;\r\n        var i = 0;\r\n        var len = originalPoints.length;\r\n        var maxValue;\r\n        while (i < len && isAllPointsNegative) {\r\n            isAllPointsNegative = originalPoints[i].value <= 0;\r\n            i++\r\n        }\r\n        points = that._points = _map(originalPoints, function(point) {\r\n            if (null === point.value || !isAllPointsNegative && point.value < 0) {\r\n                that._removePoint(point);\r\n                return null\r\n            } else {\r\n                return point\r\n            }\r\n        });\r\n        maxValue = points.reduce(function(max, p) {\r\n            return _max(max, Math.abs(p.initialValue))\r\n        }, 0);\r\n        points.forEach(function(p) {\r\n            p.normalInitialValue = p.initialValue / (0 !== maxValue ? maxValue : 1)\r\n        });\r\n        total = points.reduce(function(total, point) {\r\n            return total + (point.isVisible() ? point.normalInitialValue : 0)\r\n        }, 0);\r\n        if (minSegmentSize) {\r\n            minShownValue = this._getArrangeMinShownValue(points, total)\r\n        }\r\n        that._applyArrangeCorrection(points, minShownValue, total)\r\n    },\r\n    correctPosition: function(correction, canvas) {\r\n        _each(this._points, function(_, point) {\r\n            point.correctPosition(correction)\r\n        });\r\n        this.setVisibleArea(canvas)\r\n    },\r\n    correctRadius: function(correction) {\r\n        this._points.forEach(function(point) {\r\n            point.correctRadius(correction)\r\n        })\r\n    },\r\n    correctLabelRadius: function(labelRadius) {\r\n        this._points.forEach(function(point) {\r\n            point.correctLabelRadius(labelRadius)\r\n        })\r\n    },\r\n    setVisibleArea: function(canvas) {\r\n        this._visibleArea = {\r\n            minX: canvas.left,\r\n            maxX: canvas.width - canvas.right,\r\n            minY: canvas.top,\r\n            maxY: canvas.height - canvas.bottom\r\n        }\r\n    },\r\n    _applyVisibleArea: _noop,\r\n    _animate: function(firstDrawing) {\r\n        var that = this;\r\n        var points = that._points;\r\n        var pointsCount = points && points.length;\r\n        var completeFunc = function() {\r\n            that._animateComplete()\r\n        };\r\n        var animatePoint;\r\n        if (firstDrawing) {\r\n            animatePoint = function(p, i) {\r\n                p.animate(i === pointsCount - 1 ? completeFunc : void 0, ANIMATION_DURATION, (1 - ANIMATION_DURATION) * i / (pointsCount - 1))\r\n            }\r\n        } else {\r\n            animatePoint = function(p, i) {\r\n                p.animate(i === pointsCount - 1 ? completeFunc : void 0)\r\n            }\r\n        }\r\n        points.forEach(animatePoint)\r\n    },\r\n    getVisiblePoints: function() {\r\n        return _map(this._points, function(p) {\r\n            return p.isVisible() ? p : null\r\n        })\r\n    },\r\n    getPointsByKeys: function(arg, argumentIndex) {\r\n        var pointsByArg = this.getPointsByArg(arg);\r\n        return pointsByArg[argumentIndex] && [pointsByArg[argumentIndex]] || []\r\n    }\r\n});\r\nexports.doughnut = exports.donut = exports.pie;\r\n"]},"metadata":{},"sourceType":"script"}