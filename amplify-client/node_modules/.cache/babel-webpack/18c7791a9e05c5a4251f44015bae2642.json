{"ast":null,"code":"/**\r\n * DevExtreme (viz/axes/base_axis.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _smart_formatter = require(\"./smart_formatter\");\n\nvar _utils = require(\"../core/utils\");\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _axes_constants = require(\"./axes_constants\");\n\nvar _axes_constants2 = _interopRequireDefault(_axes_constants);\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _array = require(\"../../core/utils/array\");\n\nvar _format_helper = require(\"../../format_helper\");\n\nvar _format_helper2 = _interopRequireDefault(_format_helper);\n\nvar _parse_utils = require(\"../components/parse_utils\");\n\nvar _parse_utils2 = _interopRequireDefault(_parse_utils);\n\nvar _tick_generator = require(\"./tick_generator\");\n\nvar _tick_generator2 = _interopRequireDefault(_tick_generator);\n\nvar _translator2d = require(\"../translators/translator2d\");\n\nvar _translator2d2 = _interopRequireDefault(_translator2d);\n\nvar _range = require(\"../translators/range\");\n\nvar _tick = require(\"./tick\");\n\nvar _math2 = require(\"../../core/utils/math\");\n\nvar _date = require(\"../../core/utils/date\");\n\nvar _common = require(\"../../core/utils/common\");\n\nvar _xy_axes = require(\"./xy_axes\");\n\nvar _xy_axes2 = _interopRequireDefault(_xy_axes);\n\nvar _polar_axes = require(\"./polar_axes\");\n\nvar _polar_axes2 = _interopRequireDefault(_polar_axes);\n\nvar _constant_line = require(\"./constant_line\");\n\nvar _constant_line2 = _interopRequireDefault(_constant_line);\n\nvar _strip = require(\"./strip\");\n\nvar _strip2 = _interopRequireDefault(_strip);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar convertTicksToValues = _axes_constants2.default.convertTicksToValues;\nvar patchFontOptions = _utils2.default.patchFontOptions;\nvar getVizRangeObject = _utils2.default.getVizRangeObject;\nvar getLog = _utils2.default.getLogExt;\nvar raiseTo = _utils2.default.raiseToExt;\nvar _math = Math;\nvar _abs = _math.abs;\nvar _max = _math.max;\nvar _min = _math.min;\nvar _isArray = Array.isArray;\nvar DEFAULT_AXIS_LABEL_SPACING = 5;\nvar MAX_GRID_BORDER_ADHENSION = 4;\nvar TOP = _axes_constants2.default.top;\nvar BOTTOM = _axes_constants2.default.bottom;\nvar LEFT = _axes_constants2.default.left;\nvar RIGHT = _axes_constants2.default.right;\nvar CENTER = _axes_constants2.default.center;\nvar KEEP = \"keep\";\nvar SHIFT = \"shift\";\nvar RESET = \"reset\";\nvar ROTATE = \"rotate\";\nvar DEFAULT_AXIS_DIVISION_FACTOR = 50;\nvar DEFAULT_MINOR_AXIS_DIVISION_FACTOR = 15;\nvar SCROLL_THRESHOLD = 5;\nvar MAX_MARGIN_VALUE = .8;\nvar dateIntervals = {\n  day: 864e5,\n  week: 6048e5\n};\n\nfunction getTickGenerator(options, incidentOccurred, skipTickGeneration, rangeIsEmpty, adjustDivisionFactor, _ref) {\n  var allowNegatives = _ref.allowNegatives,\n      linearThreshold = _ref.linearThreshold;\n  return _tick_generator2.default.tickGenerator({\n    axisType: options.type,\n    dataType: options.dataType,\n    logBase: options.logarithmBase,\n    allowNegatives: allowNegatives,\n    linearThreshold: linearThreshold,\n    axisDivisionFactor: adjustDivisionFactor(options.axisDivisionFactor || DEFAULT_AXIS_DIVISION_FACTOR),\n    minorAxisDivisionFactor: adjustDivisionFactor(options.minorAxisDivisionFactor || DEFAULT_MINOR_AXIS_DIVISION_FACTOR),\n    numberMultipliers: options.numberMultipliers,\n    calculateMinors: options.minorTick.visible || options.minorGrid.visible || options.calculateMinors,\n    allowDecimals: options.allowDecimals,\n    endOnTick: options.endOnTick,\n    incidentOccurred: incidentOccurred,\n    firstDayOfWeek: options.workWeek && options.workWeek[0],\n    skipTickGeneration: skipTickGeneration,\n    skipCalculationLimits: options.skipCalculationLimits,\n    generateExtraTick: options.generateExtraTick,\n    minTickInterval: options.minTickInterval,\n    rangeIsEmpty: rangeIsEmpty\n  });\n}\n\nfunction createMajorTick(axis, renderer, skippedCategory) {\n  var options = axis.getOptions();\n  return (0, _tick.tick)(axis, renderer, options.tick, options.grid, skippedCategory, false);\n}\n\nfunction createMinorTick(axis, renderer) {\n  var options = axis.getOptions();\n  return (0, _tick.tick)(axis, renderer, options.minorTick, options.minorGrid);\n}\n\nfunction createBoundaryTick(axis, renderer, isFirst) {\n  var options = axis.getOptions();\n  return (0, _tick.tick)(axis, renderer, (0, _extend.extend)({}, options.tick, {\n    visible: options.showCustomBoundaryTicks\n  }), options.grid, void 0, false, isFirst ? -1 : 1);\n}\n\nfunction callAction(elements, action, actionArgument1, actionArgument2) {\n  (elements || []).forEach(function (e) {\n    return e[action](actionArgument1, actionArgument2);\n  });\n}\n\nfunction initTickCoords(ticks) {\n  callAction(ticks, \"initCoords\");\n}\n\nfunction drawTickMarks(ticks, options) {\n  callAction(ticks, \"drawMark\", options);\n}\n\nfunction drawGrids(ticks, drawLine) {\n  callAction(ticks, \"drawGrid\", drawLine);\n}\n\nfunction updateTicksPosition(ticks, options, animate) {\n  callAction(ticks, \"updateTickPosition\", options, animate);\n}\n\nfunction updateGridsPosition(ticks, animate) {\n  callAction(ticks, \"updateGridPosition\", animate);\n}\n\nvar measureLabels = exports.measureLabels = function (items) {\n  items.forEach(function (item) {\n    item.labelBBox = item.label ? item.label.getBBox() : {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n  });\n};\n\nfunction cleanUpInvalidTicks(ticks) {\n  var i = ticks.length - 1;\n\n  for (i; i >= 0; i--) {\n    if (!removeInvalidTick(ticks, i)) {\n      break;\n    }\n  }\n\n  for (i = 0; i < ticks.length; i++) {\n    if (removeInvalidTick(ticks, i)) {\n      i--;\n    } else {\n      break;\n    }\n  }\n}\n\nfunction removeInvalidTick(ticks, i) {\n  if (null === ticks[i].coords.x || null === ticks[i].coords.y) {\n    ticks.splice(i, 1);\n    return true;\n  }\n\n  return false;\n}\n\nfunction validateAxisOptions(options) {\n  var labelOptions = options.label;\n  var position = options.position;\n  var defaultPosition = options.isHorizontal ? BOTTOM : LEFT;\n  var secondaryPosition = options.isHorizontal ? TOP : RIGHT;\n\n  if (position !== defaultPosition && position !== secondaryPosition) {\n    position = defaultPosition;\n  }\n\n  if (position === RIGHT && !labelOptions.userAlignment) {\n    labelOptions.alignment = LEFT;\n  }\n\n  options.position = position;\n  options.hoverMode = options.hoverMode ? options.hoverMode.toLowerCase() : \"none\";\n  labelOptions.minSpacing = (0, _type.isDefined)(labelOptions.minSpacing) ? labelOptions.minSpacing : DEFAULT_AXIS_LABEL_SPACING;\n  options.type && (options.type = options.type.toLowerCase());\n  options.argumentType && (options.argumentType = options.argumentType.toLowerCase());\n  options.valueType && (options.valueType = options.valueType.toLowerCase());\n}\n\nfunction getOptimalAngle(boxes, labelOpt) {\n  var angle = 180 * _math.asin((boxes[0].height + labelOpt.minSpacing) / (boxes[1].x - boxes[0].x)) / _math.PI;\n\n  return angle < 45 ? -45 : -90;\n}\n\nfunction updateLabels(ticks, step, func) {\n  ticks.forEach(function (tick, index) {\n    if (tick.label) {\n      if (index % step !== 0) {\n        tick.removeLabel();\n      } else {\n        if (func) {\n          func(tick, index);\n        }\n      }\n    }\n  });\n}\n\nfunction valueOf(value) {\n  return value.valueOf();\n}\n\nfunction getZoomBoundValue(optionValue, dataValue) {\n  if (void 0 === optionValue) {\n    return dataValue;\n  } else {\n    if (null === optionValue) {\n      return;\n    } else {\n      return optionValue;\n    }\n  }\n}\n\nfunction configureGenerator(options, axisDivisionFactor, viewPort, screenDelta, minTickInterval) {\n  var tickGeneratorOptions = (0, _extend.extend)({}, options, {\n    endOnTick: true,\n    axisDivisionFactor: axisDivisionFactor,\n    skipCalculationLimits: true,\n    generateExtraTick: true,\n    minTickInterval: minTickInterval\n  });\n  return function (tickInterval, skipTickGeneration, min, max, breaks) {\n    return getTickGenerator(tickGeneratorOptions, _common.noop, skipTickGeneration, viewPort.isEmpty(), function (v) {\n      return v;\n    }, viewPort)({\n      min: min,\n      max: max,\n      categories: viewPort.categories,\n      isSpacedMargin: viewPort.isSpacedMargin,\n      checkMinDataVisibility: viewPort.checkMinDataVisibility,\n      checkMaxDataVisibility: viewPort.checkMaxDataVisibility\n    }, screenDelta, tickInterval, (0, _type.isDefined)(tickInterval), void 0, void 0, void 0, breaks);\n  };\n}\n\nfunction convertVisualRangeObject(visualRange, optionValue) {\n  return _utils2.default.convertVisualRangeObject(visualRange, !_isArray(optionValue));\n}\n\nfunction getConstantLineSharpDirection(coord, axisCanvas) {\n  return Math.max(axisCanvas.start, axisCanvas.end) !== coord ? 1 : -1;\n}\n\nvar calculateCanvasMargins = exports.calculateCanvasMargins = function (bBoxes, canvas) {\n  var cLeft = canvas.left;\n  var cTop = canvas.top;\n  var cRight = canvas.width - canvas.right;\n  var cBottom = canvas.height - canvas.bottom;\n  return bBoxes.reduce(function (margins, bBox) {\n    if (!bBox || bBox.isEmpty) {\n      return margins;\n    }\n\n    return {\n      left: _max(margins.left, cLeft - bBox.x),\n      top: _max(margins.top, cTop - bBox.y),\n      right: _max(margins.right, bBox.x + bBox.width - cRight),\n      bottom: _max(margins.bottom, bBox.y + bBox.height - cBottom)\n    };\n  }, {\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0\n  });\n};\n\nvar Axis = exports.Axis = function (renderSettings) {\n  var that = this;\n  that._renderer = renderSettings.renderer;\n  that._incidentOccurred = renderSettings.incidentOccurred;\n  that._eventTrigger = renderSettings.eventTrigger;\n  that._stripsGroup = renderSettings.stripsGroup;\n  that._labelAxesGroup = renderSettings.labelAxesGroup;\n  that._constantLinesGroup = renderSettings.constantLinesGroup;\n  that._scaleBreaksGroup = renderSettings.scaleBreaksGroup;\n  that._axesContainerGroup = renderSettings.axesContainerGroup;\n  that._gridContainerGroup = renderSettings.gridGroup;\n  that._axisCssPrefix = renderSettings.widgetClass + \"-\" + (renderSettings.axisClass ? renderSettings.axisClass + \"-\" : \"\");\n\n  that._setType(renderSettings.axisType, renderSettings.drawingType);\n\n  that._createAxisGroups();\n\n  that._translator = that._createTranslator();\n  that.isArgumentAxis = renderSettings.isArgumentAxis;\n  that._viewport = {};\n  that._firstDrawing = true;\n  that._initRange = {};\n};\n\nAxis.prototype = {\n  constructor: Axis,\n  _drawAxis: function _drawAxis() {\n    var options = this._options;\n\n    if (!options.visible) {\n      return;\n    }\n\n    this._axisElement = this._createAxisElement();\n\n    this._updateAxisElementPosition();\n\n    this._axisElement.attr({\n      \"stroke-width\": options.width,\n      stroke: options.color,\n      \"stroke-opacity\": options.opacity\n    }).sharp(this._getSharpParam(true), this.getAxisSharpDirection()).append(this._axisLineGroup);\n  },\n  _createPathElement: function _createPathElement(points, attr, sharpDirection) {\n    return this.sharp(this._renderer.path(points, \"line\").attr(attr), sharpDirection);\n  },\n  sharp: function sharp(svgElement) {\n    var sharpDirection = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\n    return svgElement.sharp(this._getSharpParam(), sharpDirection);\n  },\n  getAxisSharpDirection: function getAxisSharpDirection() {\n    var position = this._options.position;\n    return position === TOP || position === LEFT ? 1 : -1;\n  },\n  getSharpDirectionByCoords: function getSharpDirectionByCoords(coords) {\n    var canvas = this._getCanvasStartEnd();\n\n    var maxCoord = Math.max(canvas.start, canvas.end);\n    return this.getRadius ? 0 : maxCoord !== coords[this._isHorizontal ? \"x\" : \"y\"] ? 1 : -1;\n  },\n  _getGridLineDrawer: function _getGridLineDrawer() {\n    var that = this;\n    return function (tick, gridStyle) {\n      var grid = that._getGridPoints(tick.coords);\n\n      if (grid.points) {\n        return that._createPathElement(grid.points, gridStyle, that.getSharpDirectionByCoords(tick.coords));\n      }\n\n      return null;\n    };\n  },\n  _getGridPoints: function _getGridPoints(coords) {\n    var that = this;\n    var isHorizontal = this._isHorizontal;\n    var tickPositionField = isHorizontal ? \"x\" : \"y\";\n    var orthogonalPositions = this._orthogonalPositions;\n    var positionFrom = orthogonalPositions.start;\n    var positionTo = orthogonalPositions.end;\n    var borderOptions = that.borderOptions;\n    var canvasStart = isHorizontal ? LEFT : TOP;\n    var canvasEnd = isHorizontal ? RIGHT : BOTTOM;\n    var axisCanvas = that.getCanvas();\n    var canvas = {\n      left: axisCanvas.left,\n      right: axisCanvas.width - axisCanvas.right,\n      top: axisCanvas.top,\n      bottom: axisCanvas.height - axisCanvas.bottom\n    };\n    var firstBorderLinePosition = borderOptions.visible && borderOptions[canvasStart] ? canvas[canvasStart] : void 0;\n    var lastBorderLinePosition = borderOptions.visible && borderOptions[canvasEnd] ? canvas[canvasEnd] : void 0;\n    var minDelta = MAX_GRID_BORDER_ADHENSION + firstBorderLinePosition;\n    var maxDelta = lastBorderLinePosition - MAX_GRID_BORDER_ADHENSION;\n\n    if (that.areCoordsOutsideAxis(coords) || void 0 === coords[tickPositionField] || coords[tickPositionField] < minDelta || coords[tickPositionField] > maxDelta) {\n      return {\n        points: null\n      };\n    }\n\n    return {\n      points: isHorizontal ? null !== coords[tickPositionField] ? [coords[tickPositionField], positionFrom, coords[tickPositionField], positionTo] : null : null !== coords[tickPositionField] ? [positionFrom, coords[tickPositionField], positionTo, coords[tickPositionField]] : null\n    };\n  },\n  _getConstantLinePos: function _getConstantLinePos(parsedValue, canvasStart, canvasEnd) {\n    var value = this._getTranslatedCoord(parsedValue);\n\n    if (!(0, _type.isDefined)(value) || value < _min(canvasStart, canvasEnd) || value > _max(canvasStart, canvasEnd)) {\n      return;\n    }\n\n    return value;\n  },\n  _getConstantLineGraphicAttributes: function _getConstantLineGraphicAttributes(value) {\n    var positionFrom = this._orthogonalPositions.start;\n    var positionTo = this._orthogonalPositions.end;\n    return {\n      points: this._isHorizontal ? [value, positionFrom, value, positionTo] : [positionFrom, value, positionTo, value]\n    };\n  },\n  _createConstantLine: function _createConstantLine(value, attr) {\n    return this._createPathElement(this._getConstantLineGraphicAttributes(value).points, attr, getConstantLineSharpDirection(value, this._getCanvasStartEnd()));\n  },\n  _drawConstantLineLabelText: function _drawConstantLineLabelText(text, x, y, _ref2, group) {\n    var font = _ref2.font,\n        cssClass = _ref2.cssClass;\n    return this._renderer.text(text, x, y).css(patchFontOptions((0, _extend.extend)({}, this._options.label.font, font))).attr({\n      align: \"center\",\n      \"class\": cssClass\n    }).append(group);\n  },\n  _drawConstantLineLabels: function _drawConstantLineLabels(parsedValue, lineLabelOptions, value, group) {\n    var that = this;\n    var text = lineLabelOptions.text;\n    var options = that._options;\n    var labelOptions = options.label;\n    var coords;\n\n    that._checkAlignmentConstantLineLabels(lineLabelOptions);\n\n    text = (0, _type.isDefined)(text) ? text : that.formatLabel(parsedValue, labelOptions);\n    coords = that._getConstantLineLabelsCoords(value, lineLabelOptions);\n    return that._drawConstantLineLabelText(text, coords.x, coords.y, lineLabelOptions, group);\n  },\n  _getStripPos: function _getStripPos(startValue, endValue, canvasStart, canvasEnd, range) {\n    var isContinuous = !!(range.minVisible || range.maxVisible);\n    var categories = (range.categories || []).reduce(function (result, cat) {\n      result.push(cat.valueOf());\n      return result;\n    }, []);\n    var start;\n    var end;\n    var swap;\n    var startCategoryIndex;\n    var endCategoryIndex;\n    var min = range.minVisible;\n\n    if (!isContinuous) {\n      if ((0, _type.isDefined)(startValue) && (0, _type.isDefined)(endValue)) {\n        var parsedStartValue = this.parser(startValue);\n        var parsedEndValue = this.parser(endValue);\n        startCategoryIndex = (0, _array.inArray)((0, _type.isDefined)(parsedStartValue) ? parsedStartValue.valueOf() : void 0, categories);\n        endCategoryIndex = (0, _array.inArray)((0, _type.isDefined)(parsedEndValue) ? parsedEndValue.valueOf() : void 0, categories);\n\n        if (startCategoryIndex === -1 || endCategoryIndex === -1) {\n          return {\n            from: 0,\n            to: 0\n          };\n        }\n\n        if (startCategoryIndex > endCategoryIndex) {\n          swap = endValue;\n          endValue = startValue;\n          startValue = swap;\n        }\n      }\n    }\n\n    if ((0, _type.isDefined)(startValue)) {\n      startValue = this.validateUnit(startValue, \"E2105\", \"strip\");\n      start = this._getTranslatedCoord(startValue, -1);\n\n      if (!(0, _type.isDefined)(start) && isContinuous) {\n        start = startValue < min ? canvasStart : canvasEnd;\n      }\n    } else {\n      start = canvasStart;\n    }\n\n    if ((0, _type.isDefined)(endValue)) {\n      endValue = this.validateUnit(endValue, \"E2105\", \"strip\");\n      end = this._getTranslatedCoord(endValue, 1);\n\n      if (!(0, _type.isDefined)(end) && isContinuous) {\n        end = endValue > min ? canvasEnd : canvasStart;\n      }\n    } else {\n      end = canvasEnd;\n    }\n\n    return start < end ? {\n      from: start,\n      to: end\n    } : {\n      from: end,\n      to: start\n    };\n  },\n  _getStripGraphicAttributes: function _getStripGraphicAttributes(fromPoint, toPoint) {\n    var x;\n    var y;\n    var width;\n    var height;\n    var orthogonalPositions = this._orthogonalPositions;\n    var positionFrom = orthogonalPositions.start;\n    var positionTo = orthogonalPositions.end;\n\n    if (this._isHorizontal) {\n      x = fromPoint;\n      y = _min(positionFrom, positionTo);\n      width = toPoint - fromPoint;\n      height = _abs(positionFrom - positionTo);\n    } else {\n      x = _min(positionFrom, positionTo);\n      y = fromPoint;\n      width = _abs(positionFrom - positionTo);\n      height = _abs(fromPoint - toPoint);\n    }\n\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    };\n  },\n  _createStrip: function _createStrip(attrs) {\n    return this._renderer.rect(attrs.x, attrs.y, attrs.width, attrs.height);\n  },\n  _adjustStripLabels: function _adjustStripLabels() {\n    var that = this;\n\n    this._strips.forEach(function (strip) {\n      if (strip.label) {\n        strip.label.attr(that._getAdjustedStripLabelCoords(strip));\n      }\n    });\n  },\n  _adjustLabelsCoord: function _adjustLabelsCoord(offset, maxWidth, checkCanvas) {\n    var that = this;\n\n    that._majorTicks.forEach(function (tick) {\n      if (tick.label) {\n        tick.updateMultilineTextAlignment();\n        tick.label.attr(that._getLabelAdjustedCoord(tick, offset + (tick.labelOffset || 0), maxWidth, checkCanvas));\n      }\n    });\n  },\n  _adjustLabels: function _adjustLabels(offset) {\n    var that = this;\n\n    var maxSize = that._majorTicks.reduce(function (size, tick) {\n      if (!tick.label) {\n        return size;\n      }\n\n      var bBox = tick.labelRotationAngle ? _utils2.default.rotateBBox(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle) : tick.labelBBox;\n      return {\n        width: _max(size.width || 0, bBox.width),\n        height: _max(size.height || 0, bBox.height),\n        offset: _max(size.offset || 0, tick.labelOffset || 0)\n      };\n    }, {});\n\n    var additionalOffset = that._isHorizontal ? maxSize.height : maxSize.width;\n\n    that._adjustLabelsCoord(offset, maxSize.width);\n\n    return offset + additionalOffset + (additionalOffset && that._options.label.indentFromAxis) + maxSize.offset;\n  },\n  _getLabelAdjustedCoord: function _getLabelAdjustedCoord(tick, offset, maxWidth) {\n    offset = offset || 0;\n    var that = this;\n    var options = that._options;\n\n    var box = _utils2.default.rotateBBox(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle || 0);\n\n    var position = options.position;\n    var textAlign = tick.labelAlignment || options.label.alignment;\n    var isDiscrete = \"discrete\" === that._options.type;\n    var isFlatLabel = tick.labelRotationAngle % 90 === 0;\n    var indentFromAxis = options.label.indentFromAxis;\n    var axisPosition = that._axisPosition;\n    var labelCoords = tick.labelCoords;\n    var labelX = labelCoords.x;\n    var translateX;\n    var translateY;\n\n    if (that._isHorizontal) {\n      if (position === BOTTOM) {\n        translateY = axisPosition + indentFromAxis - box.y + offset;\n      } else {\n        translateY = axisPosition - indentFromAxis - (box.y + box.height) - offset;\n      }\n\n      if (textAlign === RIGHT) {\n        translateX = isDiscrete && isFlatLabel ? tick.coords.x - (box.x + box.width) : labelX - box.x - box.width;\n      } else {\n        if (textAlign === LEFT) {\n          translateX = isDiscrete && isFlatLabel ? labelX - box.x - (tick.coords.x - labelX) : labelX - box.x;\n        } else {\n          translateX = labelX - box.x - box.width / 2;\n        }\n      }\n    } else {\n      translateY = labelCoords.y - box.y - box.height / 2;\n\n      if (position === LEFT) {\n        if (textAlign === LEFT) {\n          translateX = axisPosition - indentFromAxis - maxWidth - box.x;\n        } else {\n          if (textAlign === CENTER) {\n            translateX = axisPosition - indentFromAxis - maxWidth / 2 - box.x - box.width / 2;\n          } else {\n            translateX = axisPosition - indentFromAxis - box.x - box.width;\n          }\n        }\n\n        translateX -= offset;\n      } else {\n        if (textAlign === RIGHT) {\n          translateX = axisPosition + indentFromAxis + maxWidth - box.x - box.width;\n        } else {\n          if (textAlign === CENTER) {\n            translateX = axisPosition + indentFromAxis + maxWidth / 2 - box.x - box.width / 2;\n          } else {\n            translateX = axisPosition + indentFromAxis - box.x;\n          }\n        }\n\n        translateX += offset;\n      }\n    }\n\n    return {\n      translateX: translateX,\n      translateY: translateY\n    };\n  },\n  _createAxisConstantLineGroups: function _createAxisConstantLineGroups() {\n    var that = this;\n    var renderer = that._renderer;\n    var classSelector = that._axisCssPrefix;\n    var constantLinesClass = classSelector + \"constant-lines\";\n    var insideGroup;\n    var outsideGroup1;\n    var outsideGroup2;\n    insideGroup = renderer.g().attr({\n      \"class\": constantLinesClass\n    });\n    outsideGroup1 = renderer.g().attr({\n      \"class\": constantLinesClass\n    });\n    outsideGroup2 = renderer.g().attr({\n      \"class\": constantLinesClass\n    });\n    return {\n      inside: insideGroup,\n      outside1: outsideGroup1,\n      left: outsideGroup1,\n      top: outsideGroup1,\n      outside2: outsideGroup2,\n      right: outsideGroup2,\n      bottom: outsideGroup2,\n      remove: function remove() {\n        this.inside.remove();\n        this.outside1.remove();\n        this.outside2.remove();\n      },\n      clear: function clear() {\n        this.inside.clear();\n        this.outside1.clear();\n        this.outside2.clear();\n      }\n    };\n  },\n  _createAxisGroups: function _createAxisGroups() {\n    var that = this;\n    var renderer = that._renderer;\n    var classSelector = that._axisCssPrefix;\n    that._axisGroup = renderer.g().attr({\n      \"class\": classSelector + \"axis\"\n    });\n    that._axisStripGroup = renderer.g().attr({\n      \"class\": classSelector + \"strips\"\n    });\n    that._axisGridGroup = renderer.g().attr({\n      \"class\": classSelector + \"grid\"\n    });\n    that._axisElementsGroup = renderer.g().attr({\n      \"class\": classSelector + \"elements\"\n    }).append(that._axisGroup);\n    that._axisLineGroup = renderer.g().attr({\n      \"class\": classSelector + \"line\"\n    }).append(that._axisGroup);\n    that._axisTitleGroup = renderer.g().attr({\n      \"class\": classSelector + \"title\"\n    }).append(that._axisGroup);\n    that._axisConstantLineGroups = {\n      above: that._createAxisConstantLineGroups(),\n      under: that._createAxisConstantLineGroups()\n    };\n    that._axisStripLabelGroup = renderer.g().attr({\n      \"class\": classSelector + \"axis-labels\"\n    });\n  },\n  _clearAxisGroups: function _clearAxisGroups() {\n    var that = this;\n\n    that._axisGroup.remove();\n\n    that._axisStripGroup.remove();\n\n    that._axisStripLabelGroup.remove();\n\n    that._axisConstantLineGroups.above.remove();\n\n    that._axisConstantLineGroups.under.remove();\n\n    that._axisGridGroup.remove();\n\n    that._axisTitleGroup.clear();\n\n    that._axisElementsGroup.clear();\n\n    that._axisLineGroup && that._axisLineGroup.clear();\n    that._axisStripGroup && that._axisStripGroup.clear();\n    that._axisGridGroup && that._axisGridGroup.clear();\n\n    that._axisConstantLineGroups.above.clear();\n\n    that._axisConstantLineGroups.under.clear();\n\n    that._axisStripLabelGroup && that._axisStripLabelGroup.clear();\n  },\n  _getLabelFormatObject: function _getLabelFormatObject(value, labelOptions, range, point, tickInterval, ticks) {\n    range = range || this._getViewportRange();\n    var formatObject = {\n      value: value,\n      valueText: (0, _smart_formatter.smartFormatter)(value, {\n        labelOptions: labelOptions,\n        ticks: ticks || convertTicksToValues(this._majorTicks),\n        tickInterval: (0, _type.isDefined)(tickInterval) ? tickInterval : this._tickInterval,\n        dataType: this._options.dataType,\n        logarithmBase: this._options.logarithmBase,\n        type: this._options.type,\n        showTransition: !this._options.marker.visible,\n        point: point\n      }) || \"\",\n      min: range.minVisible,\n      max: range.maxVisible\n    };\n\n    if (point) {\n      formatObject.point = point;\n    }\n\n    return formatObject;\n  },\n  formatLabel: function formatLabel(value, labelOptions, range, point, tickInterval, ticks) {\n    var formatObject = this._getLabelFormatObject(value, labelOptions, range, point, tickInterval, ticks);\n\n    return (0, _type.isFunction)(labelOptions.customizeText) ? labelOptions.customizeText.call(formatObject, formatObject) : formatObject.valueText;\n  },\n  formatHint: function formatHint(value, labelOptions, range) {\n    var formatObject = this._getLabelFormatObject(value, labelOptions, range);\n\n    return (0, _type.isFunction)(labelOptions.customizeHint) ? labelOptions.customizeHint.call(formatObject, formatObject) : void 0;\n  },\n  formatRange: function formatRange(startValue, endValue, interval) {\n    return (0, _smart_formatter.formatRange)(startValue, endValue, interval, this.getOptions());\n  },\n  _setTickOffset: function _setTickOffset() {\n    var options = this._options;\n    var discreteAxisDivisionMode = options.discreteAxisDivisionMode;\n    this._tickOffset = +(\"crossLabels\" !== discreteAxisDivisionMode || !discreteAxisDivisionMode);\n  },\n  getMargins: function getMargins() {\n    var that = this;\n    var options = that._options;\n    var position = options.position;\n    var placeholderSize = options.placeholderSize;\n    var canvas = that.getCanvas();\n    var cLeft = canvas.left;\n    var cTop = canvas.top;\n    var cRight = canvas.width - canvas.right;\n    var cBottom = canvas.height - canvas.bottom;\n\n    var edgeMarginCorrection = _max(options.grid.visible && options.grid.width || 0, options.tick.visible && options.tick.width || 0);\n\n    var constantLineAboveSeries = that._axisConstantLineGroups.above;\n    var constantLineUnderSeries = that._axisConstantLineGroups.under;\n    var boxes = [that._axisElementsGroup, constantLineAboveSeries.outside1, constantLineAboveSeries.outside2, constantLineUnderSeries.outside1, constantLineUnderSeries.outside2, that._axisLineGroup].map(function (group) {\n      return group && group.getBBox();\n    }).concat(function (group) {\n      var box = group && group.getBBox();\n\n      if (!box || box.isEmpty) {\n        return box;\n      }\n\n      if (that._isHorizontal) {\n        box.x = cLeft;\n        box.width = cRight - cLeft;\n      } else {\n        box.y = cTop;\n        box.height = cBottom - cTop;\n      }\n\n      return box;\n    }(that._axisTitleGroup));\n    var margins = calculateCanvasMargins(boxes, canvas);\n    margins[position] += options.crosshairMargin;\n\n    if (placeholderSize) {\n      margins[position] = placeholderSize;\n    }\n\n    if (edgeMarginCorrection) {\n      if (that._isHorizontal && canvas.right < edgeMarginCorrection && margins.right < edgeMarginCorrection) {\n        margins.right = edgeMarginCorrection;\n      }\n\n      if (!that._isHorizontal && canvas.bottom < edgeMarginCorrection && margins.bottom < edgeMarginCorrection) {\n        margins.bottom = edgeMarginCorrection;\n      }\n    }\n\n    return margins;\n  },\n  validateUnit: function validateUnit(unit, idError, parameters) {\n    var that = this;\n    unit = that.parser(unit);\n\n    if (void 0 === unit && idError) {\n      that._incidentOccurred(idError, [parameters]);\n    }\n\n    return unit;\n  },\n  _setType: function _setType(axisType, drawingType) {\n    var that = this;\n    var axisTypeMethods;\n\n    switch (axisType) {\n      case \"xyAxes\":\n        axisTypeMethods = _xy_axes2.default;\n        break;\n\n      case \"polarAxes\":\n        axisTypeMethods = _polar_axes2.default;\n    }\n\n    (0, _extend.extend)(that, axisTypeMethods[drawingType]);\n  },\n  _getSharpParam: function _getSharpParam() {\n    return true;\n  },\n  _disposeBreaksGroup: _common.noop,\n  dispose: function dispose() {\n    var that = this;\n    [that._axisElementsGroup, that._axisStripGroup, that._axisGroup].forEach(function (g) {\n      g.dispose();\n    });\n    that._strips = that._title = null;\n    that._axisStripGroup = that._axisConstantLineGroups = that._axisStripLabelGroup = that._axisBreaksGroup = null;\n    that._axisLineGroup = that._axisElementsGroup = that._axisGridGroup = null;\n    that._axisGroup = that._axisTitleGroup = null;\n    that._axesContainerGroup = that._stripsGroup = that._constantLinesGroup = null;\n    that._renderer = that._options = that._textOptions = that._textFontStyles = null;\n    that._translator = null;\n    that._majorTicks = that._minorTicks = null;\n\n    that._disposeBreaksGroup();\n  },\n  getOptions: function getOptions() {\n    return this._options;\n  },\n  setPane: function setPane(pane) {\n    this.pane = pane;\n    this._options.pane = pane;\n  },\n  setTypes: function setTypes(type, axisType, typeSelector) {\n    this._options.type = type || this._options.type;\n    this._options[typeSelector] = axisType || this._options[typeSelector];\n\n    this._updateTranslator();\n  },\n  resetTypes: function resetTypes(typeSelector) {\n    this._options.type = this._initTypes.type;\n    this._options[typeSelector] = this._initTypes[typeSelector];\n  },\n  getTranslator: function getTranslator() {\n    return this._translator;\n  },\n  updateOptions: function updateOptions(options) {\n    var that = this;\n    var labelOpt = options.label;\n    validateAxisOptions(options);\n    that._options = options;\n    options.tick = options.tick || {};\n    options.minorTick = options.minorTick || {};\n    options.grid = options.grid || {};\n    options.minorGrid = options.minorGrid || {};\n    options.title = options.title || {};\n    options.marker = options.marker || {};\n    that._initTypes = {\n      type: options.type,\n      argumentType: options.argumentType,\n      valueType: options.valueType\n    };\n\n    that._setTickOffset();\n\n    that._isHorizontal = options.isHorizontal;\n    that.pane = options.pane;\n    that.name = options.name;\n    that.priority = options.priority;\n    that._hasLabelFormat = \"\" !== labelOpt.format && (0, _type.isDefined)(labelOpt.format);\n    that._textOptions = {\n      opacity: labelOpt.opacity,\n      align: \"center\",\n      \"class\": labelOpt.cssClass\n    };\n    that._textFontStyles = _utils2.default.patchFontOptions(labelOpt.font);\n\n    if (options.type === _axes_constants2.default.logarithmic) {\n      if (options.logarithmBaseError) {\n        that._incidentOccurred(\"E2104\");\n\n        delete options.logarithmBaseError;\n      }\n    }\n\n    that._updateTranslator();\n\n    that._createConstantLines();\n\n    that._strips = (options.strips || []).map(function (o) {\n      return (0, _strip2.default)(that, o);\n    });\n    that._majorTicks = that._minorTicks = null;\n    that._firstDrawing = true;\n  },\n  calculateInterval: function calculateInterval(value, prevValue) {\n    var options = this._options;\n\n    if (!options || options.type !== _axes_constants2.default.logarithmic) {\n      return _abs(value - prevValue);\n    }\n\n    var _ref3 = new _range.Range(this.getTranslator().getBusinessRange()),\n        allowNegatives = _ref3.allowNegatives,\n        linearThreshold = _ref3.linearThreshold;\n\n    return _abs(getLog(value, options.logarithmBase, allowNegatives, linearThreshold) - getLog(prevValue, options.logarithmBase, allowNegatives, linearThreshold));\n  },\n  _processCanvas: function _processCanvas(canvas) {\n    return canvas;\n  },\n  updateCanvas: function updateCanvas(canvas) {\n    var positions = this._orthogonalPositions = {\n      start: !this._isHorizontal ? canvas.left : canvas.top,\n      end: !this._isHorizontal ? canvas.width - canvas.right : canvas.height - canvas.bottom\n    };\n    this._canvas = canvas;\n    positions.center = positions.start + (positions.end - positions.start) / 2;\n\n    this._translator.updateCanvas(this._processCanvas(canvas));\n\n    this._initAxisPositions();\n  },\n  getCanvas: function getCanvas() {\n    return this._canvas;\n  },\n  getAxisShift: function getAxisShift() {\n    return this._axisShift || 0;\n  },\n  hideTitle: function hideTitle() {\n    var that = this;\n\n    if (that._options.title.text) {\n      that._incidentOccurred(\"W2105\", [that._isHorizontal ? \"horizontal\" : \"vertical\"]);\n\n      that._axisTitleGroup.clear();\n    }\n  },\n  getTitle: function getTitle() {\n    return this._title;\n  },\n  hideOuterElements: function hideOuterElements() {\n    var that = this;\n    var options = that._options;\n\n    if ((options.label.visible || that._outsideConstantLines.length) && !that._translator.getBusinessRange().isEmpty()) {\n      that._incidentOccurred(\"W2106\", [that._isHorizontal ? \"horizontal\" : \"vertical\"]);\n\n      that._axisElementsGroup.clear();\n\n      callAction(that._outsideConstantLines, \"removeLabel\");\n    }\n  },\n  adjustViewport: function adjustViewport(businessRange) {\n    var that = this;\n    var options = that._options;\n    var isDiscrete = options.type === _axes_constants2.default.discrete;\n    var categories = that._seriesData && that._seriesData.categories || [];\n    var wholeRange = that.adjustRange(getVizRangeObject(options.wholeRange));\n    var visualRange = that.getViewport() || {};\n    var result = new _range.Range(businessRange);\n\n    that._addConstantLinesToRange(result, \"minVisible\", \"maxVisible\");\n\n    var minDefined = (0, _type.isDefined)(visualRange.startValue);\n    var maxDefined = (0, _type.isDefined)(visualRange.endValue);\n\n    if (!isDiscrete) {\n      minDefined = minDefined && (!(0, _type.isDefined)(wholeRange.endValue) || visualRange.startValue < wholeRange.endValue);\n      maxDefined = maxDefined && (!(0, _type.isDefined)(wholeRange.startValue) || visualRange.endValue > wholeRange.startValue);\n    }\n\n    var minVisible = minDefined ? visualRange.startValue : result.minVisible;\n    var maxVisible = maxDefined ? visualRange.endValue : result.maxVisible;\n\n    if (!isDiscrete) {\n      result.min = (0, _type.isDefined)(wholeRange.startValue) ? wholeRange.startValue : result.min;\n      result.max = (0, _type.isDefined)(wholeRange.endValue) ? wholeRange.endValue : result.max;\n    } else {\n      var categoriesInfo = _utils2.default.getCategoriesInfo(categories, wholeRange.startValue, wholeRange.endValue);\n\n      categories = categoriesInfo.categories;\n      result.categories = categories;\n    }\n\n    var adjustedVisualRange = _utils2.default.adjustVisualRange({\n      axisType: options.type,\n      dataType: options.dataType,\n      base: options.logarithmBase\n    }, {\n      startValue: minDefined ? visualRange.startValue : void 0,\n      endValue: maxDefined ? visualRange.endValue : void 0,\n      length: visualRange.length\n    }, {\n      categories: categories,\n      min: wholeRange.startValue,\n      max: wholeRange.endValue\n    }, {\n      categories: categories,\n      min: minVisible,\n      max: maxVisible\n    });\n\n    result.minVisible = adjustedVisualRange.startValue;\n    result.maxVisible = adjustedVisualRange.endValue;\n    !(0, _type.isDefined)(result.min) && (result.min = result.minVisible);\n    !(0, _type.isDefined)(result.max) && (result.max = result.maxVisible);\n    result.addRange({});\n    return result;\n  },\n  adjustRange: function adjustRange(range) {\n    range = range || {};\n    var isDiscrete = this._options.type === _axes_constants2.default.discrete;\n    var isLogarithmic = this._options.type === _axes_constants2.default.logarithmic;\n    var disabledNegatives = false === this._options.allowNegatives;\n\n    if (isLogarithmic) {\n      range.startValue = disabledNegatives && range.startValue <= 0 ? null : range.startValue;\n      range.endValue = disabledNegatives && range.endValue <= 0 ? null : range.endValue;\n    }\n\n    if (!isDiscrete && (0, _type.isDefined)(range.startValue) && (0, _type.isDefined)(range.endValue) && range.startValue > range.endValue) {\n      var tmp = range.endValue;\n      range.endValue = range.startValue;\n      range.startValue = tmp;\n    }\n\n    return range;\n  },\n  _getVisualRangeUpdateMode: function _getVisualRangeUpdateMode(viewport, newRange, oppositeValue) {\n    var value = this._options.visualRangeUpdateMode;\n    var translator = this._translator;\n    var range = this._seriesData;\n\n    if (this.isArgumentAxis) {\n      if ([SHIFT, KEEP, RESET].indexOf(value) === -1) {\n        if (range.axisType === _axes_constants2.default.discrete) {\n          var categories = range.categories;\n          var newCategories = newRange.categories;\n          var visualRange = this.visualRange();\n\n          if (categories && newCategories && categories.length && newCategories.map(function (c) {\n            return c.valueOf();\n          }).join(\",\").indexOf(categories.map(function (c) {\n            return c.valueOf();\n          }).join(\",\")) !== -1 && (visualRange.startValue.valueOf() !== categories[0].valueOf() || visualRange.endValue.valueOf() !== categories[categories.length - 1].valueOf())) {\n            value = KEEP;\n          } else {\n            value = RESET;\n          }\n        } else {\n          var minPoint = translator.translate(range.min);\n          var minVisiblePoint = translator.translate(viewport.startValue);\n          var maxPoint = translator.translate(range.max);\n          var maxVisiblePoint = translator.translate(viewport.endValue);\n\n          if (minPoint === minVisiblePoint && maxPoint === maxVisiblePoint) {\n            value = RESET;\n          } else {\n            if (minPoint !== minVisiblePoint && maxPoint === maxVisiblePoint) {\n              value = SHIFT;\n            } else {\n              value = KEEP;\n            }\n          }\n        }\n      }\n    } else {\n      if ([KEEP, RESET].indexOf(value) === -1) {\n        if (oppositeValue === KEEP) {\n          value = KEEP;\n        } else {\n          value = RESET;\n        }\n      }\n    }\n\n    return value;\n  },\n  _handleBusinessRangeChanged: function _handleBusinessRangeChanged(oppositeVisualRangeUpdateMode, axisReinitialized, newRange) {\n    var that = this;\n    var visualRange = this.visualRange();\n\n    if (axisReinitialized || that._translator.getBusinessRange().isEmpty()) {\n      return;\n    }\n\n    var visualRangeUpdateMode = that._lastVisualRangeUpdateMode = that._getVisualRangeUpdateMode(visualRange, newRange, oppositeVisualRangeUpdateMode);\n\n    if (!that.isArgumentAxis) {\n      var viewport = that.getViewport();\n\n      if (!(0, _type.isDefined)(viewport.startValue) && !(0, _type.isDefined)(viewport.endValue) && !(0, _type.isDefined)(viewport.length)) {\n        visualRangeUpdateMode = RESET;\n      }\n    }\n\n    that._prevDataWasEmpty && (visualRangeUpdateMode = KEEP);\n\n    if (visualRangeUpdateMode === KEEP) {\n      that._setVisualRange([visualRange.startValue, visualRange.endValue]);\n    }\n\n    if (visualRangeUpdateMode === RESET) {\n      that._setVisualRange([null, null]);\n    }\n\n    if (visualRangeUpdateMode === SHIFT) {\n      that._setVisualRange({\n        length: that.getVisualRangeLength()\n      });\n    }\n  },\n  getVisualRangeLength: function getVisualRangeLength(range) {\n    var currentBusinessRange = range || this._translator.getBusinessRange();\n\n    var type = this._options.type;\n    var length;\n\n    if (type === _axes_constants2.default.logarithmic) {\n      length = (0, _math2.adjust)(this.calculateInterval(currentBusinessRange.maxVisible, currentBusinessRange.minVisible));\n    } else {\n      if (type === _axes_constants2.default.discrete) {\n        var categoriesInfo = _utils2.default.getCategoriesInfo(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);\n\n        length = categoriesInfo.categories.length;\n      } else {\n        length = currentBusinessRange.maxVisible - currentBusinessRange.minVisible;\n      }\n    }\n\n    return length;\n  },\n  getVisualRangeCenter: function getVisualRangeCenter(range) {\n    var businessRange = this._translator.getBusinessRange();\n\n    var currentBusinessRange = range || businessRange;\n    var _this$_options = this._options,\n        type = _this$_options.type,\n        logarithmBase = _this$_options.logarithmBase;\n    var center;\n\n    if (!(0, _type.isDefined)(currentBusinessRange.minVisible) || !(0, _type.isDefined)(currentBusinessRange.maxVisible)) {\n      return;\n    }\n\n    if (type === _axes_constants2.default.logarithmic) {\n      var allowNegatives = currentBusinessRange.allowNegatives,\n          linearThreshold = currentBusinessRange.linearThreshold,\n          minVisible = currentBusinessRange.minVisible,\n          maxVisible = currentBusinessRange.maxVisible;\n      center = raiseTo((0, _math2.adjust)(getLog(maxVisible, logarithmBase, allowNegatives, linearThreshold) + getLog(minVisible, logarithmBase, allowNegatives, linearThreshold)) / 2, logarithmBase, allowNegatives, linearThreshold);\n    } else {\n      if (type === _axes_constants2.default.discrete) {\n        var categoriesInfo = _utils2.default.getCategoriesInfo(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);\n\n        var index = Math.ceil(categoriesInfo.categories.length / 2) - 1;\n        center = businessRange.categories.indexOf(categoriesInfo.categories[index]);\n      } else {\n        center = (currentBusinessRange.maxVisible.valueOf() + currentBusinessRange.minVisible.valueOf()) / 2;\n      }\n    }\n\n    return center;\n  },\n  setBusinessRange: function setBusinessRange(range, axisReinitialized, oppositeVisualRangeUpdateMode, argCategories) {\n    var that = this;\n    var options = that._options;\n    var isDiscrete = options.type === _axes_constants2.default.discrete;\n\n    that._handleBusinessRangeChanged(oppositeVisualRangeUpdateMode, axisReinitialized, range);\n\n    that._seriesData = new _range.Range(range);\n\n    var dataIsEmpty = that._seriesData.isEmpty();\n\n    that._prevDataWasEmpty = dataIsEmpty;\n\n    that._seriesData.addRange({\n      categories: options.categories,\n      dataType: options.dataType,\n      axisType: options.type,\n      base: options.logarithmBase,\n      invert: options.inverted\n    });\n\n    if (options.type === _axes_constants2.default.logarithmic) {\n      that._seriesData.addRange({\n        allowNegatives: void 0 !== options.allowNegatives ? options.allowNegatives : range.min <= 0\n      });\n\n      if (!isNaN(options.linearThreshold)) {\n        that._seriesData.linearThreshold = options.linearThreshold;\n      }\n    }\n\n    if (!isDiscrete) {\n      if (!(0, _type.isDefined)(that._seriesData.min) && !(0, _type.isDefined)(that._seriesData.max)) {\n        var visualRange = that.getViewport();\n        visualRange && that._seriesData.addRange({\n          min: visualRange.startValue,\n          max: visualRange.endValue\n        });\n      }\n\n      var synchronizedValue = options.synchronizedValue;\n\n      if ((0, _type.isDefined)(synchronizedValue)) {\n        that._seriesData.addRange({\n          min: synchronizedValue,\n          max: synchronizedValue\n        });\n      }\n    }\n\n    that._seriesData.minVisible = void 0 === that._seriesData.minVisible ? that._seriesData.min : that._seriesData.minVisible;\n    that._seriesData.maxVisible = void 0 === that._seriesData.maxVisible ? that._seriesData.max : that._seriesData.maxVisible;\n\n    if (!that.isArgumentAxis && options.showZero) {\n      that._seriesData.correctValueZeroLevel();\n    }\n\n    that._seriesData.sortCategories(that.getCategoriesSorter(argCategories));\n\n    that._seriesData.breaks = that._breaks = that._getScaleBreaks(options, that._seriesData, that._series, that.isArgumentAxis);\n\n    that._translator.updateBusinessRange(that.adjustViewport(that._seriesData));\n  },\n  _addConstantLinesToRange: function _addConstantLinesToRange(dataRange, minValueField, maxValueField) {\n    this._outsideConstantLines.concat(this._insideConstantLines || []).forEach(function (cl) {\n      if (cl.options.extendAxis) {\n        var _dataRange$addRange;\n\n        var value = cl.getParsedValue();\n        dataRange.addRange((_dataRange$addRange = {}, _defineProperty(_dataRange$addRange, minValueField, value), _defineProperty(_dataRange$addRange, maxValueField, value), _dataRange$addRange));\n      }\n    });\n  },\n  setGroupSeries: function setGroupSeries(series) {\n    this._series = series;\n  },\n  getLabelsPosition: function getLabelsPosition() {\n    var that = this;\n    var options = that._options;\n    var position = options.position;\n    var labelShift = options.label.indentFromAxis + (that._axisShift || 0) + that._constantLabelOffset;\n    var axisPosition = that._axisPosition;\n    return position === TOP || position === LEFT ? axisPosition - labelShift : axisPosition + labelShift;\n  },\n  getFormattedValue: function getFormattedValue(value, options, point) {\n    var labelOptions = this._options.label;\n    return (0, _type.isDefined)(value) ? this.formatLabel(value, (0, _extend.extend)(true, {}, labelOptions, options), void 0, point) : null;\n  },\n  _getBoundaryTicks: function _getBoundaryTicks(majors, viewPort) {\n    var that = this;\n    var length = majors.length;\n    var options = that._options;\n    var customBounds = options.customBoundTicks;\n    var min = viewPort.minVisible;\n    var max = viewPort.maxVisible;\n    var addMinMax = options.showCustomBoundaryTicks ? that._boundaryTicksVisibility : {};\n    var boundaryTicks = [];\n\n    if (options.type === _axes_constants2.default.discrete) {\n      if (that._tickOffset && 0 !== majors.length) {\n        boundaryTicks = [majors[0], majors[majors.length - 1]];\n      }\n    } else {\n      if (customBounds) {\n        if (addMinMax.min && (0, _type.isDefined)(customBounds[0])) {\n          boundaryTicks.push(customBounds[0]);\n        }\n\n        if (addMinMax.max && (0, _type.isDefined)(customBounds[1])) {\n          boundaryTicks.push(customBounds[1]);\n        }\n      } else {\n        if (addMinMax.min && (0 === length || majors[0] > min)) {\n          boundaryTicks.push(min);\n        }\n\n        if (addMinMax.max && (0 === length || majors[length - 1] < max)) {\n          boundaryTicks.push(max);\n        }\n      }\n    }\n\n    return boundaryTicks;\n  },\n  setPercentLabelFormat: function setPercentLabelFormat() {\n    if (!this._hasLabelFormat) {\n      this._options.label.format = \"percent\";\n    }\n  },\n  resetAutoLabelFormat: function resetAutoLabelFormat() {\n    if (!this._hasLabelFormat) {\n      delete this._options.label.format;\n    }\n  },\n  getMultipleAxesSpacing: function getMultipleAxesSpacing() {\n    return this._options.multipleAxesSpacing || 0;\n  },\n  getTicksValues: function getTicksValues() {\n    return {\n      majorTicksValues: convertTicksToValues(this._majorTicks),\n      minorTicksValues: convertTicksToValues(this._minorTicks)\n    };\n  },\n  setTicks: function setTicks(ticks) {\n    var majors = ticks.majorTicks || [];\n    this._majorTicks = majors.map(createMajorTick(this, this._renderer, this._getSkippedCategory(majors)));\n    this._minorTicks = (ticks.minorTicks || []).map(createMinorTick(this, this._renderer));\n    this._isSynchronized = true;\n  },\n  _adjustDivisionFactor: function _adjustDivisionFactor(val) {\n    return val;\n  },\n  _getTicks: function _getTicks(viewPort, incidentOccurred, skipTickGeneration) {\n    var that = this;\n    var options = that._options;\n    var customTicks = options.customTicks;\n    var customMinorTicks = options.customMinorTicks;\n    return getTickGenerator(options, incidentOccurred || that._incidentOccurred, skipTickGeneration, that._translator.getBusinessRange().isEmpty(), that._adjustDivisionFactor.bind(that), viewPort)({\n      min: viewPort.minVisible,\n      max: viewPort.maxVisible,\n      categories: viewPort.categories,\n      isSpacedMargin: viewPort.isSpacedMargin,\n      checkMinDataVisibility: viewPort.checkMinDataVisibility,\n      checkMaxDataVisibility: viewPort.checkMaxDataVisibility\n    }, that._getScreenDelta(), options.tickInterval, \"ignore\" === options.label.overlappingBehavior || options.forceUserTickInterval, {\n      majors: customTicks,\n      minors: customMinorTicks\n    }, options.minorTickInterval, options.minorTickCount, that._breaks);\n  },\n  _createTicksAndLabelFormat: function _createTicksAndLabelFormat(range, incidentOccurred) {\n    var options = this._options;\n    var ticks;\n    ticks = this._getTicks(range, incidentOccurred, false);\n\n    if (!range.isEmpty() && options.type === _axes_constants2.default.discrete && \"datetime\" === options.dataType && !this._hasLabelFormat && ticks.ticks.length) {\n      options.label.format = _format_helper2.default.getDateFormatByTicks(ticks.ticks);\n    }\n\n    return ticks;\n  },\n  getAggregationInfo: function getAggregationInfo(useAllAggregatedPoints, range) {\n    var that = this;\n    var options = that._options;\n    var marginOptions = that._marginOptions;\n    var businessRange = new _range.Range(that.getTranslator().getBusinessRange()).addRange(range);\n    var visualRange = that.getViewport();\n    var minVisible = visualRange && (0, _type.isDefined)(visualRange.startValue) ? visualRange.startValue : businessRange.minVisible;\n    var maxVisible = visualRange && (0, _type.isDefined)(visualRange.endValue) ? visualRange.endValue : businessRange.maxVisible;\n    var ticks = [];\n\n    if (options.type === _axes_constants2.default.discrete && options.aggregateByCategory) {\n      return {\n        aggregateByCategory: true\n      };\n    }\n\n    var aggregationInterval = options.aggregationInterval;\n    var aggregationGroupWidth = options.aggregationGroupWidth;\n\n    if (!aggregationGroupWidth && marginOptions) {\n      if (marginOptions.checkInterval) {\n        aggregationGroupWidth = options.axisDivisionFactor;\n      }\n\n      if (marginOptions.sizePointNormalState) {\n        aggregationGroupWidth = Math.min(marginOptions.sizePointNormalState, options.axisDivisionFactor);\n      }\n    }\n\n    var minInterval = !options.aggregationGroupWidth && !aggregationInterval && range.interval;\n    var generateTicks = configureGenerator(options, aggregationGroupWidth, businessRange, that._getScreenDelta(), minInterval);\n    var tickInterval = generateTicks(aggregationInterval, true, minVisible, maxVisible, that._breaks).tickInterval;\n\n    if (options.type !== _axes_constants2.default.discrete) {\n      var min = useAllAggregatedPoints ? businessRange.min : minVisible;\n      var max = useAllAggregatedPoints ? businessRange.max : maxVisible;\n\n      if ((0, _type.isDefined)(min) && (0, _type.isDefined)(max)) {\n        var add = _utils2.default.getAddFunction({\n          base: options.logarithmBase,\n          axisType: options.type,\n          dataType: options.dataType\n        }, false);\n\n        var start = min;\n        var end = max;\n\n        if (!useAllAggregatedPoints) {\n          var maxMinDistance = Math.max(that.calculateInterval(max, min), \"datetime\" === options.dataType ? (0, _date.dateToMilliseconds)(tickInterval) : tickInterval);\n          start = add(min, maxMinDistance, -1);\n          end = add(max, maxMinDistance);\n        }\n\n        start = start < businessRange.min ? businessRange.min : start;\n        end = end > businessRange.max ? businessRange.max : end;\n\n        var breaks = that._getScaleBreaks(options, {\n          minVisible: start,\n          maxVisible: end\n        }, that._series, that.isArgumentAxis);\n\n        ticks = generateTicks(tickInterval, false, start, end, breaks).ticks;\n      }\n    }\n\n    that._aggregationInterval = tickInterval;\n    return {\n      interval: tickInterval,\n      ticks: ticks\n    };\n  },\n  createTicks: function createTicks(canvas) {\n    var that = this;\n    var renderer = that._renderer;\n    var options = that._options;\n    var ticks;\n    var boundaryTicks;\n    var range;\n\n    if (!canvas) {\n      return;\n    }\n\n    that._isSynchronized = false;\n    that.updateCanvas(canvas);\n    that._estimatedTickInterval = that._getTicks(that.adjustViewport(this._seriesData), _common.noop, true).tickInterval;\n    range = that._getViewportRange();\n\n    var margins = this._calculateValueMargins();\n\n    range.addRange({\n      minVisible: margins.minValue,\n      maxVisible: margins.maxValue,\n      isSpacedMargin: margins.isSpacedMargin,\n      checkMinDataVisibility: !this.isArgumentAxis && margins.checkInterval && !(0, _type.isDefined)(options.min) && margins.minValue.valueOf() > 0,\n      checkMaxDataVisibility: !this.isArgumentAxis && margins.checkInterval && !(0, _type.isDefined)(options.max) && margins.maxValue.valueOf() < 0\n    });\n    ticks = that._createTicksAndLabelFormat(range);\n    boundaryTicks = that._getBoundaryTicks(ticks.ticks, that._getViewportRange());\n\n    if (options.showCustomBoundaryTicks && boundaryTicks.length) {\n      that._boundaryTicks = [boundaryTicks[0]].map(createBoundaryTick(that, renderer, true));\n\n      if (boundaryTicks.length > 1) {\n        that._boundaryTicks = that._boundaryTicks.concat([boundaryTicks[1]].map(createBoundaryTick(that, renderer, false)));\n      }\n    } else {\n      that._boundaryTicks = [];\n    }\n\n    var minors = (ticks.minorTicks || []).filter(function (minor) {\n      return !boundaryTicks.some(function (boundary) {\n        return valueOf(boundary) === valueOf(minor);\n      });\n    });\n    that._tickInterval = ticks.tickInterval;\n    that._minorTickInterval = ticks.minorTickInterval;\n    var oldMajorTicks = that._majorTicks || [];\n    var majorTicksByValues = oldMajorTicks.reduce(function (r, t) {\n      r[t.value.valueOf()] = t;\n      return r;\n    }, {});\n    var sameType = (0, _type.type)(ticks.ticks[0]) === (0, _type.type)(oldMajorTicks[0] && oldMajorTicks[0].value);\n\n    var skippedCategory = that._getSkippedCategory(ticks.ticks);\n\n    var majorTicks = ticks.ticks.map(function (v) {\n      var tick = majorTicksByValues[v.valueOf()];\n\n      if (tick && sameType) {\n        delete majorTicksByValues[v.valueOf()];\n        tick.setSkippedCategory(skippedCategory);\n        return tick;\n      } else {\n        return createMajorTick(that, renderer, skippedCategory)(v);\n      }\n    });\n    that._majorTicks = majorTicks;\n    var oldMinorTicks = that._minorTicks || [];\n    that._minorTicks = minors.map(function (v, i) {\n      var minorTick = oldMinorTicks[i];\n\n      if (minorTick) {\n        minorTick.updateValue(v);\n        return minorTick;\n      }\n\n      return createMinorTick(that, renderer)(v);\n    });\n    that._ticksToRemove = Object.keys(majorTicksByValues).map(function (k) {\n      return majorTicksByValues[k];\n    }).concat(oldMinorTicks.slice(that._minorTicks.length, oldMinorTicks.length));\n    that._correctedBreaks = ticks.breaks;\n\n    that._reinitTranslator(that._getViewportRange());\n  },\n  _reinitTranslator: function _reinitTranslator(range) {\n    var that = this;\n    var translator = that._translator;\n\n    if (that._correctedBreaks) {\n      range.breaks = that._correctedBreaks;\n    }\n\n    if (that._isSynchronized) {\n      return;\n    }\n\n    translator.updateBusinessRange(that.adjustViewport(range));\n  },\n  _getViewportRange: function _getViewportRange() {\n    return this.adjustViewport(this._seriesData);\n  },\n  setMarginOptions: function setMarginOptions(options) {\n    this._marginOptions = options;\n  },\n  getMarginOptions: function getMarginOptions() {\n    return (0, _type.isDefined)(this._marginOptions) ? this._marginOptions : {};\n  },\n  allowToExtendVisualRange: function allowToExtendVisualRange(isEnd) {\n    var wholeRange = this.adjustRange(getVizRangeObject(this._options.wholeRange));\n    var bound = isEnd ? wholeRange.endValue : wholeRange.startValue;\n    return !this.isArgumentAxis || !(0, _type.isDefined)(bound) && this.isExtremePosition(isEnd);\n  },\n  _calculateRangeInterval: function _calculateRangeInterval(interval) {\n    var isDateTime = \"datetime\" === this._options.dataType;\n    var minArgs = [];\n\n    var addToArgs = function addToArgs(value) {\n      (0, _type.isDefined)(value) && minArgs.push(isDateTime ? (0, _date.dateToMilliseconds)(value) : value);\n    };\n\n    addToArgs(this._tickInterval);\n    addToArgs(this._estimatedTickInterval);\n    (0, _type.isDefined)(interval) && minArgs.push(interval);\n    addToArgs(this._aggregationInterval);\n    return this._calculateWorkWeekInterval(_min.apply(this, minArgs));\n  },\n  _calculateWorkWeekInterval: function _calculateWorkWeekInterval(businessInterval) {\n    var options = this._options;\n\n    if (\"datetime\" === options.dataType && options.workdaysOnly && businessInterval) {\n      var workWeek = options.workWeek.length * dateIntervals.day;\n      var weekend = dateIntervals.week - workWeek;\n\n      if (workWeek !== businessInterval && weekend < businessInterval) {\n        var weekendsCount = Math.ceil(businessInterval / dateIntervals.week);\n        businessInterval = weekend >= businessInterval ? dateIntervals.day : businessInterval - weekend * weekendsCount;\n      } else {\n        if (weekend >= businessInterval && businessInterval > dateIntervals.day) {\n          businessInterval = dateIntervals.day;\n        }\n      }\n    }\n\n    return businessInterval;\n  },\n  _calculateValueMargins: function _calculateValueMargins(ticks) {\n    this._resetMargins();\n\n    var that = this;\n    var margins = that.getMarginOptions();\n    var marginSize = (margins.size || 0) / 2;\n    var options = that._options;\n\n    var dataRange = this._getViewportRange();\n\n    var viewPort = this.getViewport();\n\n    var screenDelta = that._getScreenDelta();\n\n    var isDiscrete = (options.type || \"\").indexOf(_axes_constants2.default.discrete) !== -1;\n    var valueMarginsEnabled = options.valueMarginsEnabled && !isDiscrete;\n    var translator = that._translator;\n    var minValueMargin = options.minValueMargin;\n    var maxValueMargin = options.maxValueMargin;\n    var minPadding = 0;\n    var maxPadding = 0;\n    var interval = 0;\n    var rangeInterval;\n\n    if (dataRange.stubData || !screenDelta) {\n      return {\n        startPadding: 0,\n        endPadding: 0\n      };\n    }\n\n    function getConvertIntervalCoefficient(intervalInPx) {\n      var ratioOfCanvasRange = translator.ratioOfCanvasRange();\n      return ratioOfCanvasRange / (ratioOfCanvasRange * screenDelta / (intervalInPx + screenDelta));\n    }\n\n    if (that.isArgumentAxis && margins.checkInterval) {\n      rangeInterval = that._calculateRangeInterval(dataRange.interval);\n      var pxInterval = translator.getInterval(rangeInterval);\n\n      if (isFinite(pxInterval)) {\n        interval = Math.ceil(pxInterval / (2 * getConvertIntervalCoefficient(pxInterval)));\n      } else {\n        rangeInterval = 0;\n      }\n    }\n\n    var minPercentPadding;\n    var maxPercentPadding;\n    var maxPaddingValue = screenDelta * MAX_MARGIN_VALUE / 2;\n\n    if (valueMarginsEnabled) {\n      if ((0, _type.isDefined)(minValueMargin)) {\n        minPercentPadding = isFinite(minValueMargin) ? minValueMargin : 0;\n      } else {\n        minPadding = Math.max(marginSize, interval);\n        minPadding = Math.min(maxPaddingValue, minPadding);\n      }\n\n      if ((0, _type.isDefined)(maxValueMargin)) {\n        maxPercentPadding = isFinite(maxValueMargin) ? maxValueMargin : 0;\n      } else {\n        maxPadding = Math.max(marginSize, interval);\n        maxPadding = Math.min(maxPaddingValue, maxPadding);\n      }\n    }\n\n    var percentStick = margins.percentStick && !this.isArgumentAxis;\n\n    if (percentStick) {\n      if (1 === _abs(dataRange.max)) {\n        maxPadding = 0;\n      }\n\n      if (1 === _abs(dataRange.min)) {\n        minPadding = 0;\n      }\n    }\n\n    var canvasStartEnd = that._getCanvasStartEnd();\n\n    var commonMargin = 1 + (minPercentPadding || 0) + (maxPercentPadding || 0);\n    var screenDeltaWithMargins = (screenDelta - minPadding - maxPadding) / commonMargin || screenDelta;\n\n    if (void 0 !== minPercentPadding || void 0 !== maxPercentPadding) {\n      if (void 0 !== minPercentPadding) {\n        minPadding = screenDeltaWithMargins * minPercentPadding;\n      }\n\n      if (void 0 !== maxPercentPadding) {\n        maxPadding = screenDeltaWithMargins * maxPercentPadding;\n      }\n    }\n\n    var minValue;\n    var maxValue;\n\n    if (options.type !== _axes_constants2.default.discrete && ticks && ticks.length > 1 && !options.skipViewportExtending && !viewPort.action && false !== options.endOnTick) {\n      var length = ticks.length;\n      var firstTickPosition = translator.translate(ticks[0].value);\n      var lastTickPosition = translator.translate(ticks[length - 1].value);\n      var invertMultiplier = firstTickPosition > lastTickPosition ? -1 : 1;\n\n      var minTickPadding = _max(invertMultiplier * (canvasStartEnd.start - firstTickPosition), 0);\n\n      var maxTickPadding = _max(invertMultiplier * (lastTickPosition - canvasStartEnd.end), 0);\n\n      if (minTickPadding > minPadding || maxTickPadding > maxPadding) {\n        var commonPadding = maxTickPadding + minTickPadding;\n        var coeff = getConvertIntervalCoefficient(commonPadding);\n\n        if (minTickPadding >= minPadding) {\n          minValue = ticks[0].value;\n        }\n\n        if (maxTickPadding >= maxPadding) {\n          maxValue = ticks[length - 1].value;\n        }\n\n        minPadding = _max(minTickPadding, minPadding) / coeff;\n        maxPadding = _max(maxTickPadding, maxPadding) / coeff;\n      }\n    }\n\n    minPercentPadding = void 0 === minPercentPadding ? minPadding / screenDeltaWithMargins : minPercentPadding;\n    maxPercentPadding = void 0 === maxPercentPadding ? maxPadding / screenDeltaWithMargins : maxPercentPadding;\n\n    if (!isDiscrete) {\n      if (this._translator.isInverted()) {\n        minValue = (0, _type.isDefined)(minValue) ? minValue : translator.from(canvasStartEnd.start + screenDelta * minPercentPadding, -1);\n        maxValue = (0, _type.isDefined)(maxValue) ? maxValue : translator.from(canvasStartEnd.end - screenDelta * maxPercentPadding, 1);\n      } else {\n        minValue = (0, _type.isDefined)(minValue) ? minValue : translator.from(canvasStartEnd.start - screenDelta * minPercentPadding, -1);\n        maxValue = (0, _type.isDefined)(maxValue) ? maxValue : translator.from(canvasStartEnd.end + screenDelta * maxPercentPadding, 1);\n      }\n    }\n\n    function correctZeroLevel(minPoint, maxPoint) {\n      var minExpectedPadding = _abs(canvasStartEnd.start - minPoint);\n\n      var maxExpectedPadding = _abs(canvasStartEnd.end - maxPoint);\n\n      var coeff = getConvertIntervalCoefficient(minExpectedPadding + maxExpectedPadding);\n      minPadding = minExpectedPadding / coeff;\n      maxPadding = maxExpectedPadding / coeff;\n    }\n\n    if (!that.isArgumentAxis) {\n      if (minValue * dataRange.min <= 0 && minValue * dataRange.minVisible <= 0) {\n        correctZeroLevel(translator.translate(0), translator.translate(maxValue));\n        minValue = 0;\n      }\n\n      if (maxValue * dataRange.max <= 0 && maxValue * dataRange.maxVisible <= 0) {\n        correctZeroLevel(translator.translate(minValue), translator.translate(0));\n        maxValue = 0;\n      }\n    }\n\n    return {\n      startPadding: this._translator.isInverted() ? maxPadding : minPadding,\n      endPadding: this._translator.isInverted() ? minPadding : maxPadding,\n      minValue: minValue,\n      maxValue: maxValue,\n      interval: rangeInterval,\n      isSpacedMargin: minPadding === maxPadding && 0 !== minPadding\n    };\n  },\n  applyMargins: function applyMargins() {\n    if (this._isSynchronized) {\n      return;\n    }\n\n    var margins = this._calculateValueMargins(this._majorTicks);\n\n    var canvas = (0, _extend.extend)({}, this._canvas, {\n      startPadding: margins.startPadding,\n      endPadding: margins.endPadding\n    });\n\n    this._translator.updateCanvas(this._processCanvas(canvas));\n\n    if (isFinite(margins.interval)) {\n      var br = this._translator.getBusinessRange();\n\n      br.addRange({\n        interval: margins.interval\n      });\n\n      this._translator.updateBusinessRange(br);\n    }\n  },\n  _resetMargins: function _resetMargins() {\n    this._reinitTranslator(this._getViewportRange());\n\n    if (this._canvas) {\n      this._translator.updateCanvas(this._processCanvas(this._canvas));\n    }\n  },\n  _createConstantLines: function _createConstantLines() {\n    var _this = this;\n\n    var constantLines = (this._options.constantLines || []).map(function (o) {\n      return (0, _constant_line2.default)(_this, o);\n    });\n    this._outsideConstantLines = constantLines.filter(function (l) {\n      return \"outside\" === l.labelPosition;\n    });\n    this._insideConstantLines = constantLines.filter(function (l) {\n      return \"inside\" === l.labelPosition;\n    });\n  },\n  draw: function draw(canvas, borderOptions) {\n    var that = this;\n    var options = this._options;\n    that.borderOptions = borderOptions || {\n      visible: false\n    };\n\n    that._resetMargins();\n\n    that.createTicks(canvas);\n    that.applyMargins();\n\n    that._clearAxisGroups();\n\n    initTickCoords(that._majorTicks);\n    initTickCoords(that._minorTicks);\n    initTickCoords(that._boundaryTicks);\n\n    that._axisGroup.append(that._axesContainerGroup);\n\n    that._drawAxis();\n\n    that._drawTitle();\n\n    drawTickMarks(that._majorTicks, options.tick);\n    drawTickMarks(that._minorTicks, options.minorTick);\n    drawTickMarks(that._boundaryTicks, options.tick);\n\n    var drawGridLine = that._getGridLineDrawer();\n\n    drawGrids(that._majorTicks, drawGridLine);\n    drawGrids(that._minorTicks, drawGridLine);\n    callAction(that._majorTicks, \"drawLabel\", that._getViewportRange());\n\n    that._majorTicks.forEach(function (tick) {\n      tick.labelRotationAngle = 0;\n      tick.labelAlignment = void 0;\n      tick.labelOffset = 0;\n    });\n\n    callAction(that._outsideConstantLines.concat(that._insideConstantLines), \"draw\");\n    callAction(that._strips, \"draw\");\n    that._dateMarkers = that._drawDateMarkers() || [];\n    that._labelAxesGroup && that._axisStripLabelGroup.append(that._labelAxesGroup);\n    that._gridContainerGroup && that._axisGridGroup.append(that._gridContainerGroup);\n    that._stripsGroup && that._axisStripGroup.append(that._stripsGroup);\n\n    if (that._constantLinesGroup) {\n      that._axisConstantLineGroups.above.inside.append(that._constantLinesGroup.above);\n\n      that._axisConstantLineGroups.above.outside1.append(that._constantLinesGroup.above);\n\n      that._axisConstantLineGroups.above.outside2.append(that._constantLinesGroup.above);\n\n      that._axisConstantLineGroups.under.inside.append(that._constantLinesGroup.under);\n\n      that._axisConstantLineGroups.under.outside1.append(that._constantLinesGroup.under);\n\n      that._axisConstantLineGroups.under.outside2.append(that._constantLinesGroup.under);\n    }\n\n    that._measureTitle();\n\n    measureLabels(that._majorTicks);\n    var textWidth;\n    var textHeight;\n    var convertedTickInterval;\n    var tickInterval = that._tickInterval;\n\n    if ((0, _type.isDefined)(tickInterval)) {\n      convertedTickInterval = that.getTranslator().getInterval(\"datetime\" === options.dataType ? (0, _date.dateToMilliseconds)(tickInterval) : tickInterval);\n    }\n\n    var usefulSpace = (0, _type.isDefined)(options.placeholderSize) ? options.placeholderSize - options.label.indentFromAxis : void 0;\n\n    if (that._isHorizontal) {\n      textWidth = convertedTickInterval;\n      textHeight = usefulSpace;\n    } else {\n      textWidth = usefulSpace;\n      textHeight = convertedTickInterval;\n    }\n\n    var displayMode = that._validateDisplayMode(options.label.displayMode);\n\n    var overlappingMode = that._validateOverlappingMode(options.label.overlappingBehavior, displayMode);\n\n    var wordWrapMode = options.label.wordWrap || \"none\";\n    var overflowMode = options.label.textOverflow || \"none\";\n\n    if ((\"none\" !== wordWrapMode || \"none\" !== overflowMode) && displayMode !== ROTATE && overlappingMode !== ROTATE && \"auto\" !== overlappingMode) {\n      var correctByWidth = false;\n      var correctByHeight = false;\n\n      if (textWidth) {\n        if (that._majorTicks.some(function (tick) {\n          return tick.labelBBox.width > textWidth;\n        })) {\n          correctByWidth = true;\n        }\n      }\n\n      if (textHeight) {\n        if (that._majorTicks.some(function (tick) {\n          return tick.labelBBox.height > textHeight;\n        })) {\n          correctByHeight = true;\n        }\n      }\n\n      if (correctByWidth || correctByHeight) {\n        that._majorTicks.forEach(function (tick) {\n          tick.label && tick.label.setMaxSize(textWidth, textHeight, options.label);\n        });\n\n        measureLabels(that._majorTicks);\n      }\n    }\n\n    measureLabels(that._outsideConstantLines);\n    measureLabels(that._insideConstantLines);\n    measureLabels(that._strips);\n    measureLabels(that._dateMarkers);\n\n    that._adjustConstantLineLabels(that._insideConstantLines);\n\n    that._adjustStripLabels();\n\n    var offset = that._constantLabelOffset = that._adjustConstantLineLabels(that._outsideConstantLines);\n\n    if (!that._translator.getBusinessRange().isEmpty()) {\n      that._setLabelsPlacement();\n\n      offset = that._adjustLabels(offset);\n    }\n\n    offset = that._adjustDateMarkers(offset);\n\n    that._adjustTitle(offset);\n  },\n  _measureTitle: _common.noop,\n  animate: function animate() {\n    callAction(this._majorTicks, \"animateLabels\");\n  },\n  updateSize: function updateSize(canvas, animate) {\n    var updateTitle = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : true;\n    var that = this;\n    that.updateCanvas(canvas);\n\n    if (updateTitle) {\n      that._checkTitleOverflow();\n\n      that._measureTitle();\n\n      that._updateTitleCoords();\n    }\n\n    that._reinitTranslator(that._getViewportRange());\n\n    that.applyMargins();\n    var animationEnabled = !that._firstDrawing && animate;\n    var options = this._options;\n    initTickCoords(that._majorTicks);\n    initTickCoords(that._minorTicks);\n    initTickCoords(that._boundaryTicks);\n    cleanUpInvalidTicks(that._majorTicks);\n    cleanUpInvalidTicks(that._minorTicks);\n    cleanUpInvalidTicks(that._boundaryTicks);\n\n    if (this._axisElement) {\n      that._updateAxisElementPosition();\n    }\n\n    updateTicksPosition(that._majorTicks, options.tick, animationEnabled);\n    updateTicksPosition(that._minorTicks, options.minorTick, animationEnabled);\n    updateTicksPosition(that._boundaryTicks, options.tick);\n    callAction(that._majorTicks, \"updateLabelPosition\", animationEnabled);\n\n    that._outsideConstantLines.concat(that._insideConstantLines || []).forEach(function (l) {\n      return l.updatePosition(animationEnabled);\n    });\n\n    callAction(that._strips, \"updatePosition\", animationEnabled);\n    updateGridsPosition(that._majorTicks, animationEnabled);\n    updateGridsPosition(that._minorTicks, animationEnabled);\n\n    if (animationEnabled) {\n      callAction(that._ticksToRemove || [], \"fadeOutElements\");\n    }\n\n    that.prepareAnimation();\n    that._ticksToRemove = null;\n\n    if (!that._translator.getBusinessRange().isEmpty()) {\n      that._firstDrawing = false;\n    }\n  },\n  prepareAnimation: function prepareAnimation() {\n    var that = this;\n    var action = \"saveCoords\";\n    callAction(that._majorTicks, action);\n    callAction(that._minorTicks, action);\n    callAction(that._insideConstantLines, action);\n    callAction(that._outsideConstantLines, action);\n    callAction(that._strips, action);\n  },\n  applyClipRects: function applyClipRects(elementsClipID, canvasClipID) {\n    this._axisGroup.attr({\n      \"clip-path\": canvasClipID\n    });\n\n    this._axisStripGroup.attr({\n      \"clip-path\": elementsClipID\n    });\n  },\n  _mergeViewportOptions: function _mergeViewportOptions() {\n    var that = this;\n    var options = that._options;\n    var visualRange = {};\n    var visualRangeOptionValue = options._customVisualRange;\n\n    if (((0, _type.isDefined)(options.max) || (0, _type.isDefined)(options.min)) && !(0, _type.isDefined)(visualRangeOptionValue.startValue) && !(0, _type.isDefined)(visualRangeOptionValue.endValue) && !(0, _type.isDefined)(visualRangeOptionValue.length)) {\n      visualRange = {\n        startValue: options.min,\n        endValue: options.max\n      };\n    } else {\n      visualRange = visualRangeOptionValue;\n    }\n\n    that._setVisualRange(visualRange);\n  },\n  _validateVisualRange: function _validateVisualRange(visualRange) {\n    var range = getVizRangeObject(visualRange);\n\n    if (void 0 !== range.startValue) {\n      range.startValue = this.validateUnit(range.startValue);\n    }\n\n    if (void 0 !== range.endValue) {\n      range.endValue = this.validateUnit(range.endValue);\n    }\n\n    return convertVisualRangeObject(range, visualRange);\n  },\n  _validateOptions: function _validateOptions(options) {\n    var that = this;\n\n    if (void 0 !== options.min) {\n      options.min = that.validateUnit(options.min, \"E2106\");\n    }\n\n    if (void 0 !== options.max) {\n      options.max = that.validateUnit(options.max, \"E2106\");\n    }\n\n    options.wholeRange = that._validateVisualRange(options.wholeRange);\n    options.visualRange = options._customVisualRange = that._validateVisualRange(options._customVisualRange);\n\n    that._mergeViewportOptions();\n  },\n  validate: function validate() {\n    var that = this;\n    var options = that._options;\n    var dataType = that.isArgumentAxis ? options.argumentType : options.valueType;\n    var parser = dataType ? _parse_utils2.default.getParser(dataType) : function (unit) {\n      return unit;\n    };\n    that.parser = parser;\n    options.dataType = dataType;\n\n    that._validateOptions(options);\n  },\n  resetVisualRange: function resetVisualRange(isSilent) {\n    this._seriesData.minVisible = this._seriesData.min;\n    this._seriesData.maxVisible = this._seriesData.max;\n    this.handleZooming([null, null], {\n      start: !!isSilent,\n      end: !!isSilent\n    });\n  },\n  _setVisualRange: function _setVisualRange(visualRange, allowPartialUpdate) {\n    var range = this.adjustRange(_utils2.default.getVizRangeObject(visualRange));\n\n    if (allowPartialUpdate) {\n      (0, _type.isDefined)(range.startValue) && (this._viewport.startValue = range.startValue);\n      (0, _type.isDefined)(range.endValue) && (this._viewport.endValue = range.endValue);\n    } else {\n      this._viewport = range;\n    }\n  },\n  _applyZooming: function _applyZooming(visualRange, allowPartialUpdate) {\n    var that = this;\n\n    that._resetVisualRangeOption();\n\n    that._setVisualRange(visualRange, allowPartialUpdate);\n\n    var viewPort = that.getViewport();\n    that._breaks = that._getScaleBreaks(that._options, {\n      minVisible: viewPort.startValue,\n      maxVisible: viewPort.endValue\n    }, that._series, that.isArgumentAxis);\n\n    that._translator.updateBusinessRange(that._getViewportRange());\n  },\n  getZoomStartEventArg: function getZoomStartEventArg(event, actionType) {\n    return {\n      axis: this,\n      range: this.visualRange(),\n      cancel: false,\n      event: event,\n      actionType: actionType\n    };\n  },\n  getZoomEndEventArg: function getZoomEndEventArg(previousRange, event, actionType, zoomFactor, shift) {\n    var newRange = this.visualRange();\n    return {\n      axis: this,\n      previousRange: previousRange,\n      range: newRange,\n      cancel: false,\n      event: event,\n      actionType: actionType,\n      zoomFactor: zoomFactor,\n      shift: shift,\n      rangeStart: newRange.startValue,\n      rangeEnd: newRange.endValue\n    };\n  },\n  getZoomBounds: function getZoomBounds() {\n    var wholeRange = _utils2.default.getVizRangeObject(this._options.wholeRange);\n\n    var range = this.getTranslator().getBusinessRange();\n    var secondPriorityRange = {\n      startValue: getZoomBoundValue(this._initRange.startValue, range.min),\n      endValue: getZoomBoundValue(this._initRange.endValue, range.max)\n    };\n    return {\n      startValue: getZoomBoundValue(wholeRange.startValue, secondPriorityRange.startValue),\n      endValue: getZoomBoundValue(wholeRange.endValue, secondPriorityRange.endValue)\n    };\n  },\n  setInitRange: function setInitRange() {\n    this._initRange = {};\n\n    if (0 === Object.keys(this._options.wholeRange || {}).length) {\n      this._initRange = this.getZoomBounds();\n    }\n  },\n  _resetVisualRangeOption: function _resetVisualRangeOption() {\n    this._options._customVisualRange = {};\n  },\n  setCustomVisualRange: function setCustomVisualRange(range) {\n    this._options._customVisualRange = range;\n  },\n  visualRange: function visualRange() {\n    var that = this;\n    var args = arguments;\n    var visualRange;\n\n    if (0 === args.length) {\n      var adjustedRange = that._getAdjustedBusinessRange();\n\n      var startValue = adjustedRange.minVisible;\n      var endValue = adjustedRange.maxVisible;\n\n      if (that._options.type === _axes_constants2.default.discrete) {\n        startValue = (0, _type.isDefined)(startValue) ? startValue : adjustedRange.categories[0];\n        endValue = (0, _type.isDefined)(endValue) ? endValue : adjustedRange.categories[adjustedRange.categories.length - 1];\n        return {\n          startValue: startValue,\n          endValue: endValue,\n          categories: _utils2.default.getCategoriesInfo(adjustedRange.categories, startValue, endValue).categories\n        };\n      }\n\n      return {\n        startValue: startValue,\n        endValue: endValue\n      };\n    } else {\n      if (_isArray(args[0])) {\n        visualRange = args[0];\n      } else {\n        if ((0, _type.isPlainObject)(args[0])) {\n          visualRange = (0, _extend.extend)({}, args[0]);\n        } else {\n          visualRange = [args[0], args[1]];\n        }\n      }\n    }\n\n    var zoomResults = that.handleZooming(visualRange, args[1]);\n\n    if (!zoomResults.isPrevented) {\n      that._visualRange(that, zoomResults);\n    }\n  },\n  handleZooming: function handleZooming(visualRange, preventEvents, domEvent, action) {\n    var that = this;\n    preventEvents = preventEvents || {};\n\n    if ((0, _type.isDefined)(visualRange)) {\n      visualRange = that._validateVisualRange(visualRange);\n      visualRange.action = action;\n    }\n\n    var zoomStartEvent = that.getZoomStartEventArg(domEvent, action);\n    var previousRange = zoomStartEvent.range;\n    !preventEvents.start && that._eventTrigger(\"zoomStart\", zoomStartEvent);\n    var zoomResults = {\n      isPrevented: zoomStartEvent.cancel,\n      skipEventRising: preventEvents.skipEventRising,\n      range: visualRange || zoomStartEvent.range\n    };\n\n    if (!zoomStartEvent.cancel) {\n      (0, _type.isDefined)(visualRange) && that._applyZooming(visualRange, preventEvents.allowPartialUpdate);\n\n      if (!(0, _type.isDefined)(that._storedZoomEndParams)) {\n        that._storedZoomEndParams = {\n          startRange: previousRange,\n          type: this.getOptions().type\n        };\n      }\n\n      that._storedZoomEndParams.event = domEvent;\n      that._storedZoomEndParams.action = action;\n      that._storedZoomEndParams.prevent = !!preventEvents.end;\n    }\n\n    return zoomResults;\n  },\n  handleZoomEnd: function handleZoomEnd() {\n    var that = this;\n\n    if ((0, _type.isDefined)(that._storedZoomEndParams) && !that._storedZoomEndParams.prevent) {\n      var previousRange = that._storedZoomEndParams.startRange;\n      var domEvent = that._storedZoomEndParams.event;\n      var action = that._storedZoomEndParams.action;\n      var previousBusinessRange = {\n        minVisible: previousRange.startValue,\n        maxVisible: previousRange.endValue,\n        categories: previousRange.categories\n      };\n\n      var typeIsNotChanged = that.getOptions().type === that._storedZoomEndParams.type;\n\n      var shift = typeIsNotChanged ? (0, _math2.adjust)(that.getVisualRangeCenter() - that.getVisualRangeCenter(previousBusinessRange)) : NaN;\n      var zoomFactor = typeIsNotChanged ? +(Math.round(that.getVisualRangeLength(previousBusinessRange) / that.getVisualRangeLength() + \"e+2\") + \"e-2\") : NaN;\n      var zoomEndEvent = that.getZoomEndEventArg(previousRange, domEvent, action, zoomFactor, shift);\n      zoomEndEvent.cancel = that.isZoomingLowerLimitOvercome(1 === zoomFactor ? \"pan\" : \"zoom\", zoomFactor);\n\n      that._eventTrigger(\"zoomEnd\", zoomEndEvent);\n\n      if (zoomEndEvent.cancel) {\n        that.restorePreviousVisualRange(previousRange);\n      }\n\n      that._storedZoomEndParams = null;\n    }\n  },\n  restorePreviousVisualRange: function restorePreviousVisualRange(previousRange) {\n    var that = this;\n    that._storedZoomEndParams = null;\n\n    that._applyZooming(previousRange);\n\n    that._visualRange(that, previousRange);\n  },\n  isZoomingLowerLimitOvercome: function isZoomingLowerLimitOvercome(actionType, zoomFactor, range) {\n    var that = this;\n    var options = that._options;\n    var minZoom = options.minVisualRangeLength;\n    var isOvercoming = \"zoom\" === actionType && zoomFactor >= 1;\n\n    var businessRange = that._translator.getBusinessRange();\n\n    var visualRange;\n\n    if ((0, _type.isDefined)(range)) {\n      visualRange = that.adjustRange(_utils2.default.getVizRangeObject(range));\n      visualRange = {\n        minVisible: visualRange.startValue,\n        maxVisible: visualRange.endValue,\n        categories: businessRange.categories\n      };\n    }\n\n    var visualRangeLength = that.getVisualRangeLength(visualRange);\n\n    if (\"discrete\" !== options.type) {\n      if ((0, _type.isDefined)(minZoom)) {\n        if (\"datetime\" === options.dataType && !(0, _type.isNumeric)(minZoom)) {\n          minZoom = (0, _date.dateToMilliseconds)(minZoom);\n        }\n\n        isOvercoming &= minZoom >= visualRangeLength;\n      } else {\n        var canvasLength = that._translator.canvasLength;\n        var fullRange = {\n          minVisible: businessRange.min,\n          maxVisible: businessRange.max,\n          categories: businessRange.categories\n        };\n        isOvercoming &= that.getVisualRangeLength(fullRange) / canvasLength >= visualRangeLength;\n      }\n    } else {\n      !(0, _type.isDefined)(minZoom) && (minZoom = 1);\n      isOvercoming &= (0, _type.isDefined)(range) && that.getVisualRangeLength() === minZoom && visualRangeLength <= minZoom;\n    }\n\n    return !!isOvercoming;\n  },\n  dataVisualRangeIsReduced: function dataVisualRangeIsReduced() {\n    var minDataValue;\n    var maxDataValue;\n    var translator = this.getTranslator();\n\n    if (\"discrete\" === this._options.type) {\n      var categories = translator.getBusinessRange().categories;\n      minDataValue = categories[0];\n      maxDataValue = categories[categories.length - 1];\n    } else {\n      var seriesData = this._seriesData;\n      minDataValue = seriesData.min;\n      maxDataValue = seriesData.max;\n    }\n\n    if (!(0, _type.isDefined)(minDataValue) || !(0, _type.isDefined)(maxDataValue)) {\n      return false;\n    }\n\n    var startPoint = translator.translate(minDataValue);\n    var endPoint = translator.translate(maxDataValue);\n    var edges = [Math.min(startPoint, endPoint), Math.max(startPoint, endPoint)];\n    var visualRange = this.visualRange();\n    var visualRangeStartPoint = translator.translate(visualRange.startValue);\n    var visualRangeEndPoint = translator.translate(visualRange.endValue);\n    return visualRangeStartPoint > edges[0] && visualRangeStartPoint < edges[1] || visualRangeEndPoint > edges[0] && visualRangeEndPoint < edges[1] || visualRangeStartPoint === visualRangeEndPoint && edges[0] !== edges[1];\n  },\n  isExtremePosition: function isExtremePosition(isMax) {\n    var extremeDataValue;\n    var seriesData;\n\n    if (\"discrete\" === this._options.type) {\n      seriesData = this._translator.getBusinessRange();\n      extremeDataValue = isMax ? seriesData.categories[seriesData.categories.length - 1] : seriesData.categories[0];\n    } else {\n      seriesData = this.getZoomBounds();\n      extremeDataValue = isMax ? seriesData.endValue : seriesData.startValue;\n    }\n\n    var translator = this.getTranslator();\n    var extremePoint = translator.translate(extremeDataValue);\n    var visualRange = this.visualRange();\n    var visualRangePoint = isMax ? translator.translate(visualRange.endValue) : translator.translate(visualRange.startValue);\n    return _abs(visualRangePoint - extremePoint) < SCROLL_THRESHOLD;\n  },\n  getViewport: function getViewport() {\n    return this._viewport;\n  },\n  getFullTicks: function getFullTicks() {\n    var majors = this._majorTicks || [];\n\n    if (this._options.type === _axes_constants2.default.discrete) {\n      return convertTicksToValues(majors);\n    } else {\n      return convertTicksToValues(majors.concat(this._minorTicks, this._boundaryTicks)).sort(function (a, b) {\n        return valueOf(a) - valueOf(b);\n      });\n    }\n  },\n  measureLabels: function measureLabels(canvas, withIndents) {\n    var that = this;\n    var options = that._options;\n    var widthAxis = options.visible ? options.width : 0;\n    var ticks;\n    var maxText;\n    var text;\n    var box;\n    var indent = withIndents ? options.label.indentFromAxis + .5 * options.tick.length : 0;\n    var tickInterval;\n\n    var viewportRange = that._getViewportRange();\n\n    if (viewportRange.isEmpty() || !options.label.visible || !that._axisElementsGroup) {\n      return {\n        height: widthAxis,\n        width: widthAxis,\n        x: 0,\n        y: 0\n      };\n    }\n\n    if (that._majorTicks) {\n      ticks = convertTicksToValues(that._majorTicks);\n    } else {\n      this.updateCanvas(canvas);\n      ticks = that._createTicksAndLabelFormat(viewportRange, _common.noop);\n      tickInterval = ticks.tickInterval;\n      ticks = ticks.ticks;\n    }\n\n    maxText = ticks.reduce(function (prevLabel, tick, index) {\n      var label = that.formatLabel(tick, options.label, viewportRange, void 0, tickInterval, ticks);\n\n      if (prevLabel.length < label.length) {\n        return label;\n      } else {\n        return prevLabel;\n      }\n    }, that.formatLabel(ticks[0], options.label, viewportRange, void 0, tickInterval, ticks));\n    text = that._renderer.text(maxText, 0, 0).css(that._textFontStyles).attr(that._textOptions).append(that._renderer.root);\n    box = text.getBBox();\n    text.remove();\n    return {\n      x: box.x,\n      y: box.y,\n      width: box.width + indent,\n      height: box.height + indent\n    };\n  },\n  _setLabelsPlacement: function _setLabelsPlacement() {\n    if (!this._options.label.visible) {\n      return;\n    }\n\n    var that = this;\n    var labelOpt = that._options.label;\n\n    var displayMode = that._validateDisplayMode(labelOpt.displayMode);\n\n    var overlappingMode = that._validateOverlappingMode(labelOpt.overlappingBehavior, displayMode);\n\n    var ignoreOverlapping = \"none\" === overlappingMode || \"ignore\" === overlappingMode;\n    var behavior = {\n      rotationAngle: labelOpt.rotationAngle,\n      staggeringSpacing: labelOpt.staggeringSpacing\n    };\n    var notRecastStep;\n\n    var boxes = that._majorTicks.map(function (tick) {\n      return tick.labelBBox;\n    });\n\n    var step;\n    step = that._getStep(boxes);\n\n    switch (displayMode) {\n      case ROTATE:\n        if (ignoreOverlapping) {\n          notRecastStep = true;\n          step = 1;\n        }\n\n        that._applyLabelMode(displayMode, step, boxes, labelOpt, notRecastStep);\n\n        break;\n\n      case \"stagger\":\n        if (ignoreOverlapping) {\n          step = 2;\n        }\n\n        that._applyLabelMode(displayMode, _max(step, 2), boxes, labelOpt);\n\n        break;\n\n      default:\n        that._applyLabelOverlapping(boxes, overlappingMode, step, behavior);\n\n    }\n  },\n  _applyLabelOverlapping: function _applyLabelOverlapping(boxes, mode, step, behavior) {\n    var that = this;\n    var labelOpt = that._options.label;\n    var majorTicks = that._majorTicks;\n\n    if (\"none\" === mode || \"ignore\" === mode) {\n      return;\n    }\n\n    var checkLabels = function checkLabels(box, index, array) {\n      if (0 === index) {\n        return false;\n      }\n\n      return _axes_constants2.default.areLabelsOverlap(box, array[index - 1], labelOpt.minSpacing, labelOpt.alignment);\n    };\n\n    if (step > 1 && boxes.some(checkLabels)) {\n      that._applyLabelMode(mode, step, boxes, behavior);\n    }\n\n    that._checkBoundedLabelsOverlapping(majorTicks, boxes, mode);\n  },\n  _applyLabelMode: function _applyLabelMode(mode, step, boxes, behavior, notRecastStep) {\n    var that = this;\n    var majorTicks = that._majorTicks;\n    var labelOpt = that._options.label;\n    var angle = behavior.rotationAngle;\n    var labelHeight;\n    var alignment;\n    var func;\n\n    switch (mode) {\n      case ROTATE:\n        if (!labelOpt.userAlignment) {\n          alignment = angle < 0 ? RIGHT : LEFT;\n\n          if (angle % 90 === 0) {\n            alignment = CENTER;\n          }\n        }\n\n        step = notRecastStep ? step : that._getStep(boxes, angle);\n\n        func = function func(tick) {\n          tick.label.rotate(angle);\n          tick.labelRotationAngle = angle;\n          alignment && (tick.labelAlignment = alignment);\n        };\n\n        updateLabels(majorTicks, step, func);\n        break;\n\n      case \"stagger\":\n        labelHeight = that._getMaxLabelHeight(boxes, behavior.staggeringSpacing);\n\n        func = function func(tick, index) {\n          if (index / (step - 1) % 2 !== 0) {\n            tick.labelOffset = labelHeight;\n          }\n        };\n\n        updateLabels(majorTicks, step - 1, func);\n        break;\n\n      case \"auto\":\n      case \"_auto\":\n        if (2 === step) {\n          that._applyLabelMode(\"stagger\", step, boxes, behavior);\n        } else {\n          that._applyLabelMode(ROTATE, step, boxes, {\n            rotationAngle: getOptimalAngle(boxes, labelOpt)\n          });\n        }\n\n        break;\n\n      default:\n        updateLabels(majorTicks, step);\n    }\n  },\n  getMarkerTrackers: _common.noop,\n  _drawDateMarkers: _common.noop,\n  _adjustDateMarkers: _common.noop,\n  coordsIn: _common.noop,\n  areCoordsOutsideAxis: _common.noop,\n  _getSkippedCategory: _common.noop,\n  _initAxisPositions: _common.noop,\n  _drawTitle: _common.noop,\n  _updateTitleCoords: _common.noop,\n  _adjustConstantLineLabels: _common.noop,\n  _createTranslator: function _createTranslator() {\n    return new _translator2d2.default.Translator2D({}, {}, {});\n  },\n  _updateTranslator: function _updateTranslator() {\n    var translator = this._translator;\n    translator.update(translator.getBusinessRange(), this._canvas || {}, this._getTranslatorOptions());\n  },\n  _getTranslatorOptions: function _getTranslatorOptions() {\n    var options = this._options;\n    return {\n      isHorizontal: this._isHorizontal,\n      shiftZeroValue: !this.isArgumentAxis,\n      interval: options.semiDiscreteInterval,\n      stick: this._getStick(),\n      breaksSize: options.breakStyle ? options.breakStyle.width : 0\n    };\n  },\n  getVisibleArea: function getVisibleArea() {\n    var canvas = this._getCanvasStartEnd();\n\n    return [canvas.start, canvas.end].sort(function (a, b) {\n      return a - b;\n    });\n  },\n  _getCanvasStartEnd: function _getCanvasStartEnd() {\n    var isHorizontal = this._isHorizontal;\n    var canvas = this._canvas || {};\n\n    var invert = this._translator.getBusinessRange().invert;\n\n    var coords = isHorizontal ? [canvas.left, canvas.width - canvas.right] : [canvas.height - canvas.bottom, canvas.top];\n    invert && coords.reverse();\n    return {\n      start: coords[0],\n      end: coords[1]\n    };\n  },\n  _getScreenDelta: function _getScreenDelta() {\n    var that = this;\n\n    var canvas = that._getCanvasStartEnd();\n\n    var breaks = that._breaks;\n    var breaksLength = breaks ? breaks.length : 0;\n\n    var screenDelta = _abs(canvas.start - canvas.end);\n\n    return screenDelta - (breaksLength ? breaks[breaksLength - 1].cumulativeWidth : 0);\n  },\n  _getScaleBreaks: function _getScaleBreaks() {\n    return [];\n  },\n  _adjustTitle: _common.noop,\n  _checkTitleOverflow: _common.noop,\n  getSpiderTicks: _common.noop,\n  setSpiderTicks: _common.noop,\n  _checkBoundedLabelsOverlapping: _common.noop,\n  drawScaleBreaks: _common.noop,\n  _visualRange: _common.noop,\n  _rotateConstantLine: _common.noop,\n  applyVisualRangeSetter: function applyVisualRangeSetter(visualRangeSetter) {\n    this._visualRange = visualRangeSetter;\n  },\n  getCategoriesSorter: function getCategoriesSorter(argCategories) {\n    var sort;\n\n    if (this.isArgumentAxis) {\n      sort = argCategories;\n    } else {\n      var categoriesSortingMethod = this._options.categoriesSortingMethod;\n      sort = (0, _type.isDefined)(categoriesSortingMethod) ? categoriesSortingMethod : this._options.categories;\n    }\n\n    return sort;\n  },\n  _getAdjustedBusinessRange: function _getAdjustedBusinessRange() {\n    return this.adjustViewport(this._translator.getBusinessRange());\n  }\n};","map":null,"metadata":{},"sourceType":"script"}