{"ast":null,"code":"/**\r\n * DevExtreme (viz/core/series_family.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar isNumeric = require(\"../../core/utils/type\").isNumeric;\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar each = require(\"../../core/utils/iterator\").each;\n\nvar isDefined = require(\"../../core/utils/type\").isDefined;\n\nvar sign = require(\"../../core/utils/math\").sign;\n\nvar _math = Math;\nvar _round = _math.round;\nvar _abs = _math.abs;\nvar _pow = _math.pow;\nvar _each = each;\n\nvar _noop = require(\"../../core/utils/common\").noop;\n\nvar vizUtils = require(\"./utils\");\n\nvar DEFAULT_BAR_GROUP_PADDING = .3;\nvar _normalizeEnum = vizUtils.normalizeEnum;\n\nfunction validateBarPadding(barPadding) {\n  return barPadding < 0 || barPadding > 1 ? void 0 : barPadding;\n}\n\nfunction validateBarGroupPadding(barGroupPadding) {\n  return barGroupPadding < 0 || barGroupPadding > 1 ? DEFAULT_BAR_GROUP_PADDING : barGroupPadding;\n}\n\nfunction isStackExist(series, arg, equalBarWidth) {\n  return series.some(function (s) {\n    return equalBarWidth && !s.getOptions().ignoreEmptyPoints || s.getPointsByArg(arg, true).some(function (point) {\n      return point.hasValue();\n    });\n  });\n}\n\nfunction correctStackCoordinates(series, currentStacks, arg, stack, parameters, barsArea, seriesStackIndexCallback) {\n  series.forEach(function (series) {\n    var stackIndex = seriesStackIndexCallback(currentStacks.indexOf(stack), currentStacks.length);\n    var points = series.getPointsByArg(arg, true);\n    var barPadding = validateBarPadding(series.getOptions().barPadding);\n    var barWidth = series.getOptions().barWidth;\n    var offset = getOffset(stackIndex, parameters);\n    var width = parameters.width;\n    var extraParameters;\n\n    if (stackIndex === -1) {\n      return;\n    }\n\n    if (isDefined(barPadding) || isDefined(barWidth)) {\n      extraParameters = calculateParams(barsArea, currentStacks.length, 1 - barPadding, barWidth);\n      width = extraParameters.width;\n      offset = getOffset(stackIndex, extraParameters);\n    }\n\n    correctPointCoordinates(points, width, offset);\n  });\n}\n\nfunction adjustBarSeriesDimensionsCore(series, options, seriesStackIndexCallback) {\n  var commonStacks = [];\n  var allArguments = [];\n  var seriesInStacks = {};\n  var barWidth = options.barWidth;\n  var barGroupWidth = options.barGroupWidth;\n  var interval = series[0] && series[0].getArgumentAxis().getTranslator().getInterval();\n  var barsArea = barGroupWidth ? interval > barGroupWidth ? barGroupWidth : interval : interval * (1 - validateBarGroupPadding(options.barGroupPadding));\n  series.forEach(function (s, i) {\n    var stackName = s.getStackName() || s.getBarOverlapGroup() || i.toString();\n    var argument;\n\n    for (argument in s.pointsByArgument) {\n      if (allArguments.indexOf(argument.valueOf()) === -1) {\n        allArguments.push(argument.valueOf());\n      }\n    }\n\n    if (commonStacks.indexOf(stackName) === -1) {\n      commonStacks.push(stackName);\n      seriesInStacks[stackName] = [];\n    }\n\n    seriesInStacks[stackName].push(s);\n  });\n  allArguments.forEach(function (arg) {\n    var currentStacks = commonStacks.reduce(function (stacks, stack) {\n      if (isStackExist(seriesInStacks[stack], arg, options.equalBarWidth)) {\n        stacks.push(stack);\n      }\n\n      return stacks;\n    }, []);\n    var parameters = calculateParams(barsArea, currentStacks.length, barWidth);\n    commonStacks.forEach(function (stack) {\n      correctStackCoordinates(seriesInStacks[stack], currentStacks, arg, stack, parameters, barsArea, seriesStackIndexCallback);\n    });\n  });\n}\n\nfunction calculateParams(barsArea, count, percentWidth, fixedBarWidth) {\n  var spacing;\n  var width;\n\n  if (fixedBarWidth) {\n    width = Math.min(fixedBarWidth, _round(barsArea / count));\n    spacing = count > 1 ? _round((barsArea - width * count) / (count - 1)) : 0;\n  } else {\n    if (isDefined(percentWidth)) {\n      width = _round(barsArea * percentWidth / count);\n      spacing = _round(count > 1 ? (barsArea - barsArea * percentWidth) / (count - 1) : 0);\n    } else {\n      spacing = _round(barsArea / count * .2);\n      width = _round((barsArea - spacing * (count - 1)) / count);\n    }\n  }\n\n  return {\n    width: width > 1 ? width : 1,\n    spacing: spacing,\n    middleIndex: count / 2\n  };\n}\n\nfunction getOffset(stackIndex, parameters) {\n  return (stackIndex - parameters.middleIndex + .5) * parameters.width - (parameters.middleIndex - stackIndex - .5) * parameters.spacing;\n}\n\nfunction correctPointCoordinates(points, width, offset) {\n  _each(points, function (_, point) {\n    point.correctCoordinates({\n      width: width,\n      offset: offset\n    });\n  });\n}\n\nfunction getValueType(value) {\n  return value >= 0 ? \"positive\" : \"negative\";\n}\n\nfunction getVisibleSeries(that) {\n  return that.series.filter(function (s) {\n    return s.isVisible();\n  });\n}\n\nfunction getAbsStackSumByArg(stackKeepers, stackName, argument) {\n  var positiveStackValue = (stackKeepers.positive[stackName] || {})[argument] || 0;\n  var negativeStackValue = -(stackKeepers.negative[stackName] || {})[argument] || 0;\n  return positiveStackValue + negativeStackValue;\n}\n\nfunction getStackSumByArg(stackKeepers, stackName, argument) {\n  var positiveStackValue = (stackKeepers.positive[stackName] || {})[argument] || 0;\n  var negativeStackValue = (stackKeepers.negative[stackName] || {})[argument] || 0;\n  return positiveStackValue + negativeStackValue;\n}\n\nfunction getSeriesStackIndexCallback(inverted) {\n  if (!inverted) {\n    return function (index) {\n      return index;\n    };\n  } else {\n    return function (index, stackCount) {\n      return stackCount - index - 1;\n    };\n  }\n}\n\nfunction isInverted(series) {\n  return series[0] && series[0].getArgumentAxis().getTranslator().isInverted();\n}\n\nfunction adjustBarSeriesDimensions() {\n  var series = getVisibleSeries(this);\n  adjustBarSeriesDimensionsCore(series, this._options, getSeriesStackIndexCallback(isInverted(series)));\n}\n\nfunction getFirstValueSign(series) {\n  var points = series.getPoints();\n  var value;\n\n  for (var i = 0; i < points.length; i++) {\n    var point = points[i];\n    value = point.initialValue && point.initialValue.valueOf();\n\n    if (Math.abs(value) > 0) {\n      break;\n    }\n  }\n\n  return sign(value);\n}\n\nfunction adjustStackedSeriesValues() {\n  var that = this;\n  var negativesAsZeroes = that._options.negativesAsZeroes;\n  var series = getVisibleSeries(that);\n  var stackKeepers = {\n    positive: {},\n    negative: {}\n  };\n  var holesStack = {\n    left: {},\n    right: {}\n  };\n  var lastSeriesInPositiveStack = {};\n  var lastSeriesInNegativeStack = {};\n  series.forEach(function (singleSeries) {\n    var stackName = singleSeries.getStackName() || singleSeries.getBarOverlapGroup();\n    var hole = false;\n    var stack = getFirstValueSign(singleSeries) < 0 ? lastSeriesInNegativeStack : lastSeriesInPositiveStack;\n    singleSeries._prevSeries = stack[stackName];\n    stack[stackName] = singleSeries;\n    singleSeries.holes = extend(true, {}, holesStack);\n    singleSeries.getPoints().forEach(function (point, index, points) {\n      var value = point.initialValue && point.initialValue.valueOf();\n      var argument = point.argument.valueOf();\n      var stacks = value >= 0 ? stackKeepers.positive : stackKeepers.negative;\n      var isNotBarSeries = \"bar\" !== singleSeries.type;\n      var currentStack;\n\n      if (negativesAsZeroes && value < 0) {\n        stacks = stackKeepers.positive;\n        value = 0;\n        point.resetValue();\n      }\n\n      stacks[stackName] = stacks[stackName] || {};\n      currentStack = stacks[stackName];\n\n      if (currentStack[argument]) {\n        if (isNotBarSeries) {\n          point.correctValue(currentStack[argument]);\n        }\n\n        currentStack[argument] += value;\n      } else {\n        currentStack[argument] = value;\n\n        if (isNotBarSeries) {\n          point.resetCorrection();\n        }\n      }\n\n      if (!point.hasValue()) {\n        var prevPoint = points[index - 1];\n\n        if (!hole && prevPoint && prevPoint.hasValue()) {\n          argument = prevPoint.argument.valueOf();\n          prevPoint._skipSetRightHole = true;\n          holesStack.right[argument] = (holesStack.right[argument] || 0) + (prevPoint.value.valueOf() - (isFinite(prevPoint.minValue) ? prevPoint.minValue.valueOf() : 0));\n        }\n\n        hole = true;\n      } else {\n        if (hole) {\n          hole = false;\n          holesStack.left[argument] = (holesStack.left[argument] || 0) + (point.value.valueOf() - (isFinite(point.minValue) ? point.minValue.valueOf() : 0));\n          point._skipSetLeftHole = true;\n        }\n      }\n    });\n  });\n  series.forEach(function (singleSeries) {\n    var holes = singleSeries.holes;\n    singleSeries.getPoints().forEach(function (point) {\n      var argument = point.argument.valueOf();\n      point.resetHoles();\n      !point._skipSetLeftHole && point.setHole(holes.left[argument] || holesStack.left[argument] && 0, \"left\");\n      !point._skipSetRightHole && point.setHole(holes.right[argument] || holesStack.right[argument] && 0, \"right\");\n      point._skipSetLeftHole = null;\n      point._skipSetRightHole = null;\n    });\n  });\n  that._stackKeepers = stackKeepers;\n  series.forEach(function (singleSeries) {\n    singleSeries.getPoints().forEach(function (point) {\n      var argument = point.argument.valueOf();\n      var stackName = singleSeries.getStackName() || singleSeries.getBarOverlapGroup();\n      var absTotal = getAbsStackSumByArg(stackKeepers, stackName, argument);\n      var total = getStackSumByArg(stackKeepers, stackName, argument);\n      point.setPercentValue(absTotal, total, holesStack.left[argument], holesStack.right[argument]);\n    });\n  });\n}\n\nfunction updateStackedSeriesValues() {\n  var that = this;\n  var series = getVisibleSeries(that);\n  var stack = that._stackKeepers;\n  var stackKeepers = {\n    positive: {},\n    negative: {}\n  };\n\n  _each(series, function (_, singleSeries) {\n    var minBarSize = singleSeries.getOptions().minBarSize;\n    var valueAxisTranslator = singleSeries.getValueAxis().getTranslator();\n    var minShownBusinessValue = minBarSize && valueAxisTranslator.getMinBarSize(minBarSize);\n    var stackName = singleSeries.getStackName();\n\n    _each(singleSeries.getPoints(), function (index, point) {\n      if (!point.hasValue()) {\n        return;\n      }\n\n      var value = point.initialValue && point.initialValue.valueOf();\n      var argument = point.argument.valueOf();\n      var updateValue;\n      var valueType;\n      var currentStack;\n\n      if (that.fullStacked) {\n        value = value / getAbsStackSumByArg(stack, stackName, argument) || 0;\n      }\n\n      updateValue = valueAxisTranslator.checkMinBarSize(value, minShownBusinessValue, point.value);\n      valueType = getValueType(updateValue);\n      currentStack = stackKeepers[valueType][stackName] = stackKeepers[valueType][stackName] || {};\n\n      if (currentStack[argument]) {\n        point.minValue = currentStack[argument];\n        currentStack[argument] += updateValue;\n      } else {\n        currentStack[argument] = updateValue;\n      }\n\n      point.value = currentStack[argument];\n    });\n  });\n\n  if (that.fullStacked) {\n    updateFullStackedSeriesValues(series, stackKeepers);\n  }\n}\n\nfunction updateFullStackedSeriesValues(series, stackKeepers) {\n  _each(series, function (_, singleSeries) {\n    var stackName = singleSeries.getStackName ? singleSeries.getStackName() : \"default\";\n\n    _each(singleSeries.getPoints(), function (index, point) {\n      var stackSum = getAbsStackSumByArg(stackKeepers, stackName, point.argument.valueOf());\n      point.value = point.value / stackSum;\n\n      if (isNumeric(point.minValue)) {\n        point.minValue = point.minValue / stackSum;\n      }\n    });\n  });\n}\n\nfunction updateBarSeriesValues() {\n  _each(this.series, function (_, singleSeries) {\n    var minBarSize = singleSeries.getOptions().minBarSize;\n    var valueAxisTranslator = singleSeries.getValueAxis().getTranslator();\n    var minShownBusinessValue = minBarSize && valueAxisTranslator.getMinBarSize(minBarSize);\n\n    if (minShownBusinessValue) {\n      _each(singleSeries.getPoints(), function (index, point) {\n        if (point.hasValue()) {\n          point.value = valueAxisTranslator.checkMinBarSize(point.initialValue, minShownBusinessValue);\n        }\n      });\n    }\n  });\n}\n\nfunction adjustCandlestickSeriesDimensions() {\n  var series = getVisibleSeries(this);\n  adjustBarSeriesDimensionsCore(series, {\n    barWidth: null,\n    equalBarWidth: true,\n    barGroupPadding: .3\n  }, getSeriesStackIndexCallback(isInverted(series)));\n}\n\nfunction adjustBubbleSeriesDimensions() {\n  var series = getVisibleSeries(this);\n\n  if (!series.length) {\n    return;\n  }\n\n  var options = this._options;\n  var visibleAreaX = series[0].getArgumentAxis().getVisibleArea();\n  var visibleAreaY = series[0].getValueAxis().getVisibleArea();\n\n  var min = _math.min(visibleAreaX[1] - visibleAreaX[0], visibleAreaY[1] - visibleAreaY[0]);\n\n  var minBubbleArea = _pow(options.minBubbleSize, 2);\n\n  var maxBubbleArea = _pow(min * options.maxBubbleSize, 2);\n\n  var equalBubbleSize = (min * options.maxBubbleSize + options.minBubbleSize) / 2;\n  var minPointSize = 1 / 0;\n  var maxPointSize = -(1 / 0);\n  var pointSize;\n  var bubbleArea;\n  var sizeProportion;\n  var sizeDispersion;\n  var areaDispersion;\n\n  _each(series, function (_, seriesItem) {\n    _each(seriesItem.getPoints(), function (_, point) {\n      maxPointSize = maxPointSize > point.size ? maxPointSize : point.size;\n      minPointSize = minPointSize < point.size ? minPointSize : point.size;\n    });\n  });\n\n  sizeDispersion = maxPointSize - minPointSize;\n  areaDispersion = _abs(maxBubbleArea - minBubbleArea);\n\n  _each(series, function (_, seriesItem) {\n    _each(seriesItem.getPoints(), function (_, point) {\n      if (maxPointSize === minPointSize) {\n        pointSize = _round(equalBubbleSize);\n      } else {\n        sizeProportion = _abs(point.size - minPointSize) / sizeDispersion;\n        bubbleArea = areaDispersion * sizeProportion + minBubbleArea;\n        pointSize = _round(_math.sqrt(bubbleArea));\n      }\n\n      point.correctCoordinates(pointSize);\n    });\n  });\n}\n\nfunction SeriesFamily(options) {\n  var that = this;\n  that.type = _normalizeEnum(options.type);\n  that.pane = options.pane;\n  that.series = [];\n  that.updateOptions(options);\n\n  switch (that.type) {\n    case \"bar\":\n      that.adjustSeriesDimensions = adjustBarSeriesDimensions;\n      that.updateSeriesValues = updateBarSeriesValues;\n      that.adjustSeriesValues = adjustStackedSeriesValues;\n      break;\n\n    case \"rangebar\":\n      that.adjustSeriesDimensions = adjustBarSeriesDimensions;\n      break;\n\n    case \"fullstackedbar\":\n      that.fullStacked = true;\n      that.adjustSeriesDimensions = adjustBarSeriesDimensions;\n      that.adjustSeriesValues = adjustStackedSeriesValues;\n      that.updateSeriesValues = updateStackedSeriesValues;\n      break;\n\n    case \"stackedbar\":\n      that.adjustSeriesDimensions = adjustBarSeriesDimensions;\n      that.adjustSeriesValues = adjustStackedSeriesValues;\n      that.updateSeriesValues = updateStackedSeriesValues;\n      break;\n\n    case \"fullstackedarea\":\n    case \"fullstackedline\":\n    case \"fullstackedspline\":\n    case \"fullstackedsplinearea\":\n      that.fullStacked = true;\n      that.adjustSeriesValues = adjustStackedSeriesValues;\n      break;\n\n    case \"stackedarea\":\n    case \"stackedsplinearea\":\n    case \"stackedline\":\n    case \"stackedspline\":\n      that.adjustSeriesValues = adjustStackedSeriesValues;\n      break;\n\n    case \"candlestick\":\n    case \"stock\":\n      that.adjustSeriesDimensions = adjustCandlestickSeriesDimensions;\n      break;\n\n    case \"bubble\":\n      that.adjustSeriesDimensions = adjustBubbleSeriesDimensions;\n  }\n}\n\nexports.SeriesFamily = SeriesFamily;\nSeriesFamily.prototype = {\n  constructor: SeriesFamily,\n  adjustSeriesDimensions: _noop,\n  adjustSeriesValues: _noop,\n  updateSeriesValues: _noop,\n  updateOptions: function updateOptions(options) {\n    this._options = options;\n  },\n  dispose: function dispose() {\n    this.series = null;\n  },\n  add: function add(series) {\n    var type = this.type;\n    this.series = vizUtils.map(series, function (singleSeries) {\n      return singleSeries.type === type ? singleSeries : null;\n    });\n  }\n};","map":{"version":3,"sources":["C:/Users/User/Documents/Templates/Angular/black-dashboard-pro-angular-v1.1.1/black-dashboard-pro-angular-v1.1.1/node_modules/devextreme/viz/core/series_family.js"],"names":["isNumeric","require","extend","each","isDefined","sign","_math","Math","_round","round","_abs","abs","_pow","pow","_each","_noop","noop","vizUtils","DEFAULT_BAR_GROUP_PADDING","_normalizeEnum","normalizeEnum","validateBarPadding","barPadding","validateBarGroupPadding","barGroupPadding","isStackExist","series","arg","equalBarWidth","some","s","getOptions","ignoreEmptyPoints","getPointsByArg","point","hasValue","correctStackCoordinates","currentStacks","stack","parameters","barsArea","seriesStackIndexCallback","forEach","stackIndex","indexOf","length","points","barWidth","offset","getOffset","width","extraParameters","calculateParams","correctPointCoordinates","adjustBarSeriesDimensionsCore","options","commonStacks","allArguments","seriesInStacks","barGroupWidth","interval","getArgumentAxis","getTranslator","getInterval","i","stackName","getStackName","getBarOverlapGroup","toString","argument","pointsByArgument","valueOf","push","reduce","stacks","count","percentWidth","fixedBarWidth","spacing","min","middleIndex","_","correctCoordinates","getValueType","value","getVisibleSeries","that","filter","isVisible","getAbsStackSumByArg","stackKeepers","positiveStackValue","positive","negativeStackValue","negative","getStackSumByArg","getSeriesStackIndexCallback","inverted","index","stackCount","isInverted","adjustBarSeriesDimensions","_options","getFirstValueSign","getPoints","initialValue","adjustStackedSeriesValues","negativesAsZeroes","holesStack","left","right","lastSeriesInPositiveStack","lastSeriesInNegativeStack","singleSeries","hole","_prevSeries","holes","isNotBarSeries","type","currentStack","resetValue","correctValue","resetCorrection","prevPoint","_skipSetRightHole","isFinite","minValue","_skipSetLeftHole","resetHoles","setHole","_stackKeepers","absTotal","total","setPercentValue","updateStackedSeriesValues","minBarSize","valueAxisTranslator","getValueAxis","minShownBusinessValue","getMinBarSize","updateValue","valueType","fullStacked","checkMinBarSize","updateFullStackedSeriesValues","stackSum","updateBarSeriesValues","adjustCandlestickSeriesDimensions","adjustBubbleSeriesDimensions","visibleAreaX","getVisibleArea","visibleAreaY","minBubbleArea","minBubbleSize","maxBubbleArea","maxBubbleSize","equalBubbleSize","minPointSize","maxPointSize","pointSize","bubbleArea","sizeProportion","sizeDispersion","areaDispersion","seriesItem","size","sqrt","SeriesFamily","pane","updateOptions","adjustSeriesDimensions","updateSeriesValues","adjustSeriesValues","exports","prototype","constructor","dispose","add","map"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (viz/core/series_family.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nvar isNumeric = require(\"../../core/utils/type\").isNumeric;\r\nvar extend = require(\"../../core/utils/extend\").extend;\r\nvar each = require(\"../../core/utils/iterator\").each;\r\nvar isDefined = require(\"../../core/utils/type\").isDefined;\r\nvar sign = require(\"../../core/utils/math\").sign;\r\nvar _math = Math;\r\nvar _round = _math.round;\r\nvar _abs = _math.abs;\r\nvar _pow = _math.pow;\r\nvar _each = each;\r\nvar _noop = require(\"../../core/utils/common\").noop;\r\nvar vizUtils = require(\"./utils\");\r\nvar DEFAULT_BAR_GROUP_PADDING = .3;\r\nvar _normalizeEnum = vizUtils.normalizeEnum;\r\n\r\nfunction validateBarPadding(barPadding) {\r\n    return barPadding < 0 || barPadding > 1 ? void 0 : barPadding\r\n}\r\n\r\nfunction validateBarGroupPadding(barGroupPadding) {\r\n    return barGroupPadding < 0 || barGroupPadding > 1 ? DEFAULT_BAR_GROUP_PADDING : barGroupPadding\r\n}\r\n\r\nfunction isStackExist(series, arg, equalBarWidth) {\r\n    return series.some(function(s) {\r\n        return equalBarWidth && !s.getOptions().ignoreEmptyPoints || s.getPointsByArg(arg, true).some(function(point) {\r\n            return point.hasValue()\r\n        })\r\n    })\r\n}\r\n\r\nfunction correctStackCoordinates(series, currentStacks, arg, stack, parameters, barsArea, seriesStackIndexCallback) {\r\n    series.forEach(function(series) {\r\n        var stackIndex = seriesStackIndexCallback(currentStacks.indexOf(stack), currentStacks.length);\r\n        var points = series.getPointsByArg(arg, true);\r\n        var barPadding = validateBarPadding(series.getOptions().barPadding);\r\n        var barWidth = series.getOptions().barWidth;\r\n        var offset = getOffset(stackIndex, parameters);\r\n        var width = parameters.width;\r\n        var extraParameters;\r\n        if (stackIndex === -1) {\r\n            return\r\n        }\r\n        if (isDefined(barPadding) || isDefined(barWidth)) {\r\n            extraParameters = calculateParams(barsArea, currentStacks.length, 1 - barPadding, barWidth);\r\n            width = extraParameters.width;\r\n            offset = getOffset(stackIndex, extraParameters)\r\n        }\r\n        correctPointCoordinates(points, width, offset)\r\n    })\r\n}\r\n\r\nfunction adjustBarSeriesDimensionsCore(series, options, seriesStackIndexCallback) {\r\n    var commonStacks = [];\r\n    var allArguments = [];\r\n    var seriesInStacks = {};\r\n    var barWidth = options.barWidth;\r\n    var barGroupWidth = options.barGroupWidth;\r\n    var interval = series[0] && series[0].getArgumentAxis().getTranslator().getInterval();\r\n    var barsArea = barGroupWidth ? interval > barGroupWidth ? barGroupWidth : interval : interval * (1 - validateBarGroupPadding(options.barGroupPadding));\r\n    series.forEach(function(s, i) {\r\n        var stackName = s.getStackName() || s.getBarOverlapGroup() || i.toString();\r\n        var argument;\r\n        for (argument in s.pointsByArgument) {\r\n            if (allArguments.indexOf(argument.valueOf()) === -1) {\r\n                allArguments.push(argument.valueOf())\r\n            }\r\n        }\r\n        if (commonStacks.indexOf(stackName) === -1) {\r\n            commonStacks.push(stackName);\r\n            seriesInStacks[stackName] = []\r\n        }\r\n        seriesInStacks[stackName].push(s)\r\n    });\r\n    allArguments.forEach(function(arg) {\r\n        var currentStacks = commonStacks.reduce(function(stacks, stack) {\r\n            if (isStackExist(seriesInStacks[stack], arg, options.equalBarWidth)) {\r\n                stacks.push(stack)\r\n            }\r\n            return stacks\r\n        }, []);\r\n        var parameters = calculateParams(barsArea, currentStacks.length, barWidth);\r\n        commonStacks.forEach(function(stack) {\r\n            correctStackCoordinates(seriesInStacks[stack], currentStacks, arg, stack, parameters, barsArea, seriesStackIndexCallback)\r\n        })\r\n    })\r\n}\r\n\r\nfunction calculateParams(barsArea, count, percentWidth, fixedBarWidth) {\r\n    var spacing;\r\n    var width;\r\n    if (fixedBarWidth) {\r\n        width = Math.min(fixedBarWidth, _round(barsArea / count));\r\n        spacing = count > 1 ? _round((barsArea - width * count) / (count - 1)) : 0\r\n    } else {\r\n        if (isDefined(percentWidth)) {\r\n            width = _round(barsArea * percentWidth / count);\r\n            spacing = _round(count > 1 ? (barsArea - barsArea * percentWidth) / (count - 1) : 0)\r\n        } else {\r\n            spacing = _round(barsArea / count * .2);\r\n            width = _round((barsArea - spacing * (count - 1)) / count)\r\n        }\r\n    }\r\n    return {\r\n        width: width > 1 ? width : 1,\r\n        spacing: spacing,\r\n        middleIndex: count / 2\r\n    }\r\n}\r\n\r\nfunction getOffset(stackIndex, parameters) {\r\n    return (stackIndex - parameters.middleIndex + .5) * parameters.width - (parameters.middleIndex - stackIndex - .5) * parameters.spacing\r\n}\r\n\r\nfunction correctPointCoordinates(points, width, offset) {\r\n    _each(points, function(_, point) {\r\n        point.correctCoordinates({\r\n            width: width,\r\n            offset: offset\r\n        })\r\n    })\r\n}\r\n\r\nfunction getValueType(value) {\r\n    return value >= 0 ? \"positive\" : \"negative\"\r\n}\r\n\r\nfunction getVisibleSeries(that) {\r\n    return that.series.filter(function(s) {\r\n        return s.isVisible()\r\n    })\r\n}\r\n\r\nfunction getAbsStackSumByArg(stackKeepers, stackName, argument) {\r\n    var positiveStackValue = (stackKeepers.positive[stackName] || {})[argument] || 0;\r\n    var negativeStackValue = -(stackKeepers.negative[stackName] || {})[argument] || 0;\r\n    return positiveStackValue + negativeStackValue\r\n}\r\n\r\nfunction getStackSumByArg(stackKeepers, stackName, argument) {\r\n    var positiveStackValue = (stackKeepers.positive[stackName] || {})[argument] || 0;\r\n    var negativeStackValue = (stackKeepers.negative[stackName] || {})[argument] || 0;\r\n    return positiveStackValue + negativeStackValue\r\n}\r\n\r\nfunction getSeriesStackIndexCallback(inverted) {\r\n    if (!inverted) {\r\n        return function(index) {\r\n            return index\r\n        }\r\n    } else {\r\n        return function(index, stackCount) {\r\n            return stackCount - index - 1\r\n        }\r\n    }\r\n}\r\n\r\nfunction isInverted(series) {\r\n    return series[0] && series[0].getArgumentAxis().getTranslator().isInverted()\r\n}\r\n\r\nfunction adjustBarSeriesDimensions() {\r\n    var series = getVisibleSeries(this);\r\n    adjustBarSeriesDimensionsCore(series, this._options, getSeriesStackIndexCallback(isInverted(series)))\r\n}\r\n\r\nfunction getFirstValueSign(series) {\r\n    var points = series.getPoints();\r\n    var value;\r\n    for (var i = 0; i < points.length; i++) {\r\n        var point = points[i];\r\n        value = point.initialValue && point.initialValue.valueOf();\r\n        if (Math.abs(value) > 0) {\r\n            break\r\n        }\r\n    }\r\n    return sign(value)\r\n}\r\n\r\nfunction adjustStackedSeriesValues() {\r\n    var that = this;\r\n    var negativesAsZeroes = that._options.negativesAsZeroes;\r\n    var series = getVisibleSeries(that);\r\n    var stackKeepers = {\r\n        positive: {},\r\n        negative: {}\r\n    };\r\n    var holesStack = {\r\n        left: {},\r\n        right: {}\r\n    };\r\n    var lastSeriesInPositiveStack = {};\r\n    var lastSeriesInNegativeStack = {};\r\n    series.forEach(function(singleSeries) {\r\n        var stackName = singleSeries.getStackName() || singleSeries.getBarOverlapGroup();\r\n        var hole = false;\r\n        var stack = getFirstValueSign(singleSeries) < 0 ? lastSeriesInNegativeStack : lastSeriesInPositiveStack;\r\n        singleSeries._prevSeries = stack[stackName];\r\n        stack[stackName] = singleSeries;\r\n        singleSeries.holes = extend(true, {}, holesStack);\r\n        singleSeries.getPoints().forEach(function(point, index, points) {\r\n            var value = point.initialValue && point.initialValue.valueOf();\r\n            var argument = point.argument.valueOf();\r\n            var stacks = value >= 0 ? stackKeepers.positive : stackKeepers.negative;\r\n            var isNotBarSeries = \"bar\" !== singleSeries.type;\r\n            var currentStack;\r\n            if (negativesAsZeroes && value < 0) {\r\n                stacks = stackKeepers.positive;\r\n                value = 0;\r\n                point.resetValue()\r\n            }\r\n            stacks[stackName] = stacks[stackName] || {};\r\n            currentStack = stacks[stackName];\r\n            if (currentStack[argument]) {\r\n                if (isNotBarSeries) {\r\n                    point.correctValue(currentStack[argument])\r\n                }\r\n                currentStack[argument] += value\r\n            } else {\r\n                currentStack[argument] = value;\r\n                if (isNotBarSeries) {\r\n                    point.resetCorrection()\r\n                }\r\n            }\r\n            if (!point.hasValue()) {\r\n                var prevPoint = points[index - 1];\r\n                if (!hole && prevPoint && prevPoint.hasValue()) {\r\n                    argument = prevPoint.argument.valueOf();\r\n                    prevPoint._skipSetRightHole = true;\r\n                    holesStack.right[argument] = (holesStack.right[argument] || 0) + (prevPoint.value.valueOf() - (isFinite(prevPoint.minValue) ? prevPoint.minValue.valueOf() : 0))\r\n                }\r\n                hole = true\r\n            } else {\r\n                if (hole) {\r\n                    hole = false;\r\n                    holesStack.left[argument] = (holesStack.left[argument] || 0) + (point.value.valueOf() - (isFinite(point.minValue) ? point.minValue.valueOf() : 0));\r\n                    point._skipSetLeftHole = true\r\n                }\r\n            }\r\n        })\r\n    });\r\n    series.forEach(function(singleSeries) {\r\n        var holes = singleSeries.holes;\r\n        singleSeries.getPoints().forEach(function(point) {\r\n            var argument = point.argument.valueOf();\r\n            point.resetHoles();\r\n            !point._skipSetLeftHole && point.setHole(holes.left[argument] || holesStack.left[argument] && 0, \"left\");\r\n            !point._skipSetRightHole && point.setHole(holes.right[argument] || holesStack.right[argument] && 0, \"right\");\r\n            point._skipSetLeftHole = null;\r\n            point._skipSetRightHole = null\r\n        })\r\n    });\r\n    that._stackKeepers = stackKeepers;\r\n    series.forEach(function(singleSeries) {\r\n        singleSeries.getPoints().forEach(function(point) {\r\n            var argument = point.argument.valueOf();\r\n            var stackName = singleSeries.getStackName() || singleSeries.getBarOverlapGroup();\r\n            var absTotal = getAbsStackSumByArg(stackKeepers, stackName, argument);\r\n            var total = getStackSumByArg(stackKeepers, stackName, argument);\r\n            point.setPercentValue(absTotal, total, holesStack.left[argument], holesStack.right[argument])\r\n        })\r\n    })\r\n}\r\n\r\nfunction updateStackedSeriesValues() {\r\n    var that = this;\r\n    var series = getVisibleSeries(that);\r\n    var stack = that._stackKeepers;\r\n    var stackKeepers = {\r\n        positive: {},\r\n        negative: {}\r\n    };\r\n    _each(series, function(_, singleSeries) {\r\n        var minBarSize = singleSeries.getOptions().minBarSize;\r\n        var valueAxisTranslator = singleSeries.getValueAxis().getTranslator();\r\n        var minShownBusinessValue = minBarSize && valueAxisTranslator.getMinBarSize(minBarSize);\r\n        var stackName = singleSeries.getStackName();\r\n        _each(singleSeries.getPoints(), function(index, point) {\r\n            if (!point.hasValue()) {\r\n                return\r\n            }\r\n            var value = point.initialValue && point.initialValue.valueOf();\r\n            var argument = point.argument.valueOf();\r\n            var updateValue;\r\n            var valueType;\r\n            var currentStack;\r\n            if (that.fullStacked) {\r\n                value = value / getAbsStackSumByArg(stack, stackName, argument) || 0\r\n            }\r\n            updateValue = valueAxisTranslator.checkMinBarSize(value, minShownBusinessValue, point.value);\r\n            valueType = getValueType(updateValue);\r\n            currentStack = stackKeepers[valueType][stackName] = stackKeepers[valueType][stackName] || {};\r\n            if (currentStack[argument]) {\r\n                point.minValue = currentStack[argument];\r\n                currentStack[argument] += updateValue\r\n            } else {\r\n                currentStack[argument] = updateValue\r\n            }\r\n            point.value = currentStack[argument]\r\n        })\r\n    });\r\n    if (that.fullStacked) {\r\n        updateFullStackedSeriesValues(series, stackKeepers)\r\n    }\r\n}\r\n\r\nfunction updateFullStackedSeriesValues(series, stackKeepers) {\r\n    _each(series, function(_, singleSeries) {\r\n        var stackName = singleSeries.getStackName ? singleSeries.getStackName() : \"default\";\r\n        _each(singleSeries.getPoints(), function(index, point) {\r\n            var stackSum = getAbsStackSumByArg(stackKeepers, stackName, point.argument.valueOf());\r\n            point.value = point.value / stackSum;\r\n            if (isNumeric(point.minValue)) {\r\n                point.minValue = point.minValue / stackSum\r\n            }\r\n        })\r\n    })\r\n}\r\n\r\nfunction updateBarSeriesValues() {\r\n    _each(this.series, function(_, singleSeries) {\r\n        var minBarSize = singleSeries.getOptions().minBarSize;\r\n        var valueAxisTranslator = singleSeries.getValueAxis().getTranslator();\r\n        var minShownBusinessValue = minBarSize && valueAxisTranslator.getMinBarSize(minBarSize);\r\n        if (minShownBusinessValue) {\r\n            _each(singleSeries.getPoints(), function(index, point) {\r\n                if (point.hasValue()) {\r\n                    point.value = valueAxisTranslator.checkMinBarSize(point.initialValue, minShownBusinessValue)\r\n                }\r\n            })\r\n        }\r\n    })\r\n}\r\n\r\nfunction adjustCandlestickSeriesDimensions() {\r\n    var series = getVisibleSeries(this);\r\n    adjustBarSeriesDimensionsCore(series, {\r\n        barWidth: null,\r\n        equalBarWidth: true,\r\n        barGroupPadding: .3\r\n    }, getSeriesStackIndexCallback(isInverted(series)))\r\n}\r\n\r\nfunction adjustBubbleSeriesDimensions() {\r\n    var series = getVisibleSeries(this);\r\n    if (!series.length) {\r\n        return\r\n    }\r\n    var options = this._options;\r\n    var visibleAreaX = series[0].getArgumentAxis().getVisibleArea();\r\n    var visibleAreaY = series[0].getValueAxis().getVisibleArea();\r\n    var min = _math.min(visibleAreaX[1] - visibleAreaX[0], visibleAreaY[1] - visibleAreaY[0]);\r\n    var minBubbleArea = _pow(options.minBubbleSize, 2);\r\n    var maxBubbleArea = _pow(min * options.maxBubbleSize, 2);\r\n    var equalBubbleSize = (min * options.maxBubbleSize + options.minBubbleSize) / 2;\r\n    var minPointSize = 1 / 0;\r\n    var maxPointSize = -(1 / 0);\r\n    var pointSize;\r\n    var bubbleArea;\r\n    var sizeProportion;\r\n    var sizeDispersion;\r\n    var areaDispersion;\r\n    _each(series, function(_, seriesItem) {\r\n        _each(seriesItem.getPoints(), function(_, point) {\r\n            maxPointSize = maxPointSize > point.size ? maxPointSize : point.size;\r\n            minPointSize = minPointSize < point.size ? minPointSize : point.size\r\n        })\r\n    });\r\n    sizeDispersion = maxPointSize - minPointSize;\r\n    areaDispersion = _abs(maxBubbleArea - minBubbleArea);\r\n    _each(series, function(_, seriesItem) {\r\n        _each(seriesItem.getPoints(), function(_, point) {\r\n            if (maxPointSize === minPointSize) {\r\n                pointSize = _round(equalBubbleSize)\r\n            } else {\r\n                sizeProportion = _abs(point.size - minPointSize) / sizeDispersion;\r\n                bubbleArea = areaDispersion * sizeProportion + minBubbleArea;\r\n                pointSize = _round(_math.sqrt(bubbleArea))\r\n            }\r\n            point.correctCoordinates(pointSize)\r\n        })\r\n    })\r\n}\r\n\r\nfunction SeriesFamily(options) {\r\n    var that = this;\r\n    that.type = _normalizeEnum(options.type);\r\n    that.pane = options.pane;\r\n    that.series = [];\r\n    that.updateOptions(options);\r\n    switch (that.type) {\r\n        case \"bar\":\r\n            that.adjustSeriesDimensions = adjustBarSeriesDimensions;\r\n            that.updateSeriesValues = updateBarSeriesValues;\r\n            that.adjustSeriesValues = adjustStackedSeriesValues;\r\n            break;\r\n        case \"rangebar\":\r\n            that.adjustSeriesDimensions = adjustBarSeriesDimensions;\r\n            break;\r\n        case \"fullstackedbar\":\r\n            that.fullStacked = true;\r\n            that.adjustSeriesDimensions = adjustBarSeriesDimensions;\r\n            that.adjustSeriesValues = adjustStackedSeriesValues;\r\n            that.updateSeriesValues = updateStackedSeriesValues;\r\n            break;\r\n        case \"stackedbar\":\r\n            that.adjustSeriesDimensions = adjustBarSeriesDimensions;\r\n            that.adjustSeriesValues = adjustStackedSeriesValues;\r\n            that.updateSeriesValues = updateStackedSeriesValues;\r\n            break;\r\n        case \"fullstackedarea\":\r\n        case \"fullstackedline\":\r\n        case \"fullstackedspline\":\r\n        case \"fullstackedsplinearea\":\r\n            that.fullStacked = true;\r\n            that.adjustSeriesValues = adjustStackedSeriesValues;\r\n            break;\r\n        case \"stackedarea\":\r\n        case \"stackedsplinearea\":\r\n        case \"stackedline\":\r\n        case \"stackedspline\":\r\n            that.adjustSeriesValues = adjustStackedSeriesValues;\r\n            break;\r\n        case \"candlestick\":\r\n        case \"stock\":\r\n            that.adjustSeriesDimensions = adjustCandlestickSeriesDimensions;\r\n            break;\r\n        case \"bubble\":\r\n            that.adjustSeriesDimensions = adjustBubbleSeriesDimensions\r\n    }\r\n}\r\nexports.SeriesFamily = SeriesFamily;\r\nSeriesFamily.prototype = {\r\n    constructor: SeriesFamily,\r\n    adjustSeriesDimensions: _noop,\r\n    adjustSeriesValues: _noop,\r\n    updateSeriesValues: _noop,\r\n    updateOptions: function(options) {\r\n        this._options = options\r\n    },\r\n    dispose: function() {\r\n        this.series = null\r\n    },\r\n    add: function(series) {\r\n        var type = this.type;\r\n        this.series = vizUtils.map(series, function(singleSeries) {\r\n            return singleSeries.type === type ? singleSeries : null\r\n        })\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}