{"ast":null,"code":"/**\r\n * DevExtreme (viz/range_selector/range_selector.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _component_registrator = require(\"../../core/component_registrator\");\n\nvar _component_registrator2 = _interopRequireDefault(_component_registrator);\n\nvar _type2 = require(\"../../core/utils/type\");\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _iterator = require(\"../../core/utils/iterator\");\n\nvar _utils = require(\"../core/utils\");\n\nvar _date = require(\"../../core/utils/date\");\n\nvar _math = require(\"../../core/utils/math\");\n\nvar _range = require(\"../translators/range\");\n\nvar _range2 = _interopRequireDefault(_range);\n\nvar _base_axis = require(\"../axes/base_axis\");\n\nvar _base_axis2 = _interopRequireDefault(_base_axis);\n\nvar _parse_utils = require(\"../components/parse_utils\");\n\nvar _parse_utils2 = _interopRequireDefault(_parse_utils);\n\nvar _format_helper = require(\"../../format_helper\");\n\nvar _format_helper2 = _interopRequireDefault(_format_helper);\n\nvar _common = require(\"./common\");\n\nvar _common2 = _interopRequireDefault(_common);\n\nvar _sliders_controller = require(\"./sliders_controller\");\n\nvar _sliders_controller2 = _interopRequireDefault(_sliders_controller);\n\nvar _tracker = require(\"./tracker\");\n\nvar _range_view = require(\"./range_view\");\n\nvar _range_view2 = _interopRequireDefault(_range_view);\n\nvar _series_data_source = require(\"./series_data_source\");\n\nvar _series_data_source2 = _interopRequireDefault(_series_data_source);\n\nvar _tick_generator = require(\"../axes/tick_generator\");\n\nvar _tick_generator2 = _interopRequireDefault(_tick_generator);\n\nvar _base_widget = require(\"../core/base_widget\");\n\nvar _base_widget2 = _interopRequireDefault(_base_widget);\n\nvar _export = require(\"../core/export\");\n\nvar _title = require(\"../core/title\");\n\nvar _loading_indicator = require(\"../core/loading_indicator\");\n\nvar _data_source = require(\"../core/data_source\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar _max = Math.max;\nvar _ceil = Math.ceil;\nvar _floor = Math.floor;\nvar START_VALUE = \"startValue\";\nvar END_VALUE = \"endValue\";\nvar DATETIME = \"datetime\";\nvar VALUE = \"value\";\nvar DISCRETE = \"discrete\";\nvar SEMIDISCRETE = \"semidiscrete\";\nvar STRING = \"string\";\nvar VALUE_CHANGED = VALUE + \"Changed\";\nvar CONTAINER_BACKGROUND_COLOR = \"containerBackgroundColor\";\nvar SLIDER_MARKER = \"sliderMarker\";\nvar OPTION_BACKGROUND = \"background\";\nvar LOGARITHMIC = \"logarithmic\";\nvar KEEP = \"keep\";\nvar SHIFT = \"shift\";\nvar RESET = \"reset\";\nvar INVISIBLE_POS = -1e3;\nvar SEMIDISCRETE_GRID_SPACING_FACTOR = 50;\nvar DEFAULT_AXIS_DIVISION_FACTOR = 30;\nvar DEFAULT_MINOR_AXIS_DIVISION_FACTOR = 15;\nvar logarithmBase = 10;\n\nfunction calculateMarkerHeight(renderer, value, sliderMarkerOptions) {\n  var formattedText = void 0 === value ? _common2.default.consts.emptySliderMarkerText : _common2.default.formatValue(value, sliderMarkerOptions);\n  var textBBox = getTextBBox(renderer, formattedText, sliderMarkerOptions.font);\n  return _ceil(textBBox.height) + 2 * sliderMarkerOptions.paddingTopBottom + _common2.default.consts.pointerSize;\n}\n\nfunction calculateScaleLabelHalfWidth(renderer, value, scaleOptions, tickIntervalsInfo) {\n  var formattedText = _common2.default.formatValue(value, scaleOptions.label, tickIntervalsInfo, scaleOptions.valueType, scaleOptions.type, scaleOptions.logarithmBase);\n\n  var textBBox = getTextBBox(renderer, formattedText, scaleOptions.label.font);\n  return _ceil(textBBox.width / 2);\n}\n\nfunction calculateIndents(renderer, scale, sliderMarkerOptions, indentOptions, tickIntervalsInfo) {\n  var leftMarkerHeight;\n  var leftScaleLabelWidth = 0;\n  var rightScaleLabelWidth = 0;\n  var rightMarkerHeight;\n  var placeholderWidthLeft;\n  var placeholderWidthRight;\n  var placeholderHeight;\n  var ticks = \"semidiscrete\" === scale.type ? scale.customTicks : tickIntervalsInfo.ticks;\n  var startTickValue;\n  var endTickValue;\n  indentOptions = indentOptions || {};\n  placeholderWidthLeft = indentOptions.left;\n  placeholderWidthRight = indentOptions.right;\n  placeholderHeight = sliderMarkerOptions.placeholderHeight;\n\n  if (sliderMarkerOptions.visible) {\n    leftMarkerHeight = calculateMarkerHeight(renderer, scale.startValue, sliderMarkerOptions);\n    rightMarkerHeight = calculateMarkerHeight(renderer, scale.endValue, sliderMarkerOptions);\n\n    if (void 0 === placeholderHeight) {\n      placeholderHeight = _max(leftMarkerHeight, rightMarkerHeight);\n    }\n  }\n\n  if (scale.label.visible) {\n    startTickValue = (0, _type2.isDefined)(scale.startValue) ? ticks[0] : void 0;\n    endTickValue = (0, _type2.isDefined)(scale.endValue) ? ticks[ticks.length - 1] : void 0;\n    leftScaleLabelWidth = calculateScaleLabelHalfWidth(renderer, startTickValue, scale, tickIntervalsInfo);\n    rightScaleLabelWidth = calculateScaleLabelHalfWidth(renderer, endTickValue, scale, tickIntervalsInfo);\n  }\n\n  placeholderWidthLeft = void 0 !== placeholderWidthLeft ? placeholderWidthLeft : leftScaleLabelWidth;\n  placeholderWidthRight = (void 0 !== placeholderWidthRight ? placeholderWidthRight : rightScaleLabelWidth) || 1;\n  return {\n    left: placeholderWidthLeft,\n    right: placeholderWidthRight,\n    top: placeholderHeight || 0,\n    bottom: 0\n  };\n}\n\nfunction calculateValueType(firstValue, secondValue) {\n  var typeFirstValue = (0, _type2.type)(firstValue);\n  var typeSecondValue = (0, _type2.type)(secondValue);\n\n  var validType = function validType(type) {\n    return typeFirstValue === type || typeSecondValue === type;\n  };\n\n  return validType(\"date\") ? DATETIME : validType(\"number\") ? \"numeric\" : validType(STRING) ? STRING : \"\";\n}\n\nfunction showScaleMarkers(scaleOptions) {\n  return scaleOptions.valueType === DATETIME && scaleOptions.marker.visible;\n}\n\nfunction updateTranslatorRangeInterval(translatorRange, scaleOptions) {\n  var intervalX = scaleOptions.minorTickInterval || scaleOptions.tickInterval;\n\n  if (\"datetime\" === scaleOptions.valueType) {\n    intervalX = (0, _date.dateToMilliseconds)(intervalX);\n  }\n\n  translatorRange.addRange({\n    interval: intervalX\n  });\n}\n\nfunction checkLogarithmicOptions(options, defaultLogarithmBase, incidentOccurred) {\n  var logarithmBase;\n\n  if (!options) {\n    return;\n  }\n\n  logarithmBase = options.logarithmBase;\n\n  if (options.type === LOGARITHMIC && logarithmBase <= 0 || logarithmBase && !(0, _type2.isNumeric)(logarithmBase)) {\n    options.logarithmBase = defaultLogarithmBase;\n    incidentOccurred(\"E2104\");\n  } else {\n    if (options.type !== LOGARITHMIC) {\n      options.logarithmBase = void 0;\n    }\n  }\n}\n\nfunction calculateScaleAreaHeight(renderer, scaleOptions, visibleMarkers, tickIntervalsInfo) {\n  var labelScaleOptions = scaleOptions.label;\n  var markerScaleOptions = scaleOptions.marker;\n  var placeholderHeight = scaleOptions.placeholderHeight;\n  var ticks = \"semidiscrete\" === scaleOptions.type ? scaleOptions.customTicks : tickIntervalsInfo.ticks;\n\n  var text = _common2.default.formatValue(ticks[0], labelScaleOptions);\n\n  if (placeholderHeight) {\n    return placeholderHeight;\n  } else {\n    return (labelScaleOptions.visible ? labelScaleOptions.topIndent + getTextBBox(renderer, text, labelScaleOptions.font).height : 0) + (visibleMarkers ? markerScaleOptions.topIndent + markerScaleOptions.separatorHeight : 0);\n  }\n}\n\nfunction getMinorTickIntervalUnit(tickInterval, minorTickInterval, withCorrection) {\n  var interval = (0, _date.getDateUnitInterval)(minorTickInterval);\n  var majorUnit = (0, _date.getDateUnitInterval)(tickInterval);\n\n  var idx = _date.dateUnitIntervals.indexOf(interval);\n\n  if (withCorrection && interval === majorUnit && idx > 0) {\n    interval = _date.dateUnitIntervals[idx - 1];\n  }\n\n  return interval;\n}\n\nfunction getNextTickInterval(tickInterval, minorTickInterval, isDateType) {\n  if (!tickInterval) {\n    tickInterval = minorTickInterval;\n  } else {\n    if (isDateType) {\n      tickInterval = (0, _date.getNextDateUnit)(tickInterval);\n    } else {\n      tickInterval += minorTickInterval;\n    }\n  }\n\n  return tickInterval;\n}\n\nfunction calculateTickIntervalsForSemidiscreteScale(scaleOptions, min, max, screenDelta) {\n  var minorTickInterval = scaleOptions.minorTickInterval;\n  var tickInterval = scaleOptions.tickInterval;\n  var interval;\n  var isDateType = \"datetime\" === scaleOptions.valueType;\n  var gridSpacingFactor = scaleOptions.axisDivisionFactor || {};\n  var tickCountByInterval;\n  var tickCountByScreen;\n\n  if (!tickInterval) {\n    do {\n      interval = getNextTickInterval(tickInterval, minorTickInterval, isDateType);\n\n      if (tickInterval !== interval) {\n        tickInterval = interval;\n      } else {\n        break;\n      }\n\n      if (isDateType) {\n        interval = (0, _date.dateToMilliseconds)(tickInterval);\n      }\n\n      tickCountByInterval = _ceil((max - min) / interval);\n      tickCountByScreen = _floor(screenDelta / (gridSpacingFactor[tickInterval] || SEMIDISCRETE_GRID_SPACING_FACTOR)) || 1;\n    } while (interval && tickCountByInterval > tickCountByScreen);\n  }\n\n  return {\n    tickInterval: tickInterval,\n    minorTickInterval: minorTickInterval,\n    bounds: {\n      minVisible: min,\n      maxVisible: max\n    },\n    ticks: []\n  };\n}\n\nfunction updateTickIntervals(scaleOptions, screenDelta, incidentOccurred, range) {\n  var result;\n  var min = (0, _type2.isDefined)(range.minVisible) ? range.minVisible : range.min;\n  var max = (0, _type2.isDefined)(range.maxVisible) ? range.maxVisible : range.max;\n  var categoriesInfo = scaleOptions._categoriesInfo;\n  var ticksInfo;\n  var length;\n  var bounds = {};\n\n  if (scaleOptions.type === SEMIDISCRETE) {\n    result = calculateTickIntervalsForSemidiscreteScale(scaleOptions, min, max, screenDelta);\n  } else {\n    ticksInfo = _tick_generator2.default.tickGenerator({\n      axisType: scaleOptions.type,\n      dataType: scaleOptions.valueType,\n      logBase: scaleOptions.logarithmBase,\n      allowNegatives: true,\n      linearThreshold: Math.abs(scaleOptions.linearThreshold || 0),\n      axisDivisionFactor: scaleOptions.axisDivisionFactor,\n      minorAxisDivisionFactor: scaleOptions.minorAxisDivisionFactor,\n      calculateMinors: true,\n      allowDecimals: scaleOptions.allowDecimals,\n      endOnTick: scaleOptions.endOnTick,\n      incidentOccurred: incidentOccurred,\n      rangeIsEmpty: range.isEmpty()\n    })({\n      min: min,\n      max: max,\n      categories: (0, _type2.isDefined)(categoriesInfo) ? categoriesInfo.categories : []\n    }, screenDelta, scaleOptions.tickInterval, scaleOptions.forceUserTickInterval, void 0, scaleOptions.minorTickInterval, scaleOptions.minorTickCount);\n    length = ticksInfo.ticks.length;\n    bounds.minVisible = ticksInfo.ticks[0] < min ? ticksInfo.ticks[0] : min;\n    bounds.maxVisible = ticksInfo.ticks[length - 1] > max ? ticksInfo.ticks[length - 1] : max;\n    result = {\n      tickInterval: ticksInfo.tickInterval,\n      minorTickInterval: 0 === scaleOptions.minorTickInterval ? 0 : ticksInfo.minorTickInterval,\n      bounds: bounds,\n      ticks: ticksInfo.ticks\n    };\n  }\n\n  return result;\n}\n\nfunction calculateTranslatorRange(seriesDataSource, scaleOptions) {\n  var minValue;\n  var maxValue;\n  var inverted = false;\n  var startValue = scaleOptions.startValue;\n  var endValue = scaleOptions.endValue;\n  var categories;\n  var categoriesInfo;\n  var translatorRange = seriesDataSource ? seriesDataSource.getBoundRange().arg : new _range2.default.Range();\n  var rangeForCategories;\n  var isDate = \"datetime\" === scaleOptions.valueType;\n  var minRange = scaleOptions.minRange;\n\n  if (scaleOptions.type === DISCRETE) {\n    rangeForCategories = new _range2.default.Range({\n      minVisible: startValue,\n      maxVisible: endValue\n    });\n    rangeForCategories.addRange(translatorRange);\n    translatorRange = rangeForCategories;\n    categories = seriesDataSource ? seriesDataSource.argCategories : scaleOptions.categories || !seriesDataSource && startValue && endValue && [startValue, endValue];\n    categories = categories || [];\n    scaleOptions._categoriesInfo = categoriesInfo = (0, _utils.getCategoriesInfo)(categories, startValue, endValue);\n  }\n\n  if (scaleOptions.type === SEMIDISCRETE) {\n    startValue = scaleOptions.startValue = correctValueByInterval(scaleOptions.startValue, isDate, minRange);\n    endValue = scaleOptions.endValue = correctValueByInterval(scaleOptions.endValue, isDate, minRange);\n    translatorRange.minVisible = correctValueByInterval(translatorRange.minVisible, isDate, minRange);\n    translatorRange.maxVisible = correctValueByInterval(translatorRange.maxVisible, isDate, minRange);\n    translatorRange.min = correctValueByInterval(translatorRange.min, isDate, minRange);\n    translatorRange.max = correctValueByInterval(translatorRange.max, isDate, minRange);\n  }\n\n  if ((0, _type2.isDefined)(startValue) && (0, _type2.isDefined)(endValue)) {\n    inverted = categoriesInfo ? categoriesInfo.inverted : startValue > endValue;\n    minValue = categoriesInfo ? categoriesInfo.start : inverted ? endValue : startValue;\n    maxValue = categoriesInfo ? categoriesInfo.end : inverted ? startValue : endValue;\n  } else {\n    if ((0, _type2.isDefined)(startValue) || (0, _type2.isDefined)(endValue)) {\n      minValue = startValue;\n      maxValue = endValue;\n    } else {\n      if (categoriesInfo) {\n        minValue = categoriesInfo.start;\n        maxValue = categoriesInfo.end;\n      }\n    }\n  }\n\n  translatorRange.addRange({\n    invert: inverted,\n    min: minValue,\n    max: maxValue,\n    minVisible: minValue,\n    maxVisible: maxValue,\n    dataType: scaleOptions.valueType\n  });\n  translatorRange.addRange({\n    categories: !seriesDataSource ? categories : void 0,\n    base: scaleOptions.logarithmBase,\n    axisType: scaleOptions.type,\n    dataType: scaleOptions.valueType\n  });\n  seriesDataSource && translatorRange.sortCategories(categories);\n  return translatorRange;\n}\n\nfunction startEndNotDefined(start, end) {\n  return !(0, _type2.isDefined)(start) || !(0, _type2.isDefined)(end);\n}\n\nfunction getTextBBox(renderer, text, fontOptions) {\n  var textElement = renderer.text(text, INVISIBLE_POS, INVISIBLE_POS).css((0, _utils.patchFontOptions)(fontOptions)).append(renderer.root);\n  var textBBox = textElement.getBBox();\n  textElement.remove();\n  return textBBox;\n}\n\nfunction getDateMarkerVisibilityChecker(screenDelta) {\n  return function (isDateScale, isMarkerVisible, min, max, tickInterval) {\n    if (isMarkerVisible && isDateScale) {\n      if (!(0, _type2.isDefined)(tickInterval) || tickInterval.years || tickInterval.months >= 6 || screenDelta / SEMIDISCRETE_GRID_SPACING_FACTOR < _ceil((max - min) / (0, _date.dateToMilliseconds)(\"year\")) + 1) {\n        isMarkerVisible = false;\n      }\n    }\n\n    return isMarkerVisible;\n  };\n}\n\nfunction updateScaleOptions(scaleOptions, seriesDataSource, translatorRange, tickIntervalsInfo, checkDateMarkerVisibility) {\n  var bounds;\n  var isEmptyInterval;\n  var categoriesInfo = scaleOptions._categoriesInfo;\n  var intervals;\n  var isDateTime = scaleOptions.valueType === DATETIME;\n\n  if (seriesDataSource && !seriesDataSource.isEmpty() && !translatorRange.isEmpty()) {\n    bounds = tickIntervalsInfo.bounds;\n    translatorRange.addRange(bounds);\n    scaleOptions.startValue = translatorRange.invert ? bounds.maxVisible : bounds.minVisible;\n    scaleOptions.endValue = translatorRange.invert ? bounds.minVisible : bounds.maxVisible;\n  }\n\n  scaleOptions.marker.visible = checkDateMarkerVisibility(isDateTime && scaleOptions.type.indexOf(DISCRETE) === -1, scaleOptions.marker.visible, scaleOptions.startValue, scaleOptions.endValue, tickIntervalsInfo.tickInterval);\n\n  if (categoriesInfo) {\n    scaleOptions.startValue = categoriesInfo.start;\n    scaleOptions.endValue = categoriesInfo.end;\n  }\n\n  if (scaleOptions.type.indexOf(DISCRETE) === -1) {\n    isEmptyInterval = (0, _type2.isDate)(scaleOptions.startValue) && (0, _type2.isDate)(scaleOptions.endValue) && scaleOptions.startValue.getTime() === scaleOptions.endValue.getTime() || scaleOptions.startValue === scaleOptions.endValue;\n  }\n\n  scaleOptions.isEmpty = startEndNotDefined(scaleOptions.startValue, scaleOptions.endValue) || isEmptyInterval;\n\n  if (scaleOptions.isEmpty) {\n    scaleOptions.startValue = scaleOptions.endValue = void 0;\n  } else {\n    scaleOptions.minorTickInterval = tickIntervalsInfo.minorTickInterval;\n    scaleOptions.tickInterval = tickIntervalsInfo.tickInterval;\n\n    if (isDateTime && (!(0, _type2.isDefined)(scaleOptions.label.format) || scaleOptions.type === SEMIDISCRETE && scaleOptions.minorTickInterval !== scaleOptions.tickInterval)) {\n      if (scaleOptions.type === DISCRETE) {\n        scaleOptions.label.format = _format_helper2.default.getDateFormatByTicks(tickIntervalsInfo.ticks);\n      } else {\n        if (!scaleOptions.marker.visible) {\n          scaleOptions.label.format = _format_helper2.default.getDateFormatByTickInterval(scaleOptions.startValue, scaleOptions.endValue, scaleOptions.tickInterval);\n        } else {\n          scaleOptions.label.format = (0, _date.getDateFormatByTickInterval)(scaleOptions.tickInterval);\n        }\n      }\n    }\n  }\n\n  if (scaleOptions.type === SEMIDISCRETE) {\n    intervals = getIntervalCustomTicks(scaleOptions);\n    scaleOptions.customMinorTicks = intervals.altIntervals;\n    scaleOptions.customTicks = intervals.intervals;\n    scaleOptions.customBoundTicks = [scaleOptions.customTicks[0]];\n  }\n}\n\nfunction prepareScaleOptions(scaleOption, calculatedValueType, incidentOccurred, containerColor) {\n  var parsedValue = 0;\n\n  var valueType = _parse_utils2.default.correctValueType((0, _utils.normalizeEnum)(scaleOption.valueType));\n\n  var parser;\n\n  var validateStartEndValues = function validateStartEndValues(field, parser) {\n    var messageToIncidentOccurred = field === START_VALUE ? \"start\" : \"end\";\n\n    if ((0, _type2.isDefined)(scaleOption[field])) {\n      parsedValue = parser(scaleOption[field]);\n\n      if ((0, _type2.isDefined)(parsedValue)) {\n        scaleOption[field] = parsedValue;\n      } else {\n        scaleOption[field] = void 0;\n        incidentOccurred(\"E2202\", [messageToIncidentOccurred]);\n      }\n    }\n  };\n\n  valueType = calculatedValueType || valueType;\n\n  if (!valueType) {\n    valueType = calculateValueType(scaleOption.startValue, scaleOption.endValue) || \"numeric\";\n  }\n\n  if (valueType === STRING || scaleOption.categories) {\n    scaleOption.type = DISCRETE;\n    valueType = STRING;\n  }\n\n  scaleOption.containerColor = containerColor;\n  scaleOption.valueType = valueType;\n  scaleOption.dataType = valueType;\n  parser = _parse_utils2.default.getParser(valueType);\n  validateStartEndValues(START_VALUE, parser);\n  validateStartEndValues(END_VALUE, parser);\n  checkLogarithmicOptions(scaleOption, logarithmBase, incidentOccurred);\n\n  if (!scaleOption.type) {\n    scaleOption.type = \"continuous\";\n  }\n\n  scaleOption.parser = parser;\n\n  if (scaleOption.type === SEMIDISCRETE) {\n    scaleOption.minorTick.visible = false;\n    scaleOption.minorTickInterval = scaleOption.minRange;\n    scaleOption.marker.visible = false;\n    scaleOption.maxRange = void 0;\n  }\n\n  scaleOption.forceUserTickInterval |= (0, _type2.isDefined)(scaleOption.tickInterval) && !(0, _type2.isDefined)(scaleOption.axisDivisionFactor);\n  scaleOption.axisDivisionFactor = (0, _type2.isDefined)(scaleOption.axisDivisionFactor) ? scaleOption.axisDivisionFactor : DEFAULT_AXIS_DIVISION_FACTOR;\n  scaleOption.minorAxisDivisionFactor = (0, _type2.isDefined)(scaleOption.minorAxisDivisionFactor) ? scaleOption.minorAxisDivisionFactor : DEFAULT_MINOR_AXIS_DIVISION_FACTOR;\n  return scaleOption;\n}\n\nfunction correctValueByInterval(value, isDate, interval) {\n  if ((0, _type2.isDefined)(value)) {\n    value = isDate ? (0, _date.correctDateWithUnitBeginning)(new Date(value), interval) : (0, _math.adjust)(_floor((0, _math.adjust)(value / interval)) * interval);\n  }\n\n  return value;\n}\n\nfunction getIntervalCustomTicks(options) {\n  var min = options.startValue;\n  var max = options.endValue;\n  var isDate = \"datetime\" === options.valueType;\n  var tickInterval = options.tickInterval;\n  var res = {\n    intervals: []\n  };\n\n  if (!(0, _type2.isDefined)(min) || !(0, _type2.isDefined)(max)) {\n    return res;\n  }\n\n  res.intervals = (0, _date.getSequenceByInterval)(min, max, options.minorTickInterval);\n\n  if (tickInterval !== options.minorTickInterval) {\n    res.altIntervals = res.intervals;\n    min = correctValueByInterval(min, isDate, tickInterval);\n    max = correctValueByInterval(max, isDate, tickInterval);\n    res.intervals = (0, _date.getSequenceByInterval)(min, max, tickInterval);\n    res.intervals[0] = res.altIntervals[0];\n  }\n\n  return res;\n}\n\nfunction getPrecisionForSlider(startValue, endValue, screenDelta) {\n  var d = Math.abs(endValue - startValue) / screenDelta;\n\n  var tail = d - _floor(d);\n\n  return tail > 0 ? _ceil(Math.abs((0, _math.adjust)((0, _utils.getLog)(tail, 10)))) : 0;\n}\n\nvar dxRangeSelector = _base_widget2.default.inherit({\n  _toggleParentsScrollSubscription: function _toggleParentsScrollSubscription() {},\n  _eventsMap: {\n    onValueChanged: {\n      name: VALUE_CHANGED\n    }\n  },\n  _setDeprecatedOptions: function _setDeprecatedOptions() {\n    this.callBase.apply(this, arguments);\n    (0, _extend.extend)(this._deprecatedOptions, {\n      \"chart.barWidth\": {\n        since: \"18.1\",\n        message: \"Use the 'chart.commonSeriesSettings.barPadding' or 'chart.series.barPadding' option instead\"\n      },\n      \"chart.equalBarWidth\": {\n        since: \"18.1\",\n        message: \"Use the 'chart.commonSeriesSettings.ignoreEmptyPoints' or 'chart.series.ignoreEmptyPoints' option instead\"\n      },\n      \"chart.useAggregation\": {\n        since: \"18.1\",\n        message: \"Use the 'chart.commonSeriesSettings.aggregation.enabled' or 'chart.series.aggregation.enabled' option instead\"\n      }\n    });\n  },\n  _rootClassPrefix: \"dxrs\",\n  _rootClass: \"dxrs-range-selector\",\n  _dataIsReady: function _dataIsReady() {\n    return this._dataIsLoaded();\n  },\n  _initialChanges: [\"DATA_SOURCE\", \"VALUE\"],\n  _themeDependentChanges: [\"MOSTLY_TOTAL\"],\n  _themeSection: \"rangeSelector\",\n  _fontFields: [\"scale.label.font\", \"sliderMarker.font\"],\n  _initCore: function _initCore() {\n    var that = this;\n    var renderer = that._renderer;\n    var root = renderer.root;\n    var rangeViewGroup;\n    var slidersGroup;\n    var scaleGroup;\n    var scaleBreaksGroup;\n    var trackersGroup;\n    root.css({\n      \"touch-action\": \"pan-y\"\n    });\n    that._clipRect = renderer.clipRect();\n    rangeViewGroup = renderer.g().attr({\n      \"class\": \"dxrs-view\"\n    }).append(root);\n    slidersGroup = renderer.g().attr({\n      \"class\": \"dxrs-slidersContainer\",\n      \"clip-path\": that._clipRect.id\n    }).append(root);\n    scaleGroup = renderer.g().attr({\n      \"class\": \"dxrs-scale\",\n      \"clip-path\": that._clipRect.id\n    }).append(root);\n    scaleBreaksGroup = renderer.g().attr({\n      \"class\": \"dxrs-scale-breaks\"\n    }).append(root);\n    trackersGroup = renderer.g().attr({\n      \"class\": \"dxrs-trackers\"\n    }).append(root);\n    that._axis = new AxisWrapper({\n      renderer: renderer,\n      root: scaleGroup,\n      scaleBreaksGroup: scaleBreaksGroup,\n      updateSelectedRange: function updateSelectedRange(range, e) {\n        that.setValue((0, _utils.convertVisualRangeObject)(range), e);\n      },\n      incidentOccurred: that._incidentOccurred\n    });\n    that._rangeView = new _range_view2.default.RangeView({\n      renderer: renderer,\n      root: rangeViewGroup,\n      translator: that._axis.getTranslator()\n    });\n    that._slidersController = new _sliders_controller2.default.SlidersController({\n      renderer: renderer,\n      root: slidersGroup,\n      trackersGroup: trackersGroup,\n      updateSelectedRange: function updateSelectedRange(range, lastSelectedRange, e) {\n        if (!that._rangeOption) {\n          that.option(VALUE, (0, _utils.convertVisualRangeObject)(range, (0, _type2.isPlainObject)(that._options[VALUE])));\n        }\n\n        that._eventTrigger(VALUE_CHANGED, {\n          value: (0, _utils.convertVisualRangeObject)(range),\n          previousValue: (0, _utils.convertVisualRangeObject)(lastSelectedRange),\n          event: e\n        });\n      },\n      axis: that._axis,\n      translator: that._axis.getTranslator()\n    });\n    that._tracker = new _tracker.Tracker({\n      renderer: renderer,\n      controller: that._slidersController\n    });\n  },\n  _getDefaultSize: function _getDefaultSize() {\n    return {\n      width: 400,\n      height: 160\n    };\n  },\n  _disposeCore: function _disposeCore() {\n    this._axis.dispose();\n\n    this._slidersController.dispose();\n\n    this._tracker.dispose();\n  },\n  _applySize: function _applySize(rect) {\n    this._clientRect = rect.slice();\n\n    this._change([\"MOSTLY_TOTAL\"]);\n  },\n  _optionChangesMap: {\n    scale: \"SCALE\",\n    value: \"VALUE\",\n    dataSource: \"DATA_SOURCE\"\n  },\n  _optionChangesOrder: [\"SCALE\", \"DATA_SOURCE\"],\n  _change_SCALE: function _change_SCALE() {\n    this._change([\"MOSTLY_TOTAL\"]);\n  },\n  _setValueByDataSource: function _setValueByDataSource() {\n    var that = this;\n    var options = that._options;\n    var axis = that._axis;\n\n    if (options.dataSource) {\n      var selectedRangeUpdateMode = that.option(\"selectedRangeUpdateMode\");\n      var value = that.getValue();\n      var valueIsReady = (0, _type2.isDefined)(value[0]) && (0, _type2.isDefined)(value[1]);\n\n      if ((0, _type2.isDefined)(selectedRangeUpdateMode)) {\n        selectedRangeUpdateMode = (0, _utils.normalizeEnum)(selectedRangeUpdateMode);\n        that.__skipAnimation = true;\n      } else {\n        if (valueIsReady) {\n          selectedRangeUpdateMode = RESET;\n        }\n      }\n\n      if (\"auto\" === selectedRangeUpdateMode && valueIsReady) {\n        var rangesInfo = axis.allScaleSelected(value);\n\n        if (rangesInfo.startValue && rangesInfo.endValue) {\n          selectedRangeUpdateMode = RESET;\n        } else {\n          if (rangesInfo.endValue) {\n            selectedRangeUpdateMode = SHIFT;\n          } else {\n            selectedRangeUpdateMode = KEEP;\n          }\n        }\n      }\n\n      if (selectedRangeUpdateMode === RESET) {\n        options[VALUE] = null;\n      } else {\n        if (selectedRangeUpdateMode === SHIFT && valueIsReady) {\n          var _value = that.getValue();\n\n          that.__skipAnimation = true;\n          options[VALUE] = {\n            length: axis.getVisualRangeLength({\n              minVisible: _value[0],\n              maxVisible: _value[1]\n            })\n          };\n        } else {\n          if (selectedRangeUpdateMode === KEEP) {\n            that.__skipAnimation = true;\n          }\n        }\n      }\n    }\n  },\n  _change_DATA_SOURCE: function _change_DATA_SOURCE() {\n    if (this._options.dataSource) {\n      this._updateDataSource();\n    }\n  },\n  _customChangesOrder: [\"MOSTLY_TOTAL\", \"VALUE\", \"SLIDER_SELECTION\"],\n  _change_MOSTLY_TOTAL: function _change_MOSTLY_TOTAL() {\n    this._applyMostlyTotalChange();\n  },\n  _change_SLIDER_SELECTION: function _change_SLIDER_SELECTION() {\n    var that = this;\n    var value = that._options[VALUE];\n\n    that._slidersController.setSelectedRange(value && (0, _utils.getVizRangeObject)(value));\n  },\n  _change_VALUE: function _change_VALUE() {\n    var that = this;\n    var option = that._rangeOption;\n\n    if (option) {\n      that._options[VALUE] = option;\n      that.setValue(option);\n    }\n  },\n  _validateRange: function _validateRange(start, end) {\n    var that = this;\n\n    var translator = that._axis.getTranslator();\n\n    if ((0, _type2.isDefined)(start) && !translator.isValid(start) || (0, _type2.isDefined)(end) && !translator.isValid(end)) {\n      that._incidentOccurred(\"E2203\");\n    }\n  },\n  _applyChanges: function _applyChanges() {\n    var that = this;\n    var value = that._options[VALUE];\n\n    if (that._changes.has(\"VALUE\") && value) {\n      that._rangeOption = value;\n    }\n\n    that.callBase.apply(that, arguments);\n    that._rangeOption = null;\n    that.__isResizing = that.__skipAnimation = false;\n  },\n  _applyMostlyTotalChange: function _applyMostlyTotalChange() {\n    var that = this;\n    var renderer = that._renderer;\n    var rect = that._clientRect;\n    var currentAnimationEnabled;\n    var canvas = {\n      left: rect[0],\n      top: rect[1],\n      width: rect[2] - rect[0],\n      height: rect[3] - rect[1]\n    };\n\n    if (that.__isResizing || that.__skipAnimation) {\n      currentAnimationEnabled = renderer.animationEnabled();\n      renderer.updateAnimationOptions({\n        enabled: false\n      });\n    }\n\n    that._clipRect.attr({\n      x: rect[0],\n      y: rect[1],\n      width: rect[2] - rect[0],\n      height: rect[3] - rect[1]\n    });\n\n    that._axis.getTranslator().update(new _range2.default.Range(), canvas, {\n      isHorizontal: true\n    });\n\n    that._updateContent({\n      left: rect[0],\n      top: rect[1],\n      width: rect[2] - rect[0],\n      height: rect[3] - rect[1]\n    });\n\n    if (that.__isResizing || that.__skipAnimation) {\n      renderer.updateAnimationOptions({\n        enabled: currentAnimationEnabled\n      });\n    }\n\n    that._drawn();\n  },\n  _dataSourceChangedHandler: function _dataSourceChangedHandler() {\n    this._setValueByDataSource();\n\n    this._requestChange([\"MOSTLY_TOTAL\"]);\n  },\n  _completeSeriesDataSourceCreation: function _completeSeriesDataSourceCreation(scaleOptions, seriesDataSource) {\n    var rect = this._clientRect;\n    var canvas = {\n      left: rect[0],\n      top: rect[1],\n      width: rect[2] - rect[0],\n      height: rect[3] - rect[1]\n    };\n\n    this._axis.updateOptions((0, _extend.extend)({}, scaleOptions, {\n      isHorizontal: true,\n      label: {}\n    }));\n\n    seriesDataSource.isShowChart() && this._axis.setMarginOptions(seriesDataSource.getMarginOptions(canvas));\n\n    this._axis.updateCanvas(canvas);\n\n    seriesDataSource.createPoints();\n  },\n  _updateContent: function _updateContent(canvas) {\n    var that = this;\n    var chartOptions = that.option(\"chart\");\n\n    var seriesDataSource = that._createSeriesDataSource(chartOptions);\n\n    var isCompactMode = !(seriesDataSource && seriesDataSource.isShowChart() || that.option(\"background.image.url\"));\n    var scaleOptions = prepareScaleOptions(that._getOption(\"scale\"), seriesDataSource && seriesDataSource.getCalculatedValueType(), that._incidentOccurred, this._getOption(\"containerBackgroundColor\", true));\n    seriesDataSource && that._completeSeriesDataSourceCreation(scaleOptions, seriesDataSource);\n    var argTranslatorRange = calculateTranslatorRange(seriesDataSource, scaleOptions);\n    var tickIntervalsInfo = updateTickIntervals(scaleOptions, canvas.width, that._incidentOccurred, argTranslatorRange);\n    var sliderMarkerOptions;\n    var indents;\n    var rangeContainerCanvas;\n    var chartThemeManager = seriesDataSource && seriesDataSource.isShowChart() && seriesDataSource.getThemeManager();\n\n    if (chartThemeManager) {\n      checkLogarithmicOptions(chartOptions && chartOptions.valueAxis, chartThemeManager.getOptions(\"valueAxis\").logarithmBase, that._incidentOccurred);\n    }\n\n    updateScaleOptions(scaleOptions, seriesDataSource, argTranslatorRange, tickIntervalsInfo, getDateMarkerVisibilityChecker(canvas.width));\n    updateTranslatorRangeInterval(argTranslatorRange, scaleOptions);\n    sliderMarkerOptions = that._prepareSliderMarkersOptions(scaleOptions, canvas.width, tickIntervalsInfo, argTranslatorRange);\n    indents = calculateIndents(that._renderer, scaleOptions, sliderMarkerOptions, that.option(\"indent\"), tickIntervalsInfo);\n    rangeContainerCanvas = {\n      left: canvas.left + indents.left,\n      top: canvas.top + indents.top,\n      width: canvas.left + indents.left + _max(canvas.width - indents.left - indents.right, 1),\n      height: _max(!isCompactMode ? canvas.height - indents.top - indents.bottom - calculateScaleAreaHeight(that._renderer, scaleOptions, showScaleMarkers(scaleOptions), tickIntervalsInfo) : _common2.default.HEIGHT_COMPACT_MODE, 0),\n      right: 0,\n      bottom: 0\n    };\n\n    that._axis.update(scaleOptions, isCompactMode, rangeContainerCanvas, argTranslatorRange, seriesDataSource);\n\n    scaleOptions.minorTickInterval = scaleOptions.isEmpty ? 0 : scaleOptions.minorTickInterval;\n\n    that._updateElements(scaleOptions, sliderMarkerOptions, isCompactMode, rangeContainerCanvas, seriesDataSource);\n\n    if (chartThemeManager) {\n      chartThemeManager.dispose();\n    }\n  },\n  _updateElements: function _updateElements(scaleOptions, sliderMarkerOptions, isCompactMode, canvas, seriesDataSource) {\n    var that = this;\n\n    var behavior = that._getOption(\"behavior\");\n\n    var shutterOptions = that._getOption(\"shutter\");\n\n    var isNotSemiDiscrete = scaleOptions.type !== SEMIDISCRETE;\n    shutterOptions.color = shutterOptions.color || that._getOption(CONTAINER_BACKGROUND_COLOR, true);\n\n    that._rangeView.update(that.option(\"background\"), that._themeManager.theme(\"background\"), canvas, isCompactMode, behavior.animationEnabled && that._renderer.animationEnabled(), seriesDataSource);\n\n    that._isUpdating = true;\n\n    that._slidersController.update([canvas.top, canvas.top + canvas.height], behavior, isCompactMode, that._getOption(\"sliderHandle\"), sliderMarkerOptions, shutterOptions, {\n      minRange: isNotSemiDiscrete ? that.option(\"scale.minRange\") : void 0,\n      maxRange: isNotSemiDiscrete ? that.option(\"scale.maxRange\") : void 0\n    }, that._axis.getFullTicks(), that._getOption(\"selectedRangeColor\", true));\n\n    that._requestChange([\"SLIDER_SELECTION\"]);\n\n    that._isUpdating = false;\n\n    that._tracker.update(!that._axis.getTranslator().getBusinessRange().isEmpty(), behavior);\n  },\n  _createSeriesDataSource: function _createSeriesDataSource(chartOptions) {\n    var that = this;\n    var seriesDataSource;\n\n    var dataSource = that._dataSourceItems();\n\n    var scaleOptions = that._getOption(\"scale\");\n\n    var valueType = scaleOptions.valueType || calculateValueType(scaleOptions.startValue, scaleOptions.endValue);\n    var valueAxis = new _base_axis2.default.Axis({\n      renderer: that._renderer,\n      axisType: \"xyAxes\",\n      drawingType: \"linear\"\n    });\n    valueAxis.updateOptions({\n      isHorizontal: false,\n      label: {},\n      categoriesSortingMethod: that._getOption(\"chart\").valueAxis.categoriesSortingMethod\n    });\n\n    if (dataSource || chartOptions && chartOptions.series) {\n      chartOptions = (0, _extend.extend)({}, chartOptions, {\n        theme: that.option(\"theme\")\n      });\n      seriesDataSource = new _series_data_source2.default.SeriesDataSource({\n        renderer: that._renderer,\n        dataSource: dataSource,\n        valueType: (0, _utils.normalizeEnum)(valueType),\n        axisType: scaleOptions.type,\n        chart: chartOptions,\n        dataSourceField: that.option(\"dataSourceField\"),\n        incidentOccurred: that._incidentOccurred,\n        categories: scaleOptions.categories,\n        argumentAxis: that._axis,\n        valueAxis: valueAxis\n      });\n    }\n\n    return seriesDataSource;\n  },\n  _prepareSliderMarkersOptions: function _prepareSliderMarkersOptions(scaleOptions, screenDelta, tickIntervalsInfo, argRange) {\n    var that = this;\n    var minorTickInterval = tickIntervalsInfo.minorTickInterval;\n    var tickInterval = tickIntervalsInfo.tickInterval;\n    var interval = tickInterval;\n    var endValue = scaleOptions.endValue;\n    var startValue = scaleOptions.startValue;\n\n    var sliderMarkerOptions = that._getOption(SLIDER_MARKER);\n\n    var doNotSnap = !that._getOption(\"behavior\").snapToTicks;\n    var isTypeDiscrete = scaleOptions.type === DISCRETE;\n    var isValueTypeDatetime = scaleOptions.valueType === DATETIME;\n    sliderMarkerOptions.borderColor = that._getOption(CONTAINER_BACKGROUND_COLOR, true);\n\n    if (!sliderMarkerOptions.format && !argRange.isEmpty()) {\n      if (doNotSnap && (0, _type2.isNumeric)(scaleOptions.startValue)) {\n        sliderMarkerOptions.format = {\n          type: \"fixedPoint\",\n          precision: getPrecisionForSlider(startValue, endValue, screenDelta)\n        };\n      }\n\n      if (isValueTypeDatetime && !isTypeDiscrete) {\n        if ((0, _type2.isDefined)(minorTickInterval) && 0 !== minorTickInterval) {\n          interval = getMinorTickIntervalUnit(tickInterval, minorTickInterval, doNotSnap);\n        }\n\n        if (!scaleOptions.marker.visible) {\n          if ((0, _type2.isDefined)(startValue) && (0, _type2.isDefined)(endValue)) {\n            sliderMarkerOptions.format = _format_helper2.default.getDateFormatByTickInterval(startValue, endValue, interval);\n          }\n        } else {\n          sliderMarkerOptions.format = (0, _date.getDateFormatByTickInterval)(interval);\n        }\n      }\n\n      if (isValueTypeDatetime && isTypeDiscrete && tickIntervalsInfo.ticks.length) {\n        sliderMarkerOptions.format = _format_helper2.default.getDateFormatByTicks(tickIntervalsInfo.ticks);\n      }\n    }\n\n    return sliderMarkerOptions;\n  },\n  getValue: function getValue() {\n    return (0, _utils.convertVisualRangeObject)(this._slidersController.getSelectedRange());\n  },\n  setValue: function setValue(value, e) {\n    var current;\n    var visualRange = (0, _utils.getVizRangeObject)(value);\n\n    if (!this._isUpdating && value) {\n      this._validateRange(visualRange.startValue, visualRange.endValue);\n\n      current = this._slidersController.getSelectedRange();\n\n      if (!current || current.startValue !== visualRange.startValue || current.endValue !== visualRange.endValue) {\n        this._slidersController.setSelectedRange((0, _utils.getVizRangeObject)(value), e);\n      }\n    }\n  },\n  _setContentSize: function _setContentSize() {\n    this.__isResizing = 2 === this._changes.count();\n    this.callBase.apply(this, arguments);\n  }\n});\n\n(0, _iterator.each)([\"selectedRangeColor\", \"containerBackgroundColor\", \"sliderMarker\", \"sliderHandle\", \"shutter\", OPTION_BACKGROUND, \"behavior\", \"chart\", \"indent\"], function (_, name) {\n  dxRangeSelector.prototype._optionChangesMap[name] = \"MOSTLY_TOTAL\";\n});\n\nfunction prepareAxisOptions(scaleOptions, isCompactMode, height, axisPosition) {\n  scaleOptions.marker.label.font = scaleOptions.label.font;\n  scaleOptions.color = scaleOptions.marker.color = scaleOptions.tick.color;\n  scaleOptions.opacity = scaleOptions.marker.opacity = scaleOptions.tick.opacity;\n  scaleOptions.width = scaleOptions.marker.width = scaleOptions.tick.width;\n  scaleOptions.placeholderSize = (scaleOptions.placeholderHeight || 0) + axisPosition;\n  scaleOptions.argumentType = scaleOptions.valueType;\n  scaleOptions.visible = isCompactMode;\n  scaleOptions.isHorizontal = true;\n  scaleOptions.calculateMinors = true;\n  scaleOptions.semiDiscreteInterval = scaleOptions.minRange;\n\n  if (!isCompactMode) {\n    scaleOptions.minorTick.length = scaleOptions.tick.length = height;\n  }\n\n  scaleOptions.label.indentFromAxis = scaleOptions.label.topIndent + axisPosition;\n  return scaleOptions;\n}\n\nfunction createDateMarkersEvent(scaleOptions, markerTrackers, setSelectedRange) {\n  (0, _iterator.each)(markerTrackers, function (_, value) {\n    value.on(\"dxpointerdown\", onPointerDown);\n  });\n\n  function onPointerDown(e) {\n    var range = e.target.range;\n    var minRange = scaleOptions.minRange ? (0, _date.addInterval)(range.startValue, scaleOptions.minRange) : void 0;\n    var maxRange = scaleOptions.maxRange ? (0, _date.addInterval)(range.startValue, scaleOptions.maxRange) : void 0;\n\n    if (!(minRange && minRange > range.endValue || maxRange && maxRange < range.endValue)) {\n      setSelectedRange(range, e);\n    }\n  }\n}\n\nfunction getShiftDirection() {\n  return 1;\n}\n\nfunction getTickStartPositionShift(length) {\n  return length % 2 === 1 ? -_floor(length / 2) : -length / 2;\n}\n\nfunction AxisWrapper(params) {\n  var that = this;\n  that._axis = new _base_axis2.default.Axis({\n    renderer: params.renderer,\n    axesContainerGroup: params.root,\n    scaleBreaksGroup: params.scaleBreaksGroup,\n    incidentOccurred: params.incidentOccurred,\n    axisType: \"xyAxes\",\n    drawingType: \"linear\",\n    widgetClass: \"dxrs\",\n    axisClass: \"range-selector\",\n    isArgumentAxis: true\n  });\n  that._updateSelectedRangeCallback = params.updateSelectedRange;\n  that._axis.getAxisSharpDirection = that._axis.getSharpDirectionByCoords = getShiftDirection;\n  that._axis.getTickStartPositionShift = getTickStartPositionShift;\n}\n\nAxisWrapper.prototype = {\n  constructor: AxisWrapper,\n  dispose: function dispose() {\n    this._axis.dispose();\n  },\n  calculateInterval: function calculateInterval(value, prevValue) {\n    return this._axis.calculateInterval(value, prevValue);\n  },\n  update: function update(options, isCompactMode, canvas, businessRange, seriesDataSource) {\n    var axis = this._axis;\n    axis.updateOptions(prepareAxisOptions(options, isCompactMode, canvas.height, canvas.height / 2 - _ceil(options.width / 2)));\n    axis.validate();\n    axis.setBusinessRange(businessRange, true);\n\n    if (void 0 !== seriesDataSource && seriesDataSource.isShowChart()) {\n      axis.setMarginOptions(seriesDataSource.getMarginOptions(canvas));\n    }\n\n    axis.draw(canvas);\n    axis.shift({\n      left: 0,\n      bottom: -canvas.height / 2 + canvas.top\n    });\n\n    if (axis.getMarkerTrackers()) {\n      createDateMarkersEvent(options, axis.getMarkerTrackers(), this._updateSelectedRangeCallback);\n    }\n\n    axis.drawScaleBreaks({\n      start: canvas.top,\n      end: canvas.top + canvas.height\n    });\n  },\n  visualRange: function visualRange() {},\n  getViewport: function getViewport() {\n    return {};\n  },\n  allScaleSelected: function allScaleSelected(value) {\n    var _this$_axis$visualRan = this._axis.visualRange(),\n        startValue = _this$_axis$visualRan.startValue,\n        endValue = _this$_axis$visualRan.endValue;\n\n    return {\n      startValue: value[0].valueOf() === startValue.valueOf(),\n      endValue: value[1].valueOf() === endValue.valueOf()\n    };\n  },\n  getOptions: function getOptions() {\n    return this._axis.getOptions() || {};\n  }\n};\n[\"setMarginOptions\", \"getFullTicks\", \"updateCanvas\", \"updateOptions\", \"getAggregationInfo\", \"getTranslator\", \"getVisualRangeLength\", \"getVisibleArea\", \"getMarginOptions\"].forEach(function (methodName) {\n  AxisWrapper.prototype[methodName] = function () {\n    var axis = this._axis;\n    return axis[methodName].apply(axis, arguments);\n  };\n});\n(0, _component_registrator2.default)(\"dxRangeSelector\", dxRangeSelector);\nmodule.exports = dxRangeSelector;\ndxRangeSelector.addPlugin(_export.plugin);\ndxRangeSelector.addPlugin(_title.plugin);\ndxRangeSelector.addPlugin(_loading_indicator.plugin);\ndxRangeSelector.addPlugin(_data_source.plugin);","map":null,"metadata":{},"sourceType":"script"}