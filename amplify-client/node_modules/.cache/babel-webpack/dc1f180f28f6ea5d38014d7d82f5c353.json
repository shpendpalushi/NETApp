{"ast":null,"code":"/**\r\n * DevExtreme (viz/series/line_series.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar series = require(\"./scatter_series\");\n\nvar chartScatterSeries = series.chart;\nvar polarScatterSeries = series.polar;\n\nvar objectUtils = require(\"../../core/utils/object\");\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar each = require(\"../../core/utils/iterator\").each;\n\nvar vizUtils = require(\"../core/utils\");\n\nvar mathUtils = require(\"../../core/utils/math\");\n\nvar normalizeAngle = vizUtils.normalizeAngle;\nvar DISCRETE = \"discrete\";\nvar _map = vizUtils.map;\nvar _extend = extend;\nvar _each = each;\nexports.chart = {};\nexports.polar = {};\n\nfunction clonePoint(point, newX, newY, newAngle) {\n  var p = objectUtils.clone(point);\n  p.x = newX;\n  p.y = newY;\n  p.angle = newAngle;\n  return p;\n}\n\nfunction getTangentPoint(point, prevPoint, centerPoint, tan, nextStepAngle) {\n  var correctAngle = point.angle + nextStepAngle;\n  var cosSin = vizUtils.getCosAndSin(correctAngle);\n  var x = centerPoint.x + (point.radius + tan * nextStepAngle) * cosSin.cos;\n  var y = centerPoint.y - (point.radius + tan * nextStepAngle) * cosSin.sin;\n  return clonePoint(prevPoint, x, y, correctAngle);\n}\n\nfunction obtainCubicBezierTCoef(p, p0, p1, p2, p3) {\n  var d = p0 - p;\n  var c = 3 * p1 - 3 * p0;\n  var b = 3 * p2 - 6 * p1 + 3 * p0;\n  var a = p3 - 3 * p2 + 3 * p1 - p0;\n  return mathUtils.solveCubicEquation(a, b, c, d);\n}\n\nvar lineMethods = {\n  autoHidePointMarkersEnabled: function autoHidePointMarkersEnabled() {\n    return true;\n  },\n  _applyGroupSettings: function _applyGroupSettings(style, settings, group) {\n    var that = this;\n    settings = _extend(settings, style);\n\n    that._applyElementsClipRect(settings);\n\n    group.attr(settings);\n  },\n  _setGroupsSettings: function _setGroupsSettings(animationEnabled) {\n    var that = this;\n    var style = that._styles.normal;\n\n    that._applyGroupSettings(style.elements, {\n      \"class\": \"dxc-elements\"\n    }, that._elementsGroup);\n\n    that._bordersGroup && that._applyGroupSettings(style.border, {\n      \"class\": \"dxc-borders\"\n    }, that._bordersGroup);\n\n    chartScatterSeries._setGroupsSettings.call(that, animationEnabled);\n\n    animationEnabled && that._markersGroup && that._markersGroup.attr({\n      opacity: .001\n    });\n  },\n  _createGroups: function _createGroups() {\n    var that = this;\n\n    that._createGroup(\"_elementsGroup\", that, that._group);\n\n    that._areBordersVisible() && that._createGroup(\"_bordersGroup\", that, that._group);\n\n    chartScatterSeries._createGroups.call(that);\n  },\n  _areBordersVisible: function _areBordersVisible() {\n    return false;\n  },\n  _getDefaultSegment: function _getDefaultSegment(segment) {\n    return {\n      line: _map(segment.line || [], function (pt) {\n        return pt.getDefaultCoords();\n      })\n    };\n  },\n  _prepareSegment: function _prepareSegment(points) {\n    return {\n      line: points\n    };\n  },\n  _parseLineOptions: function _parseLineOptions(options, defaultColor) {\n    return {\n      stroke: options.color || defaultColor,\n      \"stroke-width\": options.width,\n      dashStyle: options.dashStyle || \"solid\"\n    };\n  },\n  _parseStyle: function _parseStyle(options, defaultColor) {\n    return {\n      elements: this._parseLineOptions(options, defaultColor)\n    };\n  },\n  _applyStyle: function _applyStyle(style) {\n    var that = this;\n    that._elementsGroup && that._elementsGroup.attr(style.elements);\n\n    _each(that._graphics || [], function (_, graphic) {\n      graphic.line && graphic.line.attr({\n        \"stroke-width\": style.elements[\"stroke-width\"]\n      }).sharp();\n    });\n  },\n  _drawElement: function _drawElement(segment, group) {\n    return {\n      line: this._createMainElement(segment.line, {\n        \"stroke-width\": this._styles.normal.elements[\"stroke-width\"]\n      }).append(group)\n    };\n  },\n  _removeElement: function _removeElement(element) {\n    element.line.remove();\n  },\n  _updateElement: function _updateElement(element, segment, animate, animationComplete) {\n    var params = {\n      points: segment.line\n    };\n    var lineElement = element.line;\n    animate ? lineElement.animate(params, {}, animationComplete) : lineElement.attr(params);\n  },\n  _animateComplete: function _animateComplete() {\n    var that = this;\n\n    chartScatterSeries._animateComplete.call(that);\n\n    that._markersGroup && that._markersGroup.animate({\n      opacity: 1\n    }, {\n      duration: that._defaultDuration\n    });\n  },\n  _animate: function _animate() {\n    var that = this;\n    var lastIndex = that._graphics.length - 1;\n\n    _each(that._graphics || [], function (i, elem) {\n      var complete;\n\n      if (i === lastIndex) {\n        complete = function complete() {\n          that._animateComplete();\n        };\n      }\n\n      that._updateElement(elem, that._segments[i], true, complete);\n    });\n  },\n  _drawPoint: function _drawPoint(options) {\n    chartScatterSeries._drawPoint.call(this, {\n      point: options.point,\n      groups: options.groups\n    });\n  },\n  _createMainElement: function _createMainElement(points, settings) {\n    return this._renderer.path(points, \"line\").attr(settings).sharp();\n  },\n  _sortPoints: function _sortPoints(points, rotated) {\n    return rotated ? points.sort(function (p1, p2) {\n      return p2.y - p1.y;\n    }) : points.sort(function (p1, p2) {\n      return p1.x - p2.x;\n    });\n  },\n  _drawSegment: function _drawSegment(points, animationEnabled, segmentCount, lastSegment) {\n    var that = this;\n    var rotated = that._options.rotated;\n    var forceDefaultSegment = false;\n\n    var segment = that._prepareSegment(points, rotated, lastSegment);\n\n    that._segments.push(segment);\n\n    if (!that._graphics[segmentCount]) {\n      that._graphics[segmentCount] = that._drawElement(animationEnabled ? that._getDefaultSegment(segment) : segment, that._elementsGroup);\n    } else {\n      if (!animationEnabled) {\n        that._updateElement(that._graphics[segmentCount], segment);\n      } else {\n        if (forceDefaultSegment) {\n          that._updateElement(that._graphics[segmentCount], that._getDefaultSegment(segment));\n        }\n      }\n    }\n  },\n  _getTrackerSettings: function _getTrackerSettings() {\n    var that = this;\n    var defaultTrackerWidth = that._defaultTrackerWidth;\n    var strokeWidthFromElements = that._styles.normal.elements[\"stroke-width\"];\n    return {\n      \"stroke-width\": strokeWidthFromElements > defaultTrackerWidth ? strokeWidthFromElements : defaultTrackerWidth,\n      fill: \"none\"\n    };\n  },\n  _getMainPointsFromSegment: function _getMainPointsFromSegment(segment) {\n    return segment.line;\n  },\n  _drawTrackerElement: function _drawTrackerElement(segment) {\n    return this._createMainElement(this._getMainPointsFromSegment(segment), this._getTrackerSettings(segment));\n  },\n  _updateTrackerElement: function _updateTrackerElement(segment, element) {\n    var settings = this._getTrackerSettings(segment);\n\n    settings.points = this._getMainPointsFromSegment(segment);\n    element.attr(settings);\n  },\n  checkSeriesViewportCoord: function checkSeriesViewportCoord(axis, coord) {\n    if (0 === this._points.length) {\n      return false;\n    }\n\n    var range = axis.isArgumentAxis ? this.getArgumentRange() : this.getViewport();\n    var min = axis.getTranslator().translate(range.categories ? range.categories[0] : range.min);\n    var max = axis.getTranslator().translate(range.categories ? range.categories[range.categories.length - 1] : range.max);\n    var rotated = this.getOptions().rotated;\n    var inverted = axis.getOptions().inverted;\n    return axis.isArgumentAxis && (!rotated && !inverted || rotated && inverted) || !axis.isArgumentAxis && (rotated && !inverted || !rotated && inverted) ? coord >= min && coord <= max : coord >= max && coord <= min;\n  },\n  getSeriesPairCoord: function getSeriesPairCoord(coord, isArgument) {\n    var that = this;\n    var oppositeCoord = null;\n    var nearestPoints = this.getNearestPointsByCoord(coord, isArgument);\n    var needValueCoord = isArgument && !that._options.rotated || !isArgument && that._options.rotated;\n\n    for (var i = 0; i < nearestPoints.length; i++) {\n      var p = nearestPoints[i];\n      var k = (p[1].vy - p[0].vy) / (p[1].vx - p[0].vx);\n      var b = p[0].vy - p[0].vx * k;\n      var tmpCoord = void 0;\n\n      if (p[1].vx - p[0].vx === 0) {\n        tmpCoord = needValueCoord ? p[0].vy : p[0].vx;\n      } else {\n        tmpCoord = needValueCoord ? k * coord + b : (coord - b) / k;\n      }\n\n      if (this.checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\n        oppositeCoord = tmpCoord;\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  }\n};\n\nvar lineSeries = exports.chart.line = _extend({}, chartScatterSeries, lineMethods, {\n  getPointCenterByArg: function getPointCenterByArg(arg) {\n    var value = this.getArgumentAxis().getTranslator().translate(arg);\n    return {\n      x: value,\n      y: value\n    };\n  }\n});\n\nexports.chart.stepline = _extend({}, lineSeries, {\n  _calculateStepLinePoints: function _calculateStepLinePoints(points) {\n    var segment = [];\n    var coordName = this._options.rotated ? \"x\" : \"y\";\n\n    _each(points, function (i, pt) {\n      var point;\n\n      if (!i) {\n        segment.push(pt);\n        return;\n      }\n\n      var step = segment[segment.length - 1][coordName];\n\n      if (step !== pt[coordName]) {\n        point = objectUtils.clone(pt);\n        point[coordName] = step;\n        segment.push(point);\n      }\n\n      segment.push(pt);\n    });\n\n    return segment;\n  },\n  _prepareSegment: function _prepareSegment(points) {\n    return lineSeries._prepareSegment(this._calculateStepLinePoints(points));\n  },\n  getSeriesPairCoord: function getSeriesPairCoord(coord, isArgument) {\n    var oppositeCoord;\n    var rotated = this._options.rotated;\n    var isOpposite = !isArgument && !rotated || isArgument && rotated;\n    var coordName = !isOpposite ? \"vx\" : \"vy\";\n    var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\n    var nearestPoints = this.getNearestPointsByCoord(coord, isArgument);\n\n    for (var i = 0; i < nearestPoints.length; i++) {\n      var p = nearestPoints[i];\n      var tmpCoord = void 0;\n\n      if (isArgument) {\n        tmpCoord = coord !== p[1][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName];\n      } else {\n        tmpCoord = coord === p[0][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName];\n      }\n\n      if (this.checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\n        oppositeCoord = tmpCoord;\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  }\n});\nexports.chart.spline = _extend({}, lineSeries, {\n  _calculateBezierPoints: function _calculateBezierPoints(src, rotated) {\n    var bezierPoints = [];\n    var pointsCopy = src;\n\n    var checkExtremum = function checkExtremum(otherPointCoord, pointCoord, controlCoord) {\n      return otherPointCoord > pointCoord && controlCoord > otherPointCoord || otherPointCoord < pointCoord && controlCoord < otherPointCoord ? otherPointCoord : controlCoord;\n    };\n\n    if (1 !== pointsCopy.length) {\n      pointsCopy.forEach(function (curPoint, i) {\n        var leftControlX;\n        var leftControlY;\n        var rightControlX;\n        var rightControlY;\n        var prevPoint = pointsCopy[i - 1];\n        var nextPoint = pointsCopy[i + 1];\n        var xCur;\n        var yCur;\n        var x1;\n        var x2;\n        var y1;\n        var y2;\n        var lambda = .5;\n        var curIsExtremum;\n        var leftPoint;\n        var rightPoint;\n        var a;\n        var b;\n        var c;\n        var xc;\n        var yc;\n        var shift;\n\n        if (!i || i === pointsCopy.length - 1) {\n          bezierPoints.push(curPoint, curPoint);\n          return;\n        }\n\n        xCur = curPoint.x;\n        yCur = curPoint.y;\n        x1 = prevPoint.x;\n        x2 = nextPoint.x;\n        y1 = prevPoint.y;\n        y2 = nextPoint.y;\n        curIsExtremum = !!(!rotated && (yCur <= prevPoint.y && yCur <= nextPoint.y || yCur >= prevPoint.y && yCur >= nextPoint.y) || rotated && (xCur <= prevPoint.x && xCur <= nextPoint.x || xCur >= prevPoint.x && xCur >= nextPoint.x));\n\n        if (curIsExtremum) {\n          if (!rotated) {\n            rightControlY = leftControlY = yCur;\n            rightControlX = (xCur + nextPoint.x) / 2;\n            leftControlX = (xCur + prevPoint.x) / 2;\n          } else {\n            rightControlX = leftControlX = xCur;\n            rightControlY = (yCur + nextPoint.y) / 2;\n            leftControlY = (yCur + prevPoint.y) / 2;\n          }\n        } else {\n          a = y2 - y1;\n          b = x1 - x2;\n          c = y1 * x2 - x1 * y2;\n\n          if (!rotated) {\n            if (!b) {\n              bezierPoints.push(curPoint, curPoint, curPoint);\n              return;\n            }\n\n            xc = xCur;\n            yc = -1 * (a * xc + c) / b;\n            shift = yc - yCur;\n            y1 -= shift;\n            y2 -= shift;\n          } else {\n            if (!a) {\n              bezierPoints.push(curPoint, curPoint, curPoint);\n              return;\n            }\n\n            yc = yCur;\n            xc = -1 * (b * yc + c) / a;\n            shift = xc - xCur;\n            x1 -= shift;\n            x2 -= shift;\n          }\n\n          rightControlX = (xCur + lambda * x2) / (1 + lambda);\n          rightControlY = (yCur + lambda * y2) / (1 + lambda);\n          leftControlX = (xCur + lambda * x1) / (1 + lambda);\n          leftControlY = (yCur + lambda * y1) / (1 + lambda);\n        }\n\n        if (!rotated) {\n          leftControlY = checkExtremum(prevPoint.y, yCur, leftControlY);\n          rightControlY = checkExtremum(nextPoint.y, yCur, rightControlY);\n        } else {\n          leftControlX = checkExtremum(prevPoint.x, xCur, leftControlX);\n          rightControlX = checkExtremum(nextPoint.x, xCur, rightControlX);\n        }\n\n        leftPoint = clonePoint(curPoint, leftControlX, leftControlY);\n        rightPoint = clonePoint(curPoint, rightControlX, rightControlY);\n        bezierPoints.push(leftPoint, curPoint, rightPoint);\n      });\n    } else {\n      bezierPoints.push(pointsCopy[0]);\n    }\n\n    return bezierPoints;\n  },\n  _prepareSegment: function _prepareSegment(points, rotated) {\n    return lineSeries._prepareSegment(this._calculateBezierPoints(points, rotated));\n  },\n  _createMainElement: function _createMainElement(points, settings) {\n    return this._renderer.path(points, \"bezier\").attr(settings).sharp();\n  },\n  getSeriesPairCoord: function getSeriesPairCoord(coord, isArgument) {\n    var that = this;\n    var oppositeCoord = null;\n    var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;\n    var coordName = !isOpposite ? \"vx\" : \"vy\";\n    var bezierCoordName = !isOpposite ? \"x\" : \"y\";\n    var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\n    var bezierOppositeCoordName = !isOpposite ? \"y\" : \"x\";\n    var axis = !isArgument ? that.getArgumentAxis() : that.getValueAxis();\n    var visibleArea = axis.getVisibleArea();\n    var nearestPoints = this.getNearestPointsByCoord(coord, isArgument);\n\n    var _loop = function _loop(i) {\n      var p = nearestPoints[i];\n\n      if (1 === p.length) {\n        visibleArea[0] <= p[0][oppositeCoordName] && visibleArea[1] >= p[0][oppositeCoordName] && (oppositeCoord = p[0][oppositeCoordName]);\n      } else {\n        var ts = obtainCubicBezierTCoef(coord, p[0][coordName], p[1][bezierCoordName], p[2][bezierCoordName], p[3][coordName]);\n        ts.forEach(function (t) {\n          if (t >= 0 && t <= 1) {\n            var tmpCoord = Math.pow(1 - t, 3) * p[0][oppositeCoordName] + 3 * Math.pow(1 - t, 2) * t * p[1][bezierOppositeCoordName] + 3 * (1 - t) * t * t * p[2][bezierOppositeCoordName] + t * t * t * p[3][oppositeCoordName];\n\n            if (visibleArea[0] <= tmpCoord && visibleArea[1] >= tmpCoord) {\n              oppositeCoord = tmpCoord;\n            }\n          }\n        });\n      }\n\n      if (null !== oppositeCoord) {\n        return \"break\";\n      }\n    };\n\n    for (var i = 0; i < nearestPoints.length; i++) {\n      var _ret = _loop(i);\n\n      if (\"break\" === _ret) {\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  },\n  getNearestPointsByCoord: function getNearestPointsByCoord(coord, isArgument) {\n    var that = this;\n    var rotated = that.getOptions().rotated;\n    var isOpposite = !isArgument && !rotated || isArgument && rotated;\n    var coordName = isOpposite ? \"vy\" : \"vx\";\n    var points = that.getVisiblePoints();\n    var allPoints = that.getPoints();\n    var bezierPoints = that._segments.length > 0 ? that._segments.reduce(function (a, seg) {\n      return a.concat(seg.line);\n    }, []) : [];\n    var nearestPoints = [];\n\n    if (that.isVisible() && allPoints.length > 0) {\n      if (allPoints.length > 1) {\n        that.findNeighborPointsByCoord(coord, coordName, points.slice(0), allPoints, function (point, nextPoint) {\n          var index = bezierPoints.indexOf(point);\n          nearestPoints.push([point, bezierPoints[index + 1], bezierPoints[index + 2], nextPoint]);\n        });\n      } else {\n        if (allPoints[0][coordName] === coord) {\n          nearestPoints.push([allPoints[0]]);\n        }\n      }\n    }\n\n    return nearestPoints;\n  }\n});\nexports.polar.line = _extend({}, polarScatterSeries, lineMethods, {\n  _sortPoints: function _sortPoints(points) {\n    return points;\n  },\n  _prepareSegment: function _prepareSegment(points, rotated, lastSegment) {\n    var preparedPoints = [];\n    var centerPoint = this.getValueAxis().getCenter();\n    var i;\n    lastSegment && this._closeSegment(points);\n\n    if (this.argumentAxisType !== DISCRETE && this.valueAxisType !== DISCRETE) {\n      for (i = 1; i < points.length; i++) {\n        preparedPoints = preparedPoints.concat(this._getTangentPoints(points[i], points[i - 1], centerPoint));\n      }\n\n      if (!preparedPoints.length) {\n        preparedPoints = points;\n      }\n    } else {\n      return lineSeries._prepareSegment.call(this, points);\n    }\n\n    return {\n      line: preparedPoints\n    };\n  },\n  _getRemainingAngle: function _getRemainingAngle(angle) {\n    var normAngle = normalizeAngle(angle);\n    return angle >= 0 ? 360 - normAngle : -normAngle;\n  },\n  _closeSegment: function _closeSegment(points) {\n    var point;\n    var differenceAngle;\n\n    if (this._segments.length) {\n      point = this._segments[0].line[0];\n    } else {\n      point = clonePoint(points[0], points[0].x, points[0].y, points[0].angle);\n    }\n\n    if (points[points.length - 1].angle !== point.angle) {\n      if (normalizeAngle(Math.round(points[points.length - 1].angle)) === normalizeAngle(Math.round(point.angle))) {\n        point.angle = points[points.length - 1].angle;\n      } else {\n        differenceAngle = points[points.length - 1].angle - point.angle;\n        point.angle = points[points.length - 1].angle + this._getRemainingAngle(differenceAngle);\n      }\n\n      points.push(point);\n    }\n  },\n  _getTangentPoints: function _getTangentPoints(point, prevPoint, centerPoint) {\n    var tangentPoints = [];\n    var betweenAngle = Math.round(prevPoint.angle - point.angle);\n    var tan = (prevPoint.radius - point.radius) / betweenAngle;\n    var i;\n\n    if (0 === betweenAngle) {\n      tangentPoints = [prevPoint, point];\n    } else {\n      if (betweenAngle > 0) {\n        for (i = betweenAngle; i >= 0; i--) {\n          tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, i));\n        }\n      } else {\n        for (i = 0; i >= betweenAngle; i--) {\n          tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, betweenAngle - i));\n        }\n      }\n    }\n\n    return tangentPoints;\n  }\n});","map":{"version":3,"sources":["C:/Users/User/Documents/Templates/Angular/black-dashboard-pro-angular-v1.1.1/black-dashboard-pro-angular-v1.1.1/node_modules/devextreme/viz/series/line_series.js"],"names":["series","require","chartScatterSeries","chart","polarScatterSeries","polar","objectUtils","extend","each","vizUtils","mathUtils","normalizeAngle","DISCRETE","_map","map","_extend","_each","exports","clonePoint","point","newX","newY","newAngle","p","clone","x","y","angle","getTangentPoint","prevPoint","centerPoint","tan","nextStepAngle","correctAngle","cosSin","getCosAndSin","radius","cos","sin","obtainCubicBezierTCoef","p0","p1","p2","p3","d","c","b","a","solveCubicEquation","lineMethods","autoHidePointMarkersEnabled","_applyGroupSettings","style","settings","group","that","_applyElementsClipRect","attr","_setGroupsSettings","animationEnabled","_styles","normal","elements","_elementsGroup","_bordersGroup","border","call","_markersGroup","opacity","_createGroups","_createGroup","_group","_areBordersVisible","_getDefaultSegment","segment","line","pt","getDefaultCoords","_prepareSegment","points","_parseLineOptions","options","defaultColor","stroke","color","width","dashStyle","_parseStyle","_applyStyle","_graphics","_","graphic","sharp","_drawElement","_createMainElement","append","_removeElement","element","remove","_updateElement","animate","animationComplete","params","lineElement","_animateComplete","duration","_defaultDuration","_animate","lastIndex","length","i","elem","complete","_segments","_drawPoint","groups","_renderer","path","_sortPoints","rotated","sort","_drawSegment","segmentCount","lastSegment","_options","forceDefaultSegment","push","_getTrackerSettings","defaultTrackerWidth","_defaultTrackerWidth","strokeWidthFromElements","fill","_getMainPointsFromSegment","_drawTrackerElement","_updateTrackerElement","checkSeriesViewportCoord","axis","coord","_points","range","isArgumentAxis","getArgumentRange","getViewport","min","getTranslator","translate","categories","max","getOptions","inverted","getSeriesPairCoord","isArgument","oppositeCoord","nearestPoints","getNearestPointsByCoord","needValueCoord","k","vy","vx","tmpCoord","checkAxisVisibleAreaCoord","lineSeries","getPointCenterByArg","arg","value","getArgumentAxis","stepline","_calculateStepLinePoints","coordName","step","isOpposite","oppositeCoordName","spline","_calculateBezierPoints","src","bezierPoints","pointsCopy","checkExtremum","otherPointCoord","pointCoord","controlCoord","forEach","curPoint","leftControlX","leftControlY","rightControlX","rightControlY","nextPoint","xCur","yCur","x1","x2","y1","y2","lambda","curIsExtremum","leftPoint","rightPoint","xc","yc","shift","bezierCoordName","bezierOppositeCoordName","getValueAxis","visibleArea","getVisibleArea","_loop","ts","t","Math","pow","_ret","getVisiblePoints","allPoints","getPoints","reduce","seg","concat","isVisible","findNeighborPointsByCoord","slice","index","indexOf","preparedPoints","getCenter","_closeSegment","argumentAxisType","valueAxisType","_getTangentPoints","_getRemainingAngle","normAngle","differenceAngle","round","tangentPoints","betweenAngle"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (viz/series/line_series.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nvar series = require(\"./scatter_series\");\r\nvar chartScatterSeries = series.chart;\r\nvar polarScatterSeries = series.polar;\r\nvar objectUtils = require(\"../../core/utils/object\");\r\nvar extend = require(\"../../core/utils/extend\").extend;\r\nvar each = require(\"../../core/utils/iterator\").each;\r\nvar vizUtils = require(\"../core/utils\");\r\nvar mathUtils = require(\"../../core/utils/math\");\r\nvar normalizeAngle = vizUtils.normalizeAngle;\r\nvar DISCRETE = \"discrete\";\r\nvar _map = vizUtils.map;\r\nvar _extend = extend;\r\nvar _each = each;\r\nexports.chart = {};\r\nexports.polar = {};\r\n\r\nfunction clonePoint(point, newX, newY, newAngle) {\r\n    var p = objectUtils.clone(point);\r\n    p.x = newX;\r\n    p.y = newY;\r\n    p.angle = newAngle;\r\n    return p\r\n}\r\n\r\nfunction getTangentPoint(point, prevPoint, centerPoint, tan, nextStepAngle) {\r\n    var correctAngle = point.angle + nextStepAngle;\r\n    var cosSin = vizUtils.getCosAndSin(correctAngle);\r\n    var x = centerPoint.x + (point.radius + tan * nextStepAngle) * cosSin.cos;\r\n    var y = centerPoint.y - (point.radius + tan * nextStepAngle) * cosSin.sin;\r\n    return clonePoint(prevPoint, x, y, correctAngle)\r\n}\r\n\r\nfunction obtainCubicBezierTCoef(p, p0, p1, p2, p3) {\r\n    var d = p0 - p;\r\n    var c = 3 * p1 - 3 * p0;\r\n    var b = 3 * p2 - 6 * p1 + 3 * p0;\r\n    var a = p3 - 3 * p2 + 3 * p1 - p0;\r\n    return mathUtils.solveCubicEquation(a, b, c, d)\r\n}\r\nvar lineMethods = {\r\n    autoHidePointMarkersEnabled: function() {\r\n        return true\r\n    },\r\n    _applyGroupSettings: function(style, settings, group) {\r\n        var that = this;\r\n        settings = _extend(settings, style);\r\n        that._applyElementsClipRect(settings);\r\n        group.attr(settings)\r\n    },\r\n    _setGroupsSettings: function(animationEnabled) {\r\n        var that = this;\r\n        var style = that._styles.normal;\r\n        that._applyGroupSettings(style.elements, {\r\n            \"class\": \"dxc-elements\"\r\n        }, that._elementsGroup);\r\n        that._bordersGroup && that._applyGroupSettings(style.border, {\r\n            \"class\": \"dxc-borders\"\r\n        }, that._bordersGroup);\r\n        chartScatterSeries._setGroupsSettings.call(that, animationEnabled);\r\n        animationEnabled && that._markersGroup && that._markersGroup.attr({\r\n            opacity: .001\r\n        })\r\n    },\r\n    _createGroups: function() {\r\n        var that = this;\r\n        that._createGroup(\"_elementsGroup\", that, that._group);\r\n        that._areBordersVisible() && that._createGroup(\"_bordersGroup\", that, that._group);\r\n        chartScatterSeries._createGroups.call(that)\r\n    },\r\n    _areBordersVisible: function() {\r\n        return false\r\n    },\r\n    _getDefaultSegment: function(segment) {\r\n        return {\r\n            line: _map(segment.line || [], function(pt) {\r\n                return pt.getDefaultCoords()\r\n            })\r\n        }\r\n    },\r\n    _prepareSegment: function(points) {\r\n        return {\r\n            line: points\r\n        }\r\n    },\r\n    _parseLineOptions: function(options, defaultColor) {\r\n        return {\r\n            stroke: options.color || defaultColor,\r\n            \"stroke-width\": options.width,\r\n            dashStyle: options.dashStyle || \"solid\"\r\n        }\r\n    },\r\n    _parseStyle: function(options, defaultColor) {\r\n        return {\r\n            elements: this._parseLineOptions(options, defaultColor)\r\n        }\r\n    },\r\n    _applyStyle: function(style) {\r\n        var that = this;\r\n        that._elementsGroup && that._elementsGroup.attr(style.elements);\r\n        _each(that._graphics || [], function(_, graphic) {\r\n            graphic.line && graphic.line.attr({\r\n                \"stroke-width\": style.elements[\"stroke-width\"]\r\n            }).sharp()\r\n        })\r\n    },\r\n    _drawElement: function(segment, group) {\r\n        return {\r\n            line: this._createMainElement(segment.line, {\r\n                \"stroke-width\": this._styles.normal.elements[\"stroke-width\"]\r\n            }).append(group)\r\n        }\r\n    },\r\n    _removeElement: function(element) {\r\n        element.line.remove()\r\n    },\r\n    _updateElement: function(element, segment, animate, animationComplete) {\r\n        var params = {\r\n            points: segment.line\r\n        };\r\n        var lineElement = element.line;\r\n        animate ? lineElement.animate(params, {}, animationComplete) : lineElement.attr(params)\r\n    },\r\n    _animateComplete: function() {\r\n        var that = this;\r\n        chartScatterSeries._animateComplete.call(that);\r\n        that._markersGroup && that._markersGroup.animate({\r\n            opacity: 1\r\n        }, {\r\n            duration: that._defaultDuration\r\n        })\r\n    },\r\n    _animate: function() {\r\n        var that = this;\r\n        var lastIndex = that._graphics.length - 1;\r\n        _each(that._graphics || [], function(i, elem) {\r\n            var complete;\r\n            if (i === lastIndex) {\r\n                complete = function() {\r\n                    that._animateComplete()\r\n                }\r\n            }\r\n            that._updateElement(elem, that._segments[i], true, complete)\r\n        })\r\n    },\r\n    _drawPoint: function(options) {\r\n        chartScatterSeries._drawPoint.call(this, {\r\n            point: options.point,\r\n            groups: options.groups\r\n        })\r\n    },\r\n    _createMainElement: function(points, settings) {\r\n        return this._renderer.path(points, \"line\").attr(settings).sharp()\r\n    },\r\n    _sortPoints: function(points, rotated) {\r\n        return rotated ? points.sort(function(p1, p2) {\r\n            return p2.y - p1.y\r\n        }) : points.sort(function(p1, p2) {\r\n            return p1.x - p2.x\r\n        })\r\n    },\r\n    _drawSegment: function(points, animationEnabled, segmentCount, lastSegment) {\r\n        var that = this;\r\n        var rotated = that._options.rotated;\r\n        var forceDefaultSegment = false;\r\n        var segment = that._prepareSegment(points, rotated, lastSegment);\r\n        that._segments.push(segment);\r\n        if (!that._graphics[segmentCount]) {\r\n            that._graphics[segmentCount] = that._drawElement(animationEnabled ? that._getDefaultSegment(segment) : segment, that._elementsGroup)\r\n        } else {\r\n            if (!animationEnabled) {\r\n                that._updateElement(that._graphics[segmentCount], segment)\r\n            } else {\r\n                if (forceDefaultSegment) {\r\n                    that._updateElement(that._graphics[segmentCount], that._getDefaultSegment(segment))\r\n                }\r\n            }\r\n        }\r\n    },\r\n    _getTrackerSettings: function() {\r\n        var that = this;\r\n        var defaultTrackerWidth = that._defaultTrackerWidth;\r\n        var strokeWidthFromElements = that._styles.normal.elements[\"stroke-width\"];\r\n        return {\r\n            \"stroke-width\": strokeWidthFromElements > defaultTrackerWidth ? strokeWidthFromElements : defaultTrackerWidth,\r\n            fill: \"none\"\r\n        }\r\n    },\r\n    _getMainPointsFromSegment: function(segment) {\r\n        return segment.line\r\n    },\r\n    _drawTrackerElement: function(segment) {\r\n        return this._createMainElement(this._getMainPointsFromSegment(segment), this._getTrackerSettings(segment))\r\n    },\r\n    _updateTrackerElement: function(segment, element) {\r\n        var settings = this._getTrackerSettings(segment);\r\n        settings.points = this._getMainPointsFromSegment(segment);\r\n        element.attr(settings)\r\n    },\r\n    checkSeriesViewportCoord: function(axis, coord) {\r\n        if (0 === this._points.length) {\r\n            return false\r\n        }\r\n        var range = axis.isArgumentAxis ? this.getArgumentRange() : this.getViewport();\r\n        var min = axis.getTranslator().translate(range.categories ? range.categories[0] : range.min);\r\n        var max = axis.getTranslator().translate(range.categories ? range.categories[range.categories.length - 1] : range.max);\r\n        var rotated = this.getOptions().rotated;\r\n        var inverted = axis.getOptions().inverted;\r\n        return axis.isArgumentAxis && (!rotated && !inverted || rotated && inverted) || !axis.isArgumentAxis && (rotated && !inverted || !rotated && inverted) ? coord >= min && coord <= max : coord >= max && coord <= min\r\n    },\r\n    getSeriesPairCoord: function(coord, isArgument) {\r\n        var that = this;\r\n        var oppositeCoord = null;\r\n        var nearestPoints = this.getNearestPointsByCoord(coord, isArgument);\r\n        var needValueCoord = isArgument && !that._options.rotated || !isArgument && that._options.rotated;\r\n        for (var i = 0; i < nearestPoints.length; i++) {\r\n            var p = nearestPoints[i];\r\n            var k = (p[1].vy - p[0].vy) / (p[1].vx - p[0].vx);\r\n            var b = p[0].vy - p[0].vx * k;\r\n            var tmpCoord = void 0;\r\n            if (p[1].vx - p[0].vx === 0) {\r\n                tmpCoord = needValueCoord ? p[0].vy : p[0].vx\r\n            } else {\r\n                tmpCoord = needValueCoord ? k * coord + b : (coord - b) / k\r\n            }\r\n            if (this.checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\r\n                oppositeCoord = tmpCoord;\r\n                break\r\n            }\r\n        }\r\n        return oppositeCoord\r\n    }\r\n};\r\nvar lineSeries = exports.chart.line = _extend({}, chartScatterSeries, lineMethods, {\r\n    getPointCenterByArg: function(arg) {\r\n        var value = this.getArgumentAxis().getTranslator().translate(arg);\r\n        return {\r\n            x: value,\r\n            y: value\r\n        }\r\n    }\r\n});\r\nexports.chart.stepline = _extend({}, lineSeries, {\r\n    _calculateStepLinePoints: function(points) {\r\n        var segment = [];\r\n        var coordName = this._options.rotated ? \"x\" : \"y\";\r\n        _each(points, function(i, pt) {\r\n            var point;\r\n            if (!i) {\r\n                segment.push(pt);\r\n                return\r\n            }\r\n            var step = segment[segment.length - 1][coordName];\r\n            if (step !== pt[coordName]) {\r\n                point = objectUtils.clone(pt);\r\n                point[coordName] = step;\r\n                segment.push(point)\r\n            }\r\n            segment.push(pt)\r\n        });\r\n        return segment\r\n    },\r\n    _prepareSegment: function(points) {\r\n        return lineSeries._prepareSegment(this._calculateStepLinePoints(points))\r\n    },\r\n    getSeriesPairCoord: function(coord, isArgument) {\r\n        var oppositeCoord;\r\n        var rotated = this._options.rotated;\r\n        var isOpposite = !isArgument && !rotated || isArgument && rotated;\r\n        var coordName = !isOpposite ? \"vx\" : \"vy\";\r\n        var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\r\n        var nearestPoints = this.getNearestPointsByCoord(coord, isArgument);\r\n        for (var i = 0; i < nearestPoints.length; i++) {\r\n            var p = nearestPoints[i];\r\n            var tmpCoord = void 0;\r\n            if (isArgument) {\r\n                tmpCoord = coord !== p[1][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName]\r\n            } else {\r\n                tmpCoord = coord === p[0][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName]\r\n            }\r\n            if (this.checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\r\n                oppositeCoord = tmpCoord;\r\n                break\r\n            }\r\n        }\r\n        return oppositeCoord\r\n    }\r\n});\r\nexports.chart.spline = _extend({}, lineSeries, {\r\n    _calculateBezierPoints: function(src, rotated) {\r\n        var bezierPoints = [];\r\n        var pointsCopy = src;\r\n        var checkExtremum = function(otherPointCoord, pointCoord, controlCoord) {\r\n            return otherPointCoord > pointCoord && controlCoord > otherPointCoord || otherPointCoord < pointCoord && controlCoord < otherPointCoord ? otherPointCoord : controlCoord\r\n        };\r\n        if (1 !== pointsCopy.length) {\r\n            pointsCopy.forEach(function(curPoint, i) {\r\n                var leftControlX;\r\n                var leftControlY;\r\n                var rightControlX;\r\n                var rightControlY;\r\n                var prevPoint = pointsCopy[i - 1];\r\n                var nextPoint = pointsCopy[i + 1];\r\n                var xCur;\r\n                var yCur;\r\n                var x1;\r\n                var x2;\r\n                var y1;\r\n                var y2;\r\n                var lambda = .5;\r\n                var curIsExtremum;\r\n                var leftPoint;\r\n                var rightPoint;\r\n                var a;\r\n                var b;\r\n                var c;\r\n                var xc;\r\n                var yc;\r\n                var shift;\r\n                if (!i || i === pointsCopy.length - 1) {\r\n                    bezierPoints.push(curPoint, curPoint);\r\n                    return\r\n                }\r\n                xCur = curPoint.x;\r\n                yCur = curPoint.y;\r\n                x1 = prevPoint.x;\r\n                x2 = nextPoint.x;\r\n                y1 = prevPoint.y;\r\n                y2 = nextPoint.y;\r\n                curIsExtremum = !!(!rotated && (yCur <= prevPoint.y && yCur <= nextPoint.y || yCur >= prevPoint.y && yCur >= nextPoint.y) || rotated && (xCur <= prevPoint.x && xCur <= nextPoint.x || xCur >= prevPoint.x && xCur >= nextPoint.x));\r\n                if (curIsExtremum) {\r\n                    if (!rotated) {\r\n                        rightControlY = leftControlY = yCur;\r\n                        rightControlX = (xCur + nextPoint.x) / 2;\r\n                        leftControlX = (xCur + prevPoint.x) / 2\r\n                    } else {\r\n                        rightControlX = leftControlX = xCur;\r\n                        rightControlY = (yCur + nextPoint.y) / 2;\r\n                        leftControlY = (yCur + prevPoint.y) / 2\r\n                    }\r\n                } else {\r\n                    a = y2 - y1;\r\n                    b = x1 - x2;\r\n                    c = y1 * x2 - x1 * y2;\r\n                    if (!rotated) {\r\n                        if (!b) {\r\n                            bezierPoints.push(curPoint, curPoint, curPoint);\r\n                            return\r\n                        }\r\n                        xc = xCur;\r\n                        yc = -1 * (a * xc + c) / b;\r\n                        shift = yc - yCur;\r\n                        y1 -= shift;\r\n                        y2 -= shift\r\n                    } else {\r\n                        if (!a) {\r\n                            bezierPoints.push(curPoint, curPoint, curPoint);\r\n                            return\r\n                        }\r\n                        yc = yCur;\r\n                        xc = -1 * (b * yc + c) / a;\r\n                        shift = xc - xCur;\r\n                        x1 -= shift;\r\n                        x2 -= shift\r\n                    }\r\n                    rightControlX = (xCur + lambda * x2) / (1 + lambda);\r\n                    rightControlY = (yCur + lambda * y2) / (1 + lambda);\r\n                    leftControlX = (xCur + lambda * x1) / (1 + lambda);\r\n                    leftControlY = (yCur + lambda * y1) / (1 + lambda)\r\n                }\r\n                if (!rotated) {\r\n                    leftControlY = checkExtremum(prevPoint.y, yCur, leftControlY);\r\n                    rightControlY = checkExtremum(nextPoint.y, yCur, rightControlY)\r\n                } else {\r\n                    leftControlX = checkExtremum(prevPoint.x, xCur, leftControlX);\r\n                    rightControlX = checkExtremum(nextPoint.x, xCur, rightControlX)\r\n                }\r\n                leftPoint = clonePoint(curPoint, leftControlX, leftControlY);\r\n                rightPoint = clonePoint(curPoint, rightControlX, rightControlY);\r\n                bezierPoints.push(leftPoint, curPoint, rightPoint)\r\n            })\r\n        } else {\r\n            bezierPoints.push(pointsCopy[0])\r\n        }\r\n        return bezierPoints\r\n    },\r\n    _prepareSegment: function(points, rotated) {\r\n        return lineSeries._prepareSegment(this._calculateBezierPoints(points, rotated))\r\n    },\r\n    _createMainElement: function(points, settings) {\r\n        return this._renderer.path(points, \"bezier\").attr(settings).sharp()\r\n    },\r\n    getSeriesPairCoord: function(coord, isArgument) {\r\n        var that = this;\r\n        var oppositeCoord = null;\r\n        var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;\r\n        var coordName = !isOpposite ? \"vx\" : \"vy\";\r\n        var bezierCoordName = !isOpposite ? \"x\" : \"y\";\r\n        var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\r\n        var bezierOppositeCoordName = !isOpposite ? \"y\" : \"x\";\r\n        var axis = !isArgument ? that.getArgumentAxis() : that.getValueAxis();\r\n        var visibleArea = axis.getVisibleArea();\r\n        var nearestPoints = this.getNearestPointsByCoord(coord, isArgument);\r\n        var _loop = function(i) {\r\n            var p = nearestPoints[i];\r\n            if (1 === p.length) {\r\n                visibleArea[0] <= p[0][oppositeCoordName] && visibleArea[1] >= p[0][oppositeCoordName] && (oppositeCoord = p[0][oppositeCoordName])\r\n            } else {\r\n                var ts = obtainCubicBezierTCoef(coord, p[0][coordName], p[1][bezierCoordName], p[2][bezierCoordName], p[3][coordName]);\r\n                ts.forEach(function(t) {\r\n                    if (t >= 0 && t <= 1) {\r\n                        var tmpCoord = Math.pow(1 - t, 3) * p[0][oppositeCoordName] + 3 * Math.pow(1 - t, 2) * t * p[1][bezierOppositeCoordName] + 3 * (1 - t) * t * t * p[2][bezierOppositeCoordName] + t * t * t * p[3][oppositeCoordName];\r\n                        if (visibleArea[0] <= tmpCoord && visibleArea[1] >= tmpCoord) {\r\n                            oppositeCoord = tmpCoord\r\n                        }\r\n                    }\r\n                })\r\n            }\r\n            if (null !== oppositeCoord) {\r\n                return \"break\"\r\n            }\r\n        };\r\n        for (var i = 0; i < nearestPoints.length; i++) {\r\n            var _ret = _loop(i);\r\n            if (\"break\" === _ret) {\r\n                break\r\n            }\r\n        }\r\n        return oppositeCoord\r\n    },\r\n    getNearestPointsByCoord: function(coord, isArgument) {\r\n        var that = this;\r\n        var rotated = that.getOptions().rotated;\r\n        var isOpposite = !isArgument && !rotated || isArgument && rotated;\r\n        var coordName = isOpposite ? \"vy\" : \"vx\";\r\n        var points = that.getVisiblePoints();\r\n        var allPoints = that.getPoints();\r\n        var bezierPoints = that._segments.length > 0 ? that._segments.reduce(function(a, seg) {\r\n            return a.concat(seg.line)\r\n        }, []) : [];\r\n        var nearestPoints = [];\r\n        if (that.isVisible() && allPoints.length > 0) {\r\n            if (allPoints.length > 1) {\r\n                that.findNeighborPointsByCoord(coord, coordName, points.slice(0), allPoints, function(point, nextPoint) {\r\n                    var index = bezierPoints.indexOf(point);\r\n                    nearestPoints.push([point, bezierPoints[index + 1], bezierPoints[index + 2], nextPoint])\r\n                })\r\n            } else {\r\n                if (allPoints[0][coordName] === coord) {\r\n                    nearestPoints.push([allPoints[0]])\r\n                }\r\n            }\r\n        }\r\n        return nearestPoints\r\n    }\r\n});\r\nexports.polar.line = _extend({}, polarScatterSeries, lineMethods, {\r\n    _sortPoints: function(points) {\r\n        return points\r\n    },\r\n    _prepareSegment: function(points, rotated, lastSegment) {\r\n        var preparedPoints = [];\r\n        var centerPoint = this.getValueAxis().getCenter();\r\n        var i;\r\n        lastSegment && this._closeSegment(points);\r\n        if (this.argumentAxisType !== DISCRETE && this.valueAxisType !== DISCRETE) {\r\n            for (i = 1; i < points.length; i++) {\r\n                preparedPoints = preparedPoints.concat(this._getTangentPoints(points[i], points[i - 1], centerPoint))\r\n            }\r\n            if (!preparedPoints.length) {\r\n                preparedPoints = points\r\n            }\r\n        } else {\r\n            return lineSeries._prepareSegment.call(this, points)\r\n        }\r\n        return {\r\n            line: preparedPoints\r\n        }\r\n    },\r\n    _getRemainingAngle: function(angle) {\r\n        var normAngle = normalizeAngle(angle);\r\n        return angle >= 0 ? 360 - normAngle : -normAngle\r\n    },\r\n    _closeSegment: function(points) {\r\n        var point;\r\n        var differenceAngle;\r\n        if (this._segments.length) {\r\n            point = this._segments[0].line[0]\r\n        } else {\r\n            point = clonePoint(points[0], points[0].x, points[0].y, points[0].angle)\r\n        }\r\n        if (points[points.length - 1].angle !== point.angle) {\r\n            if (normalizeAngle(Math.round(points[points.length - 1].angle)) === normalizeAngle(Math.round(point.angle))) {\r\n                point.angle = points[points.length - 1].angle\r\n            } else {\r\n                differenceAngle = points[points.length - 1].angle - point.angle;\r\n                point.angle = points[points.length - 1].angle + this._getRemainingAngle(differenceAngle)\r\n            }\r\n            points.push(point)\r\n        }\r\n    },\r\n    _getTangentPoints: function(point, prevPoint, centerPoint) {\r\n        var tangentPoints = [];\r\n        var betweenAngle = Math.round(prevPoint.angle - point.angle);\r\n        var tan = (prevPoint.radius - point.radius) / betweenAngle;\r\n        var i;\r\n        if (0 === betweenAngle) {\r\n            tangentPoints = [prevPoint, point]\r\n        } else {\r\n            if (betweenAngle > 0) {\r\n                for (i = betweenAngle; i >= 0; i--) {\r\n                    tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, i))\r\n                }\r\n            } else {\r\n                for (i = 0; i >= betweenAngle; i--) {\r\n                    tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, betweenAngle - i))\r\n                }\r\n            }\r\n        }\r\n        return tangentPoints\r\n    }\r\n});\r\n"]},"metadata":{},"sourceType":"script"}