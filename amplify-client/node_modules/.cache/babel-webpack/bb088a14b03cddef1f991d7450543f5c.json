{"ast":null,"code":"/**\r\n * DevExtreme (ui/number_box/number_box.caret.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar fitIntoRange = require(\"../../core/utils/math\").fitIntoRange;\n\nvar escapeRegExp = require(\"../../core/utils/common\").escapeRegExp;\n\nvar number = require(\"../../localization/number\");\n\nvar getCaretBoundaries = function getCaretBoundaries(text, format) {\n  var signParts = format.split(\";\");\n  var sign = number.getSign(text, format);\n  signParts[1] = signParts[1] || \"-\" + signParts[0];\n  format = signParts[sign < 0 ? 1 : 0];\n\n  var mockEscapedStubs = function mockEscapedStubs(str) {\n    return str.replace(/'([^']*)'/g, function (str) {\n      return str.split(\"\").map(function () {\n        return \" \";\n      }).join(\"\").substr(2);\n    });\n  };\n\n  format = mockEscapedStubs(format);\n  var prefixStubLength = /^[^#0.,]*/.exec(format)[0].length;\n  var postfixStubLength = /[^#0.,]*$/.exec(format)[0].length;\n  return {\n    start: prefixStubLength,\n    end: text.length - postfixStubLength\n  };\n};\n\nvar _getDigitCountBeforeIndex = function _getDigitCountBeforeIndex(index, text) {\n  var decimalSeparator = number.getDecimalSeparator();\n  var regExp = new RegExp(\"[^0-9\" + escapeRegExp(decimalSeparator) + \"]\", \"g\");\n  var textBeforePosition = text.slice(0, index);\n  return textBeforePosition.replace(regExp, \"\").length;\n};\n\nvar _reverseText = function _reverseText(text) {\n  return text.split(\"\").reverse().join(\"\");\n};\n\nvar _getDigitPositionByIndex = function _getDigitPositionByIndex(digitIndex, text) {\n  if (!digitIndex) {\n    return -1;\n  }\n\n  var regExp = /[0-9]/g;\n  var counter = 1;\n  var index = null;\n  var result = regExp.exec(text);\n\n  while (result) {\n    index = result.index;\n\n    if (!digitIndex || counter >= digitIndex) {\n      return index;\n    }\n\n    counter++;\n    result = regExp.exec(text);\n  }\n\n  return null === index ? text.length : index;\n};\n\nvar getCaretWithOffset = function getCaretWithOffset(caret, offset) {\n  if (void 0 === caret.start) {\n    caret = {\n      start: caret,\n      end: caret\n    };\n  }\n\n  return {\n    start: caret.start + offset,\n    end: caret.end + offset\n  };\n};\n\nvar getCaretAfterFormat = function getCaretAfterFormat(text, formatted, caret, format) {\n  caret = getCaretWithOffset(caret, 0);\n  var point = number.getDecimalSeparator();\n  var isSeparatorBasedText = isSeparatorBasedString(text);\n  var pointPosition = isSeparatorBasedText ? 0 : text.indexOf(point);\n  var newPointPosition = formatted.indexOf(point);\n  var textParts = isSeparatorBasedText ? text.split(text[pointPosition]) : text.split(point);\n  var formattedParts = formatted.split(point);\n  var isCaretOnFloat = pointPosition !== -1 && caret.start > pointPosition;\n\n  if (isCaretOnFloat) {\n    var relativeIndex = caret.start - pointPosition - 1;\n\n    var digitsBefore = _getDigitCountBeforeIndex(relativeIndex, textParts[1]);\n\n    var newPosition = formattedParts[1] ? newPointPosition + 1 + _getDigitPositionByIndex(digitsBefore, formattedParts[1]) + 1 : formatted.length;\n    return getCaretInBoundaries(newPosition, formatted, format);\n  } else {\n    var positionFromEnd = textParts[0].length - caret.start;\n\n    var digitsFromEnd = _getDigitCountBeforeIndex(positionFromEnd, _reverseText(textParts[0]));\n\n    var newPositionFromEnd = _getDigitPositionByIndex(digitsFromEnd, _reverseText(formattedParts[0]));\n\n    var newPositionFromBegin = formattedParts[0].length - (newPositionFromEnd + 1);\n    return getCaretInBoundaries(newPositionFromBegin, formatted, format);\n  }\n};\n\nvar isSeparatorBasedString = function isSeparatorBasedString(text) {\n  return 1 === text.length && !!text.match(/^[,.][0-9]*$/g);\n};\n\nvar isCaretInBoundaries = function isCaretInBoundaries(caret, text, format) {\n  caret = getCaretWithOffset(caret, 0);\n  var boundaries = getCaretInBoundaries(caret, text, format);\n  return caret.start >= boundaries.start && caret.end <= boundaries.end;\n};\n\nvar getCaretInBoundaries = function getCaretInBoundaries(caret, text, format) {\n  caret = getCaretWithOffset(caret, 0);\n  var boundaries = getCaretBoundaries(text, format);\n  var adjustedCaret = {\n    start: fitIntoRange(caret.start, boundaries.start, boundaries.end),\n    end: fitIntoRange(caret.end, boundaries.start, boundaries.end)\n  };\n  return adjustedCaret;\n};\n\nvar getCaretOffset = function getCaretOffset(previousText, newText, format) {\n  var previousBoundaries = getCaretBoundaries(previousText, format);\n  var newBoundaries = getCaretBoundaries(newText, format);\n  return newBoundaries.start - previousBoundaries.start;\n};\n\nexports.getCaretBoundaries = getCaretBoundaries;\nexports.isCaretInBoundaries = isCaretInBoundaries;\nexports.getCaretWithOffset = getCaretWithOffset;\nexports.getCaretInBoundaries = getCaretInBoundaries;\nexports.getCaretAfterFormat = getCaretAfterFormat;\nexports.getCaretOffset = getCaretOffset;","map":null,"metadata":{},"sourceType":"script"}