{"ast":null,"code":"/**\r\n * DevExtreme (viz/tree_map/tree_map.base.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _common = require(\"./common\");\n\nvar _node = require(\"./node\");\n\nvar _node2 = _interopRequireDefault(_node);\n\nvar _tiling = require(\"./tiling\");\n\nvar _colorizing = require(\"./colorizing\");\n\nvar _utils = require(\"../core/utils\");\n\nvar _common2 = require(\"../../core/utils/common\");\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _extend2 = require(\"../../core/utils/extend\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar _max = Math.max;\nvar directions = {\n  lefttoprightbottom: [1, 1],\n  leftbottomrighttop: [1, -1],\n  righttopleftbottom: [-1, 1],\n  rightbottomlefttop: [-1, -1]\n};\n\nrequire(\"./tiling.squarified\");\n\nrequire(\"./tiling\").setDefaultAlgorithm(\"squarified\");\n\nrequire(\"./colorizing.discrete\");\n\nrequire(\"./colorizing\").setDefaultColorizer(\"discrete\");\n\nfunction pickPositiveInteger(val) {\n  return val > 0 ? Math.round(val) : 0;\n}\n\nvar dxTreeMap = require(\"../core/base_widget\").inherit({\n  _handlers: {\n    beginBuildNodes: _common2.noop,\n    buildNode: _common2.noop,\n    endBuildNodes: _common2.noop,\n    setTrackerData: _common2.noop,\n    calculateState: function calculateState(options) {\n      return (0, _common.buildRectAppearance)(options);\n    }\n  },\n  _rootClass: \"dxtm-tree-map\",\n  _rootClassPrefix: \"dxtm\",\n  _getDefaultSize: function _getDefaultSize() {\n    return {\n      width: 400,\n      height: 400\n    };\n  },\n  _setDeprecatedOptions: function _setDeprecatedOptions() {\n    this.callBase.apply(this, arguments);\n    (0, _extend2.extend)(this._deprecatedOptions, {\n      resolveLabelOverflow: {\n        since: \"19.1\",\n        message: \"Use the 'tile.label.overflow' and 'group.label.textOverflow' option instead\"\n      }\n    });\n  },\n  _themeSection: \"treeMap\",\n  _fontFields: [\"tile.label.font\", \"group.label.font\"],\n  _init: function _init() {\n    var that = this;\n    that._rectOffsets = {};\n    that._handlers = Object.create(that._handlers);\n    that._context = {\n      suspend: function suspend() {\n        if (!that._applyingChanges) {\n          that._suspendChanges();\n        }\n      },\n      resume: function resume() {\n        if (!that._applyingChanges) {\n          that._resumeChanges();\n        }\n      },\n      change: function change(codes) {\n        that._change(codes);\n      },\n      settings: [{}, {}],\n      calculateState: that._handlers.calculateState,\n      calculateLabelState: _common.buildTextAppearance\n    };\n    that._root = that._topNode = {\n      nodes: []\n    };\n    that.callBase.apply(that, arguments);\n  },\n  _initialChanges: [\"DATA_SOURCE\"],\n  _initCore: function _initCore() {\n    var that = this;\n    var renderer = that._renderer;\n\n    that._createProxyType();\n\n    that._tilesGroup = renderer.g().linkOn(renderer.root, \"tiles\").linkAppend();\n    that._labelsGroup = renderer.g().linkOn(renderer.root, \"labels\").linkAppend();\n  },\n  _createProxyType: _common2.noop,\n  _disposeCore: function _disposeCore() {\n    var that = this;\n    that._filter && that._filter.dispose();\n\n    that._labelsGroup.linkOff();\n\n    that._tilesGroup.linkOff();\n  },\n  _applySize: function _applySize(rect) {\n    this._tilingRect = rect.slice();\n\n    this._change([\"TILING\"]);\n  },\n  _optionChangesMap: {\n    dataSource: \"DATA_SOURCE\",\n    valueField: \"NODES_CREATE\",\n    childrenField: \"NODES_CREATE\",\n    colorField: \"TILES\",\n    colorizer: \"TILES\",\n    labelField: \"LABELS\",\n    tile: \"TILE_SETTINGS\",\n    group: \"GROUP_SETTINGS\",\n    maxDepth: \"MAX_DEPTH\",\n    layoutAlgorithm: \"TILING\",\n    layoutDirection: \"TILING\",\n    resolveLabelOverflow: \"LABEL_OVERFLOW\"\n  },\n  _themeDependentChanges: [\"TILE_SETTINGS\", \"GROUP_SETTINGS\", \"MAX_DEPTH\"],\n  _changeDataSource: function _changeDataSource() {\n    var that = this;\n    that._isDataExpected = that._isSyncData = true;\n\n    that._updateDataSource();\n\n    that._isSyncData = false;\n\n    if (that._isDataExpected) {\n      that._suspendChanges();\n    }\n  },\n  _dataSourceChangedHandler: function _dataSourceChangedHandler() {\n    var that = this;\n\n    if (that._isDataExpected) {\n      that._isDataExpected = false;\n\n      that._change([\"NODES_CREATE\"]);\n\n      if (!that._isSyncData) {\n        that._resumeChanges();\n      }\n    } else {\n      that._requestChange([\"NODES_CREATE\"]);\n    }\n  },\n  _optionChangesOrder: [\"DATA_SOURCE\", \"TILE_SETTINGS\", \"GROUP_SETTINGS\", \"MAX_DEPTH\", \"LABEL_OVERFLOW\"],\n  _change_DATA_SOURCE: function _change_DATA_SOURCE() {\n    this._changeDataSource();\n  },\n  _change_TILE_SETTINGS: function _change_TILE_SETTINGS() {\n    this._changeTileSettings();\n  },\n  _change_GROUP_SETTINGS: function _change_GROUP_SETTINGS() {\n    this._changeGroupSettings();\n  },\n  _change_LABEL_OVERFLOW: function _change_LABEL_OVERFLOW() {\n    this._changeTileSettings();\n\n    this._changeGroupSettings();\n  },\n  _change_MAX_DEPTH: function _change_MAX_DEPTH() {\n    this._changeMaxDepth();\n  },\n  _customChangesOrder: [\"NODES_CREATE\", \"NODES_RESET\", \"TILES\", \"LABELS\", \"TILING\", \"LABELS_LAYOUT\"],\n  _change_NODES_CREATE: function _change_NODES_CREATE() {\n    this._buildNodes();\n  },\n  _change_NODES_RESET: function _change_NODES_RESET() {\n    this._resetNodes();\n  },\n  _change_TILES: function _change_TILES() {\n    this._applyTilesAppearance();\n  },\n  _change_LABELS: function _change_LABELS() {\n    this._applyLabelsAppearance();\n  },\n  _change_TILING: function _change_TILING() {\n    this._performTiling();\n  },\n  _change_LABELS_LAYOUT: function _change_LABELS_LAYOUT() {\n    this._performLabelsLayout();\n  },\n  _applyChanges: function _applyChanges() {\n    var that = this;\n    that.callBase.apply(that, arguments);\n\n    if (!that._isDataExpected) {\n      that._drawn();\n    }\n\n    that._context.forceReset = false;\n  },\n  _buildNodes: function _buildNodes() {\n    var that = this;\n    var root = that._root = that._topNode = new _node2.default();\n    var processedData;\n    root._id = 0;\n    root.parent = {};\n    root.data = {};\n    root.level = root.index = -1;\n    root.ctx = that._context;\n    root.label = null;\n    that._nodes = [root];\n\n    that._handlers.beginBuildNodes();\n\n    processedData = that._processDataSourceItems(that._dataSourceItems() || []);\n    traverseDataItems(root, processedData.items, 0, {\n      itemsField: !processedData.isPlain && that._getOption(\"childrenField\", true) || \"items\",\n      valueField: that._getOption(\"valueField\", true) || \"value\",\n      buildNode: that._handlers.buildNode,\n      ctx: that._context,\n      nodes: that._nodes\n    });\n\n    that._onNodesCreated();\n\n    that._handlers.endBuildNodes();\n\n    that._change([\"NODES_RESET\"]);\n  },\n  _onNodesCreated: _common2.noop,\n  _processDataSourceItems: function _processDataSourceItems(items) {\n    return {\n      items: items,\n      isPlain: false\n    };\n  },\n  _changeTileSettings: function _changeTileSettings() {\n    var that = this;\n\n    var options = that._getOption(\"tile\");\n\n    var offsets = that._rectOffsets;\n    var borderWidth = pickPositiveInteger(options.border.width);\n    var edgeOffset = borderWidth / 2;\n    var innerOffset = 1 & borderWidth ? .5 : 0;\n    var labelOptions = options.label;\n    var settings = that._context.settings[0];\n\n    that._change([\"TILES\", \"LABELS\"]);\n\n    settings.state = that._handlers.calculateState(options);\n    that._filter = that._filter || that._renderer.shadowFilter(\"-50%\", \"-50%\", \"200%\", \"200%\");\n\n    that._filter.attr(labelOptions.shadow);\n\n    that._calculateLabelSettings(settings, labelOptions, that._filter.id);\n\n    if (offsets.tileEdge !== edgeOffset || offsets.tileInner !== innerOffset) {\n      offsets.tileEdge = edgeOffset;\n      offsets.tileInner = innerOffset;\n\n      that._change([\"TILING\"]);\n    }\n  },\n  _changeGroupSettings: function _changeGroupSettings() {\n    var that = this;\n\n    var options = that._getOption(\"group\");\n\n    var labelOptions = options.label;\n    var offsets = that._rectOffsets;\n    var borderWidth = pickPositiveInteger(options.border.width);\n    var edgeOffset = borderWidth / 2;\n    var innerOffset = 1 & borderWidth ? .5 : 0;\n    var headerHeight = 0;\n    var groupPadding = pickPositiveInteger(options.padding);\n    var settings = that._context.settings[1];\n\n    that._change([\"TILES\", \"LABELS\"]);\n\n    settings.state = that._handlers.calculateState(options);\n\n    that._calculateLabelSettings(settings, labelOptions);\n\n    if (options.headerHeight >= 0) {\n      headerHeight = pickPositiveInteger(options.headerHeight);\n    } else {\n      headerHeight = settings.labelParams.height + 2 * pickPositiveInteger(labelOptions.paddingTopBottom);\n    }\n\n    if (that._headerHeight !== headerHeight) {\n      that._headerHeight = headerHeight;\n\n      that._change([\"TILING\"]);\n    }\n\n    if (that._groupPadding !== groupPadding) {\n      that._groupPadding = groupPadding;\n\n      that._change([\"TILING\"]);\n    }\n\n    if (offsets.headerEdge !== edgeOffset || offsets.headerInner !== innerOffset) {\n      offsets.headerEdge = edgeOffset;\n      offsets.headerInner = innerOffset;\n\n      that._change([\"TILING\"]);\n    }\n  },\n  _calculateLabelSettings: function _calculateLabelSettings(settings, options, filter) {\n    var bBox = this._getTextBBox(options.font);\n\n    var paddingLeftRight = pickPositiveInteger(options.paddingLeftRight);\n    var paddingTopBottom = pickPositiveInteger(options.paddingTopBottom);\n\n    var tileLabelOptions = this._getOption(\"tile.label\");\n\n    var groupLabelOptions = this._getOption(\"group.label\");\n\n    settings.labelState = (0, _common.buildTextAppearance)(options, filter);\n    settings.labelState.visible = !(\"visible\" in options) || !!options.visible;\n    settings.labelParams = {\n      height: bBox.height,\n      rtlEnabled: this._getOption(\"rtlEnabled\", true),\n      paddingTopBottom: paddingTopBottom,\n      paddingLeftRight: paddingLeftRight,\n      resolveLabelOverflow: this._getOptionByStealth(\"resolveLabelOverflow\"),\n      tileLabelWordWrap: tileLabelOptions.wordWrap,\n      tileLabelOverflow: tileLabelOptions.textOverflow,\n      groupLabelOverflow: groupLabelOptions.textOverflow\n    };\n  },\n  _changeMaxDepth: function _changeMaxDepth() {\n    var maxDepth = this._getOption(\"maxDepth\", true);\n\n    maxDepth = maxDepth >= 1 ? Math.round(maxDepth) : 1 / 0;\n\n    if (this._maxDepth !== maxDepth) {\n      this._maxDepth = maxDepth;\n\n      this._change([\"NODES_RESET\"]);\n    }\n  },\n  _resetNodes: function _resetNodes() {\n    var that = this;\n\n    that._tilesGroup.clear();\n\n    that._renderer.initHatching();\n\n    that._context.forceReset = true;\n    that._context.minLevel = that._topNode.level + 1;\n    that._context.maxLevel = that._context.minLevel + that._maxDepth - 1;\n\n    that._change([\"TILES\", \"LABELS\", \"TILING\"]);\n  },\n  _processNodes: function _processNodes(context, process) {\n    processNodes(context, this._topNode, process);\n  },\n  _applyTilesAppearance: function _applyTilesAppearance() {\n    var that = this;\n    var colorizer = (0, _colorizing.getColorizer)(that._getOption(\"colorizer\"), that._themeManager, that._topNode);\n\n    that._processNodes({\n      renderer: that._renderer,\n      group: that._tilesGroup,\n      setTrackerData: that._handlers.setTrackerData,\n      colorField: that._getOption(\"colorField\", true) || \"color\",\n      getColor: colorizer\n    }, processTileAppearance);\n  },\n  _applyLabelsAppearance: function _applyLabelsAppearance() {\n    var that = this;\n\n    that._labelsGroup.clear();\n\n    that._processNodes({\n      renderer: that._renderer,\n      group: that._labelsGroup,\n      setTrackerData: that._handlers.setTrackerData,\n      labelField: that._getOption(\"labelField\", true) || \"name\"\n    }, processLabelAppearance);\n\n    that._change([\"LABELS_LAYOUT\"]);\n  },\n  _performTiling: function _performTiling() {\n    var that = this;\n    var context = {\n      algorithm: (0, _tiling.getAlgorithm)(that._getOption(\"layoutAlgorithm\", true)),\n      directions: directions[String(that._getOption(\"layoutDirection\", true)).toLowerCase()] || directions.lefttoprightbottom,\n      headerHeight: that._headerHeight,\n      groupPadding: that._groupPadding,\n      rectOffsets: that._rectOffsets\n    };\n    that._topNode.innerRect = that._tilingRect;\n    calculateRects(context, that._topNode);\n\n    that._processNodes(context, processTiling);\n\n    that._change([\"LABELS_LAYOUT\"]);\n\n    that._onTilingPerformed();\n  },\n  _onTilingPerformed: _common2.noop,\n  _performLabelsLayout: function _performLabelsLayout() {\n    this._processNodes(null, processLabelsLayout);\n  },\n  _getTextBBox: function _getTextBBox(fontOptions) {\n    var renderer = this._renderer;\n    var text = this._textForCalculations || renderer.text(\"0\", 0, 0);\n    var bBox;\n    this._textForCalculations = text;\n    text.css((0, _utils.patchFontOptions)(fontOptions)).append(renderer.root);\n    bBox = text.getBBox();\n    text.remove();\n    return bBox;\n  }\n});\n\nfunction traverseDataItems(root, dataItems, level, params) {\n  var nodes = [];\n  var allNodes = params.nodes;\n  var node;\n  var i;\n  var ii = dataItems.length;\n  var dataItem;\n  var totalValue = 0;\n  var items;\n\n  for (i = 0; i < ii; ++i) {\n    dataItem = dataItems[i];\n    node = new _node2.default();\n    node._id = allNodes.length;\n    node.ctx = params.ctx;\n    node.parent = root;\n    node.level = level;\n    node.index = nodes.length;\n    node.data = dataItem;\n    params.buildNode(node);\n    allNodes.push(node);\n    nodes.push(node);\n    items = dataItem[params.itemsField];\n\n    if (items && items.length) {\n      traverseDataItems(node, items, level + 1, params);\n    }\n\n    if (dataItem[params.valueField] > 0) {\n      node.value = Number(dataItem[params.valueField]);\n    }\n\n    totalValue += node.value;\n  }\n\n  root.nodes = nodes;\n  root.value = totalValue;\n}\n\nfunction processNodes(context, root, process) {\n  var nodes = root.nodes;\n  var node;\n  var i;\n  var ii = nodes.length;\n\n  for (i = 0; i < ii; ++i) {\n    node = nodes[i];\n    process(context, node);\n\n    if (node.isNode()) {\n      processNodes(context, node, process);\n    }\n  }\n}\n\nfunction processTileAppearance(context, node) {\n  node.color = node.data[context.colorField] || context.getColor(node) || node.parent.color;\n  node.updateStyles();\n  node.tile = !node.ctx.forceReset && node.tile || createTile[Number(node.isNode())](context, node);\n  node.applyState();\n}\n\nvar createTile = [createLeaf, createGroup];\n\nfunction createLeaf(context, node) {\n  var tile = context.renderer.simpleRect().append(context.group);\n  context.setTrackerData(node, tile);\n  return tile;\n}\n\nfunction createGroup(context, node) {\n  var outer = context.renderer.simpleRect().append(context.group);\n  var inner = context.renderer.simpleRect().append(context.group);\n  context.setTrackerData(node, inner);\n  return {\n    outer: outer,\n    inner: inner\n  };\n}\n\nfunction processLabelAppearance(context, node) {\n  node.updateLabelStyle();\n\n  if (node.labelState.visible) {\n    createLabel(context, node, node.labelState, node.labelParams);\n  }\n}\n\nfunction createLabel(context, currentNode, settings, params) {\n  var textData = currentNode.data[context.labelField];\n  currentNode.label = textData ? String(textData) : null;\n  textData = currentNode.customLabel || currentNode.label;\n\n  if (textData) {\n    currentNode.text = context.renderer.text(textData).attr(settings.attr).css(settings.css).append(context.group);\n    context.setTrackerData(currentNode, currentNode.text);\n  }\n}\n\nvar emptyRect = [0, 0, 0, 0];\n\nfunction calculateRects(context, root) {\n  var nodes = root.nodes;\n  var items = [];\n  var rects = [];\n  var sum = 0;\n  var i;\n  var ii = items.length = rects.length = nodes.length;\n\n  for (i = 0; i < ii; ++i) {\n    sum += nodes[i].value;\n    items[i] = {\n      value: nodes[i].value,\n      i: i\n    };\n  }\n\n  if (sum > 0) {\n    context.algorithm({\n      items: items.slice(),\n      sum: sum,\n      rect: root.innerRect.slice(),\n      isRotated: 1 & nodes[0].level,\n      directions: context.directions\n    });\n  }\n\n  for (i = 0; i < ii; ++i) {\n    rects[i] = items[i].rect || emptyRect;\n  }\n\n  root.rects = rects;\n}\n\nfunction processTiling(context, node) {\n  var rect = node.parent.rects[node.index];\n  var rectOffsets = context.rectOffsets;\n  var headerHeight;\n\n  if (node.isNode()) {\n    setRectAttrs(node.tile.outer, buildTileRect(rect, node.parent.innerRect, rectOffsets.headerEdge, rectOffsets.headerInner));\n    rect = marginateRect(rect, context.groupPadding);\n    headerHeight = Math.min(context.headerHeight, rect[3] - rect[1]);\n    node.rect = [rect[0], rect[1], rect[2], rect[1] + headerHeight];\n    setRectAttrs(node.tile.inner, marginateRect(node.rect, rectOffsets.headerEdge));\n    rect[1] += headerHeight;\n    node.innerRect = rect;\n    calculateRects(context, node);\n  } else {\n    node.rect = rect;\n    setRectAttrs(node.tile, buildTileRect(rect, node.parent.innerRect, rectOffsets.tileEdge, rectOffsets.tileInner));\n  }\n}\n\nfunction marginateRect(rect, margin) {\n  return [rect[0] + margin, rect[1] + margin, rect[2] - margin, rect[3] - margin];\n}\n\nfunction buildTileRect(rect, outer, edgeOffset, innerOffset) {\n  return [rect[0] + (rect[0] === outer[0] ? edgeOffset : +innerOffset), rect[1] + (rect[1] === outer[1] ? edgeOffset : +innerOffset), rect[2] - (rect[2] === outer[2] ? edgeOffset : -innerOffset), rect[3] - (rect[3] === outer[3] ? edgeOffset : -innerOffset)];\n}\n\nfunction setRectAttrs(element, rect) {\n  element.attr({\n    x: rect[0],\n    y: rect[1],\n    width: _max(rect[2] - rect[0], 0),\n    height: _max(rect[3] - rect[1], 0)\n  });\n}\n\nfunction processLabelsLayout(context, node) {\n  if (node.text && node.labelState.visible) {\n    layoutTextNode(node, node.labelParams);\n  }\n}\n\nfunction layoutTextNode(node, params) {\n  var rect = node.rect;\n  var text = node.text;\n  var bBox = text.getBBox();\n  var paddingLeftRight = params.paddingLeftRight;\n  var paddingTopBottom = params.paddingTopBottom;\n  var effectiveWidth = rect[2] - rect[0] - 2 * paddingLeftRight;\n  var fitByHeight = bBox.height + paddingTopBottom <= rect[3] - rect[1];\n  var fitByWidth = bBox.width <= effectiveWidth;\n  var resolveLabelOverflow = params.resolveLabelOverflow;\n  var groupLabelOverflow = params.groupLabelOverflow;\n  var tileLabelOverflow = params.tileLabelOverflow;\n  var tileLabelWordWrap = params.tileLabelWordWrap;\n\n  if ((0, _type.isDefined)(resolveLabelOverflow)) {\n    if (\"ellipsis\" === resolveLabelOverflow && fitByHeight) {\n      text.setMaxSize(effectiveWidth, void 0, {\n        wordWrap: \"none\",\n        textOverflow: \"ellipsis\"\n      });\n\n      if (!fitByWidth) {\n        bBox = text.getBBox();\n        fitByWidth = bBox.width <= effectiveWidth;\n      }\n    }\n  } else {\n    fitByWidth = true;\n    fitByHeight = true;\n    text.setMaxSize(effectiveWidth, rect[3] - rect[1] - paddingTopBottom, node.isNode() ? {\n      textOverflow: groupLabelOverflow,\n      wordWrap: \"none\"\n    } : {\n      textOverflow: tileLabelOverflow,\n      wordWrap: tileLabelWordWrap,\n      hideOverflowEllipsis: true\n    });\n  }\n\n  text.attr({\n    visibility: fitByHeight && fitByWidth ? \"visible\" : \"hidden\"\n  });\n\n  if (fitByHeight && fitByWidth) {\n    text.move(params.rtlEnabled ? rect[2] - paddingLeftRight - bBox.x - bBox.width : rect[0] + paddingLeftRight - bBox.x, rect[1] + paddingTopBottom - bBox.y);\n  }\n}\n\nrequire(\"../../core/component_registrator\")(\"dxTreeMap\", dxTreeMap);\n\nmodule.exports = dxTreeMap;\ndxTreeMap.addPlugin(require(\"../core/data_source\").plugin);","map":null,"metadata":{},"sourceType":"script"}