{"ast":null,"code":"/**\r\n * DevExtreme (viz/axes/tick_generator.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _utils = require(\"../core/utils\");\n\nvar _date = require(\"../../core/utils/date\");\n\nvar _date2 = _interopRequireDefault(_date);\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _math = require(\"../../core/utils/math\");\n\nvar _extend = require(\"../../core/utils/extend\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || \"[object Arguments]\" === Object.prototype.toString.call(arr))) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _e = void 0;\n\n  try {\n    for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) {\n        break;\n      }\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && null != _i.return) {\n        _i.return();\n      }\n    } finally {\n      if (_d) {\n        throw _e;\n      }\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) {\n    return arr;\n  }\n}\n\nvar convertDateUnitToMilliseconds = _date2.default.convertDateUnitToMilliseconds;\nvar dateToMilliseconds = _date2.default.dateToMilliseconds;\nvar math = Math;\nvar mathAbs = math.abs;\nvar mathFloor = math.floor;\nvar mathCeil = math.ceil;\nvar mathPow = math.pow;\nvar NUMBER_MULTIPLIERS = [1, 2, 2.5, 5];\nvar LOGARITHMIC_MULTIPLIERS = [1, 2, 3, 5];\nvar DATETIME_MULTIPLIERS = {\n  millisecond: [1, 2, 5, 10, 25, 50, 100, 250, 500],\n  second: [1, 2, 3, 5, 10, 15, 20, 30],\n  minute: [1, 2, 3, 5, 10, 15, 20, 30],\n  hour: [1, 2, 3, 4, 6, 8, 12],\n  day: [1, 2],\n  week: [1, 2],\n  month: [1, 2, 3, 6]\n};\nvar DATETIME_MULTIPLIERS_WITH_BIG_WEEKEND = (0, _extend.extend)({}, DATETIME_MULTIPLIERS, {\n  day: [1]\n});\nvar DATETIME_MINOR_MULTIPLIERS = {\n  millisecond: [1, 2, 5, 10, 25, 50, 100, 250, 500],\n  second: [1, 2, 3, 5, 10, 15, 20, 30],\n  minute: [1, 2, 3, 5, 10, 15, 20, 30],\n  hour: [1, 2, 3, 4, 6, 8, 12],\n  day: [1, 2, 3, 7, 14],\n  month: [1, 2, 3, 6]\n};\nvar MINOR_DELIMITERS = [2, 4, 5, 8, 10];\nvar VISIBILITY_DELIMITER = 3;\nvar MINUTE = 6e4;\n\nfunction dummyGenerator(options) {\n  return function (data, screenDelta, tickInterval, forceTickInterval) {\n    var count = mathFloor(screenDelta / options.axisDivisionFactor);\n    count = count < 1 ? 1 : count;\n    var interval = screenDelta / count;\n    return {\n      ticks: interval > 0 ? Array.apply(null, new Array(count + 1)).map(function (_, i) {\n        return interval * i;\n      }) : [],\n      tickInterval: interval\n    };\n  };\n}\n\nfunction discreteGenerator(options) {\n  return function (data, screenDelta, tickInterval, forceTickInterval) {\n    var categories = (0, _utils.getCategoriesInfo)(data.categories, data.min, data.max).categories;\n    return {\n      ticks: categories,\n      tickInterval: mathCeil(categories.length * options.axisDivisionFactor / screenDelta)\n    };\n  };\n}\n\nvar getValue = function getValue(value) {\n  return value;\n};\n\nvar getLogValue = function getLogValue(base, allowNegatives, linearThreshold) {\n  return function (value) {\n    return (0, _utils.getLogExt)(value, base, allowNegatives, linearThreshold);\n  };\n};\n\nvar raiseTo = function raiseTo(base, allowNegatives, linearThreshold) {\n  return function (value) {\n    return (0, _utils.raiseToExt)(value, base, allowNegatives, linearThreshold);\n  };\n};\n\nvar mathRaiseTo = function mathRaiseTo(base) {\n  return function (value) {\n    return (0, _utils.raiseTo)(value, base);\n  };\n};\n\nvar logAbsValue = function logAbsValue(base) {\n  return function (value) {\n    return 0 === value ? 0 : (0, _utils.getLog)(mathAbs(value), base);\n  };\n};\n\nvar correctValueByInterval = function correctValueByInterval(post, round, getValue) {\n  return function (value, interval) {\n    return (0, _math.adjust)(post(round((0, _math.adjust)(getValue(value) / interval)) * interval));\n  };\n};\n\nfunction correctMinValueByEndOnTick(floorFunc, ceilFunc, resolveEndOnTick, endOnTick) {\n  if ((0, _type.isDefined)(endOnTick)) {\n    return endOnTick ? floorFunc : ceilFunc;\n  }\n\n  return function (value, interval, businessViewInfo, forceEndOnTick) {\n    var floorTickValue = floorFunc(value, interval);\n\n    if (value - floorTickValue === 0 || !(0, _type.isDefined)(businessViewInfo) || resolveEndOnTick(value, floorTickValue, interval, businessViewInfo) || forceEndOnTick) {\n      return floorTickValue;\n    }\n\n    return ceilFunc(value, interval);\n  };\n}\n\nfunction resolveEndOnTick(curValue, tickValue, interval, businessViewInfo) {\n  var prevTickDataDiff = interval - mathAbs(tickValue - curValue);\n  var intervalCount = math.max(mathCeil(businessViewInfo.businessDelta / interval), 2);\n  var businessRatio = businessViewInfo.screenDelta / (intervalCount * interval);\n  var potentialTickScreenDiff = math.round(businessRatio * prevTickDataDiff);\n  var delimiterFactor = (0, _utils.getLogExt)(businessRatio * interval / businessViewInfo.axisDivisionFactor, 2) + 1;\n  var delimiterMultiplier = (businessViewInfo.isSpacedMargin ? 2 : 1) * delimiterFactor;\n  var screenDelimiter = math.round(VISIBILITY_DELIMITER * delimiterMultiplier);\n  return businessViewInfo.businessDelta > businessViewInfo.interval && potentialTickScreenDiff >= screenDelimiter;\n}\n\nfunction resolveEndOnTickLog(base) {\n  return function (curValue, tickValue, interval, businessViewInfo) {\n    return resolveEndOnTick((0, _utils.getLogExt)(curValue, base), (0, _utils.getLogExt)(tickValue, base), interval, businessViewInfo);\n  };\n}\n\nfunction resolveEndOnTickDate(curValue, tickValue, interval, businessViewInfo) {\n  return resolveEndOnTick(curValue.valueOf(), tickValue.valueOf(), dateToMilliseconds(interval), businessViewInfo);\n}\n\nfunction resolveExtraTickForHiddenDataPoint(checkDataVisibility, extremum, tick, businessViewInfo, isMin) {\n  var screenRatio = businessViewInfo.screenDelta / businessViewInfo.businessDelta;\n  var extDir = isMin ? 1 : -1;\n  var tickDir = isMin ? -1 : 1;\n  return checkDataVisibility && screenRatio * (extremum * extDir + tick * tickDir) < VISIBILITY_DELIMITER;\n}\n\nfunction resolveExtraTickForHiddenDataPointLog(base) {\n  return function (checkDataVisibility, extremum, tick, businessViewInfo, isMin) {\n    return resolveExtraTickForHiddenDataPoint(checkDataVisibility, (0, _utils.getLogExt)(extremum, base), (0, _utils.getLogExt)(tick, base), businessViewInfo, isMin);\n  };\n}\n\nfunction resolveExtraTickForHiddenDataPointDate(checkDataVisibility, extremum, tick, businessViewInfo, isMin) {\n  return resolveExtraTickForHiddenDataPoint(checkDataVisibility, extremum.valueOf(), tick.valueOf(), businessViewInfo, isMin);\n}\n\nfunction getBusinessDelta(data, breaks) {\n  var spacing = 0;\n\n  if (breaks) {\n    spacing = breaks.reduce(function (prev, item) {\n      return prev + (item.to - item.from);\n    }, 0);\n  }\n\n  return mathAbs(data.max - data.min - spacing);\n}\n\nfunction getBusinessDeltaLog(base, allowNegatives, linearThreshold) {\n  var getLog = getLogValue(base, allowNegatives, linearThreshold);\n  return function (data, breaks) {\n    var spacing = 0;\n\n    if (breaks) {\n      spacing = breaks.reduce(function (prev, item) {\n        return prev + mathAbs(getLog(item.to / item.from));\n      }, 0);\n    }\n\n    return mathCeil(mathAbs(getLog(data.max) - getLog(data.min)) - spacing);\n  };\n}\n\nfunction getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor, addTickCount) {\n  var count = screenDelta / axisDivisionFactor - (addTickCount || 0);\n  count = count < 1 ? 1 : count;\n  return businessDelta / count;\n}\n\nfunction getMultiplierFactor(interval, factorDelta) {\n  return mathPow(10, mathFloor((0, _utils.getLogExt)(interval, 10)) + (factorDelta || 0));\n}\n\nfunction calculateTickInterval(businessDelta, screenDelta, tickInterval, forceTickInterval, axisDivisionFactor, multipliers, allowDecimals, addTickCount, _, minTickInterval) {\n  var interval = getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor, addTickCount);\n  var result = 1;\n  var onlyIntegers = false === allowDecimals;\n\n  if (!forceTickInterval || !tickInterval) {\n    if (interval >= 1 || !onlyIntegers && interval > 0) {\n      result = adjustInterval(interval, multipliers, onlyIntegers);\n    }\n\n    if (!tickInterval || !forceTickInterval && tickInterval < result) {\n      tickInterval = result;\n    }\n  }\n\n  if (!forceTickInterval && minTickInterval) {\n    minTickInterval = adjustInterval(minTickInterval, multipliers, onlyIntegers);\n\n    if (minTickInterval > tickInterval) {\n      tickInterval = minTickInterval;\n    }\n  }\n\n  return tickInterval;\n}\n\nfunction adjustInterval(interval, multipliers, onlyIntegers) {\n  var factor = getMultiplierFactor(interval, -1);\n  var result = 1;\n  multipliers = multipliers || NUMBER_MULTIPLIERS;\n\n  if (interval > 0) {\n    interval /= factor;\n    result = multipliers.concat(10 * multipliers[0]).map(function (m) {\n      return 10 * m;\n    }).reduce(function (r, m) {\n      if (.1 === factor && onlyIntegers && 25 === m) {\n        return r;\n      }\n\n      return r < interval ? m : r;\n    }, 0);\n    result = (0, _math.adjust)(result * factor, factor);\n  }\n\n  return result;\n}\n\nfunction calculateMinorTickInterval(businessDelta, screenDelta, tickInterval, axisDivisionFactor) {\n  var interval = getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor);\n  return tickInterval || MINOR_DELIMITERS.reduce(function (r, d) {\n    var cur = businessDelta / d;\n    return cur >= interval ? cur : r;\n  }, 0);\n}\n\nfunction getCalculateTickIntervalLog(skipCalculationLimits) {\n  return function (businessDelta, screenDelta, tickInterval, forceTickInterval, axisDivisionFactor, multipliers, allowDecimals, _, __, minTickInterval) {\n    var interval = getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor);\n    var result = 0;\n    var adjustInterval = getAdjustIntervalLog(skipCalculationLimits);\n\n    if (!forceTickInterval || !tickInterval) {\n      if (interval > 0) {\n        result = adjustInterval(interval, multipliers);\n      }\n\n      if (!tickInterval || !forceTickInterval && tickInterval < result) {\n        tickInterval = result;\n      }\n    }\n\n    if (!forceTickInterval && minTickInterval) {\n      minTickInterval = adjustInterval(minTickInterval, multipliers);\n\n      if (minTickInterval > tickInterval) {\n        tickInterval = minTickInterval;\n      }\n    }\n\n    return tickInterval;\n  };\n}\n\nfunction getAdjustIntervalLog(skipCalculationLimits) {\n  return function (interval, multipliers) {\n    var factor = getMultiplierFactor(interval);\n    multipliers = multipliers || LOGARITHMIC_MULTIPLIERS;\n\n    if (!skipCalculationLimits && factor < 1) {\n      factor = 1;\n    }\n\n    return multipliers.concat(10 * multipliers[0]).reduce(function (r, m) {\n      return r < interval ? m * factor : r;\n    }, 0);\n  };\n}\n\nfunction getDataTimeMultipliers(gapSize) {\n  if (gapSize && gapSize > 2) {\n    return DATETIME_MULTIPLIERS_WITH_BIG_WEEKEND;\n  } else {\n    return DATETIME_MULTIPLIERS;\n  }\n}\n\nfunction numbersReducer(interval, key) {\n  return function (r, m) {\n    if (!r && interval <= convertDateUnitToMilliseconds(key, m)) {\n      r = {};\n      r[key + \"s\"] = m;\n    }\n\n    return r;\n  };\n}\n\nfunction yearsReducer(interval, factor) {\n  return function (r, m) {\n    var years = factor * m;\n\n    if (!r && interval <= convertDateUnitToMilliseconds(\"year\", years) && 2.5 !== years) {\n      r = {\n        years: years\n      };\n    }\n\n    return r;\n  };\n}\n\nfunction calculateTickIntervalDateTime(businessDelta, screenDelta, tickInterval, forceTickInterval, axisDivisionFactor, multipliers, allowDecimals, addTickCount, gapSize, minTickInterval) {\n  if (!forceTickInterval || !tickInterval) {\n    var result = adjustIntervalDateTime(getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor), multipliers, null, gapSize);\n\n    if (!tickInterval || !forceTickInterval && dateToMilliseconds(tickInterval) <= dateToMilliseconds(result)) {\n      tickInterval = result;\n    }\n  }\n\n  if (!forceTickInterval && minTickInterval) {\n    minTickInterval = adjustIntervalDateTime(minTickInterval, multipliers, null, gapSize);\n\n    if (dateToMilliseconds(minTickInterval) > dateToMilliseconds(tickInterval)) {\n      tickInterval = minTickInterval;\n    }\n  }\n\n  return tickInterval;\n}\n\nfunction adjustIntervalDateTime(interval, multipliers, _, gapSize) {\n  var result;\n  multipliers = multipliers || getDataTimeMultipliers(gapSize);\n\n  for (var key in multipliers) {\n    result = multipliers[key].reduce(numbersReducer(interval, key), result);\n\n    if (result) {\n      break;\n    }\n  }\n\n  if (!result) {\n    for (var factor = 1;; factor *= 10) {\n      result = NUMBER_MULTIPLIERS.reduce(yearsReducer(interval, factor), result);\n\n      if (result) {\n        break;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction calculateMinorTickIntervalDateTime(businessDelta, screenDelta, tickInterval, axisDivisionFactor) {\n  return calculateTickIntervalDateTime(businessDelta, screenDelta, tickInterval, true, axisDivisionFactor, DATETIME_MINOR_MULTIPLIERS);\n}\n\nfunction getTickIntervalByCustomTicks(getValue, postProcess) {\n  return function (ticks) {\n    return ticks ? postProcess(mathAbs((0, _math.adjust)(getValue(ticks[1]) - getValue(ticks[0])))) || void 0 : void 0;\n  };\n}\n\nfunction addInterval(value, interval, isNegative) {\n  return _date2.default.addInterval(value, interval, isNegative);\n}\n\nfunction addIntervalLog(log, raise) {\n  return function (value, interval, isNegative) {\n    return raise(addInterval(log(value), interval, isNegative));\n  };\n}\n\nfunction addIntervalDate(value, interval, isNegative) {\n  return addInterval(value, interval, isNegative);\n}\n\nfunction addIntervalWithBreaks(addInterval, breaks, correctValue) {\n  breaks = breaks.filter(function (b) {\n    return !b.gapSize;\n  });\n  return function (value, interval, isNegative) {\n    var breakSize;\n    value = addInterval(value, interval, isNegative);\n\n    if (!breaks.every(function (item) {\n      if (value >= addInterval(item.from, interval) && addInterval(value, interval) < item.to) {\n        breakSize = item.to - item.from - 2 * (addInterval(item.from, interval) - item.from);\n      }\n\n      return !breakSize;\n    })) {\n      value = correctValue(addInterval(value, breakSize), interval);\n    }\n\n    return value;\n  };\n}\n\nfunction calculateTicks(addInterval, correctMinValue, adjustInterval, resolveEndOnTick, resolveExtraTickForHiddenDataPoint) {\n  return function (data, tickInterval, endOnTick, gaps, breaks, businessDelta, screenDelta, axisDivisionFactor, generateExtraTick) {\n    var correctTickValue = correctTickValueOnGapSize(addInterval, gaps);\n    var min = data.min;\n    var max = data.max;\n    var businessViewInfo = {\n      screenDelta: screenDelta,\n      businessDelta: businessDelta,\n      axisDivisionFactor: axisDivisionFactor,\n      isSpacedMargin: data.isSpacedMargin,\n      interval: tickInterval\n    };\n    var cur = correctMinValue(min, tickInterval, businessViewInfo);\n    var ticks = [];\n\n    if (breaks && breaks.length) {\n      addInterval = addIntervalWithBreaks(addInterval, breaks, correctMinValue);\n    }\n\n    if (cur > max) {\n      cur = correctMinValue(min, adjustInterval(businessDelta / 2), businessViewInfo);\n\n      if (cur > max) {\n        endOnTick = true;\n        cur = correctMinValue(min, tickInterval, businessViewInfo, endOnTick);\n      }\n    }\n\n    cur = correctTickValue(cur);\n    var prev;\n\n    while (cur < max && cur !== prev || generateExtraTick && cur <= max) {\n      ticks.push(cur);\n      prev = cur;\n      cur = correctTickValue(addInterval(cur, tickInterval));\n    }\n\n    if (endOnTick || cur - max === 0 || !(0, _type.isDefined)(endOnTick) && resolveEndOnTick(max, cur, tickInterval, businessViewInfo)) {\n      ticks.push(cur);\n    }\n\n    if (ticks.length > 0) {\n      if (ticks[0].valueOf() > 0 && resolveExtraTickForHiddenDataPoint(data.checkMinDataVisibility, min, ticks[0], businessViewInfo, true)) {\n        cur = addInterval(ticks[0], tickInterval, true);\n        ticks.unshift(cur);\n      } else {\n        if (ticks[ticks.length - 1].valueOf() < 0 && resolveExtraTickForHiddenDataPoint(data.checkMaxDataVisibility, max, ticks[ticks.length - 1], businessViewInfo, false)) {\n          cur = addInterval(ticks[ticks.length - 1], tickInterval);\n          ticks.push(cur);\n        }\n      }\n    }\n\n    return ticks;\n  };\n}\n\nfunction calculateMinorTicks(updateTickInterval, addInterval, correctMinValue, correctTickValue, ceil) {\n  return function (min, max, majorTicks, minorTickInterval, tickInterval, breaks, maxCount) {\n    var factor = tickInterval / minorTickInterval;\n    var lastMajor = majorTicks[majorTicks.length - 1];\n    var firstMajor = majorTicks[0];\n    var tickBalance = maxCount - 1;\n\n    if (breaks && breaks.length) {\n      addInterval = addIntervalWithBreaks(addInterval, breaks, correctMinValue);\n    }\n\n    minorTickInterval = updateTickInterval(minorTickInterval, firstMajor, firstMajor, factor);\n\n    if (0 === minorTickInterval) {\n      return [];\n    }\n\n    var cur = correctTickValue(correctMinValue(min, tickInterval, min), minorTickInterval);\n    minorTickInterval = updateTickInterval(minorTickInterval, firstMajor, cur, factor);\n    var ticks = [];\n\n    while (cur < firstMajor && (!tickBalance || tickBalance > 0)) {\n      cur >= min && ticks.push(cur);\n      tickBalance--;\n      cur = addInterval(cur, minorTickInterval);\n    }\n\n    var middleTicks = majorTicks.reduce(function (r, tick) {\n      tickBalance = maxCount - 1;\n\n      if (null === r.prevTick) {\n        r.prevTick = tick;\n        return r;\n      }\n\n      minorTickInterval = updateTickInterval(minorTickInterval, tick, r.prevTick, factor);\n      var cur = correctTickValue(r.prevTick, minorTickInterval);\n\n      while (cur < tick && (!tickBalance || tickBalance > 0)) {\n        cur !== r.prevTick && r.minors.push(cur);\n        tickBalance--;\n        cur = addInterval(cur, minorTickInterval);\n      }\n\n      r.prevTick = tick;\n      return r;\n    }, {\n      prevTick: null,\n      minors: []\n    });\n    ticks = ticks.concat(middleTicks.minors);\n    var maxValue = ceil(max, tickInterval, min);\n    minorTickInterval = updateTickInterval(minorTickInterval, maxValue, maxValue, factor);\n    cur = correctTickValue(lastMajor, minorTickInterval);\n    var prev;\n\n    while (cur < max && cur !== prev) {\n      ticks.push(cur);\n      prev = cur;\n      cur = addInterval(cur, minorTickInterval);\n    }\n\n    if (lastMajor - max !== 0 && cur - max === 0) {\n      ticks.push(cur);\n    }\n\n    return ticks;\n  };\n}\n\nfunction filterTicks(ticks, breaks) {\n  if (breaks.length) {\n    var result = breaks.reduce(function (result, b) {\n      var tmpTicks = [];\n      var i;\n\n      for (i = result[1]; i < ticks.length; i++) {\n        var tickValue = ticks[i];\n\n        if (tickValue < b.from) {\n          tmpTicks.push(tickValue);\n        }\n\n        if (tickValue >= b.to) {\n          break;\n        }\n      }\n\n      return [result[0].concat(tmpTicks), i];\n    }, [[], 0]);\n    return result[0].concat(ticks.slice(result[1]));\n  }\n\n  return ticks;\n}\n\nfunction correctTickValueOnGapSize(addInterval, breaks) {\n  return function (value) {\n    var gapSize;\n\n    if (!breaks.every(function (item) {\n      if (value >= item.from && value < item.to) {\n        gapSize = item.gapSize;\n      }\n\n      return !gapSize;\n    })) {\n      value = addInterval(value, gapSize);\n    }\n\n    return value;\n  };\n}\n\nfunction generator(options, getBusinessDelta, calculateTickInterval, calculateMinorTickInterval, getMajorTickIntervalByCustomTicks, getMinorTickIntervalByCustomTicks, convertTickInterval, calculateTicks, calculateMinorTicks, processScaleBreaks) {\n  function processCustomTicks(customTicks) {\n    return {\n      tickInterval: getMajorTickIntervalByCustomTicks(customTicks.majors),\n      ticks: customTicks.majors || [],\n      minorTickInterval: getMinorTickIntervalByCustomTicks(customTicks.minors),\n      minorTicks: customTicks.minors || []\n    };\n  }\n\n  function correctUserTickInterval(tickInterval, businessDelta, limit) {\n    if (tickInterval && businessDelta / convertTickInterval(tickInterval) >= limit + 1) {\n      options.incidentOccurred(\"W2003\");\n      tickInterval = void 0;\n    }\n\n    return tickInterval;\n  }\n\n  function generateMajorTicks(ticks, data, businessDelta, screenDelta, tickInterval, forceTickInterval, customTicks, breaks) {\n    if (customTicks.majors) {\n      ticks.breaks = breaks;\n      return ticks;\n    }\n\n    var gaps = breaks.filter(function (b) {\n      return b.gapSize;\n    });\n    var majorTicks;\n    tickInterval = options.skipCalculationLimits ? tickInterval : correctUserTickInterval(tickInterval, businessDelta, screenDelta);\n    tickInterval = calculateTickInterval(businessDelta, screenDelta, tickInterval, forceTickInterval, options.axisDivisionFactor, options.numberMultipliers, options.allowDecimals, breaks.length, gaps[0] && gaps[0].gapSize.days, options.minTickInterval);\n\n    if (!options.skipTickGeneration) {\n      majorTicks = calculateTicks(data, tickInterval, options.endOnTick, gaps, breaks, businessDelta, screenDelta, options.axisDivisionFactor, options.generateExtraTick);\n      breaks = processScaleBreaks(breaks, majorTicks, tickInterval);\n      majorTicks = filterTicks(majorTicks, breaks);\n      ticks.breaks = breaks;\n      ticks.ticks = ticks.ticks.concat(majorTicks);\n    }\n\n    ticks.tickInterval = tickInterval;\n    return ticks;\n  }\n\n  function generateMinorTicks(ticks, data, businessDelta, screenDelta, minorTickInterval, minorTickCount, customTicks) {\n    if (!options.calculateMinors) {\n      return ticks;\n    }\n\n    if (customTicks.minors) {\n      return ticks;\n    }\n\n    var minorBusinessDelta = convertTickInterval(ticks.tickInterval);\n    var minorScreenDelta = screenDelta * minorBusinessDelta / businessDelta;\n    var breaks = ticks.breaks;\n\n    if (!minorTickInterval && minorTickCount) {\n      minorTickInterval = getMinorTickIntervalByCustomTicks([minorBusinessDelta / (minorTickCount + 1), minorBusinessDelta / (minorTickCount + 1) * 2]);\n    } else {\n      minorTickCount = void 0;\n    }\n\n    minorTickInterval = correctUserTickInterval(minorTickInterval, minorBusinessDelta, minorScreenDelta);\n    minorTickInterval = calculateMinorTickInterval(minorBusinessDelta, minorScreenDelta, minorTickInterval, options.minorAxisDivisionFactor);\n    ticks.minorTicks = filterTicks(ticks.minorTicks.concat(calculateMinorTicks(data.min, data.max, ticks.ticks, minorTickInterval, ticks.tickInterval, breaks, minorTickCount)), breaks);\n    ticks.minorTickInterval = minorTickInterval;\n    return ticks;\n  }\n\n  return function (data, screenDelta, tickInterval, forceTickInterval, customTicks, minorTickInterval, minorTickCount, breaks) {\n    customTicks = customTicks || {};\n    var businessDelta = getBusinessDelta(data, breaks);\n    var result = processCustomTicks(customTicks);\n\n    if (!isNaN(businessDelta)) {\n      if (0 === businessDelta && !customTicks.majors) {\n        result.ticks = [data.min];\n      } else {\n        result = generateMajorTicks(result, data, businessDelta, screenDelta, tickInterval, forceTickInterval, customTicks, breaks || []);\n\n        if (!options.skipTickGeneration && businessDelta > 0) {\n          result = generateMinorTicks(result, data, businessDelta, screenDelta, minorTickInterval, minorTickCount, customTicks);\n        }\n      }\n    }\n\n    return result;\n  };\n}\n\nfunction getBaseTick(breakValue, _ref, interval, getValue) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      tick = _ref2[0],\n      insideTick = _ref2[1];\n\n  if (!(0, _type.isDefined)(tick) || mathAbs(getValue(breakValue) - getValue(tick)) / interval > .25) {\n    if ((0, _type.isDefined)(insideTick)) {\n      tick = insideTick;\n    } else {\n      if (!(0, _type.isDefined)(tick)) {\n        tick = breakValue;\n      }\n    }\n  }\n\n  return tick;\n}\n\nfunction getScaleBreaksProcessor(convertTickInterval, getValue, addCorrection) {\n  return function (breaks, ticks, tickInterval) {\n    var interval = convertTickInterval(tickInterval);\n    var correction = .5 * interval;\n    return breaks.reduce(function (result, b) {\n      var breakTicks = ticks.filter(function (tick) {\n        return tick <= b.from;\n      });\n      var from = addCorrection(getBaseTick(b.from, [].concat(breakTicks[breakTicks.length - 1], ticks[breakTicks.length]), interval, getValue), correction);\n      breakTicks = ticks.filter(function (tick) {\n        return tick >= b.to;\n      });\n      var to = addCorrection(getBaseTick(b.to, [].concat(breakTicks[0], ticks[ticks.length - breakTicks.length - 1]), interval, getValue), -correction);\n\n      if (getValue(to) - getValue(from) < interval && !b.gapSize) {\n        return result;\n      }\n\n      if (b.gapSize) {\n        return result.concat([b]);\n      }\n\n      return result.concat([{\n        from: from,\n        to: to,\n        cumulativeWidth: b.cumulativeWidth\n      }]);\n    }, []);\n  };\n}\n\nfunction numericGenerator(options) {\n  var floor = correctValueByInterval(getValue, mathFloor, getValue);\n  var ceil = correctValueByInterval(getValue, mathCeil, getValue);\n  var calculateTickIntervalByCustomTicks = getTickIntervalByCustomTicks(getValue, getValue);\n  return generator(options, getBusinessDelta, calculateTickInterval, calculateMinorTickInterval, calculateTickIntervalByCustomTicks, calculateTickIntervalByCustomTicks, getValue, calculateTicks(addInterval, correctMinValueByEndOnTick(floor, ceil, resolveEndOnTick, options.endOnTick), adjustInterval, resolveEndOnTick, resolveExtraTickForHiddenDataPoint), calculateMinorTicks(getValue, addInterval, floor, addInterval, getValue), getScaleBreaksProcessor(getValue, getValue, function (value, correction) {\n    return value + correction;\n  }));\n}\n\nvar correctValueByIntervalLog = function correctValueByIntervalLog(post, getRound, getValue) {\n  return function (value, interval) {\n    return (0, _math.sign)(value) * (0, _math.adjust)(post(getRound(value)((0, _math.adjust)(getValue(value) / interval)) * interval));\n  };\n};\n\nfunction logarithmicGenerator(options) {\n  var base = options.logBase;\n  var raise = raiseTo(base, options.allowNegatives, options.linearThreshold);\n  var log = getLogValue(base, options.allowNegatives, options.linearThreshold);\n  var absLog = logAbsValue(base);\n  var absRaise = mathRaiseTo(base);\n\n  var absFloor = function absFloor(value) {\n    return value < 0 ? mathCeil : mathFloor;\n  };\n\n  var absCeil = function absCeil(value) {\n    return value < 0 ? mathFloor : mathCeil;\n  };\n\n  var floor = correctValueByIntervalLog(absRaise, absFloor, absLog);\n  var ceil = correctValueByIntervalLog(absRaise, absCeil, absLog);\n  var ceilNumber = correctValueByInterval(getValue, mathCeil, getValue);\n  return generator(options, getBusinessDeltaLog(base, options.allowNegatives, options.linearThreshold), getCalculateTickIntervalLog(options.skipCalculationLimits), calculateMinorTickInterval, getTickIntervalByCustomTicks(log, getValue), getTickIntervalByCustomTicks(getValue, getValue), getValue, calculateTicks(addIntervalLog(log, raise), correctMinValueByEndOnTick(floor, ceil, resolveEndOnTickLog(base), options.endOnTick), getAdjustIntervalLog(options.skipCalculationLimits), resolveEndOnTickLog(base), resolveExtraTickForHiddenDataPointLog(base)), calculateMinorTicks(function (_, tick, prevTick, factor) {\n    return Math.max(Math.abs(tick), Math.abs(prevTick)) / factor;\n  }, addInterval, floor, ceilNumber, ceil), getScaleBreaksProcessor(getValue, log, function (value, correction) {\n    return raise(log(value) + correction);\n  }));\n}\n\nfunction dateGenerator(options) {\n  function floor(value, interval) {\n    var floorNumber = correctValueByInterval(getValue, mathFloor, getValue);\n    var intervalObject = (0, _type.isString)(interval) ? _date2.default.getDateIntervalByString(interval.toLowerCase()) : interval;\n    var divider = dateToMilliseconds(interval);\n\n    if (intervalObject.days % 7 === 0 || interval.quarters) {\n      intervalObject = adjustIntervalDateTime(divider);\n    }\n\n    var correctDateWithUnitBeginning = function correctDateWithUnitBeginning(v) {\n      return _date2.default.correctDateWithUnitBeginning(v, intervalObject, null, options.firstDayOfWeek);\n    };\n\n    var floorAtStartDate = function floorAtStartDate(v) {\n      return new Date(mathFloor((v.getTime() - v.getTimezoneOffset() * MINUTE) / divider) * divider + v.getTimezoneOffset() * MINUTE);\n    };\n\n    value = correctDateWithUnitBeginning(value);\n\n    if (\"years\" in intervalObject) {\n      value.setFullYear(floorNumber(value.getFullYear(), intervalObject.years, 0));\n    } else {\n      if (\"quarters\" in intervalObject) {\n        value = correctDateWithUnitBeginning(floorAtStartDate(value));\n      } else {\n        if (\"months\" in intervalObject) {\n          value.setMonth(floorNumber(value.getMonth(), intervalObject.months, 0));\n        } else {\n          if (\"weeks\" in intervalObject || \"days\" in intervalObject) {\n            value = correctDateWithUnitBeginning(floorAtStartDate(value));\n          } else {\n            if (\"hours\" in intervalObject) {\n              value.setHours(floorNumber(value.getHours(), intervalObject.hours, 0));\n            } else {\n              if (\"minutes\" in intervalObject) {\n                value.setMinutes(floorNumber(value.getMinutes(), intervalObject.minutes, 0));\n              } else {\n                if (\"seconds\" in intervalObject) {\n                  value.setSeconds(floorNumber(value.getSeconds(), intervalObject.seconds, 0));\n                } else {\n                  if (\"milliseconds\" in intervalObject) {\n                    value = floorAtStartDate(value);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return value;\n  }\n\n  function ceil(value, interval) {\n    var newValue = floor(value, interval);\n\n    while (value - newValue > 0) {\n      newValue = addIntervalDate(newValue, interval);\n    }\n\n    return newValue;\n  }\n\n  var calculateTickIntervalByCustomTicks = getTickIntervalByCustomTicks(getValue, _date2.default.convertMillisecondsToDateUnits);\n  return generator(options, getBusinessDelta, calculateTickIntervalDateTime, calculateMinorTickIntervalDateTime, calculateTickIntervalByCustomTicks, calculateTickIntervalByCustomTicks, dateToMilliseconds, calculateTicks(addIntervalDate, correctMinValueByEndOnTick(floor, ceil, resolveEndOnTickDate, options.endOnTick), adjustIntervalDateTime, resolveEndOnTickDate, resolveExtraTickForHiddenDataPointDate), calculateMinorTicks(getValue, addIntervalDate, floor, addIntervalDate, getValue), getScaleBreaksProcessor(dateToMilliseconds, getValue, function (value, correction) {\n    return new Date(value.getTime() + correction);\n  }));\n}\n\nexports.tickGenerator = function (options) {\n  var result;\n\n  if (options.rangeIsEmpty) {\n    result = dummyGenerator(options);\n  } else {\n    if (\"discrete\" === options.axisType) {\n      result = discreteGenerator(options);\n    } else {\n      if (\"logarithmic\" === options.axisType) {\n        result = logarithmicGenerator(options);\n      } else {\n        if (\"datetime\" === options.dataType) {\n          result = dateGenerator(options);\n        } else {\n          result = numericGenerator(options);\n        }\n      }\n    }\n  }\n\n  return result;\n};","map":null,"metadata":{},"sourceType":"script"}