{"ast":null,"code":"/**\r\n * DevExtreme (viz/axes/tick.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar isDefined = require(\"../../core/utils/type\").isDefined;\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nfunction getPathStyle(options) {\n  return {\n    stroke: options.color,\n    \"stroke-width\": options.width,\n    \"stroke-opacity\": options.opacity,\n    opacity: 1\n  };\n}\n\nfunction createTick(axis, renderer, tickOptions, gridOptions, skippedCategory, skipLabels, offset) {\n  var tickOffset = offset || axis._tickOffset;\n  var lineGroup = axis._axisLineGroup;\n  var elementsGroup = axis._axisElementsGroup;\n  var tickStyle = getPathStyle(tickOptions);\n  var gridStyle = getPathStyle(gridOptions);\n  var emptyStrRegExp = /^\\s+$/;\n  var axisOptions = axis.getOptions();\n  var labelOptions = axisOptions.label;\n  var labelStyle = axis._textOptions;\n\n  function getLabelFontStyle(tick) {\n    var fontStyle = axis._textFontStyles;\n    var customizeColor = labelOptions.customizeColor;\n\n    if (customizeColor && customizeColor.call) {\n      fontStyle = extend({}, axis._textFontStyles, {\n        fill: customizeColor.call(tick, tick)\n      });\n    }\n\n    return fontStyle;\n  }\n\n  function createLabelHint(tick, range) {\n    var labelHint = axis.formatHint(tick.value, labelOptions, range);\n\n    if (isDefined(labelHint) && \"\" !== labelHint) {\n      tick.label.setTitle(labelHint);\n    }\n  }\n\n  return function (value) {\n    var tick = {\n      value: value,\n      updateValue: function updateValue(newValue) {\n        this.value = value = newValue;\n      },\n      initCoords: function initCoords() {\n        this.coords = axis._getTranslatedValue(value, tickOffset);\n        this.labelCoords = axis._getTranslatedValue(value);\n      },\n      saveCoords: function saveCoords() {\n        this._storedCoords = this.coords;\n        this._storedLabelsCoords = this.labelCoords;\n      },\n      drawMark: function drawMark(options) {\n        if (!tickOptions.visible || skippedCategory === value) {\n          return;\n        }\n\n        if (axis.areCoordsOutsideAxis(this.coords)) {\n          return;\n        }\n\n        if (this.mark) {\n          this.mark.append(lineGroup);\n          axis.sharp(this.mark, axis.getSharpDirectionByCoords(this.coords));\n          this.updateTickPosition(options);\n        } else {\n          this.mark = axis._createPathElement([], tickStyle, axis.getSharpDirectionByCoords(this.coords)).append(lineGroup);\n          this.updateTickPosition(options);\n        }\n      },\n      setSkippedCategory: function setSkippedCategory(category) {\n        skippedCategory = category;\n      },\n      _updateLine: function _updateLine(lineElement, settings, storedSettings, animate, isGridLine) {\n        if (!lineElement) {\n          return;\n        }\n\n        if (null === settings.points || null === settings.r) {\n          lineElement.remove();\n          return;\n        }\n\n        if (animate && storedSettings && null !== storedSettings.points) {\n          settings.opacity = 1;\n          lineElement.attr(storedSettings);\n          lineElement.animate(settings);\n        } else {\n          settings.opacity = animate ? 0 : 1;\n          lineElement.attr(settings);\n          animate && lineElement.animate({\n            opacity: 1\n          }, {\n            delay: .5,\n            partitionDuration: .5\n          });\n        }\n\n        this.coords.angle && axis._rotateTick(lineElement, this.coords, isGridLine);\n      },\n      updateTickPosition: function updateTickPosition(options, animate) {\n        this._updateLine(this.mark, {\n          points: axis._getTickMarkPoints(tick.coords, tickOptions.length, options)\n        }, this._storedCoords && {\n          points: axis._getTickMarkPoints(tick._storedCoords, tickOptions.length, options)\n        }, animate, false);\n      },\n      drawLabel: function drawLabel(range) {\n        var labelIsVisible = labelOptions.visible && !skipLabels && !axis.getTranslator().getBusinessRange().isEmpty() && !axis.areCoordsOutsideAxis(this.labelCoords);\n\n        if (!labelIsVisible) {\n          if (this.label) {\n            this.label.remove();\n          }\n\n          return;\n        }\n\n        var text = axis.formatLabel(value, labelOptions, range);\n\n        if (this.label) {\n          this.label.attr({\n            text: text,\n            rotate: 0\n          }).append(elementsGroup);\n          createLabelHint(this, range);\n          this.updateLabelPosition();\n          return;\n        }\n\n        if (isDefined(text) && \"\" !== text && !emptyStrRegExp.test(text)) {\n          this.label = renderer.text(text).css(getLabelFontStyle(this)).attr(labelStyle).data(\"chart-data-argument\", this.value).append(elementsGroup);\n          this.updateLabelPosition();\n          createLabelHint(this, range);\n        }\n      },\n      fadeOutElements: function fadeOutElements() {\n        var startSettings = {\n          opacity: 1\n        };\n        var endSettings = {\n          opacity: 0\n        };\n        var animationSettings = {\n          partitionDuration: .5\n        };\n\n        if (this.label) {\n          this._fadeOutLabel();\n        }\n\n        if (this.grid) {\n          this.grid.append(axis._axisGridGroup).attr(startSettings).animate(endSettings, animationSettings);\n        }\n\n        if (this.mark) {\n          this.mark.append(axis._axisLineGroup).attr(startSettings).animate(endSettings, animationSettings);\n        }\n      },\n      _fadeInLabel: function _fadeInLabel() {\n        var group = axis._renderer.g().attr({\n          opacity: 0\n        }).append(axis._axisElementsGroup).animate({\n          opacity: 1\n        }, {\n          delay: .5,\n          partitionDuration: .5\n        });\n\n        this.label.append(group);\n      },\n      _fadeOutLabel: function _fadeOutLabel() {\n        var group = axis._renderer.g().attr({\n          opacity: 1\n        }).animate({\n          opacity: 0\n        }, {\n          partitionDuration: .5\n        }).append(axis._axisElementsGroup);\n\n        this.label.append(group);\n      },\n      updateLabelPosition: function updateLabelPosition(animate) {\n        if (!this.label) {\n          return;\n        }\n\n        if (animate && this._storedLabelsCoords) {\n          this.label.attr({\n            x: this._storedLabelsCoords.x,\n            y: this._storedLabelsCoords.y\n          });\n          this.label.animate({\n            x: this.labelCoords.x,\n            y: this.labelCoords.y\n          });\n        } else {\n          this.label.attr({\n            x: this.labelCoords.x,\n            y: this.labelCoords.y\n          });\n\n          if (animate) {\n            this._fadeInLabel();\n          }\n        }\n      },\n      updateMultilineTextAlignment: function updateMultilineTextAlignment() {\n        if (!this.label) {\n          return;\n        }\n\n        this.label.attr({\n          textsAlignment: this.labelAlignment || axis.getOptions().label.alignment\n        });\n      },\n      drawGrid: function drawGrid(drawLine) {\n        if (gridOptions.visible && skippedCategory !== this.value) {\n          if (this.grid) {\n            this.grid.append(axis._axisGridGroup);\n            axis.sharp(this.grid, axis.getSharpDirectionByCoords(this.coords));\n            this.updateGridPosition();\n          } else {\n            this.grid = drawLine(this, gridStyle);\n            this.grid && this.grid.append(axis._axisGridGroup);\n          }\n        }\n      },\n      updateGridPosition: function updateGridPosition(animate) {\n        this._updateLine(this.grid, axis._getGridPoints(tick.coords), this._storedCoords && axis._getGridPoints(this._storedCoords), animate, true);\n      },\n      removeLabel: function removeLabel() {\n        this.label.remove();\n        this.label = null;\n      }\n    };\n    return tick;\n  };\n}\n\nexports.tick = createTick;","map":null,"metadata":{},"sourceType":"script"}