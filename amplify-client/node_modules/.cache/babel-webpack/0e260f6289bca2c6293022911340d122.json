{"ast":null,"code":"/**\r\n * DevExtreme (ui/html_editor/converters/delta.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _converterController = require(\"../converterController\");\n\nvar _converterController2 = _interopRequireDefault(_converterController);\n\nvar _quill_importer = require(\"../quill_importer\");\n\nvar _type = require(\"../../../core/utils/type\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _toArray(arr) {\n  return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || \"[object Arguments]\" === Object.prototype.toString.call(iter)) {\n    return Array.from(iter);\n  }\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || \"[object Arguments]\" === Object.prototype.toString.call(arr))) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _e = void 0;\n\n  try {\n    for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) {\n        break;\n      }\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && null != _i.return) {\n        _i.return();\n      }\n    } finally {\n      if (_d) {\n        throw _e;\n      }\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) {\n    return arr;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n\n    if (\"value\" in descriptor) {\n      descriptor.writable = true;\n    }\n\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) {\n    _defineProperties(Constructor.prototype, protoProps);\n  }\n\n  if (staticProps) {\n    _defineProperties(Constructor, staticProps);\n  }\n\n  return Constructor;\n}\n\nvar ESCAPING_MAP = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\"\n};\nvar LIST_BLOT_NAME = \"list\";\nvar LIST_ITEM_BLOT_NAME = \"list-item\";\n\nvar DeltaConverter = function () {\n  function DeltaConverter() {\n    _classCallCheck(this, DeltaConverter);\n\n    this.TextBlot = (0, _quill_importer.getQuill)().import(\"blots/text\");\n    this.BreakBlot = (0, _quill_importer.getQuill)().import(\"blots/break\");\n  }\n\n  _createClass(DeltaConverter, [{\n    key: \"setQuillInstance\",\n    value: function value(quillInstance) {\n      this.quillInstance = quillInstance;\n    }\n  }, {\n    key: \"toHtml\",\n    value: function value() {\n      if (!this.quillInstance) {\n        return;\n      }\n\n      return this._isQuillEmpty() ? \"\" : this._convertHTML(this.quillInstance.scroll, 0, this.quillInstance.getLength(), true);\n    }\n  }, {\n    key: \"_isQuillEmpty\",\n    value: function value() {\n      var delta = this.quillInstance.getContents();\n      return 1 === delta.length() && this._isDeltaEmpty(delta);\n    }\n  }, {\n    key: \"_isDeltaEmpty\",\n    value: function value(delta) {\n      return delta.reduce(function (__, _ref) {\n        var insert = _ref.insert;\n        return insert.indexOf(\"\\n\") !== -1;\n      });\n    }\n  }, {\n    key: \"_convertHTML\",\n    value: function value(blot, index, length) {\n      var _this = this;\n\n      var isRoot = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;\n\n      if ((0, _type.isFunction)(blot.html)) {\n        return blot.html(index, length);\n      }\n\n      if (blot instanceof this.TextBlot) {\n        return this._escapeText(blot.value().slice(index, index + length));\n      }\n\n      if (blot.children) {\n        if (blot.statics.blotName === LIST_BLOT_NAME) {\n          return this._convertList(blot, index, length);\n        }\n\n        var parts = [];\n        blot.children.forEachAt(index, length, function (child, offset, childLength) {\n          parts.push(_this._convertHTML(child, offset, childLength));\n        });\n\n        this._handleBreakLine(blot.children, parts);\n\n        if (isRoot || blot.statics.blotName === LIST_ITEM_BLOT_NAME) {\n          return parts.join(\"\");\n        }\n\n        var _blot$domNode = blot.domNode,\n            outerHTML = _blot$domNode.outerHTML,\n            innerHTML = _blot$domNode.innerHTML;\n\n        var _outerHTML$split = outerHTML.split(\">\".concat(innerHTML, \"<\")),\n            _outerHTML$split2 = _slicedToArray(_outerHTML$split, 2),\n            start = _outerHTML$split2[0],\n            end = _outerHTML$split2[1];\n\n        return \"\".concat(start, \">\").concat(parts.join(\"\"), \"<\").concat(end);\n      }\n\n      return blot.domNode.outerHTML;\n    }\n  }, {\n    key: \"_handleBreakLine\",\n    value: function value(linkedList, parts) {\n      if (1 === linkedList.length && linkedList.head instanceof this.BreakBlot) {\n        parts.push(\"<br>\");\n      }\n    }\n  }, {\n    key: \"_convertList\",\n    value: function value(blot, index, length) {\n      var items = [];\n      var parentFormats = blot.formats();\n      blot.children.forEachAt(index, length, function (child, offset, childLength) {\n        var childFormats = child.formats();\n        items.push({\n          child: child,\n          offset: offset,\n          length: childLength,\n          indent: childFormats.indent || 0,\n          type: parentFormats.list\n        });\n      });\n      return this._getListMarkup(items, -1, []);\n    }\n  }, {\n    key: \"_getListMarkup\",\n    value: function value(items, lastIndent, listTypes) {\n      if (0 === items.length) {\n        var _endTag = this._getListType(listTypes.pop());\n\n        if (lastIndent <= 0) {\n          return \"</li></\".concat(_endTag, \">\");\n        }\n\n        return this._processListMarkup([[], lastIndent - 1, listTypes], _endTag);\n      }\n\n      var _items = _toArray(items),\n          _items$ = _items[0],\n          child = _items$.child,\n          offset = _items$.offset,\n          length = _items$.length,\n          indent = _items$.indent,\n          type = _items$.type,\n          rest = _items.slice(1);\n\n      var tag = this._getListType(type);\n\n      var childItemArgs = [child, offset, length];\n      var restItemsArgs = [rest, indent, listTypes];\n\n      if (indent > lastIndent) {\n        listTypes.push(type);\n\n        var multiLevelTags = this._correctListMultiIndent(listTypes, type, tag, indent - lastIndent - 1);\n\n        return multiLevelTags + this._processIndentListMarkup(childItemArgs, restItemsArgs, tag);\n      }\n\n      if (indent === lastIndent) {\n        return this._processIndentListMarkup(childItemArgs, restItemsArgs);\n      }\n\n      var endTag = this._getListType(listTypes.pop());\n\n      return this._processListMarkup([items, lastIndent - 1, listTypes], endTag);\n    }\n  }, {\n    key: \"_correctListMultiIndent\",\n    value: function value(listTypes, type, tag, indent) {\n      var markup = \"\";\n\n      while (indent) {\n        markup += \"<\".concat(tag, \">\");\n        listTypes.push(type);\n        indent--;\n      }\n\n      return markup;\n    }\n  }, {\n    key: \"_processListMarkup\",\n    value: function value(childItemArgs, tag) {\n      return \"</li></\".concat(tag, \">\").concat(this._getListMarkup.apply(this, _toConsumableArray(childItemArgs)));\n    }\n  }, {\n    key: \"_processIndentListMarkup\",\n    value: function value(childItemArgs, restItemsArgs) {\n      var tag = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : \"/li\";\n\n      var itemAttrs = this._getListItemAttributes(childItemArgs[0]);\n\n      return \"<\".concat(tag, \"><li\").concat(itemAttrs, \">\").concat(this._convertHTML.apply(this, _toConsumableArray(childItemArgs))).concat(this._getListMarkup.apply(this, _toConsumableArray(restItemsArgs)));\n    }\n  }, {\n    key: \"_getListItemAttributes\",\n    value: function value(_ref2) {\n      var domNode = _ref2.domNode;\n\n      if (!domNode.hasAttributes()) {\n        return \"\";\n      }\n\n      var attributes = domNode.attributes;\n      var attributesString = \" \";\n\n      for (var i = 0; i < attributes.length; i++) {\n        var _attributes$i = attributes[i],\n            name = _attributes$i.name,\n            value = _attributes$i.value;\n\n        if (\"class\" === name) {\n          value = this._removeIndentClass(value);\n        }\n\n        if (value.length) {\n          attributesString += \"\".concat(name, '=\"').concat(value, '\"');\n        }\n      }\n\n      return attributesString.length > 1 ? attributesString : \"\";\n    }\n  }, {\n    key: \"_getListType\",\n    value: function value(type) {\n      return \"ordered\" === type ? \"ol\" : \"ul\";\n    }\n  }, {\n    key: \"_removeIndentClass\",\n    value: function value(classString) {\n      return classString.replace(/ql-indent-\\d/g, \"\").trim();\n    }\n  }, {\n    key: \"_escapeText\",\n    value: function value(text) {\n      return text.replace(/[&<>\"']/g, function (char) {\n        return ESCAPING_MAP[char];\n      });\n    }\n  }]);\n\n  return DeltaConverter;\n}();\n\n_converterController2.default.addConverter(\"delta\", DeltaConverter);\n\nexports.default = DeltaConverter;","map":null,"metadata":{},"sourceType":"script"}