{"ast":null,"code":"import { Directive, ViewContainerRef, Input, Injectable, Component, Renderer2, ElementRef, HostBinding, Output, EventEmitter, TemplateRef, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\n\nfunction TabsetComponent_li_1_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r6 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"span\", 7);\n    ɵngcc0.ɵɵlistener(\"click\", function TabsetComponent_li_1_span_4_Template_span_click_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r6);\n      var tabz_r1 = ɵngcc0.ɵɵnextContext().$implicit;\n      var ctx_r4 = ɵngcc0.ɵɵnextContext();\n      $event.preventDefault();\n      return ctx_r4.removeTab(tabz_r1);\n    });\n    ɵngcc0.ɵɵtext(1, \" \\u274C\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nvar _c0 = function _c0(a1) {\n  return [\"nav-item\", a1];\n};\n\nfunction TabsetComponent_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r8 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"li\", 3);\n    ɵngcc0.ɵɵlistener(\"keydown\", function TabsetComponent_li_1_Template_li_keydown_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r8);\n      var i_r2 = ctx.index;\n      var ctx_r7 = ɵngcc0.ɵɵnextContext();\n      return ctx_r7.keyNavActions($event, i_r2);\n    });\n    ɵngcc0.ɵɵelementStart(1, \"a\", 4);\n    ɵngcc0.ɵɵlistener(\"click\", function TabsetComponent_li_1_Template_a_click_1_listener() {\n      var tabz_r1 = ctx.$implicit;\n      return tabz_r1.active = true;\n    });\n    ɵngcc0.ɵɵelementStart(2, \"span\", 5);\n    ɵngcc0.ɵɵtext(3);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtemplate(4, TabsetComponent_li_1_span_4_Template, 2, 0, \"span\", 6);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var tabz_r1 = ctx.$implicit;\n    ɵngcc0.ɵɵclassProp(\"active\", tabz_r1.active)(\"disabled\", tabz_r1.disabled);\n    ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction1(13, _c0, tabz_r1.customClass || \"\"));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵclassProp(\"active\", tabz_r1.active)(\"disabled\", tabz_r1.disabled);\n    ɵngcc0.ɵɵattribute(\"id\", tabz_r1.id ? tabz_r1.id + \"-link\" : \"\");\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngTransclude\", tabz_r1.headingRef);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(tabz_r1.heading);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", tabz_r1.removable);\n  }\n}\n\nvar _c1 = [\"*\"];\n\nvar NgTranscludeDirective =\n/** @class */\nfunction () {\n  function NgTranscludeDirective(viewRef) {\n    this.viewRef = viewRef;\n  }\n\n  Object.defineProperty(NgTranscludeDirective.prototype, \"ngTransclude\", {\n    /* tslint:disable-next-line:no-any */\n    get:\n    /* tslint:disable-next-line:no-any */\n\n    /**\r\n     * @return {?}\r\n     */\n    function get() {\n      return this._ngTransclude;\n    },\n    set:\n    /**\r\n    * @param {?} templateRef\r\n    * @return {?}\r\n    */\n    function set(templateRef) {\n      this._ngTransclude = templateRef;\n\n      if (templateRef) {\n        this.viewRef.createEmbeddedView(templateRef);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /** @nocollapse */\n\n  NgTranscludeDirective.ctorParameters = function () {\n    return [{\n      type: ViewContainerRef\n    }];\n  };\n\n  NgTranscludeDirective.propDecorators = {\n    ngTransclude: [{\n      type: Input\n    }]\n  };\n\n  NgTranscludeDirective.ɵfac = function NgTranscludeDirective_Factory(t) {\n    return new (t || NgTranscludeDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  NgTranscludeDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: NgTranscludeDirective,\n    selectors: [[\"\", \"ngTransclude\", \"\"]],\n    inputs: {\n      ngTransclude: \"ngTransclude\"\n    }\n  });\n  /*@__PURE__*/\n\n  (function () {\n    ɵngcc0.ɵsetClassMetadata(NgTranscludeDirective, [{\n      type: Directive,\n      args: [{\n        selector: '[ngTransclude]'\n      }]\n    }], function () {\n      return [{\n        type: ɵngcc0.ViewContainerRef\n      }];\n    }, {\n      ngTransclude: [{\n        type: Input\n      }]\n    });\n  })();\n\n  return NgTranscludeDirective;\n}();\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nvar TabsetConfig =\n/** @class */\nfunction () {\n  function TabsetConfig() {\n    /**\r\n     * provides default navigation context class: 'tabs' or 'pills'\r\n     */\n    this.type = 'tabs';\n  }\n\n  TabsetConfig.ɵfac = function TabsetConfig_Factory(t) {\n    return new (t || TabsetConfig)();\n  };\n\n  TabsetConfig.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n    token: TabsetConfig,\n    factory: function factory(t) {\n      return TabsetConfig.ɵfac(t);\n    }\n  });\n  /*@__PURE__*/\n\n  (function () {\n    ɵngcc0.ɵsetClassMetadata(TabsetConfig, [{\n      type: Injectable\n    }], function () {\n      return [];\n    }, null);\n  })();\n\n  return TabsetConfig;\n}();\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n// todo: add active event to tab\n// todo: fix? mixing static and dynamic tabs position tabs in order of creation\n\n\nvar TabsetComponent =\n/** @class */\nfunction () {\n  function TabsetComponent(config, renderer, elementRef) {\n    this.renderer = renderer;\n    this.elementRef = elementRef;\n    this.clazz = true;\n    this.tabs = [];\n    this.classMap = {};\n    Object.assign(this, config);\n  }\n\n  Object.defineProperty(TabsetComponent.prototype, \"vertical\", {\n    /** if true tabs will be placed vertically */\n    get:\n    /**\r\n    * if true tabs will be placed vertically\r\n    * @return {?}\r\n    */\n    function get() {\n      return this._vertical;\n    },\n    set:\n    /**\r\n    * @param {?} value\r\n    * @return {?}\r\n    */\n    function set(value) {\n      this._vertical = value;\n      this.setClassMap();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TabsetComponent.prototype, \"justified\", {\n    /** if true tabs fill the container and have a consistent width */\n    get:\n    /**\r\n    * if true tabs fill the container and have a consistent width\r\n    * @return {?}\r\n    */\n    function get() {\n      return this._justified;\n    },\n    set:\n    /**\r\n    * @param {?} value\r\n    * @return {?}\r\n    */\n    function set(value) {\n      this._justified = value;\n      this.setClassMap();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TabsetComponent.prototype, \"type\", {\n    /** navigation context class: 'tabs' or 'pills' */\n    get:\n    /**\r\n    * navigation context class: 'tabs' or 'pills'\r\n    * @return {?}\r\n    */\n    function get() {\n      return this._type;\n    },\n    set:\n    /**\r\n    * @param {?} value\r\n    * @return {?}\r\n    */\n    function set(value) {\n      this._type = value;\n      this.setClassMap();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @return {?}\r\n   */\n\n  TabsetComponent.prototype.ngOnDestroy =\n  /**\r\n  * @return {?}\r\n  */\n  function () {\n    this.isDestroyed = true;\n  };\n  /**\r\n   * @param {?} tab\r\n   * @return {?}\r\n   */\n\n\n  TabsetComponent.prototype.addTab =\n  /**\r\n  * @param {?} tab\r\n  * @return {?}\r\n  */\n  function (tab) {\n    this.tabs.push(tab);\n    tab.active = this.tabs.length === 1 && typeof tab.active === 'undefined';\n  };\n  /**\r\n   * @param {?} tab\r\n   * @param {?=} options\r\n   * @return {?}\r\n   */\n\n\n  TabsetComponent.prototype.removeTab =\n  /**\r\n  * @param {?} tab\r\n  * @param {?=} options\r\n  * @return {?}\r\n  */\n  function (tab, options) {\n    if (options === void 0) {\n      options = {\n        reselect: true,\n        emit: true\n      };\n    }\n    /** @type {?} */\n\n\n    var index = this.tabs.indexOf(tab);\n\n    if (index === -1 || this.isDestroyed) {\n      return;\n    } // Select a new tab if the tab to be removed is selected and not destroyed\n\n\n    if (options.reselect && tab.active && this.hasAvailableTabs(index)) {\n      /** @type {?} */\n      var newActiveIndex = this.getClosestTabIndex(index);\n      this.tabs[newActiveIndex].active = true;\n    }\n\n    if (options.emit) {\n      tab.removed.emit(tab);\n    }\n\n    this.tabs.splice(index, 1);\n\n    if (tab.elementRef.nativeElement.parentNode) {\n      this.renderer.removeChild(tab.elementRef.nativeElement.parentNode, tab.elementRef.nativeElement);\n    }\n  };\n  /* tslint:disable-next-line: cyclomatic-complexity */\n\n  /* tslint:disable-next-line: cyclomatic-complexity */\n\n  /**\r\n   * @param {?} event\r\n   * @param {?} index\r\n   * @return {?}\r\n   */\n\n\n  TabsetComponent.prototype.keyNavActions =\n  /* tslint:disable-next-line: cyclomatic-complexity */\n\n  /**\r\n   * @param {?} event\r\n   * @param {?} index\r\n   * @return {?}\r\n   */\n  function (event, index) {\n    /** @type {?} */\n    var list = Array.from(this.elementRef.nativeElement.querySelectorAll('.nav-link')); // const activeElList = list.filter((el: HTMLElement) => !el.classList.contains('disabled'));\n    // tslint:disable-next-line:deprecation\n\n    if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\n      event.preventDefault();\n      /** @type {?} */\n\n      var currentTab = list[index % list.length];\n      currentTab.click();\n      return;\n    } // tslint:disable-next-line:deprecation\n\n\n    if (event.keyCode === 39 || event.key === 'RightArrow') {\n      /** @type {?} */\n      var nextTab = void 0;\n      /** @type {?} */\n\n      var shift = 1;\n\n      do {\n        nextTab = list[(index + shift) % list.length];\n        shift++;\n      } while (nextTab.classList.contains('disabled'));\n\n      nextTab.focus();\n      return;\n    } // tslint:disable-next-line:deprecation\n\n\n    if (event.keyCode === 37 || event.key === 'LeftArrow') {\n      /** @type {?} */\n      var previousTab = void 0;\n      /** @type {?} */\n\n      var shift = 1;\n      /** @type {?} */\n\n      var i = index;\n\n      do {\n        if (i - shift < 0) {\n          i = list.length - 1;\n          previousTab = list[i];\n          shift = 0;\n        } else {\n          previousTab = list[i - shift];\n        }\n\n        shift++;\n      } while (previousTab.classList.contains('disabled'));\n\n      previousTab.focus();\n      return;\n    } // tslint:disable-next-line:deprecation\n\n\n    if (event.keyCode === 36 || event.key === 'Home') {\n      event.preventDefault();\n      /** @type {?} */\n\n      var firstTab = void 0;\n      /** @type {?} */\n\n      var shift = 0;\n\n      do {\n        firstTab = list[shift % list.length];\n        shift++;\n      } while (firstTab.classList.contains('disabled'));\n\n      firstTab.focus();\n      return;\n    } // tslint:disable-next-line:deprecation\n\n\n    if (event.keyCode === 35 || event.key === 'End') {\n      event.preventDefault();\n      /** @type {?} */\n\n      var lastTab = void 0;\n      /** @type {?} */\n\n      var shift = 1;\n      /** @type {?} */\n\n      var i = index;\n\n      do {\n        if (i - shift < 0) {\n          i = list.length - 1;\n          lastTab = list[i];\n          shift = 0;\n        } else {\n          lastTab = list[i - shift];\n        }\n\n        shift++;\n      } while (lastTab.classList.contains('disabled'));\n\n      lastTab.focus();\n      return;\n    } // tslint:disable-next-line:deprecation\n\n\n    if (event.keyCode === 46 || event.key === 'Delete') {\n      if (this.tabs[index].removable) {\n        this.removeTab(this.tabs[index]);\n\n        if (list[index + 1]) {\n          list[(index + 1) % list.length].focus();\n          return;\n        }\n\n        if (list[list.length - 1]) {\n          list[0].focus();\n        }\n      }\n    }\n  };\n  /**\r\n   * @protected\r\n   * @param {?} index\r\n   * @return {?}\r\n   */\n\n\n  TabsetComponent.prototype.getClosestTabIndex =\n  /**\r\n  * @protected\r\n  * @param {?} index\r\n  * @return {?}\r\n  */\n  function (index) {\n    /** @type {?} */\n    var tabsLength = this.tabs.length;\n\n    if (!tabsLength) {\n      return -1;\n    }\n\n    for (var step = 1; step <= tabsLength; step += 1) {\n      /** @type {?} */\n      var prevIndex = index - step;\n      /** @type {?} */\n\n      var nextIndex = index + step;\n\n      if (this.tabs[prevIndex] && !this.tabs[prevIndex].disabled) {\n        return prevIndex;\n      }\n\n      if (this.tabs[nextIndex] && !this.tabs[nextIndex].disabled) {\n        return nextIndex;\n      }\n    }\n\n    return -1;\n  };\n  /**\r\n   * @protected\r\n   * @param {?} index\r\n   * @return {?}\r\n   */\n\n\n  TabsetComponent.prototype.hasAvailableTabs =\n  /**\r\n  * @protected\r\n  * @param {?} index\r\n  * @return {?}\r\n  */\n  function (index) {\n    /** @type {?} */\n    var tabsLength = this.tabs.length;\n\n    if (!tabsLength) {\n      return false;\n    }\n\n    for (var i = 0; i < tabsLength; i += 1) {\n      if (!this.tabs[i].disabled && i !== index) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\r\n   * @protected\r\n   * @return {?}\r\n   */\n\n\n  TabsetComponent.prototype.setClassMap =\n  /**\r\n  * @protected\r\n  * @return {?}\r\n  */\n  function () {\n    var _a;\n\n    this.classMap = (_a = {\n      'nav-stacked': this.vertical,\n      'flex-column': this.vertical,\n      'nav-justified': this.justified\n    }, _a[\"nav-\" + this.type] = true, _a);\n  };\n  /** @nocollapse */\n\n\n  TabsetComponent.ctorParameters = function () {\n    return [{\n      type: TabsetConfig\n    }, {\n      type: Renderer2\n    }, {\n      type: ElementRef\n    }];\n  };\n\n  TabsetComponent.propDecorators = {\n    vertical: [{\n      type: Input\n    }],\n    justified: [{\n      type: Input\n    }],\n    type: [{\n      type: Input\n    }],\n    clazz: [{\n      type: HostBinding,\n      args: ['class.tab-container']\n    }]\n  };\n\n  TabsetComponent.ɵfac = function TabsetComponent_Factory(t) {\n    return new (t || TabsetComponent)(ɵngcc0.ɵɵdirectiveInject(TabsetConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  TabsetComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({\n    type: TabsetComponent,\n    selectors: [[\"tabset\"]],\n    hostVars: 2,\n    hostBindings: function TabsetComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"tab-container\", ctx.clazz);\n      }\n    },\n    inputs: {\n      vertical: \"vertical\",\n      justified: \"justified\",\n      type: \"type\"\n    },\n    ngContentSelectors: _c1,\n    decls: 4,\n    vars: 2,\n    consts: [[1, \"nav\", 3, \"ngClass\", \"click\"], [3, \"ngClass\", \"active\", \"disabled\", \"keydown\", 4, \"ngFor\", \"ngForOf\"], [1, \"tab-content\"], [3, \"ngClass\", \"keydown\"], [\"href\", \"javascript:void(0);\", 1, \"nav-link\", 3, \"click\"], [3, \"ngTransclude\"], [\"class\", \"bs-remove-tab\", 3, \"click\", 4, \"ngIf\"], [1, \"bs-remove-tab\", 3, \"click\"]],\n    template: function TabsetComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"ul\", 0);\n        ɵngcc0.ɵɵlistener(\"click\", function TabsetComponent_Template_ul_click_0_listener($event) {\n          return $event.preventDefault();\n        });\n        ɵngcc0.ɵɵtemplate(1, TabsetComponent_li_1_Template, 5, 15, \"li\", 1);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(2, \"div\", 2);\n        ɵngcc0.ɵɵprojection(3);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngClass\", ctx.classMap);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.tabs);\n      }\n    },\n    directives: [ɵngcc1.NgClass, ɵngcc1.NgForOf, NgTranscludeDirective, ɵngcc1.NgIf],\n    styles: [\"[_nghost-%COMP%]   .nav-tabs[_ngcontent-%COMP%]   .nav-item.disabled[_ngcontent-%COMP%]   a.disabled[_ngcontent-%COMP%]{cursor:default}\"]\n  });\n  /*@__PURE__*/\n\n  (function () {\n    ɵngcc0.ɵsetClassMetadata(TabsetComponent, [{\n      type: Component,\n      args: [{\n        selector: 'tabset',\n        template: \"<ul class=\\\"nav\\\" [ngClass]=\\\"classMap\\\" (click)=\\\"$event.preventDefault()\\\">\\n  <li *ngFor=\\\"let tabz of tabs; let i = index\\\" [ngClass]=\\\"['nav-item', tabz.customClass || '']\\\"\\n      [class.active]=\\\"tabz.active\\\" [class.disabled]=\\\"tabz.disabled\\\" (keydown)=\\\"keyNavActions($event, i)\\\">\\n    <a href=\\\"javascript:void(0);\\\" class=\\\"nav-link\\\"\\n       [attr.id]=\\\"tabz.id ? tabz.id + '-link' : ''\\\"\\n       [class.active]=\\\"tabz.active\\\" [class.disabled]=\\\"tabz.disabled\\\"\\n       (click)=\\\"tabz.active = true\\\">\\n      <span [ngTransclude]=\\\"tabz.headingRef\\\">{{ tabz.heading }}</span>\\n      <span *ngIf=\\\"tabz.removable\\\" (click)=\\\"$event.preventDefault(); removeTab(tabz);\\\" class=\\\"bs-remove-tab\\\"> &#10060;</span>\\n    </a>\\n  </li>\\n</ul>\\n<div class=\\\"tab-content\\\">\\n  <ng-content></ng-content>\\n</div>\\n\",\n        styles: [\":host .nav-tabs .nav-item.disabled a.disabled{cursor:default}\"]\n      }]\n    }], function () {\n      return [{\n        type: TabsetConfig\n      }, {\n        type: ɵngcc0.Renderer2\n      }, {\n        type: ɵngcc0.ElementRef\n      }];\n    }, {\n      clazz: [{\n        type: HostBinding,\n        args: ['class.tab-container']\n      }],\n      vertical: [{\n        type: Input\n      }],\n      justified: [{\n        type: Input\n      }],\n      type: [{\n        type: Input\n      }]\n    });\n  })();\n\n  return TabsetComponent;\n}();\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nvar TabDirective =\n/** @class */\nfunction () {\n  function TabDirective(tabset, elementRef, renderer) {\n    this.elementRef = elementRef;\n    this.renderer = renderer;\n    /**\r\n     * fired when tab became active, $event:Tab equals to selected instance of Tab component\r\n     */\n\n    this.selectTab = new EventEmitter();\n    /**\r\n     * fired when tab became inactive, $event:Tab equals to deselected instance of Tab component\r\n     */\n\n    this.deselect = new EventEmitter();\n    /**\r\n     * fired before tab will be removed, $event:Tab equals to instance of removed tab\r\n     */\n\n    this.removed = new EventEmitter();\n    this.addClass = true;\n    this.tabset = tabset;\n    this.tabset.addTab(this);\n  }\n\n  Object.defineProperty(TabDirective.prototype, \"customClass\", {\n    /** if set, will be added to the tab's class attribute. Multiple classes are supported. */\n    get:\n    /**\r\n    * if set, will be added to the tab's class attribute. Multiple classes are supported.\r\n    * @return {?}\r\n    */\n    function get() {\n      return this._customClass;\n    },\n    set:\n    /**\r\n    * @param {?} customClass\r\n    * @return {?}\r\n    */\n    function set(customClass) {\n      var _this = this;\n\n      if (this.customClass) {\n        this.customClass.split(' ').forEach(\n        /**\r\n        * @param {?} cssClass\r\n        * @return {?}\r\n        */\n        function (cssClass) {\n          _this.renderer.removeClass(_this.elementRef.nativeElement, cssClass);\n        });\n      }\n\n      this._customClass = customClass ? customClass.trim() : null;\n\n      if (this.customClass) {\n        this.customClass.split(' ').forEach(\n        /**\r\n        * @param {?} cssClass\r\n        * @return {?}\r\n        */\n        function (cssClass) {\n          _this.renderer.addClass(_this.elementRef.nativeElement, cssClass);\n        });\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TabDirective.prototype, \"active\", {\n    /** tab active state toggle */\n    get:\n    /**\r\n    * tab active state toggle\r\n    * @return {?}\r\n    */\n    function get() {\n      return this._active;\n    },\n    set:\n    /**\r\n    * @param {?} active\r\n    * @return {?}\r\n    */\n    function set(active) {\n      var _this = this;\n\n      if (this._active === active) {\n        return;\n      }\n\n      if (this.disabled && active || !active) {\n        if (this._active && !active) {\n          this.deselect.emit(this);\n          this._active = active;\n        }\n\n        return;\n      }\n\n      this._active = active;\n      this.selectTab.emit(this);\n      this.tabset.tabs.forEach(\n      /**\r\n      * @param {?} tab\r\n      * @return {?}\r\n      */\n      function (tab) {\n        if (tab !== _this) {\n          tab.active = false;\n        }\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @return {?}\r\n   */\n\n  TabDirective.prototype.ngOnInit =\n  /**\r\n  * @return {?}\r\n  */\n  function () {\n    this.removable = this.removable;\n  };\n  /**\r\n   * @return {?}\r\n   */\n\n\n  TabDirective.prototype.ngOnDestroy =\n  /**\r\n  * @return {?}\r\n  */\n  function () {\n    this.tabset.removeTab(this, {\n      reselect: false,\n      emit: false\n    });\n  };\n  /** @nocollapse */\n\n\n  TabDirective.ctorParameters = function () {\n    return [{\n      type: TabsetComponent\n    }, {\n      type: ElementRef\n    }, {\n      type: Renderer2\n    }];\n  };\n\n  TabDirective.propDecorators = {\n    heading: [{\n      type: Input\n    }],\n    id: [{\n      type: HostBinding,\n      args: ['attr.id']\n    }, {\n      type: Input\n    }],\n    disabled: [{\n      type: Input\n    }],\n    removable: [{\n      type: Input\n    }],\n    customClass: [{\n      type: Input\n    }],\n    active: [{\n      type: HostBinding,\n      args: ['class.active']\n    }, {\n      type: Input\n    }],\n    selectTab: [{\n      type: Output\n    }],\n    deselect: [{\n      type: Output\n    }],\n    removed: [{\n      type: Output\n    }],\n    addClass: [{\n      type: HostBinding,\n      args: ['class.tab-pane']\n    }]\n  };\n\n  TabDirective.ɵfac = function TabDirective_Factory(t) {\n    return new (t || TabDirective)(ɵngcc0.ɵɵdirectiveInject(TabsetComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  TabDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: TabDirective,\n    selectors: [[\"tab\"], [\"\", \"tab\", \"\"]],\n    hostVars: 5,\n    hostBindings: function TabDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"id\", ctx.id);\n        ɵngcc0.ɵɵclassProp(\"tab-pane\", ctx.addClass)(\"active\", ctx.active);\n      }\n    },\n    inputs: {\n      customClass: \"customClass\",\n      active: \"active\",\n      removable: \"removable\",\n      heading: \"heading\",\n      id: \"id\",\n      disabled: \"disabled\"\n    },\n    outputs: {\n      selectTab: \"selectTab\",\n      deselect: \"deselect\",\n      removed: \"removed\"\n    }\n  });\n  /*@__PURE__*/\n\n  (function () {\n    ɵngcc0.ɵsetClassMetadata(TabDirective, [{\n      type: Directive,\n      args: [{\n        selector: 'tab, [tab]'\n      }]\n    }], function () {\n      return [{\n        type: TabsetComponent\n      }, {\n        type: ɵngcc0.ElementRef\n      }, {\n        type: ɵngcc0.Renderer2\n      }];\n    }, {\n      selectTab: [{\n        type: Output\n      }],\n      deselect: [{\n        type: Output\n      }],\n      removed: [{\n        type: Output\n      }],\n      addClass: [{\n        type: HostBinding,\n        args: ['class.tab-pane']\n      }],\n      customClass: [{\n        type: Input\n      }],\n      active: [{\n        type: HostBinding,\n        args: ['class.active']\n      }, {\n        type: Input\n      }],\n      removable: [{\n        type: Input\n      }],\n      heading: [{\n        type: Input\n      }],\n      id: [{\n        type: HostBinding,\n        args: ['attr.id']\n      }, {\n        type: Input\n      }],\n      disabled: [{\n        type: Input\n      }]\n    });\n  })();\n\n  return TabDirective;\n}();\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * Should be used to mark <ng-template> element as a template for tab heading\r\n */\n\n\nvar TabHeadingDirective =\n/** @class */\nfunction () {\n  /* tslint:disable-next-line:no-any */\n  function TabHeadingDirective(templateRef, tab) {\n    tab.headingRef = templateRef;\n  }\n  /** @nocollapse */\n\n\n  TabHeadingDirective.ctorParameters = function () {\n    return [{\n      type: TemplateRef\n    }, {\n      type: TabDirective\n    }];\n  };\n\n  TabHeadingDirective.ɵfac = function TabHeadingDirective_Factory(t) {\n    return new (t || TabHeadingDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(TabDirective));\n  };\n\n  TabHeadingDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: TabHeadingDirective,\n    selectors: [[\"\", \"tabHeading\", \"\"]]\n  });\n  /*@__PURE__*/\n\n  (function () {\n    ɵngcc0.ɵsetClassMetadata(TabHeadingDirective, [{\n      type: Directive,\n      args: [{\n        selector: '[tabHeading]'\n      }]\n    }], function () {\n      return [{\n        type: ɵngcc0.TemplateRef\n      }, {\n        type: TabDirective\n      }];\n    }, null);\n  })();\n\n  return TabHeadingDirective;\n}();\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n\nvar TabsModule =\n/** @class */\nfunction () {\n  function TabsModule() {}\n  /**\r\n   * @return {?}\r\n   */\n\n\n  TabsModule.forRoot =\n  /**\r\n  * @return {?}\r\n  */\n  function () {\n    return {\n      ngModule: TabsModule,\n      providers: [TabsetConfig]\n    };\n  };\n\n  TabsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n    type: TabsModule\n  });\n  TabsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n    factory: function TabsModule_Factory(t) {\n      return new (t || TabsModule)();\n    },\n    imports: [[CommonModule]]\n  });\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TabsModule, {\n      declarations: function declarations() {\n        return [NgTranscludeDirective, TabDirective, TabsetComponent, TabHeadingDirective];\n      },\n      imports: function imports() {\n        return [CommonModule];\n      },\n      exports: function exports() {\n        return [TabDirective, TabsetComponent, TabHeadingDirective, NgTranscludeDirective];\n      }\n    });\n  })();\n  /*@__PURE__*/\n\n\n  (function () {\n    ɵngcc0.ɵsetClassMetadata(TabsModule, [{\n      type: NgModule,\n      args: [{\n        imports: [CommonModule],\n        declarations: [NgTranscludeDirective, TabDirective, TabsetComponent, TabHeadingDirective],\n        exports: [TabDirective, TabsetComponent, TabHeadingDirective, NgTranscludeDirective]\n      }]\n    }], function () {\n      return [];\n    }, null);\n  })();\n\n  return TabsModule;\n}();\n\nexport { NgTranscludeDirective, TabDirective, TabHeadingDirective, TabsModule, TabsetComponent, TabsetConfig };","map":null,"metadata":{},"sourceType":"module"}