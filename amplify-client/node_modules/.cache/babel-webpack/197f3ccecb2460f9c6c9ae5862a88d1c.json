{"ast":null,"code":"/**\r\n * DevExtreme (viz/chart_components/advanced_chart.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar inArray = require(\"../../core/utils/array\").inArray;\n\nvar iteratorModule = require(\"../../core/utils/iterator\");\n\nvar rangeModule = require(\"../translators/range\");\n\nvar DEFAULT_AXIS_NAME = \"defaultAxisName\";\n\nvar axisModule = require(\"../axes/base_axis\");\n\nvar seriesFamilyModule = require(\"../core/series_family\");\n\nvar BaseChart = require(\"./base_chart\").BaseChart;\n\nvar crosshairModule = require(\"./crosshair\");\n\nvar _isArray = Array.isArray;\n\nvar _isDefined = require(\"../../core/utils/type\").isDefined;\n\nvar _each = iteratorModule.each;\nvar _reverseEach = iteratorModule.reverseEach;\n\nvar _noop = require(\"../../core/utils/common\").noop;\n\nvar _extend = extend;\n\nvar vizUtils = require(\"../core/utils\");\n\nvar type = require(\"../../core/utils/type\").type;\n\nvar convertVisualRangeObject = vizUtils.convertVisualRangeObject;\nvar rangesAreEqual = vizUtils.rangesAreEqual;\nvar _map = vizUtils.map;\nvar mergeMarginOptions = vizUtils.mergeMarginOptions;\nvar FONT = \"font\";\nvar COMMON_AXIS_SETTINGS = \"commonAxisSettings\";\nvar DEFAULT_PANE_NAME = \"default\";\nvar VISUAL_RANGE = \"VISUAL_RANGE\";\n\nfunction prepareAxis(axisOptions) {\n  return _isArray(axisOptions) ? 0 === axisOptions.length ? [{}] : axisOptions : [axisOptions];\n}\n\nfunction processBubbleMargin(opt, bubbleSize) {\n  if (opt.processBubbleSize) {\n    opt.size = bubbleSize;\n  }\n\n  return opt;\n}\n\nfunction estimateBubbleSize(size, panesCount, maxSize, rotated) {\n  var width = rotated ? size.width / panesCount : size.width;\n  var height = rotated ? size.height : size.height / panesCount;\n  return Math.min(width, height) * maxSize;\n}\n\nfunction setAxisVisualRangeByOption(arg, axis, isDirectOption, index) {\n  var options;\n  var visualRange;\n\n  if (isDirectOption) {\n    visualRange = arg.value;\n    options = {\n      skipEventRising: true\n    };\n    var pathElements = arg.fullName.split(\".\");\n    var destElem = pathElements[pathElements.length - 1];\n\n    if (\"endValue\" === destElem || \"startValue\" === destElem) {\n      options = {\n        allowPartialUpdate: true\n      };\n      visualRange = _defineProperty({}, destElem, arg.value);\n    }\n  } else {\n    visualRange = (_isDefined(index) ? arg.value[index] : arg.value).visualRange;\n  }\n\n  axis.visualRange(visualRange, options);\n}\n\nvar AdvancedChart = BaseChart.inherit({\n  _setDeprecatedOptions: function _setDeprecatedOptions() {\n    this.callBase.apply(this, arguments);\n\n    _extend(this._deprecatedOptions, {\n      barWidth: {\n        since: \"18.1\",\n        message: \"Use the 'commonSeriesSettings.barPadding' or 'series.barPadding' option instead\"\n      },\n      equalBarWidth: {\n        since: \"18.1\",\n        message: \"Use the 'commonSeriesSettings.ignoreEmptyPoints' or 'series.ignoreEmptyPoints' option instead\"\n      }\n    });\n  },\n  _fontFields: [COMMON_AXIS_SETTINGS + \".label.\" + FONT, COMMON_AXIS_SETTINGS + \".title.\" + FONT],\n  _partialOptionChangesMap: {\n    visualRange: VISUAL_RANGE,\n    _customVisualRange: VISUAL_RANGE,\n    strips: \"REFRESH_AXES\",\n    constantLines: \"REFRESH_AXES\"\n  },\n  _partialOptionChangesPath: {\n    argumentAxis: [\"strips\", \"constantLines\", \"visualRange\", \"_customVisualRange\"],\n    valueAxis: [\"strips\", \"constantLines\", \"visualRange\", \"_customVisualRange\"]\n  },\n  _initCore: function _initCore() {\n    this._panesClipRects = {};\n    this.callBase();\n  },\n  _disposeCore: function _disposeCore() {\n    var disposeObjectsInArray = this._disposeObjectsInArray;\n    var panesClipRects = this._panesClipRects;\n    this.callBase();\n    disposeObjectsInArray.call(panesClipRects, \"fixed\");\n    disposeObjectsInArray.call(panesClipRects, \"base\");\n    disposeObjectsInArray.call(panesClipRects, \"wide\");\n    this._panesClipRects = null;\n  },\n  _dispose: function _dispose() {\n    var that = this;\n    var disposeObjectsInArray = this._disposeObjectsInArray;\n    that.callBase();\n    that.panes = null;\n\n    if (that._legend) {\n      that._legend.dispose();\n\n      that._legend = null;\n    }\n\n    disposeObjectsInArray.call(that, \"panesBackground\");\n    disposeObjectsInArray.call(that, \"seriesFamilies\");\n\n    that._disposeAxes();\n  },\n  _createPanes: function _createPanes() {\n    this._cleanPanesClipRects(\"fixed\");\n\n    this._cleanPanesClipRects(\"base\");\n\n    this._cleanPanesClipRects(\"wide\");\n  },\n  _cleanPanesClipRects: function _cleanPanesClipRects(clipArrayName) {\n    var clipArray = this._panesClipRects[clipArrayName];\n    (clipArray || []).forEach(function (clipRect) {\n      return clipRect && clipRect.dispose();\n    });\n    this._panesClipRects[clipArrayName] = [];\n  },\n  _getElementsClipRectID: function _getElementsClipRectID(paneName) {\n    var clipShape = this._panesClipRects.fixed[this._getPaneIndex(paneName)];\n\n    return clipShape && clipShape.id;\n  },\n  _getPaneIndex: function _getPaneIndex(paneName) {\n    var paneIndex;\n    var name = paneName || DEFAULT_PANE_NAME;\n\n    _each(this.panes, function (index, pane) {\n      if (pane.name === name) {\n        paneIndex = index;\n        return false;\n      }\n    });\n\n    return paneIndex;\n  },\n  _reinitAxes: function _reinitAxes() {\n    this.panes = this._createPanes();\n\n    this._populateAxes();\n\n    this._axesReinitialized = true;\n  },\n  _getCrosshairMargins: function _getCrosshairMargins() {\n    var crosshairOptions = this._getCrosshairOptions() || {};\n    var crosshairEnabled = crosshairOptions.enabled;\n    var margins = crosshairModule.getMargins();\n    return {\n      x: crosshairEnabled && crosshairOptions.horizontalLine.visible ? margins.x : 0,\n      y: crosshairEnabled && crosshairOptions.verticalLine.visible ? margins.y : 0\n    };\n  },\n  _populateAxes: function _populateAxes() {\n    var that = this;\n    var panes = that.panes;\n\n    var rotated = that._isRotated();\n\n    var argumentAxesOptions = prepareAxis(that.option(\"argumentAxis\") || {})[0];\n    var valueAxisOption = that.option(\"valueAxis\");\n    var valueAxesOptions = prepareAxis(valueAxisOption || {});\n    var argumentAxesPopulatedOptions = [];\n    var valueAxesPopulatedOptions = [];\n    var axisNames = [];\n    var valueAxesCounter = 0;\n    var paneWithNonVirtualAxis;\n\n    var crosshairMargins = that._getCrosshairMargins();\n\n    function getNextAxisName() {\n      return DEFAULT_AXIS_NAME + valueAxesCounter++;\n    }\n\n    if (rotated) {\n      paneWithNonVirtualAxis = \"right\" === argumentAxesOptions.position ? panes[panes.length - 1].name : panes[0].name;\n    } else {\n      paneWithNonVirtualAxis = \"top\" === argumentAxesOptions.position ? panes[0].name : panes[panes.length - 1].name;\n    }\n\n    argumentAxesPopulatedOptions = _map(panes, function (pane) {\n      var virtual = pane.name !== paneWithNonVirtualAxis;\n      return that._populateAxesOptions(\"argumentAxis\", argumentAxesOptions, {\n        pane: pane.name,\n        name: null,\n        optionPath: \"argumentAxis\",\n        crosshairMargin: rotated ? crosshairMargins.x : crosshairMargins.y\n      }, rotated, virtual);\n    });\n\n    _each(valueAxesOptions, function (priority, axisOptions) {\n      var axisPanes = [];\n      var name = axisOptions.name;\n\n      if (name && inArray(name, axisNames) !== -1) {\n        that._incidentOccurred(\"E2102\");\n\n        return;\n      }\n\n      name && axisNames.push(name);\n\n      if (axisOptions.pane) {\n        axisPanes.push(axisOptions.pane);\n      }\n\n      if (axisOptions.panes && axisOptions.panes.length) {\n        axisPanes = axisPanes.concat(axisOptions.panes.slice(0));\n      }\n\n      axisPanes = vizUtils.unique(axisPanes);\n\n      if (!axisPanes.length) {\n        axisPanes.push(void 0);\n      }\n\n      _each(axisPanes, function (_, pane) {\n        var optionPath = _isArray(valueAxisOption) ? \"valueAxis[\".concat(priority, \"]\") : \"valueAxis\";\n        valueAxesPopulatedOptions.push(that._populateAxesOptions(\"valueAxis\", axisOptions, {\n          name: name || getNextAxisName(),\n          pane: pane,\n          priority: priority,\n          optionPath: optionPath,\n          crosshairMargin: rotated ? crosshairMargins.y : crosshairMargins.x\n        }, rotated));\n      });\n    });\n\n    that._redesignAxes(argumentAxesPopulatedOptions, true, paneWithNonVirtualAxis);\n\n    that._redesignAxes(valueAxesPopulatedOptions, false);\n  },\n  _redesignAxes: function _redesignAxes(options, isArgumentAxes, paneWithNonVirtualAxis) {\n    var that = this;\n    var axesBasis = [];\n    var axes = isArgumentAxes ? that._argumentAxes : that._valueAxes;\n\n    _each(options, function (_, opt) {\n      var curAxes = axes && axes.filter(function (a) {\n        return a.name === opt.name && (!_isDefined(opt.pane) && that.panes.some(function (p) {\n          return p.name === a.pane;\n        }) || a.pane === opt.pane);\n      });\n\n      if (curAxes && curAxes.length > 0) {\n        _each(curAxes, function (_, axis) {\n          axis.updateOptions(opt);\n          axis.validate();\n          axesBasis.push({\n            axis: axis\n          });\n        });\n      } else {\n        axesBasis.push({\n          options: opt\n        });\n      }\n    });\n\n    if (axes) {\n      _reverseEach(axes, function (index, axis) {\n        if (!axesBasis.some(function (basis) {\n          return basis.axis && basis.axis === axis;\n        })) {\n          that._disposeAxis(index, isArgumentAxes);\n        }\n      });\n    } else {\n      if (isArgumentAxes) {\n        axes = that._argumentAxes = [];\n      } else {\n        axes = that._valueAxes = [];\n      }\n    }\n\n    _each(axesBasis, function (index, basis) {\n      var axis = basis.axis;\n\n      if (basis.axis && isArgumentAxes) {\n        basis.axis.isVirtual = basis.axis.pane !== paneWithNonVirtualAxis;\n      } else {\n        if (basis.options) {\n          axis = that._createAxis(isArgumentAxes, basis.options, isArgumentAxes ? basis.options.pane !== paneWithNonVirtualAxis : void 0, isArgumentAxes ? index : void 0);\n          axes.push(axis);\n        }\n      }\n\n      axis.applyVisualRangeSetter(that._getVisualRangeSetter());\n    });\n  },\n  _disposeAxis: function _disposeAxis(index, isArgumentAxis) {\n    var axes = isArgumentAxis ? this._argumentAxes : this._valueAxes;\n    var axis = axes[index];\n\n    if (!axis) {\n      return;\n    }\n\n    axis.dispose();\n    axes.splice(index, 1);\n  },\n  _disposeAxes: function _disposeAxes() {\n    var that = this;\n    var disposeObjectsInArray = that._disposeObjectsInArray;\n    disposeObjectsInArray.call(that, \"_argumentAxes\");\n    disposeObjectsInArray.call(that, \"_valueAxes\");\n  },\n  _appendAdditionalSeriesGroups: function _appendAdditionalSeriesGroups() {\n    this._crosshairCursorGroup.linkAppend();\n\n    this._scrollBar && this._scrollBarGroup.linkAppend();\n  },\n  _getLegendTargets: function _getLegendTargets() {\n    var _this = this;\n\n    return (this.series || []).map(function (s) {\n      var item = _this._getLegendOptions(s);\n\n      item.legendData.series = s;\n\n      if (!s.getOptions().showInLegend) {\n        item.legendData.visible = false;\n      }\n\n      return item;\n    });\n  },\n  _legendItemTextField: \"name\",\n  _seriesPopulatedHandlerCore: function _seriesPopulatedHandlerCore() {\n    this._processSeriesFamilies();\n\n    this._processValueAxisFormat();\n  },\n  _renderTrackers: function _renderTrackers() {\n    var that = this;\n    var i;\n\n    for (i = 0; i < that.series.length; ++i) {\n      that.series[i].drawTrackers();\n    }\n  },\n  _specialProcessSeries: function _specialProcessSeries() {\n    this._processSeriesFamilies();\n  },\n  _processSeriesFamilies: function _processSeriesFamilies() {\n    var that = this;\n    var types = [];\n    var families = [];\n    var paneSeries;\n    var themeManager = that._themeManager;\n    var negativesAsZeroes = themeManager.getOptions(\"negativesAsZeroes\");\n    var negativesAsZeros = themeManager.getOptions(\"negativesAsZeros\");\n    var familyOptions = {\n      equalBarWidth: themeManager.getOptions(\"equalBarWidth\"),\n      minBubbleSize: themeManager.getOptions(\"minBubbleSize\"),\n      maxBubbleSize: themeManager.getOptions(\"maxBubbleSize\"),\n      barWidth: themeManager.getOptions(\"barWidth\"),\n      barGroupPadding: themeManager.getOptions(\"barGroupPadding\"),\n      barGroupWidth: themeManager.getOptions(\"barGroupWidth\"),\n      negativesAsZeroes: _isDefined(negativesAsZeroes) ? negativesAsZeroes : negativesAsZeros\n    };\n\n    if (that.seriesFamilies && that.seriesFamilies.length) {\n      _each(that.seriesFamilies, function (_, family) {\n        family.updateOptions(familyOptions);\n        family.adjustSeriesValues();\n      });\n\n      return;\n    }\n\n    _each(that.series, function (_, item) {\n      if (inArray(item.type, types) === -1) {\n        types.push(item.type);\n      }\n    });\n\n    _each(that._getLayoutTargets(), function (_, pane) {\n      paneSeries = that._getSeriesForPane(pane.name);\n\n      _each(types, function (_, type) {\n        var family = new seriesFamilyModule.SeriesFamily({\n          type: type,\n          pane: pane.name,\n          equalBarWidth: familyOptions.equalBarWidth,\n          minBubbleSize: familyOptions.minBubbleSize,\n          maxBubbleSize: familyOptions.maxBubbleSize,\n          barWidth: familyOptions.barWidth,\n          barGroupPadding: familyOptions.barGroupPadding,\n          barGroupWidth: familyOptions.barGroupWidth,\n          negativesAsZeroes: familyOptions.negativesAsZeroes,\n          rotated: that._isRotated()\n        });\n        family.add(paneSeries);\n        family.adjustSeriesValues();\n        families.push(family);\n      });\n    });\n\n    that.seriesFamilies = families;\n  },\n  _updateSeriesDimensions: function _updateSeriesDimensions() {\n    var that = this;\n    var i;\n    var seriesFamilies = that.seriesFamilies || [];\n\n    for (i = 0; i < seriesFamilies.length; i++) {\n      var family = seriesFamilies[i];\n      family.updateSeriesValues();\n      family.adjustSeriesDimensions();\n    }\n  },\n  _getLegendCallBack: function _getLegendCallBack(series) {\n    return this._legend && this._legend.getActionCallback(series);\n  },\n  _appendAxesGroups: function _appendAxesGroups() {\n    var that = this;\n\n    that._stripsGroup.linkAppend();\n\n    that._gridGroup.linkAppend();\n\n    that._axesGroup.linkAppend();\n\n    that._constantLinesGroup.linkAppend();\n\n    that._labelAxesGroup.linkAppend();\n\n    that._scaleBreaksGroup.linkAppend();\n  },\n  _populateMarginOptions: function _populateMarginOptions() {\n    var that = this;\n    var bubbleSize = estimateBubbleSize(that.getSize(), that.panes.length, that._themeManager.getOptions(\"maxBubbleSize\"), that._isRotated());\n    var argumentMarginOptions = {};\n\n    that._valueAxes.forEach(function (valueAxis) {\n      var groupSeries = that.series.filter(function (series) {\n        return series.getValueAxis() === valueAxis;\n      });\n      var marginOptions = {};\n      groupSeries.forEach(function (series) {\n        if (series.isVisible()) {\n          var seriesMarginOptions = processBubbleMargin(series.getMarginOptions(), bubbleSize);\n          marginOptions = mergeMarginOptions(marginOptions, seriesMarginOptions);\n          argumentMarginOptions = mergeMarginOptions(argumentMarginOptions, seriesMarginOptions);\n        }\n      });\n      valueAxis.setMarginOptions(marginOptions);\n    });\n\n    that._argumentAxes.forEach(function (a) {\n      return a.setMarginOptions(argumentMarginOptions);\n    });\n  },\n  _populateBusinessRange: function _populateBusinessRange(updatedAxis, keepRange) {\n    var that = this;\n\n    var rotated = that._isRotated();\n\n    var argRange = new rangeModule.Range({\n      rotated: !!rotated\n    });\n\n    var series = that._getVisibleSeries();\n\n    that._valueAxes.forEach(function (valueAxis) {\n      var groupRange = new rangeModule.Range({\n        rotated: !!rotated,\n        pane: valueAxis.pane,\n        axis: valueAxis.name\n      });\n      var groupSeries = series.filter(function (series) {\n        return series.getValueAxis() === valueAxis;\n      });\n      groupSeries.forEach(function (series) {\n        var seriesRange = series.getRangeData();\n        groupRange.addRange(seriesRange.val);\n        argRange.addRange(seriesRange.arg);\n      });\n\n      if (!updatedAxis || updatedAxis && groupSeries.length && valueAxis === updatedAxis) {\n        valueAxis.setGroupSeries(groupSeries);\n        valueAxis.setBusinessRange(groupRange, that._axesReinitialized || keepRange, that._argumentAxes[0]._lastVisualRangeUpdateMode);\n      }\n    });\n\n    if (!updatedAxis || updatedAxis && series.length) {\n      that._argumentAxes.forEach(function (a) {\n        return a.setBusinessRange(argRange, that._axesReinitialized, void 0, that._groupsData.categories);\n      });\n    }\n\n    that._populateMarginOptions();\n  },\n  getArgumentAxis: function getArgumentAxis() {\n    return (this._argumentAxes || []).filter(function (a) {\n      return !a.isVirtual;\n    })[0];\n  },\n  getValueAxis: function getValueAxis(name) {\n    var _this2 = this;\n\n    return (this._valueAxes || []).filter(_isDefined(name) ? function (a) {\n      return a.name === name;\n    } : function (a) {\n      return a.pane === _this2.defaultPane;\n    })[0];\n  },\n  _getGroupsData: function _getGroupsData() {\n    var that = this;\n    var groups = [];\n\n    that._valueAxes.forEach(function (axis) {\n      groups.push({\n        series: that.series.filter(function (series) {\n          return series.getValueAxis() === axis;\n        }),\n        valueAxis: axis,\n        valueOptions: axis.getOptions()\n      });\n    });\n\n    return {\n      groups: groups,\n      argumentAxes: that._argumentAxes,\n      argumentOptions: that._argumentAxes[0].getOptions()\n    };\n  },\n  _groupSeries: function _groupSeries() {\n    var that = this;\n\n    that._correctValueAxes(false);\n\n    that._groupsData = that._getGroupsData();\n  },\n  _processValueAxisFormat: function _processValueAxisFormat() {\n    var axesWithFullStackedFormat = [];\n    this.series.forEach(function (series) {\n      var axis = series.getValueAxis();\n\n      if (series.isFullStackedSeries()) {\n        axis.setPercentLabelFormat();\n        axesWithFullStackedFormat.push(axis);\n      }\n    });\n\n    this._valueAxes.forEach(function (axis) {\n      if (axesWithFullStackedFormat.indexOf(axis) === -1) {\n        axis.resetAutoLabelFormat();\n      }\n    });\n  },\n  _populateAxesOptions: function _populateAxesOptions(typeSelector, userOptions, axisOptions, rotated, virtual) {\n    var that = this;\n\n    var preparedUserOptions = that._prepareStripsAndConstantLines(typeSelector, userOptions, rotated);\n\n    var options = _extend(true, {}, preparedUserOptions, axisOptions, that._prepareAxisOptions(typeSelector, preparedUserOptions, rotated));\n\n    if (virtual) {\n      options.visible = options.tick.visible = options.minorTick.visible = options.label.visible = false;\n      options.title = {};\n    }\n\n    return options;\n  },\n  _createAxis: function _createAxis(isArgumentAxes, options, virtual, index) {\n    var that = this;\n    var typeSelector = isArgumentAxes ? \"argumentAxis\" : \"valueAxis\";\n\n    var renderingSettings = _extend({\n      renderer: that._renderer,\n      incidentOccurred: that._incidentOccurred,\n      eventTrigger: that._eventTrigger,\n      axisClass: isArgumentAxes ? \"arg\" : \"val\",\n      widgetClass: \"dxc\",\n      stripsGroup: that._stripsGroup,\n      labelAxesGroup: that._labelAxesGroup,\n      constantLinesGroup: that._constantLinesGroup,\n      scaleBreaksGroup: that._scaleBreaksGroup,\n      axesContainerGroup: that._axesGroup,\n      gridGroup: that._gridGroup,\n      isArgumentAxis: isArgumentAxes\n    }, that._getAxisRenderingOptions(typeSelector));\n\n    var axis = new axisModule.Axis(renderingSettings);\n    axis.updateOptions(options);\n    axis.isVirtual = virtual;\n    return axis;\n  },\n  _applyVisualRangeByVirtualAxes: function _applyVisualRangeByVirtualAxes(axis, range) {\n    return false;\n  },\n  _applyCustomVisualRangeOption: function _applyCustomVisualRangeOption(axis, range) {\n    var that = this;\n\n    if (axis.getOptions().optionPath) {\n      that._parseVisualRangeOption(\"\".concat(axis.getOptions().optionPath, \".visualRange\"), range);\n    }\n  },\n  _getVisualRangeSetter: function _getVisualRangeSetter() {\n    var chart = this;\n    return function (axis, _ref) {\n      var skipEventRising = _ref.skipEventRising,\n          range = _ref.range;\n\n      chart._applyCustomVisualRangeOption(axis, range);\n\n      axis.setCustomVisualRange(range);\n      axis.skipEventRising = skipEventRising;\n\n      if (!chart._applyVisualRangeByVirtualAxes(axis, range)) {\n        if (chart._applyingChanges) {\n          chart._change_VISUAL_RANGE();\n        } else {\n          chart._requestChange([VISUAL_RANGE]);\n        }\n      }\n    };\n  },\n  _getTrackerSettings: function _getTrackerSettings() {\n    return _extend(this.callBase(), {\n      argumentAxis: this.getArgumentAxis()\n    });\n  },\n  _prepareStripsAndConstantLines: function _prepareStripsAndConstantLines(typeSelector, userOptions, rotated) {\n    userOptions = this._themeManager.getOptions(typeSelector, userOptions, rotated);\n\n    if (userOptions.strips) {\n      _each(userOptions.strips, function (i) {\n        userOptions.strips[i] = _extend(true, {}, userOptions.stripStyle, userOptions.strips[i]);\n      });\n    }\n\n    if (userOptions.constantLines) {\n      _each(userOptions.constantLines, function (i, line) {\n        userOptions.constantLines[i] = _extend(true, {}, userOptions.constantLineStyle, line);\n      });\n    }\n\n    return userOptions;\n  },\n  refresh: function refresh() {\n    this._disposeAxes();\n\n    this.callBase();\n  },\n  _layoutAxes: function _layoutAxes(drawAxes) {\n    var that = this;\n    var cleanPanesCanvases = drawAxes();\n    var needSpace = that.checkForMoreSpaceForPanesCanvas();\n\n    if (needSpace) {\n      var size = this._layout.backward(this._rect, this._rect, [needSpace.width, needSpace.height]);\n\n      needSpace.width = Math.max(0, size[0]);\n      needSpace.height = Math.max(0, size[1]);\n      this._canvas = this._createCanvasFromRect(this._rect);\n      drawAxes(needSpace, cleanPanesCanvases);\n    }\n  },\n  checkForMoreSpaceForPanesCanvas: function checkForMoreSpaceForPanesCanvas() {\n    return this.layoutManager.needMoreSpaceForPanesCanvas(this._getLayoutTargets(), this._isRotated());\n  },\n  _parseVisualRangeOption: function _parseVisualRangeOption(fullName, value) {\n    var that = this;\n    var name = fullName.split(/[.[]/)[0];\n    var index = fullName.match(/\\d+/g);\n    index = _isDefined(index) ? parseInt(index[0]) : index;\n\n    if (fullName.indexOf(\"visualRange\") > 0) {\n      that._setCustomVisualRange(name, index, value);\n    } else {\n      if ((\"object\" === type(value) || _isArray(value)) && name.indexOf(\"Axis\") > 0 && JSON.stringify(value).indexOf(\"visualRange\") > 0) {\n        if (_isDefined(value.visualRange)) {\n          that._setCustomVisualRange(name, index, value.visualRange);\n        } else {\n          if (_isArray(value)) {\n            value.forEach(function (a, i) {\n              return _isDefined(a.visualRange) && that._setCustomVisualRange(name, i, a.visualRange);\n            });\n          }\n        }\n      }\n    }\n  },\n  _setCustomVisualRange: function _setCustomVisualRange(axesName, index, value) {\n    var that = this;\n    var options = that._options[axesName];\n\n    if (!options) {\n      return;\n    }\n\n    if (!_isDefined(index)) {\n      options._customVisualRange = value;\n    } else {\n      options[index]._customVisualRange = value;\n    }\n\n    that._axesReinitialized = true;\n  },\n  _raiseZoomEndHandlers: function _raiseZoomEndHandlers() {\n    this._valueAxes.forEach(function (axis) {\n      return axis.handleZoomEnd();\n    });\n  },\n  _setOptionsByReference: function _setOptionsByReference() {\n    this.callBase();\n\n    _extend(this._optionsByReference, {\n      \"valueAxis.visualRange\": true\n    });\n  },\n  _notifyOptionChanged: function _notifyOptionChanged(option, value, previousValue) {\n    this.callBase.apply(this, arguments);\n\n    if (!this._optionChangedLocker) {\n      this._parseVisualRangeOption(option, value);\n    }\n  },\n  _notifyVisualRange: function _notifyVisualRange() {\n    var that = this;\n\n    that._valueAxes.forEach(function (axis) {\n      if (axis.getOptions().optionPath) {\n        var path = \"\".concat(axis.getOptions().optionPath, \".visualRange\");\n        var visualRange = convertVisualRangeObject(axis.visualRange(), !_isArray(that.option(path)));\n\n        if (!axis.skipEventRising || !rangesAreEqual(visualRange, that.option(path))) {\n          that.option(path, visualRange);\n        } else {\n          axis.skipEventRising = null;\n        }\n      }\n    });\n  },\n  _notify: function _notify() {\n    this.callBase();\n    this._axesReinitialized = false;\n\n    if (true !== this.option(\"disableTwoWayBinding\")) {\n      this._notifyVisualRange();\n    }\n  },\n  _getAxesForScaling: function _getAxesForScaling() {\n    return this._valueAxes;\n  },\n  _getAxesByOptionPath: function _getAxesByOptionPath(arg, isDirectOption, optionName) {\n    var that = this;\n\n    var sourceAxes = that._getAxesForScaling();\n\n    var axes = [];\n\n    if (isDirectOption) {\n      var axisPath;\n\n      if (arg.fullName) {\n        axisPath = arg.fullName.slice(0, arg.fullName.indexOf(\".\"));\n      }\n\n      axes = sourceAxes.filter(function (a) {\n        return a.getOptions().optionPath === axisPath;\n      });\n    } else {\n      if (\"object\" === type(arg.value)) {\n        axes = sourceAxes.filter(function (a) {\n          return a.getOptions().optionPath === arg.name;\n        });\n      } else {\n        if (_isArray(arg.value)) {\n          arg.value.forEach(function (v, index) {\n            var axis = sourceAxes.filter(function (a) {\n              return a.getOptions().optionPath === \"\".concat(arg.name, \"[\").concat(index, \"]\");\n            })[0];\n            _isDefined(v[optionName]) && _isDefined(axis) && (axes[index] = axis);\n          });\n        }\n      }\n    }\n\n    return axes;\n  },\n  _optionChanged: function _optionChanged(arg) {\n    var that = this;\n\n    if (!that._optionChangedLocker) {\n      var optionName = \"visualRange\";\n      var axes;\n      var isDirectOption = arg.fullName.indexOf(optionName) > 0 ? true : that.getPartialChangeOptionsName(arg).indexOf(optionName) > -1 ? false : void 0;\n\n      if (_isDefined(isDirectOption)) {\n        axes = that._getAxesByOptionPath(arg, isDirectOption, optionName);\n\n        if (axes) {\n          if (axes.length > 1 || _isArray(arg.value)) {\n            axes.forEach(function (a, index) {\n              return setAxisVisualRangeByOption(arg, a, isDirectOption, index);\n            });\n          } else {\n            if (1 === axes.length) {\n              setAxisVisualRangeByOption(arg, axes[0], isDirectOption);\n            }\n          }\n        }\n      }\n    }\n\n    that.callBase(arg);\n  },\n  _change_VISUAL_RANGE: function _change_VISUAL_RANGE() {\n    var that = this;\n\n    that._recreateSizeDependentObjects(false);\n\n    if (!that._changes.has(\"FULL_RENDER\")) {\n      var resizePanesOnZoom = this.option(\"resizePanesOnZoom\");\n\n      that._doRender({\n        force: true,\n        drawTitle: false,\n        drawLegend: false,\n        adjustAxes: _isDefined(resizePanesOnZoom) ? resizePanesOnZoom : this.option(\"adjustAxesOnZoom\") || false,\n        animate: false\n      });\n\n      that._raiseZoomEndHandlers();\n    }\n  },\n  resetVisualRange: function resetVisualRange() {\n    var that = this;\n\n    that._valueAxes.forEach(function (axis) {\n      axis.resetVisualRange(false);\n\n      that._applyCustomVisualRangeOption(axis);\n    });\n\n    that._requestChange([VISUAL_RANGE]);\n  },\n  _legendDataField: \"series\",\n  _adjustSeriesLabels: _noop,\n  _correctValueAxes: _noop\n});\nexports.AdvancedChart = AdvancedChart;","map":null,"metadata":{},"sourceType":"script"}