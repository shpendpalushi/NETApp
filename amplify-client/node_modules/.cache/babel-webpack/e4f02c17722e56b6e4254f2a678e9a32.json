{"ast":null,"code":"/**\r\n * DevExtreme (viz/sparklines/sparkline.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar BaseSparkline = require(\"./base_sparkline\");\n\nvar dataValidatorModule = require(\"../components/data_validator\");\n\nvar seriesModule = require(\"../series/base_series\");\n\nvar MIN_BAR_WIDTH = 1;\nvar MAX_BAR_WIDTH = 50;\nvar DEFAULT_BAR_INTERVAL = 4;\nvar DEFAULT_CANVAS_WIDTH = 250;\nvar DEFAULT_CANVAS_HEIGHT = 30;\nvar DEFAULT_POINT_BORDER = 2;\nvar ALLOWED_TYPES = {\n  line: true,\n  spline: true,\n  stepline: true,\n  area: true,\n  steparea: true,\n  splinearea: true,\n  bar: true,\n  winloss: true\n};\nvar _math = Math;\nvar _abs = _math.abs;\nvar _round = _math.round;\nvar _max = _math.max;\nvar _min = _math.min;\nvar _isFinite = isFinite;\n\nvar vizUtils = require(\"../core/utils\");\n\nvar _map = vizUtils.map;\nvar _normalizeEnum = vizUtils.normalizeEnum;\n\nvar _isDefined = require(\"../../core/utils/type\").isDefined;\n\nvar _Number = Number;\nvar _String = String;\n\nfunction findMinMax(data, valField) {\n  var firstItem = data[0] || {};\n  var firstValue = firstItem[valField] || 0;\n  var min = firstValue;\n  var max = firstValue;\n  var minIndexes = [0];\n  var maxIndexes = [0];\n  var dataLength = data.length;\n  var value;\n  var i;\n\n  for (i = 1; i < dataLength; i++) {\n    value = data[i][valField];\n\n    if (value < min) {\n      min = value;\n      minIndexes = [i];\n    } else {\n      if (value === min) {\n        minIndexes.push(i);\n      }\n    }\n\n    if (value > max) {\n      max = value;\n      maxIndexes = [i];\n    } else {\n      if (value === max) {\n        maxIndexes.push(i);\n      }\n    }\n  }\n\n  if (max === min) {\n    minIndexes = maxIndexes = [];\n  }\n\n  return {\n    minIndexes: minIndexes,\n    maxIndexes: maxIndexes\n  };\n}\n\nfunction parseNumericDataSource(data, argField, valField, ignoreEmptyPoints) {\n  return _map(data, function (dataItem, index) {\n    var item = null;\n    var isDataNumber;\n    var value;\n\n    if (void 0 !== dataItem) {\n      item = {};\n      isDataNumber = _isFinite(dataItem);\n      item[argField] = isDataNumber ? _String(index) : dataItem[argField];\n      value = isDataNumber ? dataItem : dataItem[valField];\n      item[valField] = null === value ? ignoreEmptyPoints ? void 0 : value : _Number(value);\n      item = void 0 !== item[argField] && void 0 !== item[valField] ? item : null;\n    }\n\n    return item;\n  });\n}\n\nfunction parseWinlossDataSource(data, argField, valField, target) {\n  var lowBarValue = -1;\n  var zeroBarValue = 0;\n  var highBarValue = 1;\n  var delta = 1e-4;\n  return _map(data, function (dataItem) {\n    var item = {};\n    item[argField] = dataItem[argField];\n\n    if (_abs(dataItem[valField] - target) < delta) {\n      item[valField] = zeroBarValue;\n    } else {\n      if (dataItem[valField] > target) {\n        item[valField] = highBarValue;\n      } else {\n        item[valField] = lowBarValue;\n      }\n    }\n\n    return item;\n  });\n}\n\nfunction selectPointColor(color, options, index, pointIndexes) {\n  if (index === pointIndexes.first || index === pointIndexes.last) {\n    color = options.firstLastColor;\n  }\n\n  if ((pointIndexes.min || []).indexOf(index) >= 0) {\n    color = options.minColor;\n  }\n\n  if ((pointIndexes.max || []).indexOf(index) >= 0) {\n    color = options.maxColor;\n  }\n\n  return color;\n}\n\nfunction createLineCustomizeFunction(pointIndexes, options) {\n  return function () {\n    var color = selectPointColor(void 0, options, this.index, pointIndexes);\n    return color ? {\n      visible: true,\n      border: {\n        color: color\n      }\n    } : {};\n  };\n}\n\nfunction createBarCustomizeFunction(pointIndexes, options, winlossData) {\n  return function () {\n    var index = this.index;\n    var isWinloss = \"winloss\" === options.type;\n    var target = isWinloss ? options.winlossThreshold : 0;\n    var value = isWinloss ? winlossData[index][options.valueField] : this.value;\n    var positiveColor = isWinloss ? options.winColor : options.barPositiveColor;\n    var negativeColor = isWinloss ? options.lossColor : options.barNegativeColor;\n    return {\n      color: selectPointColor(value >= target ? positiveColor : negativeColor, options, index, pointIndexes)\n    };\n  };\n}\n\nvar dxSparkline = BaseSparkline.inherit({\n  _rootClassPrefix: \"dxsl\",\n  _rootClass: \"dxsl-sparkline\",\n  _themeSection: \"sparkline\",\n  _defaultSize: {\n    width: DEFAULT_CANVAS_WIDTH,\n    height: DEFAULT_CANVAS_HEIGHT\n  },\n  _initCore: function _initCore() {\n    this.callBase();\n\n    this._createSeries();\n  },\n  _initialChanges: [\"DATA_SOURCE\"],\n  _dataSourceChangedHandler: function _dataSourceChangedHandler() {\n    this._requestChange([\"UPDATE\"]);\n  },\n  _updateWidgetElements: function _updateWidgetElements() {\n    this._updateSeries();\n\n    this.callBase();\n  },\n  _disposeWidgetElements: function _disposeWidgetElements() {\n    var that = this;\n    that._series && that._series.dispose();\n    that._series = that._seriesGroup = that._seriesLabelGroup = null;\n  },\n  _cleanWidgetElements: function _cleanWidgetElements() {\n    this._seriesGroup.remove();\n\n    this._seriesLabelGroup.remove();\n\n    this._seriesGroup.clear();\n\n    this._seriesLabelGroup.clear();\n  },\n  _drawWidgetElements: function _drawWidgetElements() {\n    if (this._dataIsLoaded()) {\n      this._drawSeries();\n\n      this._drawn();\n    }\n  },\n  _getCorrectCanvas: function _getCorrectCanvas() {\n    var options = this._allOptions;\n    var canvas = this._canvas;\n    var halfPointSize = options.pointSize && Math.ceil(options.pointSize / 2) + DEFAULT_POINT_BORDER;\n    var type = options.type;\n\n    if (\"bar\" !== type && \"winloss\" !== type && (options.showFirstLast || options.showMinMax)) {\n      return {\n        width: canvas.width,\n        height: canvas.height,\n        left: canvas.left + halfPointSize,\n        right: canvas.right + halfPointSize,\n        top: canvas.top + halfPointSize,\n        bottom: canvas.bottom + halfPointSize\n      };\n    }\n\n    return canvas;\n  },\n  _prepareOptions: function _prepareOptions() {\n    var that = this;\n    that._allOptions = that.callBase();\n    that._allOptions.type = _normalizeEnum(that._allOptions.type);\n\n    if (!ALLOWED_TYPES[that._allOptions.type]) {\n      that._allOptions.type = \"line\";\n    }\n  },\n  _createHtmlElements: function _createHtmlElements() {\n    this._seriesGroup = this._renderer.g().attr({\n      \"class\": \"dxsl-series\"\n    });\n    this._seriesLabelGroup = this._renderer.g().attr({\n      \"class\": \"dxsl-series-labels\"\n    });\n  },\n  _createSeries: function _createSeries() {\n    this._series = new seriesModule.Series({\n      renderer: this._renderer,\n      seriesGroup: this._seriesGroup,\n      labelsGroup: this._seriesLabelGroup,\n      argumentAxis: this._argumentAxis,\n      valueAxis: this._valueAxis\n    }, {\n      widgetType: \"chart\",\n      type: \"line\"\n    });\n  },\n  _updateSeries: function _updateSeries() {\n    var that = this;\n    var groupsData;\n    var seriesOptions;\n    var singleSeries = that._series;\n\n    that._prepareDataSource();\n\n    seriesOptions = that._prepareSeriesOptions();\n    singleSeries.updateOptions(seriesOptions);\n    groupsData = {\n      groups: [{\n        series: [singleSeries]\n      }]\n    };\n    groupsData.argumentOptions = {\n      type: \"bar\" === seriesOptions.type ? \"discrete\" : void 0\n    };\n    that._simpleDataSource = dataValidatorModule.validateData(that._simpleDataSource, groupsData, that._incidentOccurred, {\n      checkTypeForAllData: false,\n      convertToAxisDataType: true,\n      sortingMethod: true\n    })[singleSeries.getArgumentField()];\n    seriesOptions.customizePoint = that._getCustomizeFunction();\n    singleSeries.updateData(that._simpleDataSource);\n    singleSeries.createPoints();\n    that._groupsDataCategories = groupsData.categories;\n  },\n  _optionChangesMap: {\n    dataSource: \"DATA_SOURCE\"\n  },\n  _optionChangesOrder: [\"DATA_SOURCE\"],\n  _change_DATA_SOURCE: function _change_DATA_SOURCE() {\n    this._updateDataSource();\n  },\n  _prepareDataSource: function _prepareDataSource() {\n    var that = this;\n    var options = that._allOptions;\n    var argField = options.argumentField;\n    var valField = options.valueField;\n    var dataSource = that._dataSourceItems() || [];\n    var data = parseNumericDataSource(dataSource, argField, valField, that.option(\"ignoreEmptyPoints\"));\n\n    if (\"winloss\" === options.type) {\n      that._winlossDataSource = data;\n      that._simpleDataSource = parseWinlossDataSource(data, argField, valField, options.winlossThreshold);\n    } else {\n      that._simpleDataSource = data;\n    }\n  },\n  _prepareSeriesOptions: function _prepareSeriesOptions() {\n    var that = this;\n    var options = that._allOptions;\n    var type = \"winloss\" === options.type ? \"bar\" : options.type;\n    return {\n      visible: true,\n      argumentField: options.argumentField,\n      valueField: options.valueField,\n      color: options.lineColor,\n      width: options.lineWidth,\n      widgetType: \"chart\",\n      type: type,\n      opacity: type.indexOf(\"area\") !== -1 ? that._allOptions.areaOpacity : void 0,\n      point: {\n        size: options.pointSize,\n        symbol: options.pointSymbol,\n        border: {\n          visible: true,\n          width: DEFAULT_POINT_BORDER\n        },\n        color: options.pointColor,\n        visible: false,\n        hoverStyle: {\n          border: {}\n        },\n        selectionStyle: {\n          border: {}\n        }\n      },\n      border: {\n        color: options.lineColor,\n        width: options.lineWidth,\n        visible: \"bar\" !== type\n      }\n    };\n  },\n  _getCustomizeFunction: function _getCustomizeFunction() {\n    var that = this;\n    var options = that._allOptions;\n    var dataSource = that._winlossDataSource || that._simpleDataSource;\n\n    var drawnPointIndexes = that._getExtremumPointsIndexes(dataSource);\n\n    var customizeFunction;\n\n    if (\"winloss\" === options.type || \"bar\" === options.type) {\n      customizeFunction = createBarCustomizeFunction(drawnPointIndexes, options, that._winlossDataSource);\n    } else {\n      customizeFunction = createLineCustomizeFunction(drawnPointIndexes, options);\n    }\n\n    return customizeFunction;\n  },\n  _getExtremumPointsIndexes: function _getExtremumPointsIndexes(data) {\n    var that = this;\n    var options = that._allOptions;\n    var lastIndex = data.length - 1;\n    var indexes = {};\n    that._minMaxIndexes = findMinMax(data, options.valueField);\n\n    if (options.showFirstLast) {\n      indexes.first = 0;\n      indexes.last = lastIndex;\n    }\n\n    if (options.showMinMax) {\n      indexes.min = that._minMaxIndexes.minIndexes;\n      indexes.max = that._minMaxIndexes.maxIndexes;\n    }\n\n    return indexes;\n  },\n  _getStick: function _getStick() {\n    return {\n      stick: \"bar\" !== this._series.type\n    };\n  },\n  _updateRange: function _updateRange() {\n    var that = this;\n    var series = that._series;\n    var type = series.type;\n    var isBarType = \"bar\" === type;\n    var isWinlossType = \"winloss\" === type;\n    var DEFAULT_VALUE_RANGE_MARGIN = .15;\n    var DEFAULT_ARGUMENT_RANGE_MARGIN = .1;\n    var WINLOSS_MAX_RANGE = 1;\n    var WINLOSS_MIN_RANGE = -1;\n    var rangeData = series.getRangeData();\n    var minValue = that._allOptions.minValue;\n\n    var hasMinY = _isDefined(minValue) && _isFinite(minValue);\n\n    var maxValue = that._allOptions.maxValue;\n\n    var hasMaxY = _isDefined(maxValue) && _isFinite(maxValue);\n\n    var valCoef;\n    var argCoef;\n    valCoef = (rangeData.val.max - rangeData.val.min) * DEFAULT_VALUE_RANGE_MARGIN;\n\n    if (isBarType || isWinlossType || \"area\" === type) {\n      if (0 !== rangeData.val.min) {\n        rangeData.val.min -= valCoef;\n      }\n\n      if (0 !== rangeData.val.max) {\n        rangeData.val.max += valCoef;\n      }\n    } else {\n      rangeData.val.min -= valCoef;\n      rangeData.val.max += valCoef;\n    }\n\n    if (hasMinY || hasMaxY) {\n      if (hasMinY && hasMaxY) {\n        rangeData.val.minVisible = _min(minValue, maxValue);\n        rangeData.val.maxVisible = _max(minValue, maxValue);\n      } else {\n        rangeData.val.minVisible = hasMinY ? _Number(minValue) : void 0;\n        rangeData.val.maxVisible = hasMaxY ? _Number(maxValue) : void 0;\n      }\n\n      if (isWinlossType) {\n        rangeData.val.minVisible = hasMinY ? _max(rangeData.val.minVisible, WINLOSS_MIN_RANGE) : void 0;\n        rangeData.val.maxVisible = hasMaxY ? _min(rangeData.val.maxVisible, WINLOSS_MAX_RANGE) : void 0;\n      }\n    }\n\n    if (series.getPoints().length > 1) {\n      if (isBarType) {\n        argCoef = (rangeData.arg.max - rangeData.arg.min) * DEFAULT_ARGUMENT_RANGE_MARGIN;\n        rangeData.arg.min = rangeData.arg.min - argCoef;\n        rangeData.arg.max = rangeData.arg.max + argCoef;\n      }\n    }\n\n    rangeData.arg.categories = that._groupsDataCategories;\n    that._ranges = rangeData;\n  },\n  _getBarWidth: function _getBarWidth(pointsCount) {\n    var that = this;\n    var canvas = that._canvas;\n    var intervalWidth = pointsCount * DEFAULT_BAR_INTERVAL;\n    var rangeWidth = canvas.width - canvas.left - canvas.right - intervalWidth;\n\n    var width = _round(rangeWidth / pointsCount);\n\n    if (width < MIN_BAR_WIDTH) {\n      width = MIN_BAR_WIDTH;\n    }\n\n    if (width > MAX_BAR_WIDTH) {\n      width = MAX_BAR_WIDTH;\n    }\n\n    return width;\n  },\n  _correctPoints: function _correctPoints() {\n    var that = this;\n    var seriesType = that._allOptions.type;\n\n    var seriesPoints = that._series.getPoints();\n\n    var pointsLength = seriesPoints.length;\n    var barWidth;\n    var i;\n\n    if (\"bar\" === seriesType || \"winloss\" === seriesType) {\n      barWidth = that._getBarWidth(pointsLength);\n\n      for (i = 0; i < pointsLength; i++) {\n        seriesPoints[i].correctCoordinates({\n          width: barWidth,\n          offset: 0\n        });\n      }\n    }\n  },\n  _drawSeries: function _drawSeries() {\n    var that = this;\n\n    if (that._simpleDataSource.length > 0) {\n      that._correctPoints();\n\n      that._series.draw();\n\n      that._seriesGroup.append(that._renderer.root);\n    }\n  },\n  _isTooltipEnabled: function _isTooltipEnabled() {\n    return !!this._simpleDataSource.length;\n  },\n  _getTooltipData: function _getTooltipData() {\n    var that = this;\n    var options = that._allOptions;\n    var dataSource = that._winlossDataSource || that._simpleDataSource;\n    var tooltip = that._tooltip;\n\n    if (0 === dataSource.length) {\n      return {};\n    }\n\n    var minMax = that._minMaxIndexes;\n    var valueField = options.valueField;\n    var first = dataSource[0][valueField];\n    var last = dataSource[dataSource.length - 1][valueField];\n    var min = _isDefined(minMax.minIndexes[0]) ? dataSource[minMax.minIndexes[0]][valueField] : first;\n    var max = _isDefined(minMax.maxIndexes[0]) ? dataSource[minMax.maxIndexes[0]][valueField] : first;\n    var formattedFirst = tooltip.formatValue(first);\n    var formattedLast = tooltip.formatValue(last);\n    var formattedMin = tooltip.formatValue(min);\n    var formattedMax = tooltip.formatValue(max);\n    var customizeObject = {\n      firstValue: formattedFirst,\n      lastValue: formattedLast,\n      minValue: formattedMin,\n      maxValue: formattedMax,\n      originalFirstValue: first,\n      originalLastValue: last,\n      originalMinValue: min,\n      originalMaxValue: max,\n      valueText: [\"Start:\", formattedFirst, \"End:\", formattedLast, \"Min:\", formattedMin, \"Max:\", formattedMax]\n    };\n\n    if (\"winloss\" === options.type) {\n      customizeObject.originalThresholdValue = options.winlossThreshold;\n      customizeObject.thresholdValue = tooltip.formatValue(options.winlossThreshold);\n    }\n\n    return customizeObject;\n  }\n});\n\n_map([\"lineColor\", \"lineWidth\", \"areaOpacity\", \"minColor\", \"maxColor\", \"barPositiveColor\", \"barNegativeColor\", \"winColor\", \"lessColor\", \"firstLastColor\", \"pointSymbol\", \"pointColor\", \"pointSize\", \"type\", \"argumentField\", \"valueField\", \"winlossThreshold\", \"showFirstLast\", \"showMinMax\", \"ignoreEmptyPoints\", \"minValue\", \"maxValue\"], function (name) {\n  dxSparkline.prototype._optionChangesMap[name] = \"OPTIONS\";\n});\n\nrequire(\"../../core/component_registrator\")(\"dxSparkline\", dxSparkline);\n\nmodule.exports = dxSparkline;\ndxSparkline.addPlugin(require(\"../core/data_source\").plugin);","map":null,"metadata":{},"sourceType":"script"}