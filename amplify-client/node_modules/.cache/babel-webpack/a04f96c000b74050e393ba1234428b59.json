{"ast":null,"code":"/**\r\n * DevExtreme (viz/gauges/linear_gauge.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _each = require(\"../../core/utils/iterator\").each;\n\nvar _max = Math.max;\nvar _min = Math.min;\nvar _round = Math.round;\n\nvar registerComponent = require(\"../../core/component_registrator\");\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar objectUtils = require(\"../../core/utils/object\");\n\nvar dxBaseGauge = require(\"./base_gauge\").dxBaseGauge;\n\nvar dxGauge = require(\"./common\").dxGauge;\n\nvar _normalizeEnum = require(\"../core/utils\").normalizeEnum;\n\nvar linearIndicatorsModule = require(\"./linear_indicators\");\n\nvar createIndicatorCreator = require(\"./common\").createIndicatorCreator;\n\nvar LinearRangeContainer = require(\"./linear_range_container\");\n\nvar dxLinearGauge = dxGauge.inherit({\n  _rootClass: \"dxg-linear-gauge\",\n  _factoryMethods: {\n    rangeContainer: \"createLinearRangeContainer\",\n    indicator: \"createLinearIndicator\"\n  },\n  _gridSpacingFactor: 25,\n  _scaleTypes: {\n    type: \"xyAxes\",\n    drawingType: \"linear\"\n  },\n  _getTicksOrientation: function _getTicksOrientation(scaleOptions) {\n    return scaleOptions.isHorizontal ? scaleOptions.verticalOrientation : scaleOptions.horizontalOrientation;\n  },\n  _getThemeManagerOptions: function _getThemeManagerOptions() {\n    var options = this.callBase.apply(this, arguments);\n    options.subTheme = \"_linear\";\n    return options;\n  },\n  _updateScaleTickIndent: function _updateScaleTickIndent(scaleOptions) {\n    var indentFromTick = scaleOptions.label.indentFromTick;\n    var length = scaleOptions.tick.length;\n\n    var textParams = this._scale.measureLabels(extend({}, this._canvas));\n\n    var verticalTextCorrection = scaleOptions.isHorizontal ? textParams.height + textParams.y : 0;\n    var isIndentPositive = indentFromTick > 0;\n    var orientation;\n    var textCorrection;\n    var tickCorrection;\n\n    if (scaleOptions.isHorizontal) {\n      orientation = isIndentPositive ? {\n        center: .5,\n        top: 0,\n        bottom: 1\n      } : {\n        center: .5,\n        top: 1,\n        bottom: 0\n      };\n      tickCorrection = length * orientation[scaleOptions.verticalOrientation];\n      textCorrection = textParams.y;\n    } else {\n      orientation = isIndentPositive ? {\n        center: .5,\n        left: 0,\n        right: 1\n      } : {\n        center: .5,\n        left: 1,\n        right: 0\n      };\n      tickCorrection = length * orientation[scaleOptions.horizontalOrientation];\n      textCorrection = -textParams.width;\n    }\n\n    scaleOptions.label.indentFromAxis = -indentFromTick + (isIndentPositive ? -tickCorrection + textCorrection : tickCorrection - verticalTextCorrection);\n\n    this._scale.updateOptions(scaleOptions);\n  },\n  _shiftScale: function _shiftScale(layout, scaleOptions) {\n    var that = this;\n    var canvas = extend({}, that._canvas);\n    var isHorizontal = scaleOptions.isHorizontal;\n    var scale = that._scale;\n    canvas[isHorizontal ? \"left\" : \"top\"] = that._area[isHorizontal ? \"startCoord\" : \"endCoord\"];\n    canvas[isHorizontal ? \"right\" : \"bottom\"] = canvas[isHorizontal ? \"width\" : \"height\"] - that._area[isHorizontal ? \"endCoord\" : \"startCoord\"];\n    scale.draw(canvas);\n    scale.shift({\n      left: -layout.x,\n      top: -layout.y\n    });\n  },\n  _setupCodomain: function _setupCodomain() {\n    var that = this;\n    var geometry = that.option(\"geometry\") || {};\n\n    var vertical = \"vertical\" === _normalizeEnum(geometry.orientation);\n\n    var initialStartCoord = -100;\n    var initialEndCoord = 100;\n    that._area = {\n      vertical: vertical,\n      x: 0,\n      y: 0,\n      startCoord: initialStartCoord,\n      endCoord: initialEndCoord\n    };\n    that._rangeContainer.vertical = vertical;\n\n    that._translator.setCodomain(initialStartCoord, initialEndCoord);\n  },\n  _getScaleLayoutValue: function _getScaleLayoutValue() {\n    return this._area[this._area.vertical ? \"x\" : \"y\"];\n  },\n  _getTicksCoefficients: function _getTicksCoefficients(options) {\n    var coefs = {\n      inner: 0,\n      outer: 1\n    };\n\n    if (this._area.vertical) {\n      if (\"left\" === options.horizontalOrientation) {\n        coefs.inner = 1;\n        coefs.outer = 0;\n      } else {\n        if (\"center\" === options.horizontalOrientation) {\n          coefs.inner = coefs.outer = .5;\n        }\n      }\n    } else {\n      if (\"top\" === options.verticalOrientation) {\n        coefs.inner = 1;\n        coefs.outer = 0;\n      } else {\n        if (\"center\" === options.verticalOrientation) {\n          coefs.inner = coefs.outer = .5;\n        }\n      }\n    }\n\n    return coefs;\n  },\n  _correctScaleIndents: function _correctScaleIndents(result, indentFromTick, textParams) {\n    var vertical = this._area.vertical;\n\n    if (indentFromTick >= 0) {\n      result.max += indentFromTick + textParams[vertical ? \"width\" : \"height\"];\n    } else {\n      result.min -= -indentFromTick + textParams[vertical ? \"width\" : \"height\"];\n    }\n\n    result.indent = textParams[vertical ? \"height\" : \"width\"] / 2;\n  },\n  _measureMainElements: function _measureMainElements(elements, scaleMeasurement) {\n    var that = this;\n    var x = that._area.x;\n    var y = that._area.y;\n    var minBound = 1e3;\n    var maxBound = 0;\n    var indent = 0;\n    var scale = that._scale;\n\n    _each(elements.concat(scale), function (_, element) {\n      var bounds = element.measure ? element.measure({\n        x: x + element.getOffset(),\n        y: y + element.getOffset()\n      }) : scaleMeasurement;\n      void 0 !== bounds.max && (maxBound = _max(maxBound, bounds.max));\n      void 0 !== bounds.min && (minBound = _min(minBound, bounds.min));\n      bounds.indent > 0 && (indent = _max(indent, bounds.indent));\n    });\n\n    return {\n      minBound: minBound,\n      maxBound: maxBound,\n      indent: indent\n    };\n  },\n  _applyMainLayout: function _applyMainLayout(elements, scaleMeasurement) {\n    var that = this;\n\n    var measurements = that._measureMainElements(elements, scaleMeasurement);\n\n    var area = that._area;\n    var rect;\n    var offset;\n\n    if (area.vertical) {\n      rect = selectRectBySizes(that._innerRect, {\n        width: measurements.maxBound - measurements.minBound\n      });\n      offset = (rect.left + rect.right) / 2 - (measurements.minBound + measurements.maxBound) / 2;\n      area.startCoord = rect.bottom - measurements.indent;\n      area.endCoord = rect.top + measurements.indent;\n      area.x = _round(area.x + offset);\n    } else {\n      rect = selectRectBySizes(that._innerRect, {\n        height: measurements.maxBound - measurements.minBound\n      });\n      offset = (rect.top + rect.bottom) / 2 - (measurements.minBound + measurements.maxBound) / 2;\n      area.startCoord = rect.left + measurements.indent;\n      area.endCoord = rect.right - measurements.indent;\n      area.y = _round(area.y + offset);\n    }\n\n    that._translator.setCodomain(area.startCoord, area.endCoord);\n\n    that._innerRect = rect;\n  },\n  _getElementLayout: function _getElementLayout(offset) {\n    return {\n      x: _round(this._area.x + offset),\n      y: _round(this._area.y + offset)\n    };\n  },\n  _getApproximateScreenRange: function _getApproximateScreenRange() {\n    var that = this;\n    var area = that._area;\n    var s = area.vertical ? that._canvas.height : that._canvas.width;\n    s > area.totalSize && (s = area.totalSize);\n    s = .8 * s;\n    return s;\n  },\n  _getDefaultSize: function _getDefaultSize() {\n    var geometry = this.option(\"geometry\") || {};\n\n    if (\"vertical\" === geometry.orientation) {\n      return {\n        width: 100,\n        height: 300\n      };\n    } else {\n      return {\n        width: 300,\n        height: 100\n      };\n    }\n  },\n  _factory: objectUtils.clone(dxBaseGauge.prototype._factory)\n});\n\nfunction selectRectBySizes(srcRect, sizes, margins) {\n  var rect = extend({}, srcRect);\n  var step;\n  margins = margins || {};\n\n  if (sizes) {\n    rect.left += margins.left || 0;\n    rect.right -= margins.right || 0;\n    rect.top += margins.top || 0;\n    rect.bottom -= margins.bottom || 0;\n\n    if (sizes.width > 0) {\n      step = (rect.right - rect.left - sizes.width) / 2;\n\n      if (step > 0) {\n        rect.left += step;\n        rect.right -= step;\n      }\n    }\n\n    if (sizes.height > 0) {\n      step = (rect.bottom - rect.top - sizes.height) / 2;\n\n      if (step > 0) {\n        rect.top += step;\n        rect.bottom -= step;\n      }\n    }\n  }\n\n  return rect;\n}\n\nvar indicators = dxLinearGauge.prototype._factory.indicators = {};\ndxLinearGauge.prototype._factory.createIndicator = createIndicatorCreator(indicators);\nindicators._default = linearIndicatorsModule._default;\nindicators.rectangle = linearIndicatorsModule.rectangle;\nindicators.rhombus = linearIndicatorsModule.rhombus;\nindicators.circle = linearIndicatorsModule.circle;\nindicators.trianglemarker = linearIndicatorsModule.trianglemarker;\nindicators.textcloud = linearIndicatorsModule.textcloud;\nindicators.rangebar = linearIndicatorsModule.rangebar;\ndxLinearGauge.prototype._factory.RangeContainer = LinearRangeContainer;\nregisterComponent(\"dxLinearGauge\", dxLinearGauge);\nmodule.exports = dxLinearGauge;","map":null,"metadata":{},"sourceType":"script"}