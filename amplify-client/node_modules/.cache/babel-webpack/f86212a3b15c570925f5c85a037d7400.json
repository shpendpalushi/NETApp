{"ast":null,"code":"/**\r\n * DevExtreme (ui/pivot_grid/ui.pivot_grid.utils.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _ajax = require(\"../../core/utils/ajax\");\n\nvar _data = require(\"../../core/utils/data\");\n\nvar _iterator = require(\"../../core/utils/iterator\");\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _date = require(\"../../localization/date\");\n\nvar _format_helper = require(\"../../format_helper\");\n\nvar _data_source = require(\"../../data/data_source/data_source\");\n\nvar _array_store = require(\"../../data/array_store\");\n\nvar _array_store2 = _interopRequireDefault(_array_store);\n\nvar _deferred = require(\"../../core/utils/deferred\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar setFieldProperty = exports.setFieldProperty = function (field, property, value, isInitialization) {\n  var initProperties = field._initProperties = field._initProperties || {};\n  var initValue = isInitialization ? value : field[property];\n\n  if (!Object.prototype.hasOwnProperty.call(initProperties, property) || isInitialization) {\n    initProperties[property] = initValue;\n  }\n\n  field[property] = value;\n};\n\nexports.sendRequest = function (options) {\n  return (0, _ajax.sendRequest)(options);\n};\n\nvar foreachTreeAsyncDate = new Date();\n\nfunction createForeachTreeFunc(isAsync) {\n  var foreachTreeFunc = function foreachTreeFunc(items, callback, parentAtFirst, members, index, isChildrenProcessing) {\n    members = members || [];\n    items = items || [];\n    var item;\n    var i;\n    var deferred;\n    var childrenDeferred;\n    index = index || 0;\n\n    function createForeachTreeAsyncHandler(deferred, i, isChildrenProcessing) {\n      (0, _deferred.when)(foreachTreeFunc(items, callback, parentAtFirst, members, i, isChildrenProcessing)).done(deferred.resolve);\n    }\n\n    for (i = index; i < items.length; i++) {\n      if (isAsync && i > index && i % 1e4 === 0 && new Date() - foreachTreeAsyncDate >= 300) {\n        foreachTreeAsyncDate = new Date();\n        deferred = new _deferred.Deferred();\n        setTimeout(createForeachTreeAsyncHandler(deferred, i, false), 0);\n        return deferred;\n      }\n\n      item = items[i];\n\n      if (!isChildrenProcessing) {\n        members.unshift(item);\n\n        if (parentAtFirst && false === callback(members, i)) {\n          return;\n        }\n\n        if (item.children) {\n          childrenDeferred = foreachTreeFunc(item.children, callback, parentAtFirst, members);\n\n          if (isAsync && childrenDeferred) {\n            deferred = new _deferred.Deferred();\n            childrenDeferred.done(createForeachTreeAsyncHandler(deferred, i, true));\n            return deferred;\n          }\n        }\n      }\n\n      isChildrenProcessing = false;\n\n      if (!parentAtFirst && false === callback(members, i)) {\n        return;\n      }\n\n      members.shift();\n\n      if (items[i] !== item) {\n        i--;\n      }\n    }\n  };\n\n  return foreachTreeFunc;\n}\n\nexports.foreachTree = createForeachTreeFunc(false);\nexports.foreachTreeAsync = createForeachTreeFunc(true);\n\nexports.findField = function (fields, id) {\n  var i;\n  var field;\n\n  if (fields && (0, _type.isDefined)(id)) {\n    for (i = 0; i < fields.length; i++) {\n      field = fields[i];\n\n      if (field.name === id || field.caption === id || field.dataField === id || field.index === id) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n};\n\nexports.formatValue = function (value, options) {\n  var formatObject = {\n    value: value,\n    valueText: (0, _format_helper.format)(value, options.format) || \"\"\n  };\n  return options.customizeText ? options.customizeText.call(options, formatObject) : formatObject.valueText;\n};\n\nexports.getCompareFunction = function (valueSelector) {\n  return function (a, b) {\n    var result = 0;\n    var valueA = valueSelector(a);\n    var valueB = valueSelector(b);\n    var aIsDefined = (0, _type.isDefined)(valueA);\n    var bIsDefined = (0, _type.isDefined)(valueB);\n\n    if (aIsDefined && bIsDefined) {\n      if (valueA > valueB) {\n        result = 1;\n      } else {\n        if (valueA < valueB) {\n          result = -1;\n        }\n      }\n    }\n\n    if (aIsDefined && !bIsDefined) {\n      result = 1;\n    }\n\n    if (!aIsDefined && bIsDefined) {\n      result = -1;\n    }\n\n    return result;\n  };\n};\n\nexports.createPath = function (items) {\n  var result = [];\n  var i;\n\n  for (i = items.length - 1; i >= 0; i--) {\n    result.push(items[i].key || items[i].value);\n  }\n\n  return result;\n};\n\nexports.foreachDataLevel = function foreachDataLevel(data, callback, index, childrenField) {\n  var item;\n  var i;\n  index = index || 0;\n  childrenField = childrenField || \"children\";\n\n  if (data.length) {\n    callback(data, index);\n  }\n\n  for (i = 0; i < data.length; i++) {\n    item = data[i];\n\n    if (item[childrenField] && item[childrenField].length) {\n      foreachDataLevel(item[childrenField], callback, index + 1, childrenField);\n    }\n  }\n};\n\nexports.mergeArraysByMaxValue = function (values1, values2) {\n  var result = [];\n  var i;\n\n  for (i = 0; i < values1.length; i++) {\n    result.push(Math.max(values1[i] || 0, values2[i] || 0));\n  }\n\n  return result;\n};\n\nexports.getExpandedLevel = function (options, axisName) {\n  var dimensions = options[axisName];\n  var expandLevel = 0;\n  var expandedPaths = (\"columns\" === axisName ? options.columnExpandedPaths : options.rowExpandedPaths) || [];\n\n  if (options.headerName === axisName) {\n    expandLevel = options.path.length;\n  } else {\n    if (options.headerName && options.headerName !== axisName && options.oppositePath) {\n      expandLevel = options.oppositePath.length;\n    } else {\n      (0, _iterator.each)(expandedPaths, function (_, path) {\n        expandLevel = Math.max(expandLevel, path.length);\n      });\n    }\n  }\n\n  while (dimensions[expandLevel + 1] && dimensions[expandLevel].expanded) {\n    expandLevel++;\n  }\n\n  return expandLevel;\n};\n\nfunction createGroupFields(item) {\n  return (0, _iterator.map)([\"year\", \"quarter\", \"month\"], function (value, index) {\n    return (0, _extend.extend)({}, item, {\n      groupInterval: value,\n      groupIndex: index\n    });\n  });\n}\n\nfunction parseFields(dataSource, fieldsList, path, fieldsDataType) {\n  var result = [];\n  (0, _iterator.each)(fieldsList || [], function (field, value) {\n    if (field && 0 === field.indexOf(\"__\")) {\n      return;\n    }\n\n    var dataIndex = 1;\n    var currentPath = path.length ? path + \".\" + field : field;\n    var dataType = fieldsDataType[currentPath];\n    var getter = (0, _data.compileGetter)(currentPath);\n    var items;\n\n    while (!(0, _type.isDefined)(value) && dataSource[dataIndex]) {\n      value = getter(dataSource[dataIndex]);\n      dataIndex++;\n    }\n\n    if (!dataType && (0, _type.isDefined)(value)) {\n      dataType = (0, _type.type)(value);\n    }\n\n    items = [{\n      dataField: currentPath,\n      dataType: dataType,\n      groupName: \"date\" === dataType ? field : void 0,\n      groupInterval: void 0,\n      displayFolder: path\n    }];\n\n    if (\"date\" === dataType) {\n      items = items.concat(createGroupFields(items[0]));\n    } else {\n      if (\"object\" === dataType) {\n        items = parseFields(dataSource, value, currentPath, fieldsDataType);\n      }\n    }\n\n    result.push.apply(result, items);\n  });\n  return result;\n}\n\nexports.discoverObjectFields = function (items, fields) {\n  var fieldsDataType = exports.getFieldsDataType(fields);\n  return parseFields(items, items[0], \"\", fieldsDataType);\n};\n\nexports.getFieldsDataType = function (fields) {\n  var result = {};\n  (0, _iterator.each)(fields, function (_, field) {\n    result[field.dataField] = result[field.dataField] || field.dataType;\n  });\n  return result;\n};\n\nvar DATE_INTERVAL_FORMATS = {\n  month: function month(value) {\n    return (0, _date.getMonthNames)()[value - 1];\n  },\n  quarter: function quarter(value) {\n    return (0, _date.format)(new Date(2e3, 3 * value - 1), \"quarter\");\n  },\n  dayOfWeek: function dayOfWeek(value) {\n    return (0, _date.getDayNames)()[value];\n  }\n};\n\nexports.setDefaultFieldValueFormatting = function (field) {\n  if (\"date\" === field.dataType) {\n    if (!field.format) {\n      setFieldProperty(field, \"format\", DATE_INTERVAL_FORMATS[field.groupInterval]);\n    }\n  } else {\n    if (\"number\" === field.dataType) {\n      var groupInterval = (0, _type.isNumeric)(field.groupInterval) && field.groupInterval > 0 && field.groupInterval;\n\n      if (groupInterval && !field.customizeText) {\n        setFieldProperty(field, \"customizeText\", function (formatObject) {\n          var secondValue = formatObject.value + groupInterval;\n          var secondValueText = (0, _format_helper.format)(secondValue, field.format);\n          return formatObject.valueText && secondValueText ? formatObject.valueText + \" - \" + secondValueText : \"\";\n        });\n      }\n    }\n  }\n};\n\nexports.getFiltersByPath = function (fields, path) {\n  var result = [];\n  path = path || [];\n\n  for (var i = 0; i < path.length; i++) {\n    result.push((0, _extend.extend)({}, fields[i], {\n      groupIndex: null,\n      groupName: null,\n      filterType: \"include\",\n      filterValues: [path[i]]\n    }));\n  }\n\n  return result;\n};\n\nexports.storeDrillDownMixin = {\n  createDrillDownDataSource: function createDrillDownDataSource(descriptions, params) {\n    function createCustomStoreMethod(methodName) {\n      return function (options) {\n        var d;\n\n        if (arrayStore) {\n          d = arrayStore[methodName](options);\n        } else {\n          d = new _deferred.Deferred();\n          (0, _deferred.when)(items).done(function (data) {\n            arrayStore = new _array_store2.default(data);\n            arrayStore[methodName](options).done(d.resolve).fail(d.reject);\n          }).fail(d.reject);\n        }\n\n        return d;\n      };\n    }\n\n    var items = this.getDrillDownItems(descriptions, params);\n    var arrayStore;\n    var dataSource = new _data_source.DataSource({\n      load: createCustomStoreMethod(\"load\"),\n      totalCount: createCustomStoreMethod(\"totalCount\"),\n      key: this.key()\n    });\n    return dataSource;\n  }\n};\n\nexports.capitalizeFirstLetter = function (string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};","map":null,"metadata":{},"sourceType":"script"}