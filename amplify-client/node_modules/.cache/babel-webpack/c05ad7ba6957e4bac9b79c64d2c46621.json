{"ast":null,"code":"/**\r\n * DevExtreme (ui/pivot_grid/data_source.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _data_source = require(\"../../data/data_source/data_source\");\n\nvar _abstract_store = require(\"../../data/abstract_store\");\n\nvar _abstract_store2 = _interopRequireDefault(_abstract_store);\n\nvar _common = require(\"../../core/utils/common\");\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _array = require(\"../../core/utils/array\");\n\nvar _iterator = require(\"../../core/utils/iterator\");\n\nvar _deferred = require(\"../../core/utils/deferred\");\n\nvar _class = require(\"../../core/class\");\n\nvar _class2 = _interopRequireDefault(_class);\n\nvar _events_mixin = require(\"../../core/events_mixin\");\n\nvar _events_mixin2 = _interopRequireDefault(_events_mixin);\n\nvar _inflector = require(\"../../core/utils/inflector\");\n\nvar _local_store = require(\"./local_store\");\n\nvar _remote_store = require(\"./remote_store\");\n\nvar _remote_store2 = _interopRequireDefault(_remote_store);\n\nvar _xmla_store = require(\"./xmla_store/xmla_store\");\n\nvar _uiPivot_grid = require(\"./ui.pivot_grid.summary_display_modes\");\n\nvar _uiPivot_grid2 = require(\"./ui.pivot_grid.utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar DESCRIPTION_NAME_BY_AREA = {\n  row: \"rows\",\n  column: \"columns\",\n  data: \"values\",\n  filter: \"filters\"\n};\nvar STATE_PROPERTIES = [\"area\", \"areaIndex\", \"sortOrder\", \"filterType\", \"filterValues\", \"sortBy\", \"sortBySummaryField\", \"sortBySummaryPath\", \"expanded\", \"summaryType\", \"summaryDisplayMode\"];\nvar CALCULATED_PROPERTIES = [\"format\", \"selector\", \"customizeText\", \"caption\"];\nvar ALL_CALCULATED_PROPERTIES = CALCULATED_PROPERTIES.concat([\"allowSorting\", \"allowSortingBySummary\", \"allowFiltering\", \"allowExpandAll\"]);\n\nfunction createCaption(field) {\n  var caption = field.dataField || field.groupName || \"\";\n  var summaryType = (field.summaryType || \"\").toLowerCase();\n\n  if ((0, _type.isString)(field.groupInterval)) {\n    caption += \"_\" + field.groupInterval;\n  }\n\n  if (summaryType && \"custom\" !== summaryType) {\n    summaryType = summaryType.replace(/^./, summaryType[0].toUpperCase());\n\n    if (caption.length) {\n      summaryType = \" (\" + summaryType + \")\";\n    }\n  } else {\n    summaryType = \"\";\n  }\n\n  return (0, _inflector.titleize)(caption) + summaryType;\n}\n\nfunction resetFieldState(field, properties) {\n  var initialProperties = field._initProperties || {};\n  (0, _iterator.each)(properties, function (_, prop) {\n    if (Object.prototype.hasOwnProperty.call(initialProperties, prop)) {\n      field[prop] = initialProperties[prop];\n    }\n  });\n}\n\nfunction updateCalculatedFieldProperties(field, calculatedProperties) {\n  resetFieldState(field, calculatedProperties);\n\n  if (!(0, _type.isDefined)(field.caption)) {\n    (0, _uiPivot_grid2.setFieldProperty)(field, \"caption\", createCaption(field));\n  }\n}\n\nfunction areExpressionsUsed(dataFields) {\n  return dataFields.some(function (field) {\n    return field.summaryDisplayMode || field.calculateSummaryValue;\n  });\n}\n\nfunction isRunningTotalUsed(dataFields) {\n  return dataFields.some(function (field) {\n    return !!field.runningTotal;\n  });\n}\n\nfunction isDataExists(data) {\n  return data.rows.length || data.columns.length || data.values.length;\n}\n\nmodule.exports = _class2.default.inherit(function () {\n  var findHeaderItem = function findHeaderItem(headerItems, path) {\n    if (headerItems._cacheByPath) {\n      return headerItems._cacheByPath[path.join(\".\")] || null;\n    }\n  };\n\n  var getHeaderItemsLastIndex = function getHeaderItemsLastIndex(headerItems, grandTotalIndex) {\n    var i;\n    var lastIndex = -1;\n    var headerItem;\n\n    if (headerItems) {\n      for (i = 0; i < headerItems.length; i++) {\n        headerItem = headerItems[i];\n\n        if (void 0 !== headerItem.index) {\n          lastIndex = Math.max(lastIndex, headerItem.index);\n        }\n\n        if (headerItem.children) {\n          lastIndex = Math.max(lastIndex, getHeaderItemsLastIndex(headerItem.children));\n        } else {\n          if (headerItem.collapsedChildren) {\n            lastIndex = Math.max(lastIndex, getHeaderItemsLastIndex(headerItem.collapsedChildren));\n          }\n        }\n      }\n    }\n\n    if ((0, _type.isDefined)(grandTotalIndex)) {\n      lastIndex = Math.max(lastIndex, grandTotalIndex);\n    }\n\n    return lastIndex;\n  };\n\n  var updateHeaderItemChildren = function updateHeaderItemChildren(headerItems, headerItem, children, grandTotalIndex) {\n    var applyingHeaderItemsCount = getHeaderItemsLastIndex(children) + 1;\n    var emptyIndex = getHeaderItemsLastIndex(headerItems, grandTotalIndex) + 1;\n    var index;\n    var applyingItemIndexesToCurrent = [];\n    var needIndexUpdate = false;\n    var d = new _deferred.Deferred();\n\n    if (headerItem.children && headerItem.children.length === children.length) {\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n\n        if (void 0 !== child.index) {\n          if (void 0 === headerItem.children[i].index) {\n            child.index = applyingItemIndexesToCurrent[child.index] = emptyIndex++;\n            headerItem.children[i] = child;\n          } else {\n            applyingItemIndexesToCurrent[child.index] = headerItem.children[i].index;\n          }\n        }\n      }\n    } else {\n      needIndexUpdate = true;\n\n      for (index = 0; index < applyingHeaderItemsCount; index++) {\n        applyingItemIndexesToCurrent[index] = emptyIndex++;\n      }\n\n      headerItem.children = children;\n    }\n\n    (0, _deferred.when)((0, _uiPivot_grid2.foreachTreeAsync)(headerItem.children, function (items) {\n      if (needIndexUpdate) {\n        items[0].index = applyingItemIndexesToCurrent[items[0].index];\n      }\n    })).done(function () {\n      d.resolve(applyingItemIndexesToCurrent);\n    });\n    return d;\n  };\n\n  var updateHeaderItems = function updateHeaderItems(headerItems, newHeaderItems, grandTotalIndex) {\n    var d = new _deferred.Deferred();\n    var emptyIndex = grandTotalIndex >= 0 && getHeaderItemsLastIndex(headerItems, grandTotalIndex) + 1;\n    var applyingItemIndexesToCurrent = [];\n    (0, _deferred.when)((0, _uiPivot_grid2.foreachTreeAsync)(headerItems, function (items) {\n      delete items[0].collapsedChildren;\n    })).done(function () {\n      (0, _deferred.when)((0, _uiPivot_grid2.foreachTreeAsync)(newHeaderItems, function (newItems, index) {\n        var newItem = newItems[0];\n\n        if (newItem.index >= 0) {\n          var headerItem = findHeaderItem(headerItems, (0, _uiPivot_grid2.createPath)(newItems));\n\n          if (headerItem && headerItem.index >= 0) {\n            applyingItemIndexesToCurrent[newItem.index] = headerItem.index;\n          } else {\n            if (emptyIndex) {\n              var path = (0, _uiPivot_grid2.createPath)(newItems.slice(1));\n              headerItem = findHeaderItem(headerItems, path);\n              var parentItems = path.length ? headerItem && headerItem.children : headerItems;\n\n              if (parentItems) {\n                parentItems[index] = newItem;\n                newItem.index = applyingItemIndexesToCurrent[newItem.index] = emptyIndex++;\n              }\n            }\n          }\n        }\n      })).done(function () {\n        d.resolve(applyingItemIndexesToCurrent);\n      });\n    });\n    return d;\n  };\n\n  var updateDataSourceCells = function updateDataSourceCells(dataSource, newDataSourceCells, newRowItemIndexesToCurrent, newColumnItemIndexesToCurrent) {\n    var newRowIndex;\n    var newColumnIndex;\n    var newRowCells;\n    var newCell;\n    var rowIndex;\n    var columnIndex;\n    var dataSourceCells = dataSource.values;\n\n    if (newDataSourceCells) {\n      for (newRowIndex = 0; newRowIndex <= newDataSourceCells.length; newRowIndex++) {\n        newRowCells = newDataSourceCells[newRowIndex];\n        rowIndex = newRowItemIndexesToCurrent[newRowIndex];\n\n        if (!(0, _type.isDefined)(rowIndex)) {\n          rowIndex = dataSource.grandTotalRowIndex;\n        }\n\n        if (newRowCells && (0, _type.isDefined)(rowIndex)) {\n          if (!dataSourceCells[rowIndex]) {\n            dataSourceCells[rowIndex] = [];\n          }\n\n          for (newColumnIndex = 0; newColumnIndex <= newRowCells.length; newColumnIndex++) {\n            newCell = newRowCells[newColumnIndex];\n            columnIndex = newColumnItemIndexesToCurrent[newColumnIndex];\n\n            if (!(0, _type.isDefined)(columnIndex)) {\n              columnIndex = dataSource.grandTotalColumnIndex;\n            }\n\n            if ((0, _type.isDefined)(newCell) && (0, _type.isDefined)(columnIndex)) {\n              dataSourceCells[rowIndex][columnIndex] = newCell;\n            }\n          }\n        }\n      }\n    }\n  };\n\n  function createLocalOrRemoteStore(dataSourceOptions, notifyProgress) {\n    var StoreConstructor = dataSourceOptions.remoteOperations || dataSourceOptions.paginate ? _remote_store2.default : _local_store.LocalStore;\n    return new StoreConstructor((0, _extend.extend)((0, _data_source.normalizeDataSourceOptions)(dataSourceOptions), {\n      onChanged: null,\n      onLoadingChanged: null,\n      onProgressChanged: notifyProgress\n    }));\n  }\n\n  function createStore(dataSourceOptions, notifyProgress) {\n    var store;\n    var storeOptions;\n\n    if ((0, _type.isPlainObject)(dataSourceOptions) && dataSourceOptions.load) {\n      store = createLocalOrRemoteStore(dataSourceOptions, notifyProgress);\n    } else {\n      if (dataSourceOptions && !dataSourceOptions.store) {\n        dataSourceOptions = {\n          store: dataSourceOptions\n        };\n      }\n\n      storeOptions = dataSourceOptions.store;\n\n      if (\"xmla\" === storeOptions.type) {\n        store = new _xmla_store.XmlaStore(storeOptions);\n      } else {\n        if ((0, _type.isPlainObject)(storeOptions) && storeOptions.type || storeOptions instanceof _abstract_store2.default || Array.isArray(storeOptions)) {\n          store = createLocalOrRemoteStore(dataSourceOptions, notifyProgress);\n        } else {\n          if (storeOptions instanceof _class2.default) {\n            store = storeOptions;\n          }\n        }\n      }\n    }\n\n    return store;\n  }\n\n  function equalFields(fields, prevFields, count) {\n    for (var i = 0; i < count; i++) {\n      if (!fields[i] || !prevFields[i] || fields[i].index !== prevFields[i].index) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function getExpandedPaths(dataSource, loadOptions, dimensionName, prevLoadOptions) {\n    var result = [];\n    var fields = loadOptions && loadOptions[dimensionName] || [];\n    var prevFields = prevLoadOptions && prevLoadOptions[dimensionName] || [];\n    (0, _uiPivot_grid2.foreachTree)(dataSource[dimensionName], function (items) {\n      var item = items[0];\n      var path = (0, _uiPivot_grid2.createPath)(items);\n\n      if (item.children && fields[path.length - 1] && !fields[path.length - 1].expanded) {\n        if (path.length < fields.length && (!prevLoadOptions || equalFields(fields, prevFields, path.length))) {\n          result.push(path.slice());\n        }\n      }\n    }, true);\n    return result;\n  }\n\n  function setFieldProperties(field, srcField, skipInitPropertySave, properties) {\n    if (srcField) {\n      (0, _iterator.each)(properties, function (_, name) {\n        if (skipInitPropertySave) {\n          field[name] = srcField[name];\n        } else {\n          if ((\"summaryType\" === name || \"summaryDisplayMode\" === name) && void 0 === srcField[name]) {\n            return;\n          }\n\n          (0, _uiPivot_grid2.setFieldProperty)(field, name, srcField[name]);\n        }\n      });\n    } else {\n      resetFieldState(field, properties);\n    }\n\n    return field;\n  }\n\n  function getFieldsState(fields, properties) {\n    var result = [];\n    (0, _iterator.each)(fields, function (_, field) {\n      result.push(setFieldProperties({\n        dataField: field.dataField,\n        name: field.name\n      }, field, true, properties));\n    });\n    return result;\n  }\n\n  function getFieldStateId(field) {\n    if (field.name) {\n      return field.name;\n    }\n\n    return field.dataField + \"\";\n  }\n\n  function getFieldsById(fields, id) {\n    var result = [];\n    (0, _iterator.each)(fields || [], function (_, field) {\n      if (getFieldStateId(field) === id) {\n        result.push(field);\n      }\n    });\n    return result;\n  }\n\n  function setFieldsStateCore(stateFields, fields) {\n    stateFields = stateFields || [];\n    (0, _iterator.each)(fields, function (index, field) {\n      setFieldProperties(field, stateFields[index], false, STATE_PROPERTIES);\n      updateCalculatedFieldProperties(field, CALCULATED_PROPERTIES);\n    });\n    return fields;\n  }\n\n  function setFieldsState(stateFields, fields) {\n    stateFields = stateFields || [];\n    var fieldsById = {};\n    var id;\n    (0, _iterator.each)(fields, function (_, field) {\n      id = getFieldStateId(field);\n\n      if (!fieldsById[id]) {\n        fieldsById[id] = getFieldsById(fields, getFieldStateId(field));\n      }\n    });\n    (0, _iterator.each)(fieldsById, function (id, fields) {\n      setFieldsStateCore(getFieldsById(stateFields, id), fields);\n    });\n    return fields;\n  }\n\n  function getFieldsByGroup(fields, groupingField) {\n    return fields.filter(function (field) {\n      return field.groupName === groupingField.groupName && (0, _type.isNumeric)(field.groupIndex) && false !== field.visible;\n    }).map(function (field) {\n      return (0, _extend.extend)(field, {\n        areaIndex: groupingField.areaIndex,\n        area: groupingField.area,\n        expanded: (0, _type.isDefined)(field.expanded) ? field.expanded : groupingField.expanded,\n        dataField: field.dataField || groupingField.dataField,\n        dataType: field.dataType || groupingField.dataType,\n        sortBy: field.sortBy || groupingField.sortBy,\n        sortOrder: field.sortOrder || groupingField.sortOrder,\n        sortBySummaryField: field.sortBySummaryField || groupingField.sortBySummaryField,\n        sortBySummaryPath: field.sortBySummaryPath || groupingField.sortBySummaryPath,\n        visible: field.visible || groupingField.visible,\n        showTotals: (0, _type.isDefined)(field.showTotals) ? field.showTotals : groupingField.showTotals,\n        showGrandTotals: (0, _type.isDefined)(field.showGrandTotals) ? field.showGrandTotals : groupingField.showGrandTotals\n      });\n    }).sort(function (a, b) {\n      return a.groupIndex - b.groupIndex;\n    });\n  }\n\n  function sortFieldsByAreaIndex(fields) {\n    fields.sort(function (field1, field2) {\n      return field1.areaIndex - field2.areaIndex || field1.groupIndex - field2.groupIndex;\n    });\n  }\n\n  function isAreaField(field, area) {\n    var canAddFieldInArea = \"data\" === area || false !== field.visible;\n    return field.area === area && !(0, _type.isDefined)(field.groupIndex) && canAddFieldInArea;\n  }\n\n  function getFieldId(field, retrieveFieldsOptionValue) {\n    var groupName = field.groupName || \"\";\n    return (field.dataField || groupName) + (field.groupInterval ? groupName + field.groupInterval : \"NOGROUP\") + (retrieveFieldsOptionValue ? \"\" : groupName);\n  }\n\n  function mergeFields(fields, storeFields, retrieveFieldsOptionValue) {\n    var result = [];\n    var fieldsDictionary = {};\n    var removedFields = {};\n    var mergedGroups = [];\n    var dataTypes = (0, _uiPivot_grid2.getFieldsDataType)(fields);\n\n    if (storeFields) {\n      (0, _iterator.each)(storeFields, function (_, field) {\n        fieldsDictionary[getFieldId(field, retrieveFieldsOptionValue)] = field;\n      });\n      (0, _iterator.each)(fields, function (_, field) {\n        var fieldKey = getFieldId(field, retrieveFieldsOptionValue);\n        var storeField = fieldsDictionary[fieldKey] || removedFields[fieldKey];\n        var mergedField;\n\n        if (storeField) {\n          if (storeField._initProperties) {\n            resetFieldState(storeField, ALL_CALCULATED_PROPERTIES);\n          }\n\n          mergedField = (0, _extend.extend)({}, storeField, field, {\n            _initProperties: null\n          });\n        } else {\n          fieldsDictionary[fieldKey] = mergedField = field;\n        }\n\n        (0, _extend.extend)(mergedField, {\n          dataType: dataTypes[field.dataField]\n        });\n        delete fieldsDictionary[fieldKey];\n        removedFields[fieldKey] = storeField;\n        result.push(mergedField);\n      });\n\n      if (retrieveFieldsOptionValue) {\n        (0, _iterator.each)(fieldsDictionary, function (_, field) {\n          result.push(field);\n        });\n      }\n    } else {\n      result = fields;\n    }\n\n    result.push.apply(result, mergedGroups);\n    return result;\n  }\n\n  function getFields(that) {\n    var result = new _deferred.Deferred();\n    var store = that._store;\n    var storeFields = store && store.getFields(that._fields);\n    var mergedFields;\n    (0, _deferred.when)(storeFields).done(function (storeFields) {\n      that._storeFields = storeFields;\n      mergedFields = mergeFields(that._fields, storeFields, that._retrieveFields);\n      result.resolve(mergedFields);\n    }).fail(result.reject);\n    return result;\n  }\n\n  function getSliceIndex(items, path) {\n    var index = null;\n    var pathValue = (path || []).join(\".\");\n\n    if (pathValue.length) {\n      (0, _uiPivot_grid2.foreachTree)(items, function (items) {\n        var item = items[0];\n        var itemPath = (0, _uiPivot_grid2.createPath)(items).join(\".\");\n        var textPath = (0, _iterator.map)(items, function (item) {\n          return item.text;\n        }).reverse().join(\".\");\n\n        if (pathValue === itemPath || item.key && textPath === pathValue) {\n          index = items[0].index;\n          return false;\n        }\n      });\n    }\n\n    return index;\n  }\n\n  function getFieldSummaryValueSelector(field, dataSource, loadOptions, dimensionName) {\n    var values = dataSource.values;\n    var sortBySummaryFieldIndex = (0, _uiPivot_grid2.findField)(loadOptions.values, field.sortBySummaryField);\n    var areRows = \"rows\" === dimensionName;\n    var sortByDimension = areRows ? dataSource.columns : dataSource.rows;\n    var grandTotalIndex = areRows ? dataSource.grandTotalRowIndex : dataSource.grandTotalColumnIndex;\n    var sortBySummaryPath = field.sortBySummaryPath || [];\n    var sliceIndex = sortBySummaryPath.length ? getSliceIndex(sortByDimension, sortBySummaryPath) : grandTotalIndex;\n\n    if (values && values.length && sortBySummaryFieldIndex >= 0 && (0, _type.isDefined)(sliceIndex)) {\n      return function (field) {\n        var rowIndex = areRows ? field.index : sliceIndex;\n        var columnIndex = areRows ? sliceIndex : field.index;\n        var value = ((values[rowIndex] || [[]])[columnIndex] || [])[sortBySummaryFieldIndex];\n        return (0, _type.isDefined)(value) ? value : null;\n      };\n    }\n  }\n\n  function getMemberForSortBy(sortBy, getAscOrder) {\n    var member = \"text\";\n\n    if (\"none\" === sortBy) {\n      member = \"index\";\n    } else {\n      if (getAscOrder || \"displayText\" !== sortBy) {\n        member = \"value\";\n      }\n    }\n\n    return member;\n  }\n\n  function getSortingMethod(field, dataSource, loadOptions, dimensionName, getAscOrder) {\n    var sortOrder = getAscOrder ? \"asc\" : field.sortOrder;\n    var sortBy = getMemberForSortBy(field.sortBy, getAscOrder);\n    var defaultCompare = field.sortingMethod ? function (a, b) {\n      return field.sortingMethod(a, b);\n    } : (0, _uiPivot_grid2.getCompareFunction)(function (item) {\n      return item[sortBy];\n    });\n    var summaryValueSelector = !getAscOrder && getFieldSummaryValueSelector(field, dataSource, loadOptions, dimensionName);\n    var summaryCompare = summaryValueSelector && (0, _uiPivot_grid2.getCompareFunction)(summaryValueSelector);\n\n    var sortingMethod = function sortingMethod(a, b) {\n      var result = summaryCompare && summaryCompare(a, b) || defaultCompare(a, b);\n      return \"desc\" === sortOrder ? -result : result;\n    };\n\n    return sortingMethod;\n  }\n\n  function sortDimension(dataSource, loadOptions, dimensionName, getAscOrder) {\n    var fields = loadOptions[dimensionName] || [];\n    var baseIndex = loadOptions.headerName === dimensionName ? loadOptions.path.length : 0;\n    var sortingMethodByLevel = [];\n    (0, _uiPivot_grid2.foreachDataLevel)(dataSource[dimensionName], function (item, index) {\n      var field = fields[index] || {};\n      var sortingMethod = sortingMethodByLevel[index] = sortingMethodByLevel[index] || getSortingMethod(field, dataSource, loadOptions, dimensionName, getAscOrder);\n      item.sort(sortingMethod);\n    }, baseIndex);\n  }\n\n  function sort(loadOptions, dataSource, getAscOrder) {\n    sortDimension(dataSource, loadOptions, \"rows\", getAscOrder);\n    sortDimension(dataSource, loadOptions, \"columns\", getAscOrder);\n  }\n\n  function formatHeaderItems(data, loadOptions, headerName) {\n    return (0, _uiPivot_grid2.foreachTreeAsync)(data[headerName], function (items) {\n      var item = items[0];\n      item.text = item.text || (0, _uiPivot_grid2.formatValue)(item.value, loadOptions[headerName][(0, _uiPivot_grid2.createPath)(items).length - 1]);\n    });\n  }\n\n  function formatHeaders(loadOptions, data) {\n    return (0, _deferred.when)(formatHeaderItems(data, loadOptions, \"columns\"), formatHeaderItems(data, loadOptions, \"rows\"));\n  }\n\n  function updateCache(headerItems) {\n    var d = new _deferred.Deferred();\n    var cacheByPath = {};\n    (0, _deferred.when)((0, _uiPivot_grid2.foreachTreeAsync)(headerItems, function (items) {\n      var path = (0, _uiPivot_grid2.createPath)(items).join(\".\");\n      cacheByPath[path] = items[0];\n    })).done(d.resolve);\n    headerItems._cacheByPath = cacheByPath;\n    return d;\n  }\n\n  function _getAreaFields(fields, area) {\n    var areaFields = [];\n    (0, _iterator.each)(fields, function () {\n      if (isAreaField(this, area)) {\n        areaFields.push(this);\n      }\n    });\n    return areaFields;\n  }\n\n  return {\n    ctor: function ctor(options) {\n      options = options || {};\n      var that = this;\n      var store = createStore(options, function (progress) {\n        that.fireEvent(\"progressChanged\", [progress]);\n      });\n      that._store = store;\n      that._paginate = !!options.paginate;\n      that._pageSize = options.pageSize || 40;\n      that._data = {\n        rows: [],\n        columns: [],\n        values: []\n      };\n      that._loadingCount = 0;\n      that._isFieldsModified = false;\n      (0, _iterator.each)([\"changed\", \"loadError\", \"loadingChanged\", \"progressChanged\", \"fieldsPrepared\", \"expandValueChanging\"], function (_, eventName) {\n        var optionName = \"on\" + eventName[0].toUpperCase() + eventName.slice(1);\n\n        if (Object.prototype.hasOwnProperty.call(options, optionName)) {\n          this.on(eventName, options[optionName]);\n        }\n      }.bind(this));\n      that._retrieveFields = (0, _type.isDefined)(options.retrieveFields) ? options.retrieveFields : true;\n      that._fields = options.fields || [];\n      that._descriptions = options.descriptions ? (0, _extend.extend)(that._createDescriptions(), options.descriptions) : void 0;\n\n      if (!store) {\n        (0, _extend.extend)(true, that._data, options.store || options);\n      }\n    },\n    getData: function getData() {\n      return this._data;\n    },\n    getAreaFields: function getAreaFields(area, collectGroups) {\n      var areaFields = [];\n      var descriptions;\n\n      if (collectGroups || \"data\" === area) {\n        areaFields = _getAreaFields(this._fields, area);\n        sortFieldsByAreaIndex(areaFields);\n      } else {\n        descriptions = this._descriptions || {};\n        areaFields = descriptions[DESCRIPTION_NAME_BY_AREA[area]] || [];\n      }\n\n      return areaFields;\n    },\n    fields: function fields(_fields) {\n      var that = this;\n\n      if (_fields) {\n        that._fields = mergeFields(_fields, that._storeFields, that._retrieveFields);\n\n        that._fieldsPrepared(that._fields);\n      }\n\n      return that._fields;\n    },\n    field: function field(id, options) {\n      var that = this;\n      var fields = that._fields;\n      var field = fields && fields[(0, _type.isNumeric)(id) ? id : (0, _uiPivot_grid2.findField)(fields, id)];\n      var levels;\n\n      if (field && options) {\n        (0, _iterator.each)(options, function (optionName, optionValue) {\n          var isInitialization = (0, _array.inArray)(optionName, STATE_PROPERTIES) < 0;\n          (0, _uiPivot_grid2.setFieldProperty)(field, optionName, optionValue, isInitialization);\n\n          if (\"sortOrder\" === optionName) {\n            levels = field.levels || [];\n\n            for (var i = 0; i < levels.length; i++) {\n              levels[i][optionName] = optionValue;\n            }\n          }\n        });\n        updateCalculatedFieldProperties(field, CALCULATED_PROPERTIES);\n        that._descriptions = that._createDescriptions(field);\n        that._isFieldsModified = true;\n        that.fireEvent(\"fieldChanged\", [field]);\n      }\n\n      return field;\n    },\n    getFieldValues: function getFieldValues(index, applyFilters, options) {\n      var that = this;\n      var field = this._fields && this._fields[index];\n      var store = this.store();\n      var loadFields = [];\n      var loadOptions = {\n        columns: loadFields,\n        rows: [],\n        values: this.getAreaFields(\"data\"),\n        filters: applyFilters ? this._fields.filter(function (f) {\n          return f !== field && f.area && f.filterValues && f.filterValues.length;\n        }) : [],\n        skipValues: true\n      };\n      var searchValue;\n      var d = new _deferred.Deferred();\n\n      if (options) {\n        searchValue = options.searchValue;\n        loadOptions.columnSkip = options.skip;\n        loadOptions.columnTake = options.take;\n      }\n\n      if (field && store) {\n        (0, _iterator.each)(field.levels || [field], function () {\n          loadFields.push((0, _extend.extend)({}, this, {\n            expanded: true,\n            filterValues: null,\n            sortOrder: \"asc\",\n            sortBySummaryField: null,\n            searchValue: searchValue\n          }));\n        });\n        store.load(loadOptions).done(function (data) {\n          if (loadOptions.columnSkip) {\n            data.columns = data.columns.slice(loadOptions.columnSkip);\n          }\n\n          if (loadOptions.columnTake) {\n            data.columns = data.columns.slice(0, loadOptions.columnTake);\n          }\n\n          formatHeaders(loadOptions, data);\n\n          if (!loadOptions.columnTake) {\n            that._sort(loadOptions, data);\n          }\n\n          d.resolve(data.columns);\n        }).fail(d);\n      } else {\n        d.reject();\n      }\n\n      return d;\n    },\n    reload: function reload() {\n      return this.load({\n        reload: true\n      });\n    },\n    filter: function filter() {\n      var store = this._store;\n      return store.filter.apply(store, arguments);\n    },\n    load: function load(options) {\n      var that = this;\n      var d = new _deferred.Deferred();\n      options = options || {};\n      that.beginLoading();\n      d.fail(function (e) {\n        that.fireEvent(\"loadError\", [e]);\n      }).always(function () {\n        that.endLoading();\n      });\n\n      function loadTask() {\n        that._delayedLoadTask = void 0;\n\n        if (!that._descriptions) {\n          (0, _deferred.when)(getFields(that)).done(function (fields) {\n            that._fieldsPrepared(fields);\n\n            that._loadCore(options, d);\n          }).fail(d.reject).fail(that._loadErrorHandler);\n        } else {\n          that._loadCore(options, d);\n        }\n      }\n\n      if (that.store()) {\n        that._delayedLoadTask = (0, _common.executeAsync)(loadTask);\n      } else {\n        loadTask();\n      }\n\n      return d;\n    },\n    createDrillDownDataSource: function createDrillDownDataSource(params) {\n      return this._store.createDrillDownDataSource(this._descriptions, params);\n    },\n    _createDescriptions: function _createDescriptions(currentField) {\n      var that = this;\n      var fields = that.fields();\n      var descriptions = {\n        rows: [],\n        columns: [],\n        values: [],\n        filters: []\n      };\n      (0, _iterator.each)([\"row\", \"column\", \"data\", \"filter\"], function (_, areaName) {\n        (0, _array.normalizeIndexes)(_getAreaFields(fields, areaName), \"areaIndex\", currentField);\n      });\n      (0, _iterator.each)(fields || [], function (_, field) {\n        var descriptionName = DESCRIPTION_NAME_BY_AREA[field.area];\n        var dimension = descriptions[descriptionName];\n        var groupName = field.groupName;\n\n        if (groupName && !(0, _type.isNumeric)(field.groupIndex)) {\n          field.levels = getFieldsByGroup(fields, field);\n        }\n\n        if (!dimension || groupName && (0, _type.isNumeric)(field.groupIndex) || false === field.visible && \"data\" !== field.area && \"filter\" !== field.area) {\n          return;\n        }\n\n        if (field.levels && dimension !== descriptions.filters && dimension !== descriptions.values) {\n          dimension.push.apply(dimension, field.levels);\n\n          if (field.filterValues && field.filterValues.length) {\n            descriptions.filters.push(field);\n          }\n        } else {\n          dimension.push(field);\n        }\n      });\n      (0, _iterator.each)(descriptions, function (_, fields) {\n        sortFieldsByAreaIndex(fields);\n      });\n      var indices = {};\n      (0, _iterator.each)(descriptions.values, function (_, field) {\n        var expression = field.calculateSummaryValue;\n\n        if ((0, _type.isFunction)(expression)) {\n          var summaryCell = (0, _uiPivot_grid.createMockSummaryCell)(descriptions, fields, indices);\n          expression(summaryCell);\n        }\n      });\n      return descriptions;\n    },\n    _fieldsPrepared: function _fieldsPrepared(fields) {\n      var that = this;\n      that._fields = fields;\n      (0, _iterator.each)(fields, function (index, field) {\n        field.index = index;\n        updateCalculatedFieldProperties(field, ALL_CALCULATED_PROPERTIES);\n      });\n      var currentFieldState = getFieldsState(fields, [\"caption\"]);\n      that.fireEvent(\"fieldsPrepared\", [fields]);\n\n      for (var i = 0; i < fields.length; i++) {\n        if (fields[i].caption !== currentFieldState[i].caption) {\n          (0, _uiPivot_grid2.setFieldProperty)(fields[i], \"caption\", fields[i].caption, true);\n        }\n      }\n\n      that._descriptions = that._createDescriptions();\n    },\n    isLoading: function isLoading() {\n      return this._loadingCount > 0;\n    },\n    state: function state(_state, skipLoading) {\n      var that = this;\n\n      if (arguments.length) {\n        _state = (0, _extend.extend)({\n          rowExpandedPaths: [],\n          columnExpandedPaths: []\n        }, _state);\n\n        if (!that._descriptions) {\n          that.beginLoading();\n          (0, _deferred.when)(getFields(that)).done(function (fields) {\n            that._fields = setFieldsState(_state.fields, fields);\n\n            that._fieldsPrepared(fields);\n\n            !skipLoading && that.load(_state);\n          }).always(function () {\n            that.endLoading();\n          });\n        } else {\n          that._fields = setFieldsState(_state.fields, that._fields);\n          that._descriptions = that._createDescriptions();\n          !skipLoading && that.load(_state);\n        }\n      } else {\n        return {\n          fields: getFieldsState(that._fields, STATE_PROPERTIES),\n          columnExpandedPaths: getExpandedPaths(that._data, that._descriptions, \"columns\"),\n          rowExpandedPaths: getExpandedPaths(that._data, that._descriptions, \"rows\")\n        };\n      }\n    },\n    beginLoading: function beginLoading() {\n      this._changeLoadingCount(1);\n    },\n    endLoading: function endLoading() {\n      this._changeLoadingCount(-1);\n    },\n    _changeLoadingCount: function _changeLoadingCount(increment) {\n      var oldLoading = this.isLoading();\n      this._loadingCount += increment;\n      var newLoading = this.isLoading();\n\n      if (oldLoading ^ newLoading) {\n        this.fireEvent(\"loadingChanged\", [newLoading]);\n      }\n    },\n    _hasPagingValues: function _hasPagingValues(options, area, oppositeIndex) {\n      var takeField = area + \"Take\";\n      var skipField = area + \"Skip\";\n      var values = this._data.values;\n      var items = this._data[area + \"s\"];\n      var oppositeArea = \"row\" === area ? \"column\" : \"row\";\n      var indices = [];\n\n      if (options.path && options.area === area) {\n        var headerItem = findHeaderItem(items, options.path);\n        items = headerItem && headerItem.children;\n\n        if (!items) {\n          return false;\n        }\n      }\n\n      if (options.oppositePath && options.area === oppositeArea) {\n        var _headerItem = findHeaderItem(items, options.oppositePath);\n\n        items = _headerItem && _headerItem.children;\n\n        if (!items) {\n          return false;\n        }\n      }\n\n      for (var i = options[skipField]; i < options[skipField] + options[takeField]; i++) {\n        if (items[i]) {\n          indices.push(items[i].index);\n        }\n      }\n\n      return indices.every(function (index) {\n        if (void 0 !== index) {\n          if (\"row\" === area) {\n            return (values[index] || [])[oppositeIndex];\n          } else {\n            return (values[oppositeIndex] || [])[index];\n          }\n        }\n      });\n    },\n    _processPagingCacheByArea: function _processPagingCacheByArea(options, pageSize, area) {\n      var takeField = area + \"Take\";\n      var skipField = area + \"Skip\";\n      var items = this._data[area + \"s\"];\n      var oppositeArea = \"row\" === area ? \"column\" : \"row\";\n      var item;\n\n      if (options[takeField]) {\n        if (options.path && options.area === area) {\n          var headerItem = findHeaderItem(items, options.path);\n          items = headerItem && headerItem.children || [];\n        }\n\n        if (options.oppositePath && options.area === oppositeArea) {\n          var _headerItem2 = findHeaderItem(items, options.oppositePath);\n\n          items = _headerItem2 && _headerItem2.children || [];\n        }\n\n        do {\n          item = items[options[skipField]];\n\n          if (item && void 0 !== item.index) {\n            if (this._hasPagingValues(options, oppositeArea, item.index)) {\n              options[skipField]++;\n              options[takeField]--;\n            } else {\n              break;\n            }\n          }\n        } while (item && void 0 !== item.index && options[takeField]);\n\n        if (options[takeField]) {\n          var start = Math.floor(options[skipField] / pageSize) * pageSize;\n          var end = Math.ceil((options[skipField] + options[takeField]) / pageSize) * pageSize;\n          options[skipField] = start;\n          options[takeField] = end - start;\n        }\n      }\n    },\n    _processPagingCache: function _processPagingCache(storeLoadOptions) {\n      var pageSize = this._pageSize;\n\n      if (pageSize < 0) {\n        return;\n      }\n\n      for (var i = 0; i < storeLoadOptions.length; i++) {\n        this._processPagingCacheByArea(storeLoadOptions[i], pageSize, \"row\");\n\n        this._processPagingCacheByArea(storeLoadOptions[i], pageSize, \"column\");\n      }\n    },\n    _loadCore: function _loadCore(options, deferred) {\n      var that = this;\n      var store = this._store;\n      var descriptions = this._descriptions;\n\n      var reload = options.reload || this.paginate() && that._isFieldsModified;\n\n      var paginate = this.paginate();\n      var headerName = DESCRIPTION_NAME_BY_AREA[options.area];\n      options = options || {};\n\n      if (store) {\n        (0, _extend.extend)(options, descriptions);\n        options.columnExpandedPaths = options.columnExpandedPaths || getExpandedPaths(this._data, options, \"columns\", that._lastLoadOptions);\n        options.rowExpandedPaths = options.rowExpandedPaths || getExpandedPaths(this._data, options, \"rows\", that._lastLoadOptions);\n\n        if (paginate) {\n          options.pageSize = this._pageSize;\n        }\n\n        if (headerName) {\n          options.headerName = headerName;\n        }\n\n        that.beginLoading();\n        deferred.always(function () {\n          that.endLoading();\n        });\n        var storeLoadOptions = [options];\n        that.fireEvent(\"customizeStoreLoadOptions\", [storeLoadOptions, reload]);\n\n        if (!reload) {\n          that._processPagingCache(storeLoadOptions);\n        }\n\n        storeLoadOptions = storeLoadOptions.filter(function (options) {\n          return !(options.rows.length && 0 === options.rowTake) && !(options.columns.length && 0 === options.columnTake);\n        });\n\n        if (!storeLoadOptions.length) {\n          that._update(deferred);\n\n          return;\n        }\n\n        var results = storeLoadOptions.map(function (options) {\n          return store.load(options);\n        });\n\n        _deferred.when.apply(null, results).done(function () {\n          var results = arguments;\n\n          for (var i = 0; i < results.length; i++) {\n            var _options = storeLoadOptions[i];\n            var data = results[i];\n            var isLast = i === results.length - 1;\n\n            if (_options.path) {\n              that.applyPartialDataSource(_options.area, _options.path, data, isLast ? deferred : false, _options.oppositePath);\n            } else {\n              if (paginate && !reload && isDataExists(that._data)) {\n                that.mergePartialDataSource(data, isLast ? deferred : false);\n              } else {\n                (0, _extend.extend)(that._data, data);\n                that._lastLoadOptions = _options;\n\n                that._update(isLast ? deferred : false);\n              }\n            }\n          }\n        }).fail(deferred.reject);\n      } else {\n        that._update(deferred);\n      }\n    },\n    _sort: function _sort(descriptions, data, getAscOrder) {\n      var store = this._store;\n\n      if (store && !this._paginate) {\n        sort(descriptions, data, getAscOrder);\n      }\n    },\n    paginate: function paginate() {\n      return this._paginate && this._store && this._store.supportPaging();\n    },\n    isEmpty: function isEmpty() {\n      var dataFields = this.getAreaFields(\"data\");\n      var data = this.getData();\n      return !dataFields.length || !data.values.length;\n    },\n    _update: function _update(deferred) {\n      var that = this;\n      var descriptions = that._descriptions;\n      var loadedData = that._data;\n      var dataFields = descriptions.values;\n      var expressionsUsed = areExpressionsUsed(dataFields);\n      (0, _deferred.when)(formatHeaders(descriptions, loadedData), updateCache(loadedData.rows), updateCache(loadedData.columns)).done(function () {\n        if (expressionsUsed) {\n          that._sort(descriptions, loadedData, expressionsUsed);\n\n          !that.isEmpty() && (0, _uiPivot_grid.applyDisplaySummaryMode)(descriptions, loadedData);\n        }\n\n        that._sort(descriptions, loadedData);\n\n        !that.isEmpty() && isRunningTotalUsed(dataFields) && (0, _uiPivot_grid.applyRunningTotal)(descriptions, loadedData);\n        that._data = loadedData;\n        false !== deferred && (0, _deferred.when)(deferred).done(function () {\n          that._isFieldsModified = false;\n          that.fireEvent(\"changed\");\n\n          if ((0, _type.isDefined)(that._data.grandTotalRowIndex)) {\n            loadedData.grandTotalRowIndex = that._data.grandTotalRowIndex;\n          }\n\n          if ((0, _type.isDefined)(that._data.grandTotalColumnIndex)) {\n            loadedData.grandTotalColumnIndex = that._data.grandTotalColumnIndex;\n          }\n        });\n        deferred && deferred.resolve(that._data);\n      });\n      return deferred;\n    },\n    store: function store() {\n      return this._store;\n    },\n    collapseHeaderItem: function collapseHeaderItem(area, path) {\n      var that = this;\n      var headerItems = \"column\" === area ? that._data.columns : that._data.rows;\n      var headerItem = findHeaderItem(headerItems, path);\n      var field = that.getAreaFields(area)[path.length - 1];\n\n      if (headerItem && headerItem.children) {\n        that.fireEvent(\"expandValueChanging\", [{\n          area: area,\n          path: path,\n          expanded: false\n        }]);\n\n        if (field) {\n          field.expanded = false;\n        }\n\n        headerItem.collapsedChildren = headerItem.children;\n        delete headerItem.children;\n\n        that._update();\n\n        if (that.paginate()) {\n          that.load();\n        }\n\n        return true;\n      }\n\n      return false;\n    },\n    collapseAll: function collapseAll(id) {\n      var _this = this;\n\n      var dataChanged = false;\n      var field = this.field(id) || {};\n      var areaOffsets = [(0, _array.inArray)(field, this.getAreaFields(field.area))];\n      field.expanded = false;\n\n      if (field && field.levels) {\n        areaOffsets = [];\n        field.levels.forEach(function (f) {\n          areaOffsets.push((0, _array.inArray)(f, _this.getAreaFields(field.area)));\n          f.expanded = false;\n        });\n      }\n\n      (0, _uiPivot_grid2.foreachTree)(this._data[field.area + \"s\"], function (items) {\n        var item = items[0];\n        var path = (0, _uiPivot_grid2.createPath)(items);\n\n        if (item && item.children && areaOffsets.indexOf(path.length - 1) !== -1) {\n          item.collapsedChildren = item.children;\n          delete item.children;\n          dataChanged = true;\n        }\n      }, true);\n      dataChanged && this._update();\n    },\n    expandAll: function expandAll(id) {\n      var field = this.field(id);\n\n      if (field && field.area) {\n        field.expanded = true;\n\n        if (field && field.levels) {\n          field.levels.forEach(function (f) {\n            f.expanded = true;\n          });\n        }\n\n        this.load();\n      }\n    },\n    expandHeaderItem: function expandHeaderItem(area, path) {\n      var that = this;\n      var hasCache;\n      var headerItems = \"column\" === area ? that._data.columns : that._data.rows;\n      var headerItem = findHeaderItem(headerItems, path);\n      var options;\n\n      if (headerItem && !headerItem.children) {\n        hasCache = !!headerItem.collapsedChildren;\n        options = {\n          area: area,\n          path: path,\n          expanded: true,\n          needExpandData: !hasCache\n        };\n        that.fireEvent(\"expandValueChanging\", [options]);\n\n        if (hasCache) {\n          headerItem.children = headerItem.collapsedChildren;\n          delete headerItem.collapsedChildren;\n\n          that._update();\n        } else {\n          that.load(options);\n        }\n\n        return hasCache;\n      }\n\n      return false;\n    },\n    mergePartialDataSource: function mergePartialDataSource(dataSource, deferred) {\n      var that = this;\n      var loadedData = that._data;\n      var newRowItemIndexesToCurrent;\n      var newColumnItemIndexesToCurrent;\n\n      if (dataSource && dataSource.values) {\n        dataSource.rows = dataSource.rows || [];\n        dataSource.columns = dataSource.columns || [];\n        newRowItemIndexesToCurrent = updateHeaderItems(loadedData.rows, dataSource.rows, loadedData.grandTotalColumnIndex);\n        newColumnItemIndexesToCurrent = updateHeaderItems(loadedData.columns, dataSource.columns, loadedData.grandTotalColumnIndex);\n        (0, _deferred.when)(newRowItemIndexesToCurrent, newColumnItemIndexesToCurrent).done(function (newRowItemIndexesToCurrent, newColumnItemIndexesToCurrent) {\n          if (newRowItemIndexesToCurrent.length || newColumnItemIndexesToCurrent.length) {\n            updateDataSourceCells(loadedData, dataSource.values, newRowItemIndexesToCurrent, newColumnItemIndexesToCurrent);\n          }\n\n          that._update(deferred);\n        });\n      }\n    },\n    applyPartialDataSource: function applyPartialDataSource(area, path, dataSource, deferred, oppositePath) {\n      var that = this;\n      var loadedData = that._data;\n      var headerItems = \"column\" === area ? loadedData.columns : loadedData.rows;\n      var headerItem;\n      var oppositeHeaderItems = \"column\" === area ? loadedData.rows : loadedData.columns;\n      var oppositeHeaderItem;\n      var newRowItemIndexesToCurrent;\n      var newColumnItemIndexesToCurrent;\n\n      if (dataSource && dataSource.values) {\n        dataSource.rows = dataSource.rows || [];\n        dataSource.columns = dataSource.columns || [];\n        headerItem = findHeaderItem(headerItems, path);\n        oppositeHeaderItem = oppositePath && findHeaderItem(oppositeHeaderItems, oppositePath);\n\n        if (headerItem) {\n          if (\"column\" === area) {\n            newColumnItemIndexesToCurrent = updateHeaderItemChildren(headerItems, headerItem, dataSource.columns, loadedData.grandTotalColumnIndex);\n\n            if (oppositeHeaderItem) {\n              newRowItemIndexesToCurrent = updateHeaderItemChildren(oppositeHeaderItems, oppositeHeaderItem, dataSource.rows, loadedData.grandTotalRowIndex);\n            } else {\n              newRowItemIndexesToCurrent = updateHeaderItems(loadedData.rows, dataSource.rows, loadedData.grandTotalRowIndex);\n            }\n          } else {\n            newRowItemIndexesToCurrent = updateHeaderItemChildren(headerItems, headerItem, dataSource.rows, loadedData.grandTotalRowIndex);\n\n            if (oppositeHeaderItem) {\n              newColumnItemIndexesToCurrent = updateHeaderItemChildren(oppositeHeaderItems, oppositeHeaderItem, dataSource.columns, loadedData.grandTotalColumnIndex);\n            } else {\n              newColumnItemIndexesToCurrent = updateHeaderItems(loadedData.columns, dataSource.columns, loadedData.grandTotalColumnIndex);\n            }\n          }\n\n          (0, _deferred.when)(newRowItemIndexesToCurrent, newColumnItemIndexesToCurrent).done(function (newRowItemIndexesToCurrent, newColumnItemIndexesToCurrent) {\n            if (\"row\" === area && newRowItemIndexesToCurrent.length || \"column\" === area && newColumnItemIndexesToCurrent.length) {\n              updateDataSourceCells(loadedData, dataSource.values, newRowItemIndexesToCurrent, newColumnItemIndexesToCurrent);\n            }\n\n            that._update(deferred);\n          });\n        }\n      }\n    },\n    dispose: function dispose() {\n      var that = this;\n      var delayedLoadTask = that._delayedLoadTask;\n\n      this._disposeEvents();\n\n      if (delayedLoadTask) {\n        delayedLoadTask.abort();\n      }\n\n      this._isDisposed = true;\n    },\n    isDisposed: function isDisposed() {\n      return !!this._isDisposed;\n    }\n  };\n}()).include(_events_mixin2.default);\nmodule.exports.default = module.exports;","map":null,"metadata":{},"sourceType":"script"}