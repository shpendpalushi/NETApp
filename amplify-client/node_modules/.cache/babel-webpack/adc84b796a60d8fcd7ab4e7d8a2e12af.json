{"ast":null,"code":"/**\r\n * DevExtreme (animation/transition_executor/transition_executor.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar $ = require(\"../../core/renderer\");\n\nvar Class = require(\"../../core/class\");\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar commonUtils = require(\"../../core/utils/common\");\n\nvar typeUtils = require(\"../../core/utils/type\");\n\nvar iteratorUtils = require(\"../../core/utils/iterator\");\n\nvar fx = require(\"../fx\");\n\nvar animationPresetsModule = require(\"../presets/presets\");\n\nvar deferredUtils = require(\"../../core/utils/deferred\");\n\nvar when = deferredUtils.when;\nvar Deferred = deferredUtils.Deferred;\nvar directionPostfixes = {\n  forward: \" dx-forward\",\n  backward: \" dx-backward\",\n  none: \" dx-no-direction\",\n  undefined: \" dx-no-direction\"\n};\nvar DX_ANIMATING_CLASS = \"dx-animating\";\nvar TransitionExecutor = Class.inherit({\n  ctor: function ctor() {\n    this._accumulatedDelays = {\n      enter: 0,\n      leave: 0\n    };\n    this._animations = [];\n    this.reset();\n  },\n  _createAnimations: function _createAnimations($elements, initialConfig, configModifier, type) {\n    var that = this;\n    var result = [];\n    var animationConfig;\n    configModifier = configModifier || {};\n    animationConfig = this._prepareElementAnimationConfig(initialConfig, configModifier, type);\n\n    if (animationConfig) {\n      $elements.each(function () {\n        var animation = that._createAnimation($(this), animationConfig, configModifier);\n\n        if (animation) {\n          animation.element.addClass(DX_ANIMATING_CLASS);\n          animation.setup();\n          result.push(animation);\n        }\n      });\n    }\n\n    return result;\n  },\n  _prepareElementAnimationConfig: function _prepareElementAnimationConfig(config, configModifier, type) {\n    var result;\n\n    if (\"string\" === typeof config) {\n      var presetName = config;\n      config = animationPresetsModule.presets.getPreset(presetName);\n    }\n\n    if (!config) {\n      result = void 0;\n    } else {\n      if (typeUtils.isFunction(config[type])) {\n        result = config[type];\n      } else {\n        result = extend({\n          skipElementInitialStyles: true,\n          cleanupWhen: this._completePromise\n        }, config, configModifier);\n\n        if (!result.type || \"css\" === result.type) {\n          var cssClass = \"dx-\" + type;\n          var extraCssClasses = (result.extraCssClasses ? \" \" + result.extraCssClasses : \"\") + directionPostfixes[result.direction];\n          result.type = \"css\";\n          result.from = (result.from || cssClass) + extraCssClasses;\n          result.to = result.to || cssClass + \"-active\";\n        }\n\n        result.staggerDelay = result.staggerDelay || 0;\n        result.delay = result.delay || 0;\n\n        if (result.staggerDelay) {\n          result.delay += this._accumulatedDelays[type];\n          this._accumulatedDelays[type] += result.staggerDelay;\n        }\n      }\n    }\n\n    return result;\n  },\n  _createAnimation: function _createAnimation($element, animationConfig, configModifier) {\n    var result;\n\n    if (typeUtils.isPlainObject(animationConfig)) {\n      result = fx.createAnimation($element, animationConfig);\n    } else {\n      if (typeUtils.isFunction(animationConfig)) {\n        result = animationConfig($element, configModifier);\n      }\n    }\n\n    return result;\n  },\n  _startAnimations: function _startAnimations() {\n    var animations = this._animations;\n\n    for (var i = 0; i < animations.length; i++) {\n      animations[i].start();\n    }\n  },\n  _stopAnimations: function _stopAnimations(jumpToEnd) {\n    var animations = this._animations;\n\n    for (var i = 0; i < animations.length; i++) {\n      animations[i].stop(jumpToEnd);\n    }\n  },\n  _clearAnimations: function _clearAnimations() {\n    var animations = this._animations;\n\n    for (var i = 0; i < animations.length; i++) {\n      animations[i].element.removeClass(DX_ANIMATING_CLASS);\n    }\n\n    this._animations.length = 0;\n  },\n  reset: function reset() {\n    this._accumulatedDelays.enter = 0;\n    this._accumulatedDelays.leave = 0;\n\n    this._clearAnimations();\n\n    this._completeDeferred = new Deferred();\n    this._completePromise = this._completeDeferred.promise();\n  },\n  enter: function enter($elements, animationConfig, configModifier) {\n    var animations = this._createAnimations($elements, animationConfig, configModifier, \"enter\");\n\n    this._animations.push.apply(this._animations, animations);\n  },\n  leave: function leave($elements, animationConfig, configModifier) {\n    var animations = this._createAnimations($elements, animationConfig, configModifier, \"leave\");\n\n    this._animations.push.apply(this._animations, animations);\n  },\n  start: function start() {\n    var that = this;\n    var result;\n\n    if (!this._animations.length) {\n      that.reset();\n      result = new Deferred().resolve().promise();\n    } else {\n      var animationDeferreds = iteratorUtils.map(this._animations, function (animation) {\n        var result = new Deferred();\n        animation.deferred.always(function () {\n          result.resolve();\n        });\n        return result.promise();\n      });\n      result = when.apply($, animationDeferreds).always(function () {\n        that._completeDeferred.resolve();\n\n        that.reset();\n      });\n      commonUtils.executeAsync(function () {\n        that._startAnimations();\n      });\n    }\n\n    return result;\n  },\n  stop: function stop(jumpToEnd) {\n    this._stopAnimations(jumpToEnd);\n  }\n});\nexports.TransitionExecutor = TransitionExecutor;","map":null,"metadata":{},"sourceType":"script"}