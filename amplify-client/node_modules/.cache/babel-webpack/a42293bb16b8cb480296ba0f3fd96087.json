{"ast":null,"code":"/**\r\n * DevExtreme (ui/scheduler/workspaces/ui.scheduler.work_space_week.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar $ = require(\"../../../core/renderer\");\n\nvar registerComponent = require(\"../../../core/component_registrator\");\n\nvar dateUtils = require(\"../../../core/utils/date\");\n\nvar dateLocalization = require(\"../../../localization/date\");\n\nvar each = require(\"../../../core/utils/iterator\").each;\n\nvar SchedulerWorkSpace = require(\"./ui.scheduler.work_space.indicator\");\n\nvar WEEK_CLASS = \"dx-scheduler-work-space-week\";\nvar toMs = dateUtils.dateToMilliseconds;\nvar SchedulerWorkSpaceWeek = SchedulerWorkSpace.inherit({\n  _getElementClass: function _getElementClass() {\n    return WEEK_CLASS;\n  },\n  _getRowCount: function _getRowCount() {\n    return this._getCellCountInDay();\n  },\n  _getCellCount: function _getCellCount() {\n    return 7 * this.option(\"intervalCount\");\n  },\n  _getDateByIndex: function _getDateByIndex(headerIndex) {\n    var resultDate = new Date(this._firstViewDate);\n    resultDate.setDate(this._firstViewDate.getDate() + headerIndex);\n    return resultDate;\n  },\n  _getFormat: function _getFormat() {\n    return this._formatWeekdayAndDay;\n  },\n  _getStartViewDate: function _getStartViewDate() {\n    return dateUtils.getFirstWeekDate(this.option(\"startDate\"), this._firstDayOfWeek() || dateLocalization.firstDayOfWeekIndex());\n  },\n  _getIntervalDuration: function _getIntervalDuration() {\n    return 7 * toMs(\"day\") * this.option(\"intervalCount\");\n  },\n  _getCellsBetween: function _getCellsBetween($first, $last) {\n    if (this._hasAllDayClass($last)) {\n      return this.callBase($first, $last);\n    }\n\n    var $cells = this._getCells();\n\n    var firstColumn = $first.index();\n    var firstRow = $first.parent().index();\n    var lastColumn = $last.index();\n    var lastRow = $last.parent().index();\n\n    var groupCount = this._getGroupCount();\n\n    var cellCount = groupCount > 0 ? this._getTotalCellCount(groupCount) : this._getCellCount();\n\n    var rowCount = this._getTotalRowCount(groupCount);\n\n    var result = [];\n\n    for (var i = 0; i < cellCount; i++) {\n      for (var j = 0; j < rowCount; j++) {\n        var cell = $cells.get(cellCount * j + i);\n        result.push(cell);\n      }\n    }\n\n    var lastCellGroup = this.getCellData($last).groups;\n    var indexesDifference = this.option(\"showAllDayPanel\") && this._isVerticalGroupedWorkSpace() ? this._getGroupIndexByResourceId(lastCellGroup) + 1 : 0;\n    var newFirstIndex = rowCount * firstColumn + firstRow - indexesDifference;\n    var newLastIndex = rowCount * lastColumn + lastRow - indexesDifference;\n\n    if (newFirstIndex > newLastIndex) {\n      var buffer = newFirstIndex;\n      newFirstIndex = newLastIndex;\n      newLastIndex = buffer;\n    }\n\n    $cells = $(result).slice(newFirstIndex, newLastIndex + 1);\n\n    if (this._getGroupCount()) {\n      var arr = [];\n\n      var focusedGroupIndex = this._getGroupIndexByCell($first);\n\n      each($cells, function (_, cell) {\n        var groupIndex = this._getGroupIndexByCell($(cell));\n\n        if (focusedGroupIndex === groupIndex) {\n          arr.push(cell);\n        }\n      }.bind(this));\n      $cells = $(arr);\n    }\n\n    return $cells;\n  },\n  _getRightCell: function _getRightCell(isMultiSelection) {\n    if (!isMultiSelection) {\n      return this.callBase(isMultiSelection);\n    }\n\n    var $rightCell;\n    var $focusedCell = this._$focusedCell;\n\n    var groupCount = this._getGroupCount();\n\n    var rowCellCount = isMultiSelection ? this._getCellCount() : this._getTotalCellCount(groupCount);\n    var edgeCellIndex = this._isRTL() ? 0 : rowCellCount - 1;\n    var direction = this._isRTL() ? \"prev\" : \"next\";\n\n    if ($focusedCell.index() === edgeCellIndex || this._isGroupEndCell($focusedCell)) {\n      $rightCell = $focusedCell;\n    } else {\n      $rightCell = $focusedCell[direction]();\n      $rightCell = this._checkForViewBounds($rightCell);\n    }\n\n    return $rightCell;\n  },\n  _getLeftCell: function _getLeftCell(isMultiSelection) {\n    if (!isMultiSelection) {\n      return this.callBase(isMultiSelection);\n    }\n\n    var $leftCell;\n    var $focusedCell = this._$focusedCell;\n\n    var groupCount = this._getGroupCount();\n\n    var rowCellCount = isMultiSelection ? this._getCellCount() : this._getTotalCellCount(groupCount);\n    var edgeCellIndex = this._isRTL() ? rowCellCount - 1 : 0;\n    var direction = this._isRTL() ? \"next\" : \"prev\";\n\n    if ($focusedCell.index() === edgeCellIndex || this._isGroupStartCell($focusedCell)) {\n      $leftCell = $focusedCell;\n    } else {\n      $leftCell = $focusedCell[direction]();\n      $leftCell = this._checkForViewBounds($leftCell);\n    }\n\n    return $leftCell;\n  },\n  getPositionShift: function getPositionShift(timeShift, isAllDay) {\n    if (!isAllDay && this.invoke(\"isAdaptive\") && 0 === this.invoke(\"getMaxAppointmentCountPerCellByType\")) {\n      return {\n        top: 0,\n        left: 0,\n        cellPosition: 0\n      };\n    }\n\n    return this.callBase(timeShift, isAllDay);\n  },\n  _isApplyCompactAppointmentOffset: function _isApplyCompactAppointmentOffset() {\n    if (this.invoke(\"isAdaptive\") && 0 === this.invoke(\"getMaxAppointmentCountPerCellByType\")) {\n      return false;\n    }\n\n    return this.callBase();\n  }\n});\nregisterComponent(\"dxSchedulerWorkSpaceWeek\", SchedulerWorkSpaceWeek);\nmodule.exports = SchedulerWorkSpaceWeek;","map":null,"metadata":{},"sourceType":"script"}