{"ast":null,"code":"/**\r\n * DevExtreme (viz/axes/smart_formatter.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.smartFormatter = smartFormatter;\nexports.formatRange = formatRange;\n\nvar _format_helper = require(\"../../format_helper\");\n\nvar _format_helper2 = _interopRequireDefault(_format_helper);\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _date = require(\"../../core/utils/date\");\n\nvar _date2 = _interopRequireDefault(_date);\n\nvar _math = require(\"../../core/utils/math\");\n\nvar _utils = require(\"../core/utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar _format = _format_helper2.default.format;\nvar floor = Math.floor;\nvar abs = Math.abs;\nvar EXPONENTIAL = \"exponential\";\nvar formats = [\"fixedPoint\", \"thousands\", \"millions\", \"billions\", \"trillions\", EXPONENTIAL];\nvar dateUnitIntervals = [\"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"month\", \"year\"];\n\nfunction getDatesDifferences(prevDate, curDate, nextDate, tickFormat) {\n  var prevDifferences;\n  var nextDifferences;\n  var dateUnitInterval;\n  var tickFormatIndex;\n  var dateUnitsLength = dateUnitIntervals.length;\n  var i;\n  var j;\n\n  if (\"week\" === tickFormat) {\n    tickFormat = \"day\";\n  } else {\n    if (\"quarter\" === tickFormat) {\n      tickFormat = \"month\";\n    } else {\n      if (\"shorttime\" === tickFormat) {\n        tickFormat = \"hour\";\n      } else {\n        if (\"longtime\" === tickFormat) {\n          tickFormat = \"second\";\n        }\n      }\n    }\n  }\n\n  tickFormatIndex = dateUnitIntervals.indexOf(tickFormat);\n\n  if (nextDate) {\n    nextDifferences = _date2.default.getDatesDifferences(curDate, nextDate);\n    prevDifferences = _date2.default.getDatesDifferences(curDate, prevDate);\n\n    if (nextDifferences[tickFormat]) {\n      for (i = dateUnitsLength - 1; i >= tickFormatIndex; i--) {\n        dateUnitInterval = dateUnitIntervals[i];\n\n        if (i === tickFormatIndex) {\n          setDateUnitInterval(nextDifferences, tickFormatIndex + (nextDifferences.millisecond ? 2 : 1));\n        } else {\n          if (nextDifferences[dateUnitInterval]) {\n            resetDateUnitInterval(nextDifferences, i);\n            break;\n          }\n        }\n      }\n    }\n  } else {\n    prevDifferences = _date2.default.getDatesDifferences(prevDate, curDate);\n\n    for (i = dateUnitsLength - 1; i >= tickFormatIndex; i--) {\n      dateUnitInterval = dateUnitIntervals[i];\n\n      if (prevDifferences[dateUnitInterval]) {\n        if (i - tickFormatIndex > 1) {\n          for (j = tickFormatIndex + 1; j >= 0; j--) {\n            resetDateUnitInterval(prevDifferences, j);\n          }\n\n          break;\n        } else {\n          if (isDateTimeStart(curDate, dateUnitInterval)) {\n            for (j = i - 1; j > 0; j--) {\n              resetDateUnitInterval(prevDifferences, j);\n            }\n\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  return nextDate ? nextDifferences : prevDifferences;\n}\n\nfunction isDateTimeStart(date, dateUnitInterval) {\n  var unitNumbers = [date.getMilliseconds(), date.getSeconds(), date.getMinutes(), date.getHours(), date.getDate(), date.getMonth()];\n  var unitIndex = dateUnitIntervals.indexOf(dateUnitInterval);\n  var i;\n\n  for (i = 0; i < unitIndex; i++) {\n    if (4 === i && 1 !== unitNumbers[i] || 4 !== i && 0 !== unitNumbers[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction resetDateUnitInterval(differences, intervalIndex) {\n  var dateUnitInterval = dateUnitIntervals[intervalIndex];\n\n  if (differences[dateUnitInterval]) {\n    differences[dateUnitInterval] = false;\n    differences.count--;\n  }\n}\n\nfunction setDateUnitInterval(differences, intervalIndex) {\n  var dateUnitInterval = dateUnitIntervals[intervalIndex];\n\n  if (false === differences[dateUnitInterval]) {\n    differences[dateUnitInterval] = true;\n    differences.count++;\n  }\n}\n\nfunction getNoZeroIndex(str) {\n  return str.length - parseInt(str).toString().length;\n}\n\nfunction getTransitionTickIndex(ticks, value) {\n  var i;\n  var curDiff;\n  var minDiff;\n  var nearestTickIndex = 0;\n  minDiff = abs(value - ticks[0]);\n\n  for (i = 1; i < ticks.length; i++) {\n    curDiff = abs(value - ticks[i]);\n\n    if (curDiff < minDiff) {\n      minDiff = curDiff;\n      nearestTickIndex = i;\n    }\n  }\n\n  return nearestTickIndex;\n}\n\nfunction splitDecimalNumber(value) {\n  return value.toString().split(\".\");\n}\n\nfunction createFormat(type) {\n  var formatter;\n\n  if ((0, _type.isFunction)(type)) {\n    formatter = type;\n    type = null;\n  }\n\n  return {\n    type: type,\n    formatter: formatter\n  };\n}\n\nfunction smartFormatter(tick, options) {\n  var tickInterval = options.tickInterval;\n  var tickIntervalIndex;\n  var tickIndex;\n  var actualIndex;\n  var stringTick = abs(tick).toString();\n  var precision = 0;\n  var typeFormat;\n  var offset = 0;\n  var separatedTickInterval;\n  var indexOfFormat = 0;\n  var indexOfTick = -1;\n  var datesDifferences;\n  var format = options.labelOptions.format;\n  var ticks = options.ticks;\n  var log10Tick;\n  var prevDateIndex;\n  var nextDateIndex;\n  var isLogarithmic = \"logarithmic\" === options.type;\n\n  if (1 === ticks.length && 0 === ticks.indexOf(tick) && !(0, _type.isDefined)(tickInterval)) {\n    tickInterval = abs(tick) >= 1 ? 1 : (0, _math.adjust)(1 - abs(tick), tick);\n  }\n\n  if (!(0, _type.isDefined)(format) && \"discrete\" !== options.type && tick && (10 === options.logarithmBase || !isLogarithmic)) {\n    if (\"datetime\" !== options.dataType && (0, _type.isDefined)(tickInterval)) {\n      if (ticks.length && ticks.indexOf(tick) === -1) {\n        indexOfTick = getTransitionTickIndex(ticks, tick);\n        tickInterval = (0, _math.adjust)(abs(tick - ticks[indexOfTick]), tick);\n      }\n\n      separatedTickInterval = splitDecimalNumber(tickInterval);\n\n      if (separatedTickInterval < 2) {\n        separatedTickInterval = splitDecimalNumber(tick);\n      }\n\n      if (isLogarithmic) {\n        log10Tick = (0, _utils.getAdjustedLog10)(abs(tick));\n\n        if (log10Tick > 0) {\n          typeFormat = formats[floor(log10Tick / 3)] || EXPONENTIAL;\n        } else {\n          if (log10Tick < -4) {\n            typeFormat = EXPONENTIAL;\n          } else {\n            precision = void 0;\n          }\n        }\n      } else {\n        if (separatedTickInterval.length > 1 && !(0, _type.isExponential)(tickInterval)) {\n          precision = separatedTickInterval[1].length;\n          typeFormat = formats[indexOfFormat];\n        } else {\n          if ((0, _type.isExponential)(tickInterval) && (stringTick.indexOf(\".\") !== -1 || (0, _type.isExponential)(tick))) {\n            typeFormat = EXPONENTIAL;\n\n            if (!(0, _type.isExponential)(tick)) {\n              precision = abs(getNoZeroIndex(stringTick.split(\".\")[1]) - (0, _math.getExponent)(tickInterval) + 1);\n            } else {\n              precision = Math.max(abs((0, _math.getExponent)(tick) - (0, _math.getExponent)(tickInterval)), abs((0, _math.getPrecision)(tick) - (0, _math.getPrecision)(tickInterval)));\n            }\n          } else {\n            tickIntervalIndex = floor((0, _utils.getAdjustedLog10)(tickInterval));\n            actualIndex = tickIndex = floor((0, _utils.getAdjustedLog10)(abs(tick)));\n\n            if (tickIndex - tickIntervalIndex >= 2) {\n              actualIndex = tickIntervalIndex;\n            }\n\n            indexOfFormat = floor(actualIndex / 3);\n            offset = 3 * indexOfFormat;\n\n            if (indexOfFormat < 5) {\n              if (tickIntervalIndex - offset === 2 && tickIndex >= 3) {\n                indexOfFormat++;\n                offset = 3 * indexOfFormat;\n              }\n\n              typeFormat = formats[indexOfFormat];\n            } else {\n              typeFormat = formats[formats.length - 1];\n            }\n\n            if (offset > 0) {\n              separatedTickInterval = splitDecimalNumber(tickInterval / Math.pow(10, offset));\n\n              if (separatedTickInterval[1]) {\n                precision = separatedTickInterval[1].length;\n              }\n            }\n          }\n        }\n      }\n\n      if (void 0 !== typeFormat || void 0 !== precision) {\n        format = {\n          type: typeFormat,\n          precision: precision\n        };\n      }\n    } else {\n      if (\"datetime\" === options.dataType) {\n        typeFormat = _date2.default.getDateFormatByTickInterval(tickInterval);\n\n        if (options.showTransition && ticks.length) {\n          indexOfTick = ticks.map(Number).indexOf(+tick);\n\n          if (1 === ticks.length && 0 === indexOfTick) {\n            typeFormat = _format_helper2.default.getDateFormatByTicks(ticks);\n          } else {\n            if (indexOfTick === -1) {\n              prevDateIndex = getTransitionTickIndex(ticks, tick);\n            } else {\n              prevDateIndex = 0 === indexOfTick ? ticks.length - 1 : indexOfTick - 1;\n              nextDateIndex = 0 === indexOfTick ? 1 : -1;\n            }\n\n            datesDifferences = getDatesDifferences(ticks[prevDateIndex], tick, ticks[nextDateIndex], typeFormat);\n            typeFormat = _format_helper2.default.getDateFormatByDifferences(datesDifferences, typeFormat);\n          }\n        }\n\n        format = createFormat(typeFormat);\n      }\n    }\n  }\n\n  return _format(tick, format);\n}\n\nfunction getHighDiffFormat(diff) {\n  var stop = false;\n\n  for (var i in diff) {\n    if (true === diff[i] || \"hour\" === i || stop) {\n      diff[i] = false;\n      stop = true;\n    } else {\n      if (false === diff[i]) {\n        diff[i] = true;\n      }\n    }\n  }\n\n  return createFormat(_format_helper2.default.getDateFormatByDifferences(diff));\n}\n\nfunction getHighAndSelfDiffFormat(diff, interval) {\n  var stop = false;\n\n  for (var i in diff) {\n    if (stop) {\n      diff[i] = false;\n    } else {\n      if (i === interval) {\n        stop = true;\n      } else {\n        diff[i] = true;\n      }\n    }\n  }\n\n  return createFormat(_format_helper2.default.getDateFormatByDifferences(diff));\n}\n\nfunction formatDateRange(startValue, endValue, tickInterval) {\n  var diff = getDatesDifferences(startValue, endValue);\n\n  var typeFormat = _date2.default.getDateFormatByTickInterval(tickInterval);\n\n  var diffFormatType = _format_helper2.default.getDateFormatByDifferences(diff, typeFormat);\n\n  var diffFormat = createFormat(diffFormatType);\n  var values = [];\n\n  if (tickInterval in diff) {\n    var rangeFormat = getHighAndSelfDiffFormat(getDatesDifferences(startValue, endValue), tickInterval);\n\n    var value = _format(startValue, rangeFormat);\n\n    if (value) {\n      values.push(value);\n    }\n  } else {\n    var _rangeFormat = getHighDiffFormat(getDatesDifferences(startValue, endValue));\n\n    var highValue = _format(startValue, _rangeFormat);\n\n    if (highValue) {\n      values.push(highValue);\n    }\n\n    values.push(\"\".concat(_format(startValue, diffFormat), \" - \").concat(_format(endValue, diffFormat)));\n  }\n\n  return values.join(\", \");\n}\n\nfunction processDateInterval(interval) {\n  if ((0, _type.isObject)(interval)) {\n    var dateUnits = Object.keys(interval);\n    var sum = dateUnits.reduce(function (sum, k) {\n      return interval[k] + sum;\n    }, 0);\n\n    if (1 === sum) {\n      var dateUnit = dateUnits.filter(function (k) {\n        return 1 === interval[k];\n      })[0];\n      return dateUnit.slice(0, dateUnit.length - 1);\n    }\n  }\n\n  return interval;\n}\n\nfunction formatRange(startValue, endValue, tickInterval, _ref) {\n  var dataType = _ref.dataType,\n      type = _ref.type,\n      logarithmBase = _ref.logarithmBase;\n\n  if (\"discrete\" === type) {\n    return \"\";\n  }\n\n  if (\"datetime\" === dataType) {\n    return formatDateRange(startValue, endValue, processDateInterval(tickInterval));\n  }\n\n  var formatOptions = {\n    ticks: [],\n    type: type,\n    dataType: dataType,\n    tickInterval: tickInterval,\n    logarithmBase: logarithmBase,\n    labelOptions: {}\n  };\n  return \"\".concat(smartFormatter(startValue, formatOptions), \" - \").concat(smartFormatter(endValue, formatOptions));\n}","map":null,"metadata":{},"sourceType":"script"}