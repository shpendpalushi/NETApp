{"ast":null,"code":"/**\r\n * DevExtreme (viz/vector_map/map_layer.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._TESTS_findGroupingIndex = exports._TESTS_groupBySize = exports._TESTS_stub_groupBySize = exports._TESTS_groupByColor = exports._TESTS_stub_groupByColor = exports._TESTS_performGrouping = exports._TESTS_stub_performGrouping = exports._TESTS_createProxy = exports._TESTS_stub_MapLayerElement = exports._TESTS_MapLayerElement = exports._TESTS_stub_selectStrategy = exports._TESTS_selectStrategy = exports._TESTS_stub_MapLayer = exports._TESTS_MapLayer = void 0;\nexports.getMaxBound = getMaxBound;\nexports.MapLayerCollection = MapLayerCollection;\n\nvar _common = require(\"../../core/utils/common\");\n\nvar _extend2 = require(\"../../core/utils/extend\");\n\nvar _iterator = require(\"../../core/utils/iterator\");\n\nvar _data_helper = require(\"../../data_helper\");\n\nvar _data_helper2 = _interopRequireDefault(_data_helper);\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _deferred = require(\"../../core/utils/deferred\");\n\nvar _deferred2 = _interopRequireDefault(_deferred);\n\nvar _utils = require(\"../core/utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar _noop = _common.noop;\nvar _extend = _extend2.extend;\nvar _each = _iterator.each;\nvar _concat = Array.prototype.concat;\nvar TYPE_AREA = \"area\";\nvar TYPE_LINE = \"line\";\nvar TYPE_MARKER = \"marker\";\nvar STATE_DEFAULT = 0;\nvar STATE_HOVERED = 1;\nvar STATE_SELECTED = 2;\nvar STATE_TO_INDEX = [0, 1, 2, 2];\nvar TOLERANCE = 1;\nvar SELECTIONS = {\n  none: null,\n  single: -1,\n  multiple: NaN\n};\nvar _isArray = Array.isArray;\nvar _Number = Number;\nvar _String = String;\nvar _abs = Math.abs;\nvar _round = Math.round;\nvar _min = Math.min;\nvar _max = Math.max;\nvar _sqrt = Math.sqrt;\n\nfunction getMaxBound(arr) {\n  return arr.reduce(function (a, c) {\n    return c ? [_min(a[0], c[0]), _min(a[1], c[1]), _max(a[2], c[2]), _max(a[3], c[3])] : a;\n  }, arr[0]);\n}\n\nfunction getSelection(selectionMode) {\n  var selection = (0, _utils.normalizeEnum)(selectionMode);\n  selection = selection in SELECTIONS ? SELECTIONS[selection] : SELECTIONS.single;\n\n  if (null !== selection) {\n    selection = {\n      state: {},\n      single: selection\n    };\n  }\n\n  return selection;\n}\n\nfunction getName(opt, index) {\n  return (opt[index] || {}).name;\n}\n\nfunction EmptySource() {}\n\nEmptySource.prototype.count = function () {\n  return 0;\n};\n\nfunction ArraySource(raw) {\n  this.raw = raw;\n}\n\nArraySource.prototype = {\n  constructor: ArraySource,\n  count: function count() {\n    return this.raw.length;\n  },\n  item: function item(index) {\n    return this.raw[index];\n  },\n  geometry: function geometry(item) {\n    return {\n      coordinates: item.coordinates\n    };\n  },\n  attributes: function attributes(item) {\n    return item.attributes;\n  },\n  getBBox: function getBBox(index) {\n    return 0 === arguments.length ? void 0 : this.raw[index].bbox;\n  }\n};\n\nfunction GeoJsonSource(raw) {\n  this.raw = raw;\n}\n\nGeoJsonSource.prototype = {\n  constructor: GeoJsonSource,\n  count: function count() {\n    return this.raw.features.length;\n  },\n  item: function item(index) {\n    return this.raw.features[index];\n  },\n  geometry: function geometry(item) {\n    return item.geometry;\n  },\n  attributes: function attributes(item) {\n    return item.properties;\n  },\n  getBBox: function getBBox(index) {\n    return 0 === arguments.length ? this.raw.bbox : this.raw.features[index].bbox;\n  }\n};\n\nfunction isGeoJsonObject(obj) {\n  return _isArray(obj.features);\n}\n\nfunction unwrapFromDataSource(source) {\n  var sourceType;\n\n  if (source) {\n    if (isGeoJsonObject(source)) {\n      sourceType = GeoJsonSource;\n    } else {\n      if (1 === source.length && source[0] && isGeoJsonObject(source[0])) {\n        sourceType = GeoJsonSource;\n        source = source[0];\n      } else {\n        if (_isArray(source)) {\n          sourceType = ArraySource;\n        }\n      }\n    }\n  }\n\n  sourceType = sourceType || EmptySource;\n  return new sourceType(source);\n}\n\nfunction wrapToDataSource(option) {\n  return option ? isGeoJsonObject(option) ? [option] : option : [];\n}\n\nfunction customizeHandles(proxies, callback, widget) {\n  callback.call(widget, proxies);\n}\n\nfunction setAreaLabelVisibility(label) {\n  label.text.attr({\n    visibility: label.size[0] / label.spaceSize[0] < TOLERANCE && label.size[1] / label.spaceSize[1] < TOLERANCE ? null : \"hidden\"\n  });\n}\n\nfunction setLineLabelVisibility(label) {\n  label.text.attr({\n    visibility: label.size[0] / label.spaceSize[0] < TOLERANCE || label.size[1] / label.spaceSize[1] < TOLERANCE ? null : \"hidden\"\n  });\n}\n\nfunction getDataValue(proxy, dataField) {\n  return proxy.attribute(dataField);\n}\n\nvar TYPE_TO_TYPE_MAP = {\n  Point: TYPE_MARKER,\n  MultiPoint: TYPE_LINE,\n  LineString: TYPE_LINE,\n  MultiLineString: TYPE_LINE,\n  Polygon: TYPE_AREA,\n  MultiPolygon: TYPE_AREA\n};\n\nfunction pick(a, b) {\n  return void 0 !== a ? a : b;\n}\n\nfunction guessTypeByData(sample) {\n  var type = TYPE_TO_TYPE_MAP[sample.type];\n  var coordinates = sample.coordinates;\n\n  if (!type) {\n    if (\"number\" === typeof coordinates[0]) {\n      type = TYPE_MARKER;\n    } else {\n      if (\"number\" === typeof coordinates[0][0]) {\n        type = TYPE_LINE;\n      } else {\n        type = TYPE_AREA;\n      }\n    }\n  }\n\n  return type;\n}\n\nvar selectStrategy = function selectStrategy(options, data) {\n  var type = (0, _utils.normalizeEnum)(options.type);\n  var elementType = (0, _utils.normalizeEnum)(options.elementType);\n  var sample;\n\n  var strategy = _extend({}, emptyStrategy);\n\n  if (data.count() > 0) {\n    sample = data.geometry(data.item(0));\n    type = strategiesByType[type] ? type : guessTypeByData(sample);\n\n    _extend(strategy, strategiesByType[type]);\n\n    strategy.fullType = strategy.type = type;\n\n    if (strategiesByGeometry[type]) {\n      _extend(strategy, strategiesByGeometry[type](sample));\n    }\n\n    if (strategiesByElementType[type]) {\n      elementType = strategiesByElementType[type][elementType] ? elementType : strategiesByElementType[type]._default;\n\n      _extend(strategy, strategiesByElementType[type][elementType]);\n\n      strategy.elementType = elementType;\n      strategy.fullType += \":\" + elementType;\n    }\n  }\n\n  return strategy;\n};\n\nfunction applyElementState(figure, styles, state, field) {\n  figure[field].attr(styles[field][state]);\n}\n\nvar emptyStrategy = {\n  setup: _noop,\n  reset: _noop,\n  arrange: _noop,\n  updateGrouping: _noop,\n  getDefaultColor: _noop\n};\nvar strategiesByType = {};\nstrategiesByType[TYPE_AREA] = {\n  projectLabel: projectAreaLabel,\n  transform: transformPointList,\n  transformLabel: transformAreaLabel,\n  draw: function draw(context, figure, data) {\n    figure.root = context.renderer.path([], \"area\").data(context.dataKey, data);\n  },\n  refresh: _noop,\n  getLabelOffset: function getLabelOffset(label) {\n    setAreaLabelVisibility(label);\n    return [0, 0];\n  },\n  getStyles: function getStyles(settings) {\n    var color = settings.color || null;\n    var borderColor = settings.borderColor || null;\n    var borderWidth = pick(settings.borderWidth, null);\n    var opacity = pick(settings.opacity, null);\n    return {\n      root: [{\n        \"class\": \"dxm-area\",\n        stroke: borderColor,\n        \"stroke-width\": borderWidth,\n        fill: color,\n        opacity: opacity\n      }, {\n        \"class\": \"dxm-area dxm-area-hovered\",\n        stroke: settings.hoveredBorderColor || borderColor,\n        \"stroke-width\": pick(settings.hoveredBorderWidth, borderWidth),\n        fill: settings.hoveredColor || color,\n        opacity: pick(settings.hoveredOpacity, opacity)\n      }, {\n        \"class\": \"dxm-area dxm-area-selected\",\n        stroke: settings.selectedBorderColor || borderColor,\n        \"stroke-width\": pick(settings.selectedBorderWidth, borderWidth),\n        fill: settings.selectedColor || color,\n        opacity: pick(settings.selectedOpacity, opacity)\n      }]\n    };\n  },\n  setState: function setState(figure, styles, state) {\n    applyElementState(figure, styles, state, \"root\");\n  },\n  hasLabelsGroup: true,\n  updateGrouping: function updateGrouping(context) {\n    groupByColor(context);\n  },\n  getDefaultColor: _noop\n};\nstrategiesByType[TYPE_LINE] = {\n  projectLabel: projectLineLabel,\n  transform: transformPointList,\n  transformLabel: transformLineLabel,\n  draw: function draw(context, figure, data) {\n    figure.root = context.renderer.path([], \"line\").data(context.dataKey, data);\n  },\n  refresh: _noop,\n  getLabelOffset: function getLabelOffset(label) {\n    setLineLabelVisibility(label);\n    return [0, 0];\n  },\n  getStyles: function getStyles(settings) {\n    var color = settings.color || settings.borderColor || null;\n    var width = pick(settings.borderWidth, null);\n    var opacity = pick(settings.opacity, null);\n    return {\n      root: [{\n        \"class\": \"dxm-line\",\n        stroke: color,\n        \"stroke-width\": width,\n        opacity: opacity\n      }, {\n        \"class\": \"dxm-line dxm-line-hovered\",\n        stroke: settings.hoveredColor || settings.hoveredBorderColor || color,\n        \"stroke-width\": pick(settings.hoveredBorderWidth, width),\n        opacity: pick(settings.hoveredOpacity, opacity)\n      }, {\n        \"class\": \"dxm-line dxm-line-selected\",\n        stroke: settings.selectedColor || settings.selectedBorderColor || color,\n        \"stroke-width\": pick(settings.selectedBorderWidth, width),\n        opacity: pick(settings.selectedOpacity, opacity)\n      }]\n    };\n  },\n  setState: function setState(figure, styles, state) {\n    applyElementState(figure, styles, state, \"root\");\n  },\n  hasLabelsGroup: true,\n  updateGrouping: function updateGrouping(context) {\n    groupByColor(context);\n  },\n  getDefaultColor: _noop\n};\nstrategiesByType[TYPE_MARKER] = {\n  project: projectPoint,\n  transform: transformPoint,\n  draw: function draw(context, figure, data) {\n    figure.root = context.renderer.g();\n\n    this._draw(context, figure, data);\n  },\n  refresh: _noop,\n  hasLabelsGroup: false,\n  getLabelOffset: function getLabelOffset(label, settings) {\n    return [_round((label.size[0] + _max(settings.size || 0, 0)) / 2) + 2, 0];\n  },\n  getStyles: function getStyles(settings) {\n    var styles = {\n      root: [{\n        \"class\": \"dxm-marker\"\n      }, {\n        \"class\": \"dxm-marker dxm-marker-hovered\"\n      }, {\n        \"class\": \"dxm-marker dxm-marker-selected\"\n      }]\n    };\n\n    this._getStyles(styles, settings);\n\n    return styles;\n  },\n  setState: function setState(figure, styles, state) {\n    applyElementState(figure, styles, state, \"root\");\n\n    this._setState(figure, styles, state);\n  },\n  updateGrouping: function updateGrouping(context) {\n    groupByColor(context);\n    groupBySize(context);\n  },\n  getDefaultColor: function getDefaultColor(ctx, palette) {\n    return ctx.params.themeManager.getAccentColor(palette);\n  }\n};\nvar strategiesByGeometry = {};\n\nstrategiesByGeometry[TYPE_AREA] = function (sample) {\n  var coordinates = sample.coordinates;\n  return {\n    project: coordinates[0] && coordinates[0][0] && coordinates[0][0][0] && \"number\" === typeof coordinates[0][0][0][0] ? projectMultiPolygon : projectPolygon\n  };\n};\n\nstrategiesByGeometry[TYPE_LINE] = function (sample) {\n  var coordinates = sample.coordinates;\n  return {\n    project: coordinates[0] && coordinates[0][0] && \"number\" === typeof coordinates[0][0][0] ? projectPolygon : projectLineString\n  };\n};\n\nvar strategiesByElementType = {};\nstrategiesByElementType[TYPE_MARKER] = {\n  _default: \"dot\",\n  dot: {\n    setup: function setup(context) {\n      context.filter = context.renderer.shadowFilter(\"-40%\", \"-40%\", \"180%\", \"200%\", 0, 1, 1, \"#000000\", .2);\n    },\n    reset: function reset(context) {\n      context.filter.dispose();\n      context.filter = null;\n    },\n    _draw: function _draw(ctx, figure, data) {\n      figure.back = ctx.renderer.circle().sharp().data(ctx.dataKey, data).append(figure.root);\n      figure.dot = ctx.renderer.circle().sharp().data(ctx.dataKey, data).append(figure.root);\n    },\n    refresh: function refresh(ctx, figure, data, proxy, settings) {\n      figure.dot.attr({\n        filter: settings.shadow ? ctx.filter.id : null\n      });\n    },\n    _getStyles: function _getStyles(styles, style) {\n      var size = style.size > 0 ? _Number(style.size) : 0;\n      var hoveredSize = size;\n      var selectedSize = size + (style.selectedStep > 0 ? _Number(style.selectedStep) : 0);\n      var hoveredBackSize = hoveredSize + (style.backStep > 0 ? _Number(style.backStep) : 0);\n      var selectedBackSize = selectedSize + (style.backStep > 0 ? _Number(style.backStep) : 0);\n      var color = style.color || null;\n      var borderColor = style.borderColor || null;\n      var borderWidth = pick(style.borderWidth, null);\n      var opacity = pick(style.opacity, null);\n      var backColor = style.backColor || null;\n      var backOpacity = pick(style.backOpacity, null);\n      styles.dot = [{\n        r: size / 2,\n        stroke: borderColor,\n        \"stroke-width\": borderWidth,\n        fill: color,\n        opacity: opacity\n      }, {\n        r: hoveredSize / 2,\n        stroke: style.hoveredBorderColor || borderColor,\n        \"stroke-width\": pick(style.hoveredBorderWidth, borderWidth),\n        fill: style.hoveredColor || color,\n        opacity: pick(style.hoveredOpacity, opacity)\n      }, {\n        r: selectedSize / 2,\n        stroke: style.selectedBorderColor || borderColor,\n        \"stroke-width\": pick(style.selectedBorderWidth, borderWidth),\n        fill: style.selectedColor || color,\n        opacity: pick(style.selectedOpacity, opacity)\n      }];\n      styles.back = [{\n        r: size / 2,\n        stroke: \"none\",\n        \"stroke-width\": 0,\n        fill: backColor,\n        opacity: backOpacity\n      }, {\n        r: hoveredBackSize / 2,\n        stroke: \"none\",\n        \"stroke-width\": 0,\n        fill: backColor,\n        opacity: backOpacity\n      }, {\n        r: selectedBackSize / 2,\n        stroke: \"none\",\n        \"stroke-width\": 0,\n        fill: backColor,\n        opacity: backOpacity\n      }];\n    },\n    _setState: function _setState(figure, styles, state) {\n      applyElementState(figure, styles, state, \"dot\");\n      applyElementState(figure, styles, state, \"back\");\n    }\n  },\n  bubble: {\n    _draw: function _draw(ctx, figure, data) {\n      figure.bubble = ctx.renderer.circle().sharp().data(ctx.dataKey, data).append(figure.root);\n    },\n    refresh: function refresh(ctx, figure, data, proxy, settings) {\n      figure.bubble.attr({\n        r: settings.size / 2\n      });\n    },\n    _getStyles: function _getStyles(styles, style) {\n      var color = style.color || null;\n      var borderColor = style.borderColor || null;\n      var borderWidth = pick(style.borderWidth, null);\n      var opacity = pick(style.opacity, null);\n      styles.bubble = [{\n        stroke: borderColor,\n        \"stroke-width\": borderWidth,\n        fill: color,\n        opacity: opacity\n      }, {\n        stroke: style.hoveredBorderColor || borderColor,\n        \"stroke-width\": pick(style.hoveredBorderWidth, borderWidth),\n        fill: style.hoveredColor || style.color,\n        opacity: pick(style.hoveredOpacity, opacity)\n      }, {\n        stroke: style.selectedBorderColor || borderColor,\n        \"stroke-width\": pick(style.selectedBorderWidth, borderWidth),\n        fill: style.selectedColor || style.color,\n        opacity: pick(style.selectedOpacity, opacity)\n      }];\n    },\n    _setState: function _setState(figure, styles, state) {\n      applyElementState(figure, styles, state, \"bubble\");\n    },\n    arrange: function arrange(context, handles) {\n      var values = [];\n      var i;\n      var ii = values.length = handles.length;\n      var settings = context.settings;\n      var dataField = settings.dataField;\n      var minSize = settings.minSize > 0 ? _Number(settings.minSize) : 0;\n      var maxSize = settings.maxSize > minSize ? _Number(settings.maxSize) : minSize;\n      var minValue;\n      var maxValue;\n      var deltaValue;\n      var deltaSize;\n\n      if (settings.sizeGroups) {\n        return;\n      }\n\n      for (i = 0; i < ii; ++i) {\n        values[i] = _max(getDataValue(handles[i].proxy, dataField) || 0, 0);\n      }\n\n      minValue = _min.apply(null, values);\n      maxValue = _max.apply(null, values);\n      deltaValue = maxValue - minValue || 1;\n      deltaSize = maxSize - minSize;\n\n      for (i = 0; i < ii; ++i) {\n        handles[i]._settings.size = minSize + deltaSize * (values[i] - minValue) / deltaValue;\n      }\n    },\n    updateGrouping: function updateGrouping(context) {\n      var dataField = context.settings.dataField;\n      strategiesByType[TYPE_MARKER].updateGrouping(context);\n      groupBySize(context, function (proxy) {\n        return getDataValue(proxy, dataField);\n      });\n    }\n  },\n  pie: {\n    _draw: function _draw(ctx, figure, data) {\n      figure.pie = ctx.renderer.g().append(figure.root);\n      figure.border = ctx.renderer.circle().sharp().data(ctx.dataKey, data).append(figure.root);\n    },\n    refresh: function refresh(ctx, figure, data, proxy, settings) {\n      var values = getDataValue(proxy, ctx.settings.dataField) || [];\n      var colors = settings._colors;\n      var sum = 0;\n      var pie = figure.pie;\n      var renderer = ctx.renderer;\n      var dataKey = ctx.dataKey;\n      var r = (settings.size > 0 ? _Number(settings.size) : 0) / 2;\n      var start = 90;\n      var end = start;\n      var zeroSum = false;\n      sum = values.reduce(function (total, item) {\n        return total + (item || 0);\n      }, 0);\n\n      if (0 === sum) {\n        zeroSum = true;\n        sum = 360 / values.length;\n      }\n\n      values.forEach(function (item, i) {\n        start = end;\n        end += zeroSum ? sum : (item || 0) / sum * 360;\n        renderer.arc(0, 0, 0, r, start, end).attr({\n          \"stroke-linejoin\": \"round\",\n          fill: colors[i]\n        }).data(dataKey, data).append(pie);\n      });\n      figure.border.attr({\n        r: r\n      });\n    },\n    _getStyles: function _getStyles(styles, style) {\n      var opacity = pick(style.opacity, null);\n      var borderColor = style.borderColor || null;\n      var borderWidth = pick(style.borderWidth, null);\n      styles.pie = [{\n        opacity: opacity\n      }, {\n        opacity: pick(style.hoveredOpacity, opacity)\n      }, {\n        opacity: pick(style.selectedOpacity, opacity)\n      }];\n      styles.border = [{\n        stroke: borderColor,\n        \"stroke-width\": borderWidth\n      }, {\n        stroke: style.hoveredBorderColor || borderColor,\n        \"stroke-width\": pick(style.hoveredBorderWidth, borderWidth)\n      }, {\n        stroke: style.selectedBorderColor || borderColor,\n        \"stroke-width\": pick(style.selectedBorderWidth, borderWidth)\n      }];\n    },\n    _setState: function _setState(figure, styles, state) {\n      applyElementState(figure, styles, state, \"pie\");\n      applyElementState(figure, styles, state, \"border\");\n    },\n    arrange: function arrange(context, handles) {\n      var i;\n      var ii = handles.length;\n      var dataField = context.settings.dataField;\n      var values;\n      var count = 0;\n      var palette;\n\n      for (i = 0; i < ii; ++i) {\n        values = getDataValue(handles[i].proxy, dataField);\n\n        if (values && values.length > count) {\n          count = values.length;\n        }\n      }\n\n      if (count > 0) {\n        palette = context.params.themeManager.createPalette(context.settings.palette, {\n          useHighlight: true,\n          extensionMode: \"alternate\"\n        });\n        values = palette.generateColors(count);\n        context.settings._colors = values;\n        context.grouping.color = {\n          callback: _noop,\n          field: \"\",\n          partition: [],\n          values: []\n        };\n        context.params.dataExchanger.set(context.name, \"color\", {\n          partition: [],\n          values: values\n        });\n      }\n    }\n  },\n  image: {\n    _draw: function _draw(ctx, figure, data) {\n      figure.image = ctx.renderer.image(null, null, null, null, null, \"center\").attr({\n        \"pointer-events\": \"visible\"\n      }).data(ctx.dataKey, data).append(figure.root);\n    },\n    refresh: function refresh(ctx, figure, data, proxy) {\n      figure.image.attr({\n        href: getDataValue(proxy, ctx.settings.dataField)\n      });\n    },\n    _getStyles: function _getStyles(styles, style) {\n      var size = style.size > 0 ? _Number(style.size) : 0;\n      var hoveredSize = size + (style.hoveredStep > 0 ? _Number(style.hoveredStep) : 0);\n      var selectedSize = size + (style.selectedStep > 0 ? _Number(style.selectedStep) : 0);\n      var opacity = pick(style.opacity, null);\n      styles.image = [{\n        x: -size / 2,\n        y: -size / 2,\n        width: size,\n        height: size,\n        opacity: opacity\n      }, {\n        x: -hoveredSize / 2,\n        y: -hoveredSize / 2,\n        width: hoveredSize,\n        height: hoveredSize,\n        opacity: pick(style.hoveredOpacity, opacity)\n      }, {\n        x: -selectedSize / 2,\n        y: -selectedSize / 2,\n        width: selectedSize,\n        height: selectedSize,\n        opacity: pick(style.selectedOpacity, opacity)\n      }];\n    },\n    _setState: function _setState(figure, styles, state) {\n      applyElementState(figure, styles, state, \"image\");\n    }\n  }\n};\n\nfunction projectPoint(projection, coordinates) {\n  return projection.project(coordinates);\n}\n\nfunction projectPointList(projection, coordinates) {\n  var output = [];\n  var i;\n  var ii = output.length = coordinates.length;\n\n  for (i = 0; i < ii; ++i) {\n    output[i] = projection.project(coordinates[i]);\n  }\n\n  return output;\n}\n\nfunction projectLineString(projection, coordinates) {\n  return [projectPointList(projection, coordinates)];\n}\n\nfunction projectPolygon(projection, coordinates) {\n  var output = [];\n  var i;\n  var ii = output.length = coordinates.length;\n\n  for (i = 0; i < ii; ++i) {\n    output[i] = projectPointList(projection, coordinates[i]);\n  }\n\n  return output;\n}\n\nfunction projectMultiPolygon(projection, coordinates) {\n  var output = [];\n  var i;\n  var ii = output.length = coordinates.length;\n\n  for (i = 0; i < ii; ++i) {\n    output[i] = projectPolygon(projection, coordinates[i]);\n  }\n\n  return _concat.apply([], output);\n}\n\nfunction transformPoint(content, projection, coordinates) {\n  var data = projection.transform(coordinates);\n  content.root.attr({\n    translateX: data[0],\n    translateY: data[1]\n  });\n}\n\nfunction transformList(projection, coordinates) {\n  var output = [];\n  var i;\n  var ii = coordinates.length;\n  var item;\n  var k = 0;\n  output.length = 2 * ii;\n\n  for (i = 0; i < ii; ++i) {\n    item = projection.transform(coordinates[i]);\n    output[k++] = item[0];\n    output[k++] = item[1];\n  }\n\n  return output;\n}\n\nfunction transformPointList(content, projection, coordinates) {\n  var output = [];\n  var i;\n  var ii = output.length = coordinates.length;\n\n  for (i = 0; i < ii; ++i) {\n    output[i] = transformList(projection, coordinates[i]);\n  }\n\n  content.root.attr({\n    points: output\n  });\n}\n\nfunction transformAreaLabel(label, projection, coordinates) {\n  var data = projection.transform(coordinates[0]);\n  label.spaceSize = projection.getSquareSize(coordinates[1]);\n  label.text.attr({\n    translateX: data[0],\n    translateY: data[1]\n  });\n  setAreaLabelVisibility(label);\n}\n\nfunction transformLineLabel(label, projection, coordinates) {\n  var data = projection.transform(coordinates[0]);\n  label.spaceSize = projection.getSquareSize(coordinates[1]);\n  label.text.attr({\n    translateX: data[0],\n    translateY: data[1]\n  });\n  setLineLabelVisibility(label);\n}\n\nfunction getItemSettings(context, proxy, settings) {\n  var result = combineSettings(context.settings, settings);\n  applyGrouping(context.grouping, proxy, result);\n\n  if (void 0 === settings.color && settings.paletteIndex >= 0) {\n    result.color = result._colors[settings.paletteIndex];\n  }\n\n  return result;\n}\n\nfunction applyGrouping(grouping, proxy, settings) {\n  _each(grouping, function (name, data) {\n    var index = findGroupingIndex(data.callback(proxy, data.field), data.partition);\n\n    if (index >= 0) {\n      settings[name] = data.values[index];\n    }\n  });\n}\n\nfunction findGroupingIndex(value, partition) {\n  var start = 0;\n  var end = partition.length - 1;\n  var index = -1;\n  var middle;\n\n  if (partition[start] <= value && value <= partition[end]) {\n    if (value === partition[end]) {\n      index = end - 1;\n    } else {\n      while (end - start > 1) {\n        middle = start + end >> 1;\n\n        if (value < partition[middle]) {\n          end = middle;\n        } else {\n          start = middle;\n        }\n      }\n\n      index = start;\n    }\n  }\n\n  return index;\n}\n\nfunction raiseChanged(context, handle, state, name) {\n  context.params.eventTrigger(name, {\n    target: handle.proxy,\n    state: state\n  });\n}\n\nfunction combineSettings(common, partial) {\n  var obj = _extend({}, common, partial);\n\n  obj.label = _extend({}, common.label, obj.label);\n  obj.label.font = _extend({}, common.label.font, obj.label.font);\n  return obj;\n}\n\nfunction processCommonSettings(context, options) {\n  var themeManager = context.params.themeManager;\n  var strategy = context.str;\n  var settings = combineSettings(_extend({\n    label: {},\n    color: strategy.getDefaultColor(context, options.palette)\n  }, themeManager.theme(\"layer:\" + strategy.fullType)), options);\n  var colors;\n  var i;\n  var palette;\n\n  if (settings.paletteSize > 0) {\n    palette = themeManager.createDiscretePalette(settings.palette, settings.paletteSize);\n\n    for (i = 0, colors = []; i < settings.paletteSize; ++i) {\n      colors.push(palette.getColor(i));\n    }\n\n    settings._colors = colors;\n  }\n\n  return settings;\n}\n\nfunction valueCallback(proxy, dataField) {\n  return proxy.attribute(dataField);\n}\n\nvar performGrouping = function performGrouping(context, partition, settingField, dataField, valuesCallback) {\n  var values;\n\n  if (dataField && partition && partition.length > 1) {\n    values = valuesCallback(partition.length - 1);\n    context.grouping[settingField] = {\n      callback: (0, _type.isFunction)(dataField) ? dataField : valueCallback,\n      field: dataField,\n      partition: partition,\n      values: values\n    };\n    context.params.dataExchanger.set(context.name, settingField, {\n      partition: partition,\n      values: values,\n      defaultColor: context.settings.color\n    });\n  }\n};\n\nfunction dropGrouping(context) {\n  var name = context.name;\n  var dataExchanger = context.params.dataExchanger;\n\n  _each(context.grouping, function (field) {\n    dataExchanger.set(name, field, null);\n  });\n\n  context.grouping = {};\n}\n\nvar groupByColor = function groupByColor(context) {\n  performGrouping(context, context.settings.colorGroups, \"color\", context.settings.colorGroupingField, function (count) {\n    var _palette = context.params.themeManager.createDiscretePalette(context.settings.palette, count);\n\n    var i;\n    var list = [];\n\n    for (i = 0; i < count; ++i) {\n      list.push(_palette.getColor(i));\n    }\n\n    return list;\n  });\n};\n\nvar groupBySize = function groupBySize(context, valueCallback) {\n  var settings = context.settings;\n  performGrouping(context, settings.sizeGroups, \"size\", valueCallback || settings.sizeGroupingField, function (count) {\n    var minSize = settings.minSize > 0 ? _Number(settings.minSize) : 0;\n    var maxSize = settings.maxSize >= minSize ? _Number(settings.maxSize) : 0;\n    var i = 0;\n    var sizes = [];\n\n    if (count > 1) {\n      for (i = 0; i < count; ++i) {\n        sizes.push((minSize * (count - i - 1) + maxSize * i) / (count - 1));\n      }\n    } else {\n      if (1 === count) {\n        sizes.push((minSize + maxSize) / 2);\n      }\n    }\n\n    return sizes;\n  });\n};\n\nfunction setFlag(flags, flag, state) {\n  if (state) {\n    flags |= flag;\n  } else {\n    flags &= ~flag;\n  }\n\n  return flags;\n}\n\nfunction hasFlag(flags, flag) {\n  return !!(flags & flag);\n}\n\nfunction createLayerProxy(layer, name, index) {\n  var proxy = {\n    index: index,\n    name: name,\n    getElements: function getElements() {\n      return layer.getProxies();\n    },\n    clearSelection: function clearSelection(_noEvent) {\n      layer.clearSelection(_noEvent);\n      return proxy;\n    },\n    getDataSource: function getDataSource() {\n      return layer.getDataSource();\n    },\n    getBounds: function getBounds() {\n      return layer.getBounds();\n    }\n  };\n  return proxy;\n}\n\nvar MapLayer = function MapLayer(params, container, name, index) {\n  var that = this;\n  that._params = params;\n\n  that._onProjection();\n\n  that.proxy = createLayerProxy(that, name, index);\n  that._context = {\n    name: name,\n    layer: that.proxy,\n    renderer: params.renderer,\n    projection: params.projection,\n    params: params,\n    dataKey: params.dataKey,\n    str: emptyStrategy,\n    hover: false,\n    selection: null,\n    grouping: {},\n    root: params.renderer.g().attr({\n      \"class\": \"dxm-layer\"\n    }).linkOn(container, name).linkAppend()\n  };\n  that._container = container;\n  that._options = {};\n  that._handles = [];\n  that._data = new EmptySource();\n  that._dataSourceLoaded = null;\n};\n\nMapLayer.prototype = _extend({\n  constructor: MapLayer,\n  getDataReadyCallback: function getDataReadyCallback() {\n    return this._dataSourceLoaded;\n  },\n  _onProjection: function _onProjection() {\n    var that = this;\n    that._removeHandlers = that._params.projection.on({\n      engine: function engine() {\n        that._project();\n      },\n      screen: function screen() {\n        that._transform();\n      },\n      center: function center() {\n        that._transformCore();\n      },\n      zoom: function zoom() {\n        that._transform();\n      }\n    });\n  },\n  getData: function getData() {\n    return this._data;\n  },\n  _dataSourceLoadErrorHandler: function _dataSourceLoadErrorHandler() {\n    this._dataSourceChangedHandler();\n  },\n  _dataSourceChangedHandler: function _dataSourceChangedHandler() {\n    var that = this;\n    that._data = unwrapFromDataSource(that._dataSource && that._dataSource.items());\n\n    that._update(true);\n  },\n  _dataSourceOptions: function _dataSourceOptions() {\n    return {\n      paginate: false\n    };\n  },\n  _getSpecificDataSourceOption: function _getSpecificDataSourceOption() {\n    return this._specificDataSourceOption;\n  },\n  _offProjection: function _offProjection() {\n    this._removeHandlers();\n\n    this._removeHandlers = null;\n  },\n  dispose: function dispose() {\n    var that = this;\n\n    that._disposeDataSource();\n\n    that._destroyHandles();\n\n    dropGrouping(that._context);\n\n    that._context.root.linkRemove().linkOff();\n\n    that._context.labelRoot && that._context.labelRoot.linkRemove().linkOff();\n\n    that._context.str.reset(that._context);\n\n    that._offProjection();\n\n    that._params = that._container = that._context = that.proxy = null;\n    return that;\n  },\n  setOptions: function setOptions(options) {\n    var that = this;\n    options = that._options = options || {};\n    that._dataSourceLoaded = new _deferred2.default.Deferred();\n\n    if (\"dataSource\" in options && options.dataSource !== that._options_dataSource) {\n      that._options_dataSource = options.dataSource;\n\n      that._params.notifyDirty();\n\n      that._specificDataSourceOption = wrapToDataSource(options.dataSource);\n\n      that._refreshDataSource();\n    } else {\n      if (that._data.count() > 0) {\n        that._params.notifyDirty();\n\n        that._update(void 0 !== options.type && options.type !== that._context.str.type || void 0 !== options.elementType && options.elementType !== that._context.str.elementType);\n      }\n    }\n\n    that._transformCore();\n  },\n  _update: function _update(isContextChanged) {\n    var that = this;\n    var context = that._context;\n\n    if (isContextChanged) {\n      context.str.reset(context);\n      context.root.clear();\n      context.labelRoot && context.labelRoot.clear();\n\n      that._params.tracker.reset();\n\n      that._destroyHandles();\n\n      context.str = selectStrategy(that._options, that._data);\n      context.str.setup(context);\n      that.proxy.type = context.str.type;\n      that.proxy.elementType = context.str.elementType;\n    }\n\n    context.settings = processCommonSettings(context, that._options);\n    context.hasSeparateLabel = !!(context.settings.label.enabled && context.str.hasLabelsGroup);\n    context.hover = !!(0, _utils.parseScalar)(context.settings.hoverEnabled, true);\n\n    if (context.selection) {\n      _each(context.selection.state, function (_, handle) {\n        handle && handle.resetSelected();\n      });\n    }\n\n    context.selection = getSelection(context.settings.selectionMode);\n\n    if (context.hasSeparateLabel) {\n      if (!context.labelRoot) {\n        context.labelRoot = context.renderer.g().attr({\n          \"class\": \"dxm-layer-labels\"\n        }).linkOn(that._container, {\n          name: context.name + \"-labels\",\n          after: context.name\n        }).linkAppend();\n\n        that._transformCore();\n      }\n    } else {\n      if (context.labelRoot) {\n        context.labelRoot.linkRemove().linkOff();\n        context.labelRoot = null;\n      }\n    }\n\n    if (isContextChanged) {\n      that._createHandles();\n    }\n\n    dropGrouping(context);\n    context.str.arrange(context, that._handles);\n    context.str.updateGrouping(context);\n\n    that._updateHandles();\n\n    that._params.notifyReady();\n\n    that._dataSourceLoaded.resolve();\n\n    that._dataSourceLoaded = null;\n  },\n  getBounds: function getBounds() {\n    return getMaxBound(this._handles.map(function (_ref) {\n      var proxy = _ref.proxy;\n      return proxy.coordinates().map(function (coords) {\n        if (!_isArray(coords)) {\n          return;\n        }\n\n        var initValue = coords[0];\n        return coords.reduce(function (min, c) {\n          return [_min(min[0], c[0]), _min(min[1], c[1]), _max(min[2], c[0]), _max(min[3], c[1])];\n        }, [initValue[0], initValue[1], initValue[0], initValue[1]]);\n      });\n    }).map(getMaxBound));\n  },\n  _destroyHandles: function _destroyHandles() {\n    this._handles.forEach(function (h) {\n      return h.dispose();\n    });\n\n    if (this._context.selection) {\n      this._context.selection.state = {};\n    }\n\n    this._handles = [];\n  },\n  _createHandles: function _createHandles() {\n    var that = this;\n    var handles = that._handles = [];\n    var data = that._data;\n    var i;\n    var ii = handles.length = data.count();\n    var context = that._context;\n    var geometry = data.geometry;\n    var attributes = data.attributes;\n    var handle;\n    var dataItem;\n\n    for (i = 0; i < ii; ++i) {\n      dataItem = data.item(i);\n      handles[i] = new MapLayerElement(context, i, geometry(dataItem), attributes(dataItem));\n    }\n\n    (0, _type.isFunction)(that._options.customize) && customizeHandles(that.getProxies(), that._options.customize, that._params.widget);\n\n    for (i = 0; i < ii; ++i) {\n      handle = handles[i];\n      handle.project();\n      handle.draw();\n      handle.transform();\n    }\n\n    if (context.selection) {\n      _each(context.selection.state, function (_, handle) {\n        handle && handle.restoreSelected();\n      });\n    }\n  },\n  _updateHandles: function _updateHandles() {\n    var handles = this._handles;\n    var i;\n    var ii = handles.length;\n\n    for (i = 0; i < ii; ++i) {\n      handles[i].refresh();\n    }\n\n    if (this._context.settings.label.enabled) {\n      for (i = 0; i < ii; ++i) {\n        handles[i].measureLabel();\n      }\n\n      for (i = 0; i < ii; ++i) {\n        handles[i].adjustLabel();\n      }\n    }\n  },\n  _transformCore: function _transformCore() {\n    var transform = this._params.projection.getTransform();\n\n    this._context.root.attr(transform);\n\n    this._context.labelRoot && this._context.labelRoot.attr(transform);\n  },\n  _project: function _project() {\n    var handles = this._handles;\n    var i;\n    var ii = handles.length;\n\n    for (i = 0; i < ii; ++i) {\n      handles[i].project();\n    }\n  },\n  _transform: function _transform() {\n    var handles = this._handles;\n    var i;\n    var ii = handles.length;\n\n    this._transformCore();\n\n    for (i = 0; i < ii; ++i) {\n      handles[i].transform();\n    }\n  },\n  getProxies: function getProxies() {\n    return this._handles.map(function (p) {\n      return p.proxy;\n    });\n  },\n  getProxy: function getProxy(index) {\n    return this._handles[index].proxy;\n  },\n  raiseClick: function raiseClick(i, dxEvent) {\n    this._params.eventTrigger(\"click\", {\n      target: this._handles[i].proxy,\n      event: dxEvent\n    });\n  },\n  hoverItem: function hoverItem(i, state) {\n    this._handles[i].setHovered(state);\n  },\n  selectItem: function selectItem(i, state, _noEvent) {\n    this._handles[i].setSelected(state, _noEvent);\n  },\n  clearSelection: function clearSelection() {\n    var selection = this._context.selection;\n\n    if (selection) {\n      _each(selection.state, function (_, handle) {\n        handle && handle.setSelected(false);\n      });\n\n      selection.state = {};\n    }\n  }\n}, _data_helper2.default);\n\nfunction createProxy(handle, coords, attrs) {\n  var proxy = {\n    coordinates: function coordinates() {\n      return coords;\n    },\n    attribute: function attribute(name, value) {\n      if (arguments.length > 1) {\n        attrs[name] = value;\n        return proxy;\n      } else {\n        return arguments.length > 0 ? attrs[name] : attrs;\n      }\n    },\n    selected: function selected(state, _noEvent) {\n      if (arguments.length > 0) {\n        handle.setSelected(state, _noEvent);\n        return proxy;\n      } else {\n        return handle.isSelected();\n      }\n    },\n    applySettings: function applySettings(settings) {\n      handle.update(settings);\n      return proxy;\n    }\n  };\n  return proxy;\n}\n\nvar MapLayerElement = function MapLayerElement(context, index, geometry, attributes) {\n  var that = this;\n  var proxy = that.proxy = createProxy(that, geometry.coordinates, _extend({}, attributes));\n  that._ctx = context;\n  that._index = index;\n  that._fig = that._label = null;\n  that._state = STATE_DEFAULT;\n  that._coordinates = geometry.coordinates;\n  that._settings = {\n    label: {}\n  };\n  proxy.index = index;\n  proxy.layer = context.layer;\n  that._data = {\n    name: context.name,\n    index: index\n  };\n};\n\nMapLayerElement.prototype = {\n  constructor: MapLayerElement,\n  dispose: function dispose() {\n    var that = this;\n    that._ctx = that.proxy = that._settings = that._fig = that._label = that.data = null;\n    return that;\n  },\n  project: function project() {\n    var context = this._ctx;\n    this._projection = context.str.project(context.projection, this._coordinates);\n\n    if (context.hasSeparateLabel && this._label) {\n      this._projectLabel();\n    }\n  },\n  _projectLabel: function _projectLabel() {\n    this._labelProjection = this._ctx.str.projectLabel(this._projection);\n  },\n  draw: function draw() {\n    var that = this;\n    var context = this._ctx;\n    context.str.draw(context, that._fig = {}, that._data);\n\n    that._fig.root.append(context.root);\n  },\n  transform: function transform() {\n    var that = this;\n    var context = that._ctx;\n    context.str.transform(that._fig, context.projection, that._projection);\n\n    if (context.hasSeparateLabel && that._label) {\n      that._transformLabel();\n    }\n  },\n  _transformLabel: function _transformLabel() {\n    this._ctx.str.transformLabel(this._label, this._ctx.projection, this._labelProjection);\n  },\n  refresh: function refresh() {\n    var that = this;\n    var strategy = that._ctx.str;\n    var settings = getItemSettings(that._ctx, that.proxy, that._settings);\n    that._styles = strategy.getStyles(settings);\n    strategy.refresh(that._ctx, that._fig, that._data, that.proxy, settings);\n\n    that._refreshLabel(settings);\n\n    that._setState();\n  },\n  _refreshLabel: function _refreshLabel(settings) {\n    var that = this;\n    var context = that._ctx;\n    var labelSettings = settings.label;\n    var label = that._label;\n\n    if (context.settings.label.enabled) {\n      if (!label) {\n        label = that._label = {\n          root: context.labelRoot || that._fig.root,\n          text: context.renderer.text().attr({\n            \"class\": \"dxm-label\"\n          }),\n          size: [0, 0]\n        };\n\n        if (context.hasSeparateLabel) {\n          that._projectLabel();\n\n          that._transformLabel();\n        }\n      }\n\n      label.value = _String(that.proxy.text || that.proxy.attribute(labelSettings.dataField) || \"\");\n\n      if (label.value) {\n        label.text.attr({\n          text: label.value,\n          x: 0,\n          y: 0\n        }).css((0, _utils.patchFontOptions)(labelSettings.font)).attr({\n          align: \"center\",\n          stroke: labelSettings.stroke,\n          \"stroke-width\": labelSettings[\"stroke-width\"],\n          \"stroke-opacity\": labelSettings[\"stroke-opacity\"]\n        }).data(context.dataKey, that._data).append(label.root);\n        label.settings = settings;\n      }\n    } else {\n      if (label) {\n        label.text.remove();\n        that._label = null;\n      }\n    }\n  },\n  measureLabel: function measureLabel() {\n    var label = this._label;\n    var bBox;\n\n    if (label.value) {\n      bBox = label.text.getBBox();\n      label.size = [bBox.width, bBox.height, -bBox.y - bBox.height / 2];\n    }\n  },\n  adjustLabel: function adjustLabel() {\n    var label = this._label;\n    var offset;\n\n    if (label.value) {\n      offset = this._ctx.str.getLabelOffset(label, label.settings);\n      label.settings = null;\n      label.text.attr({\n        x: offset[0],\n        y: offset[1] + label.size[2]\n      });\n    }\n  },\n  update: function update(settings) {\n    var that = this;\n    that._settings = combineSettings(that._settings, settings);\n\n    if (that._fig) {\n      that.refresh();\n\n      if (that._label && that._label.value) {\n        that.measureLabel();\n        that.adjustLabel();\n      }\n    }\n  },\n  _setState: function _setState() {\n    this._ctx.str.setState(this._fig, this._styles, STATE_TO_INDEX[this._state]);\n  },\n  _setForeground: function _setForeground() {\n    var root = this._fig.root;\n    this._state ? root.toForeground() : root.toBackground();\n  },\n  setHovered: function setHovered(state) {\n    var that = this;\n    var currentState = hasFlag(that._state, STATE_HOVERED);\n    var newState = !!state;\n\n    if (that._ctx.hover && currentState !== newState) {\n      that._state = setFlag(that._state, STATE_HOVERED, newState);\n\n      that._setState();\n\n      that._setForeground();\n\n      raiseChanged(that._ctx, that, newState, \"hoverChanged\");\n    }\n\n    return that;\n  },\n  setSelected: function setSelected(state, _noEvent) {\n    var that = this;\n    var currentState = hasFlag(that._state, STATE_SELECTED);\n    var newState = !!state;\n    var selection = that._ctx.selection;\n    var tmp;\n\n    if (selection && currentState !== newState) {\n      that._state = setFlag(that._state, STATE_SELECTED, newState);\n      tmp = selection.state[selection.single];\n      selection.state[selection.single] = null;\n\n      if (tmp) {\n        tmp.setSelected(false);\n      }\n\n      selection.state[selection.single || that._index] = state ? that : null;\n\n      if (that._fig) {\n        that._setState();\n\n        that._setForeground();\n\n        if (!_noEvent) {\n          raiseChanged(that._ctx, that, newState, \"selectionChanged\");\n        }\n      }\n    }\n  },\n  isSelected: function isSelected() {\n    return hasFlag(this._state, STATE_SELECTED);\n  },\n  resetSelected: function resetSelected() {\n    this._state = setFlag(this._state, STATE_SELECTED, false);\n  },\n  restoreSelected: function restoreSelected() {\n    this._fig.root.toForeground();\n  }\n};\n\nfunction calculatePolygonCentroid(coordinates) {\n  var i;\n  var length = coordinates.length;\n  var v1;\n  var v2 = coordinates[length - 1];\n  var cross;\n  var cx = 0;\n  var cy = 0;\n  var area = 0;\n  var minX = 1 / 0;\n  var maxX = -(1 / 0);\n  var minY = 1 / 0;\n  var maxY = -(1 / 0);\n\n  for (i = 0; i < length; ++i) {\n    v1 = v2;\n    v2 = coordinates[i];\n    cross = v1[0] * v2[1] - v2[0] * v1[1];\n    area += cross;\n    cx += (v1[0] + v2[0]) * cross;\n    cy += (v1[1] + v2[1]) * cross;\n    minX = _min(minX, v2[0]);\n    maxX = _max(maxX, v2[0]);\n    minY = _min(minY, v2[1]);\n    maxY = _max(maxY, v2[1]);\n  }\n\n  return {\n    area: _abs(area) / 2,\n    center: [2 * cx / 3 / area - (minX + maxX) / 2, 2 * cy / 3 / area - (minY + maxY) / 2]\n  };\n}\n\nfunction calculateLineStringData(coordinates) {\n  var i;\n  var ii = coordinates.length;\n  var v1;\n  var v2 = coordinates[0] || [];\n  var totalLength = 0;\n  var items = [0];\n  var min0 = v2[0];\n  var max0 = v2[0];\n  var min1 = v2[1];\n  var max1 = v2[1];\n  var t;\n\n  for (i = 1; i < ii; ++i) {\n    v1 = v2;\n    v2 = coordinates[i];\n    totalLength += _sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));\n    items[i] = totalLength;\n    min0 = _min(min0, v2[0]);\n    max0 = _max(max0, v2[0]);\n    min1 = _min(min1, v2[1]);\n    max1 = _max(max1, v2[1]);\n  }\n\n  i = findGroupingIndex(totalLength / 2, items);\n  v1 = coordinates[i];\n  v2 = coordinates[i + 1];\n  t = (totalLength / 2 - items[i]) / (items[i + 1] - items[i]);\n  return ii ? [[v1[0] * (1 - t) + v2[0] * t, v1[1] * (1 - t) + v2[1] * t], [max0 - min0, max1 - min1], totalLength] : [];\n}\n\nfunction projectAreaLabel(coordinates) {\n  var i;\n  var ii = coordinates.length;\n  var centroid;\n  var resultCentroid;\n  var maxArea = 0;\n\n  for (i = 0; i < ii; ++i) {\n    centroid = calculatePolygonCentroid(coordinates[i]);\n\n    if (centroid.area > maxArea) {\n      maxArea = centroid.area;\n      resultCentroid = centroid;\n    }\n  }\n\n  return resultCentroid ? [resultCentroid.center, [_sqrt(resultCentroid.area), _sqrt(resultCentroid.area)]] : [[], []];\n}\n\nfunction projectLineLabel(coordinates) {\n  var i;\n  var ii = coordinates.length;\n  var maxLength = 0;\n  var data;\n  var resultData;\n\n  for (i = 0; i < ii; ++i) {\n    data = calculateLineStringData(coordinates[i]);\n\n    if (data[2] > maxLength) {\n      maxLength = data[2];\n      resultData = data;\n    }\n  }\n\n  return resultData || [[], []];\n}\n\nfunction MapLayerCollection(params) {\n  var that = this;\n  var renderer = params.renderer;\n  that._params = params;\n  that._layers = [];\n  that._layerByName = {};\n  that._rect = [0, 0, 0, 0];\n  that._clip = renderer.clipRect();\n  that._background = renderer.rect().attr({\n    \"class\": \"dxm-background\"\n  }).data(params.dataKey, {\n    name: \"background\"\n  }).append(renderer.root);\n  that._container = renderer.g().attr({\n    \"class\": \"dxm-layers\",\n    \"clip-path\": that._clip.id\n  }).append(renderer.root).enableLinks();\n\n  that._subscribeToTracker(params.tracker, renderer, params.eventTrigger);\n\n  that._dataReady = params.dataReady;\n}\n\nMapLayerCollection.prototype = {\n  constructor: MapLayerCollection,\n  dispose: function dispose() {\n    var that = this;\n\n    that._clip.dispose();\n\n    that._layers.forEach(function (l) {\n      return l.dispose();\n    });\n\n    that._offTracker();\n\n    that._params = that._offTracker = that._layers = that._layerByName = that._clip = that._background = that._container = null;\n  },\n  _subscribeToTracker: function _subscribeToTracker(tracker, renderer, eventTrigger) {\n    var that = this;\n    that._offTracker = tracker.on({\n      click: function click(arg) {\n        var offset = renderer.getRootOffset();\n        var layer = that.byName(arg.data.name);\n        arg.$event.x = arg.x - offset.left;\n        arg.$event.y = arg.y - offset.top;\n\n        if (layer) {\n          layer.raiseClick(arg.data.index, arg.$event);\n        } else {\n          if (\"background\" === arg.data.name) {\n            eventTrigger(\"click\", {\n              event: arg.$event\n            });\n          }\n        }\n      },\n      \"hover-on\": function hoverOn(arg) {\n        var layer = that.byName(arg.data.name);\n\n        if (layer) {\n          layer.hoverItem(arg.data.index, true);\n        }\n      },\n      \"hover-off\": function hoverOff(arg) {\n        var layer = that.byName(arg.data.name);\n\n        if (layer) {\n          layer.hoverItem(arg.data.index, false);\n        }\n      }\n    });\n  },\n  setOptions: function setOptions(options) {\n    var that = this;\n    var optionList = options ? _isArray(options) ? options : [options] : [];\n    var layerByName = that._layerByName;\n    var layers = that._layers;\n    var readyCallbacks = [];\n    var needToCreateLayers = optionList.length !== layers.length || layers.some(function (l, i) {\n      var name = getName(optionList, i);\n      return (0, _type.isDefined)(name) && name !== l.proxy.name;\n    });\n\n    if (needToCreateLayers) {\n      that._params.tracker.reset();\n\n      that._layers.forEach(function (l) {\n        return l.dispose();\n      });\n\n      that._layerByName = layerByName = {};\n      that._layers = layers = [];\n\n      for (var i = 0, ii = optionList.length; i < ii; ++i) {\n        var name = getName(optionList, i) || \"map-layer-\" + i;\n        var layer = layers[i] = new MapLayer(that._params, that._container, name, i);\n        layerByName[name] = layer;\n      }\n    }\n\n    layers.forEach(function (l, i) {\n      l.setOptions(optionList[i]);\n    });\n    readyCallbacks = layers.map(function (l) {\n      return l.getDataReadyCallback();\n    });\n    readyCallbacks.length && _deferred2.default.when.apply(void 0, readyCallbacks).done(that._dataReady);\n  },\n  _updateClip: function _updateClip() {\n    var rect = this._rect;\n    var bw = this._borderWidth;\n\n    this._clip.attr({\n      x: rect[0] + bw,\n      y: rect[1] + bw,\n      width: _max(rect[2] - 2 * bw, 0),\n      height: _max(rect[3] - 2 * bw, 0)\n    });\n  },\n  setBackgroundOptions: function setBackgroundOptions(options) {\n    this._background.attr({\n      stroke: options.borderColor,\n      \"stroke-width\": options.borderWidth,\n      fill: options.color\n    });\n\n    this._borderWidth = _max(options.borderWidth, 0);\n\n    this._updateClip();\n  },\n  setRect: function setRect(rect) {\n    this._rect = rect;\n\n    this._background.attr({\n      x: rect[0],\n      y: rect[1],\n      width: rect[2],\n      height: rect[3]\n    });\n\n    this._updateClip();\n  },\n  byIndex: function byIndex(index) {\n    return this._layers[index];\n  },\n  byName: function byName(name) {\n    return this._layerByName[name];\n  },\n  items: function items() {\n    return this._layers;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}