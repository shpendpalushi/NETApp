{"ast":null,"code":"/**\r\n * DevExtreme (ui/grid_core/ui.grid_core.columns_controller.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _renderer = require(\"../../core/renderer\");\n\nvar _renderer2 = _interopRequireDefault(_renderer);\n\nvar _callbacks = require(\"../../core/utils/callbacks\");\n\nvar _callbacks2 = _interopRequireDefault(_callbacks);\n\nvar _variable_wrapper = require(\"../../core/utils/variable_wrapper\");\n\nvar _data = require(\"../../core/utils/data\");\n\nvar _data2 = _interopRequireDefault(_data);\n\nvar _common = require(\"../../core/utils/common\");\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _iterator = require(\"../../core/utils/iterator\");\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _position = require(\"../../core/utils/position\");\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _array = require(\"../../core/utils/array\");\n\nvar _config = require(\"../../core/config\");\n\nvar _config2 = _interopRequireDefault(_config);\n\nvar _object = require(\"../../core/utils/object\");\n\nvar _ui = require(\"../widget/ui.errors\");\n\nvar _ui2 = _interopRequireDefault(_ui);\n\nvar _uiGrid_core = require(\"./ui.grid_core.modules\");\n\nvar _uiGrid_core2 = _interopRequireDefault(_uiGrid_core);\n\nvar _uiGrid_core3 = require(\"./ui.grid_core.utils\");\n\nvar _inflector = require(\"../../core/utils/inflector\");\n\nvar _inflector2 = _interopRequireDefault(_inflector);\n\nvar _date_serialization = require(\"../../core/utils/date_serialization\");\n\nvar _date_serialization2 = _interopRequireDefault(_date_serialization);\n\nvar _number = require(\"../../localization/number\");\n\nvar _number2 = _interopRequireDefault(_number);\n\nvar _date = require(\"../../localization/date\");\n\nvar _date2 = _interopRequireDefault(_date);\n\nvar _message = require(\"../../localization/message\");\n\nvar _message2 = _interopRequireDefault(_message);\n\nvar _deferred = require(\"../../core/utils/deferred\");\n\nvar _abstract_store = require(\"../../data/abstract_store\");\n\nvar _abstract_store2 = _interopRequireDefault(_abstract_store);\n\nvar _data_source = require(\"../../data/data_source/data_source\");\n\nvar _filtering = require(\"../shared/filtering\");\n\nvar _filtering2 = _interopRequireDefault(_filtering);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar USER_STATE_FIELD_NAMES_15_1 = [\"filterValues\", \"filterType\", \"fixed\", \"fixedPosition\"];\nvar USER_STATE_FIELD_NAMES = [\"visibleIndex\", \"dataField\", \"name\", \"dataType\", \"width\", \"visible\", \"sortOrder\", \"lastSortOrder\", \"sortIndex\", \"groupIndex\", \"filterValue\", \"selectedFilterOperation\", \"added\"].concat(USER_STATE_FIELD_NAMES_15_1);\nvar IGNORE_COLUMN_OPTION_NAMES = {\n  visibleWidth: true,\n  bestFitWidth: true,\n  bufferedFilterValue: true\n};\nvar COMMAND_EXPAND_CLASS = \"dx-command-expand\";\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\nvar GROUP_COMMAND_COLUMN_NAME = \"groupExpand\";\nvar regExp = /columns\\[(\\d+)\\]\\.?/gi;\nvar globalColumnId = 1;\nmodule.exports = {\n  defaultOptions: function defaultOptions() {\n    return {\n      commonColumnSettings: {\n        allowFiltering: true,\n        allowHiding: true,\n        allowSorting: true,\n        allowEditing: true,\n        encodeHtml: true,\n        trueText: _message2.default.format(\"dxDataGrid-trueText\"),\n        falseText: _message2.default.format(\"dxDataGrid-falseText\")\n      },\n      allowColumnReordering: false,\n      allowColumnResizing: false,\n      columnResizingMode: \"nextColumn\",\n      columnMinWidth: void 0,\n      columnWidth: void 0,\n      adaptColumnWidthByRatio: true,\n      columns: void 0,\n      regenerateColumnsByVisibleItems: false,\n      customizeColumns: null,\n      dateSerializationFormat: void 0\n    };\n  },\n  controllers: {\n    columns: _uiGrid_core2.default.Controller.inherit(function () {\n      var DEFAULT_COLUMN_OPTIONS = {\n        visible: true,\n        showInColumnChooser: true\n      };\n      var DATATYPE_OPERATIONS = {\n        number: [\"=\", \"<>\", \"<\", \">\", \"<=\", \">=\", \"between\"],\n        string: [\"contains\", \"notcontains\", \"startswith\", \"endswith\", \"=\", \"<>\"],\n        date: [\"=\", \"<>\", \"<\", \">\", \"<=\", \">=\", \"between\"],\n        datetime: [\"=\", \"<>\", \"<\", \">\", \"<=\", \">=\", \"between\"]\n      };\n      var COLUMN_INDEX_OPTIONS = {\n        visibleIndex: true,\n        groupIndex: true,\n        grouped: true,\n        sortIndex: true,\n        sortOrder: true\n      };\n      var GROUP_LOCATION = \"group\";\n      var COLUMN_CHOOSER_LOCATION = \"columnChooser\";\n\n      var setFilterOperationsAsDefaultValues = function setFilterOperationsAsDefaultValues(column) {\n        column.filterOperations = column.defaultFilterOperations;\n      };\n\n      var createColumn = function createColumn(that, columnOptions, userStateColumnOptions, bandColumn) {\n        var commonColumnOptions = {};\n        var calculatedColumnOptions;\n\n        if (columnOptions) {\n          if ((0, _type.isString)(columnOptions)) {\n            columnOptions = {\n              dataField: columnOptions\n            };\n          }\n\n          var result = {};\n\n          if (columnOptions.command) {\n            result = (0, _object.deepExtendArraySafe)(commonColumnOptions, columnOptions);\n          } else {\n            commonColumnOptions = that.getCommonSettings(columnOptions);\n\n            if (userStateColumnOptions && userStateColumnOptions.name && userStateColumnOptions.dataField) {\n              columnOptions = (0, _extend.extend)({}, columnOptions, {\n                dataField: userStateColumnOptions.dataField\n              });\n            }\n\n            calculatedColumnOptions = that._createCalculatedColumnOptions(columnOptions, bandColumn);\n\n            if (columnOptions.dataField && !columnOptions.type) {\n              result = {\n                headerId: \"dx-col-\".concat(globalColumnId++)\n              };\n            }\n\n            result = (0, _object.deepExtendArraySafe)(result, DEFAULT_COLUMN_OPTIONS);\n            (0, _object.deepExtendArraySafe)(result, commonColumnOptions);\n            (0, _object.deepExtendArraySafe)(result, calculatedColumnOptions);\n            (0, _object.deepExtendArraySafe)(result, columnOptions);\n            (0, _object.deepExtendArraySafe)(result, {\n              selector: null\n            });\n          }\n\n          if (columnOptions.filterOperations === columnOptions.defaultFilterOperations) {\n            setFilterOperationsAsDefaultValues(result);\n          }\n\n          return result;\n        }\n      };\n\n      var createColumnsFromOptions = function createColumnsFromOptions(that, columnsOptions, bandColumn) {\n        var result = [];\n\n        if (columnsOptions) {\n          _iterator2.default.each(columnsOptions, function (index, columnOptions) {\n            var userStateColumnOptions = that._columnsUserState && checkUserStateColumn(columnOptions, that._columnsUserState[index]) && that._columnsUserState[index];\n\n            var column = createColumn(that, columnOptions, userStateColumnOptions, bandColumn);\n\n            if (column) {\n              if (bandColumn) {\n                column.ownerBand = bandColumn;\n              }\n\n              result.push(column);\n\n              if (column.columns) {\n                result = result.concat(createColumnsFromOptions(that, column.columns, column));\n                delete column.columns;\n                column.hasColumns = true;\n              }\n            }\n          });\n        }\n\n        return result;\n      };\n\n      var getParentBandColumns = function getParentBandColumns(columnIndex, columnParentByIndex) {\n        var result = [];\n        var parent = columnParentByIndex[columnIndex];\n\n        while (parent) {\n          result.unshift(parent);\n          columnIndex = parent.index;\n          parent = columnParentByIndex[columnIndex];\n        }\n\n        return result;\n      };\n\n      var _getChildrenByBandColumn = function _getChildrenByBandColumn(columnIndex, columnChildrenByIndex, recursive) {\n        var column;\n        var result = [];\n        var children = columnChildrenByIndex[columnIndex];\n\n        if (children) {\n          for (var i = 0; i < children.length; i++) {\n            column = children[i];\n\n            if (!(0, _type.isDefined)(column.groupIndex) || column.showWhenGrouped) {\n              result.push(column);\n\n              if (recursive && column.isBand) {\n                result = result.concat(_getChildrenByBandColumn(column.index, columnChildrenByIndex, recursive));\n              }\n            }\n          }\n        }\n\n        return result;\n      };\n\n      var getColumnByIndexes = function getColumnByIndexes(that, columnIndexes) {\n        var result;\n        var columns;\n        var bandColumnsCache = that.getBandColumnsCache();\n\n        var callbackFilter = function callbackFilter(column) {\n          var ownerBand = result ? result.index : void 0;\n          return column.ownerBand === ownerBand;\n        };\n\n        if (bandColumnsCache.isPlain) {\n          result = that._columns[columnIndexes[0]];\n        } else {\n          columns = that._columns.filter(callbackFilter);\n\n          for (var i = 0; i < columnIndexes.length; i++) {\n            result = columns[columnIndexes[i]];\n\n            if (result) {\n              columns = that._columns.filter(callbackFilter);\n            }\n          }\n        }\n\n        return result;\n      };\n\n      var getColumnFullPath = function getColumnFullPath(that, column) {\n        var result = [];\n        var columns;\n        var bandColumnsCache = that.getBandColumnsCache();\n\n        var callbackFilter = function callbackFilter(item) {\n          return item.ownerBand === column.ownerBand;\n        };\n\n        if (bandColumnsCache.isPlain) {\n          var columnIndex = that._columns.indexOf(column);\n\n          if (columnIndex >= 0) {\n            result = [\"columns[\".concat(columnIndex, \"]\")];\n          }\n        } else {\n          columns = that._columns.filter(callbackFilter);\n\n          while (columns.length && columns.indexOf(column) !== -1) {\n            result.unshift(\"columns[\".concat(columns.indexOf(column), \"]\"));\n            column = bandColumnsCache.columnParentByIndex[column.index];\n            columns = column ? that._columns.filter(callbackFilter) : [];\n          }\n        }\n\n        return result.join(\".\");\n      };\n\n      var calculateColspan = function calculateColspan(that, columnID) {\n        var colspan = 0;\n        var columns = that.getChildrenByBandColumn(columnID, true);\n\n        _iterator2.default.each(columns, function (_, column) {\n          if (column.isBand) {\n            column.colspan = column.colspan || calculateColspan(that, column.index);\n            colspan += column.colspan || 1;\n          } else {\n            colspan += 1;\n          }\n        });\n\n        return colspan;\n      };\n\n      var processBandColumns = function processBandColumns(that, columns, bandColumnsCache) {\n        var i;\n        var column;\n        var rowspan;\n        var rowCount = that.getRowCount();\n\n        for (i = 0; i < columns.length; i++) {\n          column = columns[i];\n\n          if (column.visible || column.command) {\n            if (column.isBand) {\n              column.colspan = column.colspan || calculateColspan(that, column.index);\n            }\n\n            if (!column.isBand || !column.colspan) {\n              rowspan = rowCount - (!column.command && !(0, _type.isDefined)(column.groupIndex) ? getParentBandColumns(column.index, bandColumnsCache.columnParentByIndex).length : 0);\n\n              if (rowspan > 1) {\n                column.rowspan = rowspan;\n              }\n            }\n          }\n        }\n      };\n\n      var getValueDataType = function getValueDataType(value) {\n        var dataType = (0, _type.type)(value);\n\n        if (\"string\" !== dataType && \"boolean\" !== dataType && \"number\" !== dataType && \"date\" !== dataType && \"object\" !== dataType) {\n          dataType = void 0;\n        }\n\n        return dataType;\n      };\n\n      var getSerializationFormat = function getSerializationFormat(dataType, value) {\n        switch (dataType) {\n          case \"date\":\n          case \"datetime\":\n            return _date_serialization2.default.getDateSerializationFormat(value);\n\n          case \"number\":\n            if ((0, _type.isString)(value)) {\n              return \"string\";\n            }\n\n            if ((0, _type.isNumeric)(value)) {\n              return null;\n            }\n\n        }\n      };\n\n      var updateSerializers = function updateSerializers(options, dataType) {\n        if (!options.deserializeValue) {\n          if ((0, _uiGrid_core3.isDateType)(dataType)) {\n            options.deserializeValue = function (value) {\n              return _date_serialization2.default.deserializeDate(value);\n            };\n\n            options.serializeValue = function (value) {\n              return (0, _type.isString)(value) ? value : _date_serialization2.default.serializeDate(value, this.serializationFormat);\n            };\n          }\n\n          if (\"number\" === dataType) {\n            options.deserializeValue = function (value) {\n              var parsedValue = parseFloat(value);\n              return isNaN(parsedValue) ? value : parsedValue;\n            };\n\n            options.serializeValue = function (value, target) {\n              if (\"filter\" === target) {\n                return value;\n              }\n\n              return (0, _type.isDefined)(value) && \"string\" === this.serializationFormat ? value.toString() : value;\n            };\n          }\n        }\n      };\n\n      var getAlignmentByDataType = function getAlignmentByDataType(dataType, isRTL) {\n        switch (dataType) {\n          case \"number\":\n            return \"right\";\n\n          case \"boolean\":\n            return \"center\";\n\n          default:\n            return (0, _position.getDefaultAlignment)(isRTL);\n        }\n      };\n\n      var getCustomizeTextByDataType = function getCustomizeTextByDataType(dataType) {\n        if (\"boolean\" === dataType) {\n          return function (e) {\n            if (true === e.value) {\n              return this.trueText || \"true\";\n            } else {\n              if (false === e.value) {\n                return this.falseText || \"false\";\n              } else {\n                return e.valueText || \"\";\n              }\n            }\n          };\n        }\n      };\n\n      var createColumnsFromDataSource = function createColumnsFromDataSource(that, dataSource) {\n        var firstItems = that._getFirstItems(dataSource);\n\n        var fieldName;\n        var processedFields = {};\n        var i;\n        var result = [];\n\n        for (i = 0; i < firstItems.length; i++) {\n          if (firstItems[i]) {\n            for (fieldName in firstItems[i]) {\n              if (!(0, _type.isFunction)(firstItems[i][fieldName]) || (0, _variable_wrapper.isWrapped)(firstItems[i][fieldName])) {\n                processedFields[fieldName] = true;\n              }\n            }\n          }\n        }\n\n        for (fieldName in processedFields) {\n          if (0 !== fieldName.indexOf(\"__\")) {\n            var column = createColumn(that, fieldName);\n            result.push(column);\n          }\n        }\n\n        return result;\n      };\n\n      var updateColumnIndexes = function updateColumnIndexes(that) {\n        _iterator2.default.each(that._columns, function (index, column) {\n          column.index = index;\n        });\n\n        _iterator2.default.each(that._columns, function (index, column) {\n          if ((0, _type.isObject)(column.ownerBand)) {\n            column.ownerBand = column.ownerBand.index;\n          }\n        });\n\n        _iterator2.default.each(that._commandColumns, function (index, column) {\n          column.index = -(index + 1);\n        });\n      };\n\n      var updateColumnGroupIndexes = function updateColumnGroupIndexes(that, currentColumn) {\n        (0, _array.normalizeIndexes)(that._columns, \"groupIndex\", currentColumn, function (column) {\n          var grouped = column.grouped;\n          delete column.grouped;\n          return grouped;\n        });\n      };\n\n      var updateColumnSortIndexes = function updateColumnSortIndexes(that, currentColumn) {\n        _iterator2.default.each(that._columns, function (index, column) {\n          if ((0, _type.isDefined)(column.sortIndex) && !isSortOrderValid(column.sortOrder)) {\n            delete column.sortIndex;\n          }\n        });\n\n        (0, _array.normalizeIndexes)(that._columns, \"sortIndex\", currentColumn, function (column) {\n          return !(0, _type.isDefined)(column.groupIndex) && isSortOrderValid(column.sortOrder);\n        });\n      };\n\n      var updateColumnVisibleIndexes = function updateColumnVisibleIndexes(that, currentColumn) {\n        var i;\n        var key;\n        var column;\n        var bandColumnIndex;\n        var parentBandColumns;\n        var bandColumns = {};\n        var result = [];\n        var bandColumnsCache = that.getBandColumnsCache();\n\n        var columns = that._columns.filter(function (column) {\n          return !column.command;\n        });\n\n        for (i = 0; i < columns.length; i++) {\n          column = columns[i];\n          parentBandColumns = getParentBandColumns(i, bandColumnsCache.columnParentByIndex);\n\n          if (parentBandColumns.length) {\n            bandColumnIndex = parentBandColumns[parentBandColumns.length - 1].index;\n            bandColumns[bandColumnIndex] = bandColumns[bandColumnIndex] || [];\n            bandColumns[bandColumnIndex].push(column);\n          } else {\n            result.push(column);\n          }\n        }\n\n        for (key in bandColumns) {\n          (0, _array.normalizeIndexes)(bandColumns[key], \"visibleIndex\", currentColumn);\n        }\n\n        (0, _array.normalizeIndexes)(result, \"visibleIndex\", currentColumn);\n      };\n\n      var getColumnIndexByVisibleIndex = function getColumnIndexByVisibleIndex(that, visibleIndex, location) {\n        var rowIndex = (0, _type.isObject)(visibleIndex) ? visibleIndex.rowIndex : null;\n        var columns = location === GROUP_LOCATION ? that.getGroupColumns() : location === COLUMN_CHOOSER_LOCATION ? that.getChooserColumns() : that.getVisibleColumns(rowIndex);\n        var column;\n        visibleIndex = (0, _type.isObject)(visibleIndex) ? visibleIndex.columnIndex : visibleIndex;\n        column = columns[visibleIndex];\n\n        if (column && column.type === GROUP_COMMAND_COLUMN_NAME) {\n          column = that._columns.filter(function (col) {\n            return column.type === col.type;\n          })[0] || column;\n        }\n\n        return column && (0, _type.isDefined)(column.index) ? column.index : -1;\n      };\n\n      var moveColumnToGroup = function moveColumnToGroup(that, column, groupIndex) {\n        var groupColumns = that.getGroupColumns();\n        var i;\n\n        if (groupIndex >= 0) {\n          for (i = 0; i < groupColumns.length; i++) {\n            if (groupColumns[i].groupIndex >= groupIndex) {\n              groupColumns[i].groupIndex++;\n            }\n          }\n        } else {\n          groupIndex = 0;\n\n          for (i = 0; i < groupColumns.length; i++) {\n            groupIndex = Math.max(groupIndex, groupColumns[i].groupIndex + 1);\n          }\n        }\n\n        return groupIndex;\n      };\n\n      var checkUserStateColumn = function checkUserStateColumn(column, userStateColumn) {\n        return column && userStateColumn && userStateColumn.name === column.name && (userStateColumn.dataField === column.dataField || column.name);\n      };\n\n      var applyUserState = function applyUserState(that) {\n        var columnsUserState = that._columnsUserState;\n        var ignoreColumnOptionNames = that._ignoreColumnOptionNames || [];\n        var columns = that._columns;\n        var columnCountById = {};\n        var resultColumns = [];\n        var allColumnsHaveState = true;\n        var userStateColumnIndexes = [];\n        var column;\n        var columnUserState;\n        var userStateColumnIndex;\n        var i;\n\n        function applyFieldsState(column, userStateColumn) {\n          var fieldName;\n\n          if (!userStateColumn) {\n            return;\n          }\n\n          for (var index = 0; index < USER_STATE_FIELD_NAMES.length; index++) {\n            fieldName = USER_STATE_FIELD_NAMES[index];\n\n            if ((0, _array.inArray)(fieldName, ignoreColumnOptionNames) >= 0) {\n              continue;\n            }\n\n            if (\"dataType\" === fieldName) {\n              column[fieldName] = column[fieldName] || userStateColumn[fieldName];\n            } else {\n              if ((0, _array.inArray)(fieldName, USER_STATE_FIELD_NAMES_15_1) >= 0) {\n                if (fieldName in userStateColumn) {\n                  column[fieldName] = userStateColumn[fieldName];\n                }\n              } else {\n                if (\"selectedFilterOperation\" === fieldName && userStateColumn[fieldName]) {\n                  column.defaultSelectedFilterOperation = column[fieldName] || null;\n                }\n\n                column[fieldName] = userStateColumn[fieldName];\n              }\n            }\n          }\n        }\n\n        function findUserStateColumn(columnsUserState, column) {\n          var id = column.name || column.dataField;\n          var count = columnCountById[id] || 0;\n\n          for (var j = 0; j < columnsUserState.length; j++) {\n            if (checkUserStateColumn(column, columnsUserState[j])) {\n              if (count) {\n                count--;\n              } else {\n                columnCountById[id] = columnCountById[id] || 0;\n                columnCountById[id]++;\n                return j;\n              }\n            }\n          }\n\n          return -1;\n        }\n\n        if (columnsUserState) {\n          for (i = 0; i < columns.length; i++) {\n            userStateColumnIndex = findUserStateColumn(columnsUserState, columns[i]);\n            allColumnsHaveState = allColumnsHaveState && userStateColumnIndex >= 0;\n            userStateColumnIndexes.push(userStateColumnIndex);\n          }\n\n          for (i = 0; i < columns.length; i++) {\n            column = columns[i];\n            userStateColumnIndex = userStateColumnIndexes[i];\n\n            if (that._hasUserState || allColumnsHaveState) {\n              applyFieldsState(column, columnsUserState[userStateColumnIndex]);\n            }\n\n            if (userStateColumnIndex >= 0 && (0, _type.isDefined)(columnsUserState[userStateColumnIndex].initialIndex)) {\n              resultColumns[userStateColumnIndex] = column;\n            } else {\n              resultColumns.push(column);\n            }\n          }\n\n          var hasAddedBands = false;\n\n          for (i = 0; i < columnsUserState.length; i++) {\n            columnUserState = columnsUserState[i];\n\n            if (columnUserState.added && findUserStateColumn(columns, columnUserState) < 0) {\n              column = createColumn(that, columnUserState.added);\n              applyFieldsState(column, columnUserState);\n              resultColumns.push(column);\n\n              if (columnUserState.added.columns) {\n                hasAddedBands = true;\n              }\n            }\n          }\n\n          if (hasAddedBands) {\n            updateColumnIndexes(that);\n            resultColumns = createColumnsFromOptions(that, resultColumns);\n          }\n\n          assignColumns(that, resultColumns);\n        }\n      };\n\n      var updateIndexes = function updateIndexes(that, column) {\n        updateColumnIndexes(that);\n        updateColumnGroupIndexes(that, column);\n        updateColumnSortIndexes(that, column);\n        resetBandColumnsCache(that);\n        updateColumnVisibleIndexes(that, column);\n      };\n\n      var resetColumnsCache = function resetColumnsCache(that) {\n        that.resetColumnsCache();\n      };\n\n      var assignColumns = function assignColumns(that, columns) {\n        that._columns = columns;\n        resetColumnsCache(that);\n        that.updateColumnDataTypes();\n      };\n\n      var updateColumnChanges = function updateColumnChanges(that, changeType, optionName, columnIndex) {\n        var columnChanges = that._columnChanges || {\n          optionNames: {\n            length: 0\n          },\n          changeTypes: {\n            length: 0\n          },\n          columnIndex: columnIndex\n        };\n        optionName = optionName || \"all\";\n        optionName = optionName.split(\".\")[0];\n        var changeTypes = columnChanges.changeTypes;\n\n        if (changeType && !changeTypes[changeType]) {\n          changeTypes[changeType] = true;\n          changeTypes.length++;\n        }\n\n        var optionNames = columnChanges.optionNames;\n\n        if (optionName && !optionNames[optionName]) {\n          optionNames[optionName] = true;\n          optionNames.length++;\n        }\n\n        if (void 0 === columnIndex || columnIndex !== columnChanges.columnIndex) {\n          delete columnChanges.columnIndex;\n        }\n\n        that._columnChanges = columnChanges;\n        resetColumnsCache(that);\n      };\n\n      var fireColumnsChanged = function fireColumnsChanged(that) {\n        var onColumnsChanging = that.option(\"onColumnsChanging\");\n        var columnChanges = that._columnChanges;\n        var reinitOptionNames = [\"dataField\", \"lookup\", \"dataType\", \"columns\"];\n\n        var needReinit = function needReinit(options) {\n          return options && reinitOptionNames.some(function (name) {\n            return options[name];\n          });\n        };\n\n        if (that.isInitialized() && !that._updateLockCount && columnChanges) {\n          if (onColumnsChanging) {\n            that._updateLockCount++;\n            onColumnsChanging((0, _extend.extend)({\n              component: that.component\n            }, columnChanges));\n            that._updateLockCount--;\n          }\n\n          that._columnChanges = void 0;\n\n          if (needReinit(columnChanges.optionNames)) {\n            that.reinit();\n          } else {\n            that.columnsChanged.fire(columnChanges);\n          }\n        }\n      };\n\n      var updateSortOrderWhenGrouping = function updateSortOrderWhenGrouping(column, groupIndex, prevGroupIndex) {\n        var columnWasGrouped = prevGroupIndex >= 0;\n\n        if (groupIndex >= 0) {\n          if (!columnWasGrouped) {\n            column.lastSortOrder = column.sortOrder;\n          }\n        } else {\n          column.sortOrder = column.lastSortOrder;\n        }\n      };\n\n      var fireOptionChanged = function fireOptionChanged(that, options) {\n        var value = options.value;\n        var optionName = options.optionName;\n        var prevValue = options.prevValue;\n        var fullOptionName = options.fullOptionName;\n        var fullOptionPath = \"\".concat(fullOptionName, \".\").concat(optionName);\n\n        if (!IGNORE_COLUMN_OPTION_NAMES[optionName] && that._skipProcessingColumnsChange !== fullOptionPath) {\n          that._skipProcessingColumnsChange = fullOptionPath;\n\n          that.component._notifyOptionChanged(fullOptionPath, value, prevValue);\n\n          that._skipProcessingColumnsChange = false;\n        }\n      };\n\n      var columnOptionCore = function columnOptionCore(that, column, optionName, value, notFireEvent) {\n        var optionGetter = _data2.default.compileGetter(optionName);\n\n        var columnIndex = column.index;\n        var prevValue;\n        var optionSetter;\n        var columns;\n        var changeType;\n        var fullOptionName;\n        var initialColumn;\n\n        if (3 === arguments.length) {\n          return optionGetter(column, {\n            functionsAsIs: true\n          });\n        }\n\n        prevValue = optionGetter(column, {\n          functionsAsIs: true\n        });\n\n        if (prevValue !== value) {\n          if (\"groupIndex\" === optionName || \"calculateGroupValue\" === optionName) {\n            changeType = \"grouping\";\n            updateSortOrderWhenGrouping(column, value, prevValue);\n          } else {\n            if (\"sortIndex\" === optionName || \"sortOrder\" === optionName || \"calculateSortValue\" === optionName) {\n              changeType = \"sorting\";\n            } else {\n              changeType = \"columns\";\n            }\n          }\n\n          optionSetter = _data2.default.compileSetter(optionName);\n          optionSetter(column, value, {\n            functionsAsIs: true\n          });\n          fullOptionName = getColumnFullPath(that, column);\n\n          if (COLUMN_INDEX_OPTIONS[optionName]) {\n            updateIndexes(that, column);\n            value = optionGetter(column);\n          }\n\n          fullOptionName && fireOptionChanged(that, {\n            fullOptionName: fullOptionName,\n            optionName: optionName,\n            value: value,\n            prevValue: prevValue\n          });\n\n          if (!(0, _type.isDefined)(prevValue) && !(0, _type.isDefined)(value) && 0 !== optionName.indexOf(\"buffer\")) {\n            notFireEvent = true;\n          }\n\n          if (!notFireEvent) {\n            if ((0, _array.inArray)(optionName, USER_STATE_FIELD_NAMES) < 0 && \"visibleWidth\" !== optionName) {\n              columns = that.option(\"columns\");\n              initialColumn = that.getColumnByPath(fullOptionName, columns);\n\n              if ((0, _type.isString)(initialColumn)) {\n                initialColumn = columns[columnIndex] = {\n                  dataField: initialColumn\n                };\n              }\n\n              if (initialColumn && checkUserStateColumn(initialColumn, column)) {\n                optionSetter(initialColumn, value, {\n                  functionsAsIs: true\n                });\n              }\n            }\n\n            updateColumnChanges(that, changeType, optionName, columnIndex);\n          } else {\n            resetColumnsCache(that);\n          }\n        }\n      };\n\n      var isSortOrderValid = function isSortOrderValid(sortOrder) {\n        return \"asc\" === sortOrder || \"desc\" === sortOrder;\n      };\n\n      var addExpandColumn = function addExpandColumn(that) {\n        var options = that._getExpandColumnOptions();\n\n        that.addCommandColumn(options);\n      };\n\n      var defaultSetCellValue = function defaultSetCellValue(data, value) {\n        var path = this.dataField.split(\".\");\n        var dotCount = path.length - 1;\n        var name;\n        var i;\n\n        if (this.serializeValue) {\n          value = this.serializeValue(value);\n        }\n\n        for (i = 0; i < dotCount; i++) {\n          name = path[i];\n          data = data[name] = data[name] || {};\n        }\n\n        data[path[dotCount]] = value;\n      };\n\n      var getDataColumns = function getDataColumns(columns, rowIndex, bandColumnID) {\n        var result = [];\n        rowIndex = rowIndex || 0;\n        columns[rowIndex] && _iterator2.default.each(columns[rowIndex], function (_, column) {\n          if (column.ownerBand === bandColumnID || (0, _type.isDefined)(column.groupIndex)) {\n            if (!column.isBand || !column.colspan) {\n              if (!column.command || rowIndex < 1) {\n                result.push(column);\n              }\n            } else {\n              result.push.apply(result, getDataColumns(columns, rowIndex + 1, column.index));\n            }\n          }\n        });\n        return result;\n      };\n\n      var _getRowCount = function _getRowCount(that) {\n        var rowCount = 1;\n        var bandColumnsCache = that.getBandColumnsCache();\n        var columnParentByIndex = bandColumnsCache.columnParentByIndex;\n\n        that._columns.forEach(function (column) {\n          var parents = getParentBandColumns(column.index, columnParentByIndex);\n          var invisibleParents = parents.filter(function (column) {\n            return !column.visible;\n          });\n\n          if (column.visible && !invisibleParents.length) {\n            rowCount = Math.max(rowCount, parents.length + 1);\n          }\n        });\n\n        return rowCount;\n      };\n\n      var getFixedPosition = function getFixedPosition(that, column) {\n        var rtlEnabled = that.option(\"rtlEnabled\");\n\n        if (column.command && !isCustomCommandColumn(that, column) || !column.fixedPosition) {\n          return rtlEnabled ? \"right\" : \"left\";\n        }\n\n        return column.fixedPosition;\n      };\n\n      var processExpandColumns = function processExpandColumns(columns, expandColumns, type, columnIndex) {\n        var customColumnIndex;\n        var rowCount = this.getRowCount();\n        var rowspan = columns[columnIndex] && columns[columnIndex].rowspan;\n        var expandColumnsByType = expandColumns.filter(function (column) {\n          return column.type === type;\n        });\n        columns.forEach(function (column, index) {\n          if (column.type === type) {\n            customColumnIndex = index;\n            rowspan = columns[index + 1] ? columns[index + 1].rowspan : rowCount;\n          }\n        });\n\n        if (rowspan > 1) {\n          expandColumnsByType = _iterator2.default.map(expandColumnsByType, function (expandColumn) {\n            return (0, _extend.extend)({}, expandColumn, {\n              rowspan: rowspan\n            });\n          });\n        }\n\n        expandColumnsByType.unshift.apply(expandColumnsByType, (0, _type.isDefined)(customColumnIndex) ? [customColumnIndex, 1] : [columnIndex, 0]);\n        columns.splice.apply(columns, expandColumnsByType);\n        return rowspan || 1;\n      };\n\n      var digitsCount = function digitsCount(number) {\n        var i;\n\n        for (i = 0; number > 1; i++) {\n          number /= 10;\n        }\n\n        return i;\n      };\n\n      var numberToString = function numberToString(number, digitsCount) {\n        var str = number ? number.toString() : \"0\";\n\n        while (str.length < digitsCount) {\n          str = \"0\" + str;\n        }\n\n        return str;\n      };\n\n      var mergeColumns = function mergeColumns(that, columns, commandColumns, needToExtend) {\n        var i;\n        var column;\n        var columnOptions;\n        var commandColumnIndex;\n        var result = columns.slice().map(function (column) {\n          return (0, _extend.extend)({}, column);\n        });\n\n        var isColumnFixing = that._isColumnFixing();\n\n        var defaultCommandColumns = commandColumns.slice().map(function (column) {\n          return (0, _extend.extend)({\n            fixed: isColumnFixing\n          }, column);\n        });\n\n        var getCommandColumnIndex = function getCommandColumnIndex(column) {\n          return commandColumns.reduce(function (result, commandColumn, index) {\n            var columnType = needToExtend && column.type === GROUP_COMMAND_COLUMN_NAME ? \"expand\" : column.type;\n            return commandColumn.type === columnType || commandColumn.command === column.command ? index : result;\n          }, -1);\n        };\n\n        var callbackFilter = function callbackFilter(commandColumn) {\n          return commandColumn.command !== commandColumns[commandColumnIndex].command;\n        };\n\n        for (i = 0; i < columns.length; i++) {\n          column = columns[i];\n          commandColumnIndex = column && (column.type || column.command) ? getCommandColumnIndex(column) : -1;\n\n          if (commandColumnIndex >= 0) {\n            if (needToExtend) {\n              result[i] = (0, _extend.extend)({\n                fixed: isColumnFixing\n              }, commandColumns[commandColumnIndex], column);\n\n              if (column.type !== GROUP_COMMAND_COLUMN_NAME) {\n                defaultCommandColumns = defaultCommandColumns.filter(callbackFilter);\n              }\n            } else {\n              columnOptions = {\n                visibleIndex: column.visibleIndex,\n                index: column.index,\n                headerId: column.headerId,\n                allowFixing: 0 === column.groupIndex,\n                allowReordering: 0 === column.groupIndex,\n                groupIndex: column.groupIndex\n              };\n              result[i] = (0, _extend.extend)({}, column, commandColumns[commandColumnIndex], column.type === GROUP_COMMAND_COLUMN_NAME && columnOptions);\n            }\n          }\n        }\n\n        if (columns.length && needToExtend && defaultCommandColumns.length) {\n          result = result.concat(defaultCommandColumns);\n        }\n\n        return result;\n      };\n\n      var isCustomCommandColumn = function isCustomCommandColumn(that, commandColumn) {\n        return !!that._columns.filter(function (column) {\n          return column.type === commandColumn.type;\n        }).length;\n      };\n\n      var isColumnFixed = function isColumnFixed(that, column) {\n        return (0, _type.isDefined)(column.fixed) || !column.type ? column.fixed : that._isColumnFixing();\n      };\n\n      var convertOwnerBandToColumnReference = function convertOwnerBandToColumnReference(columns) {\n        columns.forEach(function (column) {\n          if ((0, _type.isDefined)(column.ownerBand)) {\n            column.ownerBand = columns[column.ownerBand];\n          }\n        });\n      };\n\n      var resetBandColumnsCache = function resetBandColumnsCache(that) {\n        return that._bandColumnsCache = void 0;\n      };\n\n      return {\n        _getExpandColumnOptions: function _getExpandColumnOptions() {\n          return {\n            type: \"expand\",\n            command: \"expand\",\n            width: \"auto\",\n            cssClass: COMMAND_EXPAND_CLASS,\n            allowEditing: false,\n            allowGrouping: false,\n            allowSorting: false,\n            allowResizing: false,\n            allowReordering: false,\n            allowHiding: false\n          };\n        },\n        _getFirstItems: function _getFirstItems(dataSource) {\n          var groupsCount;\n          var items = [];\n\n          var getFirstItemsCore = function getFirstItemsCore(items, groupsCount) {\n            var i;\n            var childItems;\n\n            if (!items || !groupsCount) {\n              return items;\n            }\n\n            for (i = 0; i < items.length; i++) {\n              childItems = getFirstItemsCore(items[i].items || items[i].collapsedItems, groupsCount - 1);\n\n              if (childItems && childItems.length) {\n                return childItems;\n              }\n            }\n          };\n\n          if (dataSource && dataSource.items().length > 0) {\n            groupsCount = (0, _uiGrid_core3.normalizeSortingInfo)(dataSource.group()).length;\n            items = getFirstItemsCore(dataSource.items(), groupsCount) || [];\n          }\n\n          return items;\n        },\n        _endUpdateCore: function _endUpdateCore() {\n          !this._skipProcessingColumnsChange && fireColumnsChanged(this);\n        },\n        init: function init() {\n          var that = this;\n          var columns = that.option(\"columns\");\n          that._commandColumns = that._commandColumns || [];\n          that._columns = that._columns || [];\n          that._isColumnsFromOptions = !!columns;\n\n          if (that._isColumnsFromOptions) {\n            assignColumns(that, columns ? createColumnsFromOptions(that, columns) : []);\n            applyUserState(that);\n          } else {\n            assignColumns(that, that._columnsUserState ? createColumnsFromOptions(that, that._columnsUserState) : that._columns);\n          }\n\n          addExpandColumn(that);\n\n          if (that._dataSourceApplied) {\n            that.applyDataSource(that._dataSource, true);\n          } else {\n            updateIndexes(that);\n          }\n        },\n        callbackNames: function callbackNames() {\n          return [\"columnsChanged\"];\n        },\n        getColumnByPath: function getColumnByPath(path, columns) {\n          var that = this;\n          var column;\n          var columnIndexes = [];\n          path.replace(regExp, function (_, columnIndex) {\n            columnIndexes.push(parseInt(columnIndex));\n            return \"\";\n          });\n\n          if (columnIndexes.length) {\n            if (columns) {\n              column = columnIndexes.reduce(function (column, index) {\n                return column && column.columns && column.columns[index];\n              }, {\n                columns: columns\n              });\n            } else {\n              column = getColumnByIndexes(that, columnIndexes);\n            }\n          }\n\n          return column;\n        },\n        optionChanged: function optionChanged(args) {\n          var needUpdateRequireResize;\n\n          switch (args.name) {\n            case \"adaptColumnWidthByRatio\":\n              args.handled = true;\n              break;\n\n            case \"dataSource\":\n              if (args.value !== args.previousValue && !this.option(\"columns\") && (!Array.isArray(args.value) || !Array.isArray(args.previousValue))) {\n                this._columns = [];\n              }\n\n              break;\n\n            case \"columns\":\n              needUpdateRequireResize = this._skipProcessingColumnsChange;\n              args.handled = true;\n\n              if (!this._skipProcessingColumnsChange) {\n                if (args.name === args.fullName) {\n                  this._columnsUserState = null;\n                  this._ignoreColumnOptionNames = null;\n                  this.init();\n                } else {\n                  this._columnOptionChanged(args);\n\n                  needUpdateRequireResize = true;\n                }\n              }\n\n              if (needUpdateRequireResize) {\n                this._updateRequireResize(args);\n              }\n\n              break;\n\n            case \"commonColumnSettings\":\n            case \"columnAutoWidth\":\n            case \"allowColumnResizing\":\n            case \"allowColumnReordering\":\n            case \"columnFixing\":\n            case \"grouping\":\n            case \"groupPanel\":\n            case \"regenerateColumnsByVisibleItems\":\n            case \"customizeColumns\":\n            case \"editing\":\n            case \"columnHidingEnabled\":\n            case \"dateSerializationFormat\":\n            case \"columnResizingMode\":\n            case \"columnMinWidth\":\n            case \"columnWidth\":\n              args.handled = true;\n              var ignoreColumnOptionNames = \"columnWidth\" === args.fullName && [\"width\"];\n              var isEditingPopup = args.fullName && 0 === args.fullName.indexOf(\"editing.popup\");\n              var isEditingForm = args.fullName && 0 === args.fullName.indexOf(\"editing.form\");\n\n              if (!isEditingPopup && !isEditingForm) {\n                this.reinit(ignoreColumnOptionNames);\n              }\n\n              break;\n\n            case \"rtlEnabled\":\n              this.reinit();\n              break;\n\n            default:\n              this.callBase(args);\n          }\n        },\n        _columnOptionChanged: function _columnOptionChanged(args) {\n          var columnOptionValue = {};\n          var column = this.getColumnByPath(args.fullName);\n          var columnOptionName = args.fullName.replace(regExp, \"\");\n\n          if (column) {\n            if (columnOptionName) {\n              columnOptionValue[columnOptionName] = args.value;\n            } else {\n              columnOptionValue = args.value;\n            }\n\n            this._skipProcessingColumnsChange = args.fullName;\n            this.columnOption(column.index, columnOptionValue);\n            this._skipProcessingColumnsChange = false;\n          }\n        },\n        _updateRequireResize: function _updateRequireResize(args) {\n          var component = this.component;\n\n          if (\"width\" === args.fullName.replace(regExp, \"\") && component._updateLockCount) {\n            component._requireResize = true;\n          }\n        },\n        publicMethods: function publicMethods() {\n          return [\"addColumn\", \"deleteColumn\", \"columnOption\", \"columnCount\", \"clearSorting\", \"clearGrouping\", \"getVisibleColumns\", \"getVisibleColumnIndex\"];\n        },\n        applyDataSource: function applyDataSource(dataSource, forceApplying) {\n          var that = this;\n          var isDataSourceLoaded = dataSource && dataSource.isLoaded();\n          that._dataSource = dataSource;\n\n          if (!that._dataSourceApplied || 0 === that._dataSourceColumnsCount || forceApplying || that.option(\"regenerateColumnsByVisibleItems\")) {\n            if (isDataSourceLoaded) {\n              if (!that._isColumnsFromOptions) {\n                var columnsFromDataSource = createColumnsFromDataSource(that, dataSource);\n\n                if (columnsFromDataSource.length) {\n                  assignColumns(that, columnsFromDataSource);\n                  that._dataSourceColumnsCount = that._columns.length;\n                  applyUserState(that);\n                }\n              }\n\n              return that.updateColumns(dataSource, forceApplying);\n            } else {\n              that._dataSourceApplied = false;\n            }\n          } else {\n            if (isDataSourceLoaded && !that.isAllDataTypesDefined(true) && that.updateColumnDataTypes(dataSource)) {\n              updateColumnChanges(that, \"columns\");\n              fireColumnsChanged(that);\n              return new _deferred.Deferred().reject().promise();\n            }\n          }\n        },\n        reset: function reset() {\n          this._dataSourceApplied = false;\n          this._dataSourceColumnsCount = void 0;\n          this.reinit();\n        },\n        resetColumnsCache: function resetColumnsCache() {\n          var that = this;\n          that._visibleColumns = void 0;\n          that._fixedColumns = void 0;\n          that._rowCount = void 0;\n          resetBandColumnsCache(that);\n        },\n        reinit: function reinit(ignoreColumnOptionNames) {\n          this._columnsUserState = this.getUserState();\n          this._ignoreColumnOptionNames = ignoreColumnOptionNames || null;\n          this.init();\n\n          if (ignoreColumnOptionNames) {\n            this._ignoreColumnOptionNames = null;\n          }\n        },\n        isInitialized: function isInitialized() {\n          return !!this._columns.length || !!this.option(\"columns\");\n        },\n        isDataSourceApplied: function isDataSourceApplied() {\n          return this._dataSourceApplied;\n        },\n        getCommonSettings: function getCommonSettings(column) {\n          var commonColumnSettings = (!column || !column.type) && this.option(\"commonColumnSettings\") || {};\n          var groupingOptions = this.option(\"grouping\") || {};\n          var groupPanelOptions = this.option(\"groupPanel\") || {};\n          return (0, _extend.extend)({\n            allowFixing: this.option(\"columnFixing.enabled\"),\n            allowResizing: this.option(\"allowColumnResizing\") || void 0,\n            allowReordering: this.option(\"allowColumnReordering\"),\n            minWidth: this.option(\"columnMinWidth\"),\n            width: this.option(\"columnWidth\"),\n            autoExpandGroup: groupingOptions.autoExpandAll,\n            allowCollapsing: groupingOptions.allowCollapsing,\n            allowGrouping: groupPanelOptions.allowColumnDragging && groupPanelOptions.visible || groupingOptions.contextMenuEnabled\n          }, commonColumnSettings);\n        },\n        isColumnOptionUsed: function isColumnOptionUsed(optionName) {\n          for (var i = 0; i < this._columns.length; i++) {\n            if (this._columns[i][optionName]) {\n              return true;\n            }\n          }\n        },\n        isAllDataTypesDefined: function isAllDataTypesDefined(checkSerializers) {\n          var columns = this._columns;\n          var i;\n\n          if (!columns.length) {\n            return false;\n          }\n\n          for (i = 0; i < columns.length; i++) {\n            if (!columns[i].dataField && columns[i].calculateCellValue === columns[i].defaultCalculateCellValue) {\n              continue;\n            }\n\n            if (!columns[i].dataType || checkSerializers && columns[i].deserializeValue && void 0 === columns[i].serializationFormat) {\n              return false;\n            }\n          }\n\n          return true;\n        },\n        getColumns: function getColumns() {\n          return this._columns;\n        },\n        isBandColumnsUsed: function isBandColumnsUsed() {\n          return this.getColumns().some(function (column) {\n            return column.isBand;\n          });\n        },\n        getGroupColumns: function getGroupColumns() {\n          var result = [];\n\n          _iterator2.default.each(this._columns, function () {\n            var column = this;\n\n            if ((0, _type.isDefined)(column.groupIndex)) {\n              result[column.groupIndex] = column;\n            }\n          });\n\n          return result;\n        },\n        getVisibleColumns: function getVisibleColumns(rowIndex) {\n          this._visibleColumns = this._visibleColumns || this._getVisibleColumnsCore();\n          rowIndex = (0, _type.isDefined)(rowIndex) ? rowIndex : this._visibleColumns.length - 1;\n          return this._visibleColumns[rowIndex] || [];\n        },\n        getFixedColumns: function getFixedColumns(rowIndex) {\n          this._fixedColumns = this._fixedColumns || this._getFixedColumnsCore();\n          rowIndex = (0, _type.isDefined)(rowIndex) ? rowIndex : this._fixedColumns.length - 1;\n          return this._fixedColumns[rowIndex] || [];\n        },\n        getFilteringColumns: function getFilteringColumns() {\n          return this.getColumns().filter(function (item) {\n            return (item.dataField || item.name) && (item.allowFiltering || item.allowHeaderFiltering);\n          }).map(function (item) {\n            var field = (0, _extend.extend)(true, {}, item);\n\n            if (!(0, _type.isDefined)(field.dataField)) {\n              field.dataField = field.name;\n            }\n\n            field.filterOperations = item.filterOperations !== item.defaultFilterOperations ? field.filterOperations : null;\n            return field;\n          });\n        },\n        _getFixedColumnsCore: function _getFixedColumnsCore() {\n          var that = this;\n          var i;\n          var j;\n          var column;\n          var prevColumn;\n          var result = [];\n          var rowCount = that.getRowCount();\n\n          var isColumnFixing = that._isColumnFixing();\n\n          var transparentColumn = {\n            command: \"transparent\"\n          };\n          var transparentColspan = 0;\n          var notFixedColumnCount;\n          var transparentColumnIndex;\n          var lastFixedPosition;\n          var visibleColumns;\n\n          if (isColumnFixing) {\n            for (i = 0; i <= rowCount; i++) {\n              notFixedColumnCount = 0;\n              lastFixedPosition = null;\n              transparentColumnIndex = null;\n              visibleColumns = that.getVisibleColumns(i, true);\n\n              for (j = 0; j < visibleColumns.length; j++) {\n                prevColumn = visibleColumns[j - 1];\n                column = visibleColumns[j];\n\n                if (!column.fixed) {\n                  if (0 === i) {\n                    if (column.isBand && column.colspan) {\n                      transparentColspan += column.colspan;\n                    } else {\n                      transparentColspan++;\n                    }\n                  }\n\n                  notFixedColumnCount++;\n\n                  if (!(0, _type.isDefined)(transparentColumnIndex)) {\n                    transparentColumnIndex = j;\n                  }\n                } else {\n                  if (prevColumn && prevColumn.fixed && getFixedPosition(that, prevColumn) !== getFixedPosition(that, column)) {\n                    if (!(0, _type.isDefined)(transparentColumnIndex)) {\n                      transparentColumnIndex = j;\n                    }\n                  } else {\n                    lastFixedPosition = column.fixedPosition;\n                  }\n                }\n              }\n\n              if (0 === i && (0 === notFixedColumnCount || notFixedColumnCount >= visibleColumns.length)) {\n                return [];\n              }\n\n              if (!(0, _type.isDefined)(transparentColumnIndex)) {\n                transparentColumnIndex = \"right\" === lastFixedPosition ? 0 : visibleColumns.length;\n              }\n\n              result[i] = visibleColumns.slice(0);\n\n              if (!transparentColumn.colspan) {\n                transparentColumn.colspan = transparentColspan;\n              }\n\n              result[i].splice(transparentColumnIndex, notFixedColumnCount, transparentColumn);\n            }\n          }\n\n          return result;\n        },\n        _isColumnFixing: function _isColumnFixing() {\n          var isColumnFixing = this.option(\"columnFixing.enabled\");\n          !isColumnFixing && _iterator2.default.each(this._columns, function (_, column) {\n            if (column.fixed) {\n              isColumnFixing = true;\n              return false;\n            }\n          });\n          return isColumnFixing;\n        },\n        _getExpandColumnsCore: function _getExpandColumnsCore() {\n          return this.getGroupColumns();\n        },\n        getExpandColumns: function getExpandColumns() {\n          var expandColumns = this._getExpandColumnsCore();\n\n          var expandColumn;\n          var firstGroupColumn = expandColumns.filter(function (column) {\n            return 0 === column.groupIndex;\n          })[0];\n          var isFixedFirstGroupColumn = firstGroupColumn && firstGroupColumn.fixed;\n\n          var isColumnFixing = this._isColumnFixing();\n\n          if (expandColumns.length) {\n            expandColumn = this.columnOption(\"command:expand\");\n          }\n\n          expandColumns = _iterator2.default.map(expandColumns, function (column) {\n            return (0, _extend.extend)({}, column, {\n              visibleWidth: null,\n              minWidth: null,\n              cellTemplate: !(0, _type.isDefined)(column.groupIndex) ? column.cellTemplate : null,\n              headerCellTemplate: null,\n              fixed: !(0, _type.isDefined)(column.groupIndex) || !isFixedFirstGroupColumn ? isColumnFixing : true\n            }, expandColumn, {\n              index: column.index,\n              type: column.type || GROUP_COMMAND_COLUMN_NAME\n            });\n          });\n          return expandColumns;\n        },\n        getBandColumnsCache: function getBandColumnsCache() {\n          if (!this._bandColumnsCache) {\n            var columns = this._columns;\n            var columnChildrenByIndex = {};\n            var columnParentByIndex = {};\n            var isPlain = true;\n            columns.forEach(function (column) {\n              var parentIndex = column.ownerBand;\n              var parent = columns[parentIndex];\n\n              if (column.hasColumns) {\n                isPlain = false;\n              }\n\n              if (column.colspan) {\n                column.colspan = void 0;\n              }\n\n              if (column.rowspan) {\n                column.rowspan = void 0;\n              }\n\n              if (parent) {\n                columnParentByIndex[column.index] = parent;\n              } else {\n                parentIndex = -1;\n              }\n\n              columnChildrenByIndex[parentIndex] = columnChildrenByIndex[parentIndex] || [];\n              columnChildrenByIndex[parentIndex].push(column);\n            });\n            this._bandColumnsCache = {\n              isPlain: isPlain,\n              columnChildrenByIndex: columnChildrenByIndex,\n              columnParentByIndex: columnParentByIndex\n            };\n          }\n\n          return this._bandColumnsCache;\n        },\n        _isColumnVisible: function _isColumnVisible(column) {\n          return column.visible && this.isParentColumnVisible(column.index);\n        },\n        _getVisibleColumnsCore: function _getVisibleColumnsCore() {\n          var that = this;\n          var i;\n          var result = [];\n          var rowspanGroupColumns = 0;\n          var rowspanExpandColumns = 0;\n          var firstPositiveIndexColumn;\n          var rowCount = that.getRowCount();\n          var positiveIndexedColumns = [];\n          var negativeIndexedColumns = [];\n          var notGroupedColumnsCount = 0;\n          var isFixedToEnd;\n          var rtlEnabled = that.option(\"rtlEnabled\");\n          var bandColumnsCache = that.getBandColumnsCache();\n          var expandColumns = mergeColumns(that, that.getExpandColumns(), that._columns);\n          var columns = mergeColumns(that, that._columns, that._commandColumns, true);\n          var columnDigitsCount = digitsCount(columns.length);\n          processBandColumns(that, columns, bandColumnsCache);\n\n          for (i = 0; i < rowCount; i++) {\n            result[i] = [];\n            negativeIndexedColumns[i] = [{}];\n            positiveIndexedColumns[i] = [{}, {}, {}];\n          }\n\n          _iterator2.default.each(columns, function () {\n            var column = this;\n            var rowIndex;\n            var visibleIndex = column.visibleIndex;\n            var indexedColumns;\n            var parentBandColumns = getParentBandColumns(column.index, bandColumnsCache.columnParentByIndex);\n\n            var visible = that._isColumnVisible(column);\n\n            if (visible && (!(0, _type.isDefined)(column.groupIndex) || column.showWhenGrouped)) {\n              rowIndex = parentBandColumns.length;\n\n              if (visibleIndex < 0) {\n                visibleIndex = -visibleIndex;\n                indexedColumns = negativeIndexedColumns[rowIndex];\n              } else {\n                column.fixed = parentBandColumns.length ? parentBandColumns[0].fixed : column.fixed;\n                column.fixedPosition = parentBandColumns.length ? parentBandColumns[0].fixedPosition : column.fixedPosition;\n\n                if (column.fixed) {\n                  isFixedToEnd = \"right\" === column.fixedPosition;\n\n                  if (rtlEnabled && (!column.command || isCustomCommandColumn(that, column))) {\n                    isFixedToEnd = !isFixedToEnd;\n                  }\n\n                  if (isFixedToEnd) {\n                    indexedColumns = positiveIndexedColumns[rowIndex][2];\n                  } else {\n                    indexedColumns = positiveIndexedColumns[rowIndex][0];\n                  }\n                } else {\n                  indexedColumns = positiveIndexedColumns[rowIndex][1];\n                }\n              }\n\n              if (parentBandColumns.length) {\n                visibleIndex = numberToString(visibleIndex, columnDigitsCount);\n\n                for (i = parentBandColumns.length - 1; i >= 0; i--) {\n                  visibleIndex = numberToString(parentBandColumns[i].visibleIndex, columnDigitsCount) + visibleIndex;\n                }\n              }\n\n              indexedColumns[visibleIndex] = indexedColumns[visibleIndex] || [];\n              indexedColumns[visibleIndex].push(column);\n              notGroupedColumnsCount++;\n            }\n          });\n\n          _iterator2.default.each(result, function (rowIndex) {\n            (0, _object.orderEach)(negativeIndexedColumns[rowIndex], function (_, columns) {\n              result[rowIndex].unshift.apply(result[rowIndex], columns);\n            });\n            firstPositiveIndexColumn = result[rowIndex].length;\n\n            _iterator2.default.each(positiveIndexedColumns[rowIndex], function (index, columnsByFixing) {\n              (0, _object.orderEach)(columnsByFixing, function (_, columnsByVisibleIndex) {\n                result[rowIndex].push.apply(result[rowIndex], columnsByVisibleIndex);\n              });\n            });\n\n            if (rowspanExpandColumns < rowIndex + 1) {\n              rowspanExpandColumns += processExpandColumns.call(that, result[rowIndex], expandColumns, \"detailExpand\", firstPositiveIndexColumn);\n            }\n\n            if (rowspanGroupColumns < rowIndex + 1) {\n              rowspanGroupColumns += processExpandColumns.call(that, result[rowIndex], expandColumns, GROUP_COMMAND_COLUMN_NAME, firstPositiveIndexColumn);\n            }\n          });\n\n          result.push(getDataColumns(result));\n\n          if (!notGroupedColumnsCount && that._columns.length) {\n            result[rowCount].push({\n              command: \"empty\"\n            });\n          }\n\n          return result;\n        },\n        getInvisibleColumns: function getInvisibleColumns(columns, bandColumnIndex) {\n          var that = this;\n          var result = [];\n          var hiddenColumnsByBand;\n          columns = columns || that._columns;\n\n          _iterator2.default.each(columns, function (_, column) {\n            if (column.ownerBand !== bandColumnIndex) {\n              return;\n            }\n\n            if (column.isBand) {\n              if (!column.visible) {\n                hiddenColumnsByBand = that.getChildrenByBandColumn(column.index);\n              } else {\n                hiddenColumnsByBand = that.getInvisibleColumns(that.getChildrenByBandColumn(column.index), column.index);\n              }\n\n              if (hiddenColumnsByBand.length) {\n                result.push(column);\n                result = result.concat(hiddenColumnsByBand);\n              }\n\n              return;\n            }\n\n            if (!column.visible) {\n              result.push(column);\n            }\n          });\n\n          return result;\n        },\n        getChooserColumns: function getChooserColumns(getAllColumns) {\n          var columns = getAllColumns ? this.getColumns() : this.getInvisibleColumns();\n          return (0, _common.grep)(columns, function (column) {\n            return column.showInColumnChooser;\n          });\n        },\n        allowMoveColumn: function allowMoveColumn(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {\n          var that = this;\n          var columnIndex = getColumnIndexByVisibleIndex(that, fromVisibleIndex, sourceLocation);\n          var sourceColumn = that._columns[columnIndex];\n\n          if (sourceColumn && (sourceColumn.allowReordering || sourceColumn.allowGrouping || sourceColumn.allowHiding)) {\n            if (sourceLocation === targetLocation) {\n              if (sourceLocation === COLUMN_CHOOSER_LOCATION) {\n                return false;\n              }\n\n              fromVisibleIndex = (0, _type.isObject)(fromVisibleIndex) ? fromVisibleIndex.columnIndex : fromVisibleIndex;\n              toVisibleIndex = (0, _type.isObject)(toVisibleIndex) ? toVisibleIndex.columnIndex : toVisibleIndex;\n              return fromVisibleIndex !== toVisibleIndex && fromVisibleIndex + 1 !== toVisibleIndex;\n            } else {\n              if (sourceLocation === GROUP_LOCATION && targetLocation !== COLUMN_CHOOSER_LOCATION || targetLocation === GROUP_LOCATION) {\n                return sourceColumn && sourceColumn.allowGrouping;\n              } else {\n                if (sourceLocation === COLUMN_CHOOSER_LOCATION || targetLocation === COLUMN_CHOOSER_LOCATION) {\n                  return sourceColumn && sourceColumn.allowHiding;\n                }\n              }\n            }\n\n            return true;\n          }\n\n          return false;\n        },\n        moveColumn: function moveColumn(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {\n          var that = this;\n          var options = {};\n          var prevGroupIndex;\n          var fromIndex = getColumnIndexByVisibleIndex(that, fromVisibleIndex, sourceLocation);\n          var toIndex = getColumnIndexByVisibleIndex(that, toVisibleIndex, targetLocation);\n          var targetGroupIndex;\n          var column;\n\n          if (fromIndex >= 0) {\n            column = that._columns[fromIndex];\n            toVisibleIndex = (0, _type.isObject)(toVisibleIndex) ? toVisibleIndex.columnIndex : toVisibleIndex;\n            targetGroupIndex = toIndex >= 0 ? that._columns[toIndex].groupIndex : -1;\n\n            if ((0, _type.isDefined)(column.groupIndex) && sourceLocation === GROUP_LOCATION) {\n              if (targetGroupIndex > column.groupIndex) {\n                targetGroupIndex--;\n              }\n\n              if (targetLocation !== GROUP_LOCATION) {\n                options.groupIndex = void 0;\n              } else {\n                prevGroupIndex = column.groupIndex;\n                delete column.groupIndex;\n                updateColumnGroupIndexes(that);\n              }\n            }\n\n            if (targetLocation === GROUP_LOCATION) {\n              options.groupIndex = moveColumnToGroup(that, column, targetGroupIndex);\n              column.groupIndex = prevGroupIndex;\n            } else {\n              if (toVisibleIndex >= 0) {\n                var targetColumn = that._columns[toIndex];\n\n                if (!targetColumn || column.ownerBand !== targetColumn.ownerBand) {\n                  options.visibleIndex = MAX_SAFE_INTEGER;\n                } else {\n                  if (isColumnFixed(that, column) ^ isColumnFixed(that, targetColumn)) {\n                    options.visibleIndex = MAX_SAFE_INTEGER;\n                  } else {\n                    options.visibleIndex = targetColumn.visibleIndex;\n                  }\n                }\n              }\n            }\n\n            var isVisible = targetLocation !== COLUMN_CHOOSER_LOCATION;\n\n            if (column.visible !== isVisible) {\n              options.visible = isVisible;\n            }\n\n            that.columnOption(column.index, options);\n          }\n        },\n        changeSortOrder: function changeSortOrder(columnIndex, sortOrder) {\n          var that = this;\n          var options = {};\n          var sortingOptions = that.option(\"sorting\");\n          var sortingMode = sortingOptions && sortingOptions.mode;\n          var needResetSorting = \"single\" === sortingMode || !sortOrder;\n          var allowSorting = \"single\" === sortingMode || \"multiple\" === sortingMode;\n          var column = that._columns[columnIndex];\n\n          var nextSortOrder = function nextSortOrder(column) {\n            if (\"ctrl\" === sortOrder) {\n              if (!(\"sortOrder\" in column && \"sortIndex\" in column)) {\n                return false;\n              }\n\n              options.sortOrder = void 0;\n              options.sortIndex = void 0;\n            } else {\n              if ((0, _type.isDefined)(column.groupIndex) || (0, _type.isDefined)(column.sortIndex)) {\n                options.sortOrder = \"desc\" === column.sortOrder ? \"asc\" : \"desc\";\n              } else {\n                options.sortOrder = \"asc\";\n              }\n            }\n\n            return true;\n          };\n\n          if (allowSorting && column && column.allowSorting) {\n            if (needResetSorting && !(0, _type.isDefined)(column.groupIndex)) {\n              _iterator2.default.each(that._columns, function (index) {\n                if (index !== columnIndex && this.sortOrder && !(0, _type.isDefined)(this.groupIndex)) {\n                  delete this.sortOrder;\n                  delete this.sortIndex;\n                }\n              });\n            }\n\n            if (isSortOrderValid(sortOrder)) {\n              if (column.sortOrder !== sortOrder) {\n                options.sortOrder = sortOrder;\n              }\n            } else {\n              if (\"none\" === sortOrder) {\n                if (column.sortOrder) {\n                  options.sortIndex = void 0;\n                  options.sortOrder = void 0;\n                }\n              } else {\n                nextSortOrder(column);\n              }\n            }\n          }\n\n          that.columnOption(column.index, options);\n        },\n        getSortDataSourceParameters: function getSortDataSourceParameters(useLocalSelector) {\n          var that = this;\n          var sortColumns = [];\n          var sort = [];\n\n          _iterator2.default.each(that._columns, function () {\n            if ((this.dataField || this.selector || this.calculateCellValue) && (0, _type.isDefined)(this.sortIndex) && !(0, _type.isDefined)(this.groupIndex)) {\n              sortColumns[this.sortIndex] = this;\n            }\n          });\n\n          _iterator2.default.each(sortColumns, function () {\n            var sortOrder = this && this.sortOrder;\n\n            if (isSortOrderValid(sortOrder)) {\n              var sortItem = {\n                selector: this.calculateSortValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue,\n                desc: \"desc\" === this.sortOrder\n              };\n\n              if (this.sortingMethod) {\n                sortItem.compare = this.sortingMethod.bind(this);\n              }\n\n              sort.push(sortItem);\n            }\n          });\n\n          return sort.length > 0 ? sort : null;\n        },\n        getGroupDataSourceParameters: function getGroupDataSourceParameters(useLocalSelector) {\n          var group = [];\n\n          _iterator2.default.each(this.getGroupColumns(), function () {\n            var selector = this.calculateGroupValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue;\n\n            if (selector) {\n              var groupItem = {\n                selector: selector,\n                desc: \"desc\" === this.sortOrder,\n                isExpanded: !!this.autoExpandGroup\n              };\n\n              if (this.sortingMethod) {\n                groupItem.compare = this.sortingMethod.bind(this);\n              }\n\n              group.push(groupItem);\n            }\n          });\n\n          return group.length > 0 ? group : null;\n        },\n        refresh: function refresh(updateNewLookupsOnly) {\n          var deferreds = [];\n\n          _iterator2.default.each(this._columns, function () {\n            var lookup = this.lookup;\n\n            if (lookup && !this.calculateDisplayValue) {\n              if (updateNewLookupsOnly && lookup.valueMap) {\n                return;\n              }\n\n              if (lookup.update) {\n                deferreds.push(lookup.update());\n              }\n            }\n          });\n\n          return _deferred.when.apply(_renderer2.default, deferreds).done(resetColumnsCache.bind(null, this));\n        },\n        _updateColumnOptions: function _updateColumnOptions(column, columnIndex) {\n          column.selector = column.selector || function (data) {\n            return column.calculateCellValue(data);\n          };\n\n          _iterator2.default.each([\"calculateSortValue\", \"calculateGroupValue\", \"calculateDisplayValue\"], function (_, calculateCallbackName) {\n            var calculateCallback = column[calculateCallbackName];\n\n            if ((0, _type.isFunction)(calculateCallback) && !calculateCallback.originalCallback) {\n              column[calculateCallbackName] = function (data) {\n                return calculateCallback.call(column, data);\n              };\n\n              column[calculateCallbackName].originalCallback = calculateCallback;\n              column[calculateCallbackName].columnIndex = columnIndex;\n            }\n          });\n\n          if ((0, _type.isString)(column.calculateDisplayValue)) {\n            column.displayField = column.calculateDisplayValue;\n            column.calculateDisplayValue = _data2.default.compileGetter(column.displayField);\n          }\n\n          if (column.calculateDisplayValue) {\n            column.displayValueMap = column.displayValueMap || {};\n          }\n\n          updateSerializers(column, column.dataType);\n          var lookup = column.lookup;\n\n          if (lookup) {\n            updateSerializers(lookup, lookup.dataType);\n          }\n\n          var dataType = lookup ? lookup.dataType : column.dataType;\n\n          if (dataType) {\n            column.alignment = column.alignment || getAlignmentByDataType(dataType, this.option(\"rtlEnabled\"));\n            column.format = column.format || (0, _uiGrid_core3.getFormatByDataType)(dataType);\n            column.customizeText = column.customizeText || getCustomizeTextByDataType(dataType);\n            column.defaultFilterOperations = column.defaultFilterOperations || !lookup && DATATYPE_OPERATIONS[dataType] || [];\n\n            if (!(0, _type.isDefined)(column.filterOperations)) {\n              setFilterOperationsAsDefaultValues(column);\n            }\n\n            column.defaultFilterOperation = column.filterOperations && column.filterOperations[0] || \"=\";\n            column.showEditorAlways = (0, _type.isDefined)(column.showEditorAlways) ? column.showEditorAlways : \"boolean\" === dataType && !column.cellTemplate;\n          }\n        },\n        updateColumnDataTypes: function updateColumnDataTypes(dataSource) {\n          var that = this;\n          var dateSerializationFormat = that.option(\"dateSerializationFormat\");\n\n          var firstItems = that._getFirstItems(dataSource);\n\n          var isColumnDataTypesUpdated = false;\n\n          _iterator2.default.each(that._columns, function (index, column) {\n            var i;\n            var value;\n            var dataType;\n            var lookupDataType;\n            var valueDataType;\n            var lookup = column.lookup;\n\n            if ((0, _uiGrid_core3.isDateType)(column.dataType) && void 0 === column.serializationFormat) {\n              column.serializationFormat = dateSerializationFormat;\n            }\n\n            if (lookup && (0, _uiGrid_core3.isDateType)(lookup.dataType) && void 0 === column.serializationFormat) {\n              lookup.serializationFormat = dateSerializationFormat;\n            }\n\n            if (column.calculateCellValue && firstItems.length) {\n              if (!column.dataType || lookup && !lookup.dataType) {\n                for (i = 0; i < firstItems.length; i++) {\n                  value = column.calculateCellValue(firstItems[i]);\n\n                  if (!column.dataType) {\n                    valueDataType = getValueDataType(value);\n                    dataType = dataType || valueDataType;\n\n                    if (dataType && valueDataType && dataType !== valueDataType) {\n                      dataType = \"string\";\n                    }\n                  }\n\n                  if (lookup && !lookup.dataType) {\n                    valueDataType = getValueDataType((0, _uiGrid_core3.getDisplayValue)(column, value, firstItems[i]));\n                    lookupDataType = lookupDataType || valueDataType;\n\n                    if (lookupDataType && valueDataType && lookupDataType !== valueDataType) {\n                      lookupDataType = \"string\";\n                    }\n                  }\n                }\n\n                if (dataType || lookupDataType) {\n                  if (dataType) {\n                    column.dataType = dataType;\n                  }\n\n                  if (lookup && lookupDataType) {\n                    lookup.dataType = lookupDataType;\n                  }\n\n                  isColumnDataTypesUpdated = true;\n                }\n              }\n\n              if (void 0 === column.serializationFormat || lookup && void 0 === lookup.serializationFormat) {\n                for (i = 0; i < firstItems.length; i++) {\n                  value = column.calculateCellValue(firstItems[i], true);\n\n                  if (void 0 === column.serializationFormat) {\n                    column.serializationFormat = getSerializationFormat(column.dataType, value);\n                  }\n\n                  if (lookup && void 0 === lookup.serializationFormat) {\n                    lookup.serializationFormat = getSerializationFormat(lookup.dataType, lookup.calculateCellValue(value, true));\n                  }\n                }\n              }\n            }\n\n            that._updateColumnOptions(column, index);\n          });\n\n          return isColumnDataTypesUpdated;\n        },\n        _customizeColumns: function _customizeColumns(columns) {\n          var that = this;\n          var hasOwnerBand;\n          var customizeColumns = that.option(\"customizeColumns\");\n\n          if (customizeColumns) {\n            hasOwnerBand = columns.some(function (column) {\n              return (0, _type.isObject)(column.ownerBand);\n            });\n\n            if (hasOwnerBand) {\n              updateIndexes(that);\n            }\n\n            customizeColumns(columns);\n            assignColumns(that, createColumnsFromOptions(that, columns));\n          }\n        },\n        _checkAsyncValidationRules: function _checkAsyncValidationRules() {\n          var currentEditMode = this.option(\"editing.mode\");\n\n          if (\"form\" !== currentEditMode && \"popup\" !== currentEditMode) {\n            var hasAsyncRules = this._columns.some(function (col) {\n              return (col.validationRules || []).some(function (rule) {\n                return \"async\" === rule.type;\n              });\n            });\n\n            if (hasAsyncRules) {\n              _ui2.default.log(\"E1057\", this.component.NAME, currentEditMode);\n            }\n          }\n        },\n        updateColumns: function updateColumns(dataSource, forceApplying) {\n          var that = this;\n          var sortParameters;\n          var groupParameters;\n\n          if (!forceApplying) {\n            that.updateSortingGrouping(dataSource);\n          }\n\n          if (!dataSource || dataSource.isLoaded()) {\n            sortParameters = dataSource ? dataSource.sort() || [] : that.getSortDataSourceParameters();\n            groupParameters = dataSource ? dataSource.group() || [] : that.getGroupDataSourceParameters();\n\n            that._customizeColumns(that._columns);\n\n            that._checkAsyncValidationRules();\n\n            updateIndexes(that);\n            var columns = that._columns;\n            return (0, _deferred.when)(that.refresh(true)).always(function () {\n              if (that._columns !== columns) {\n                return;\n              }\n\n              that._updateChanges(dataSource, {\n                sorting: sortParameters,\n                grouping: groupParameters\n              });\n\n              fireColumnsChanged(that);\n            });\n          }\n        },\n        _updateChanges: function _updateChanges(dataSource, parameters) {\n          var that = this;\n\n          if (dataSource) {\n            that.updateColumnDataTypes(dataSource);\n            that._dataSourceApplied = true;\n          }\n\n          if (!(0, _uiGrid_core3.equalSortParameters)(parameters.sorting, that.getSortDataSourceParameters())) {\n            updateColumnChanges(that, \"sorting\");\n          }\n\n          if (!(0, _uiGrid_core3.equalSortParameters)(parameters.grouping, that.getGroupDataSourceParameters())) {\n            updateColumnChanges(that, \"grouping\");\n          }\n\n          updateColumnChanges(that, \"columns\");\n        },\n        updateSortingGrouping: function updateSortingGrouping(dataSource, fromDataSource) {\n          var that = this;\n          var sortParameters;\n          var groupParameters;\n          var columnsGroupParameters;\n          var columnsSortParameters;\n          var isColumnsChanged;\n\n          var updateSortGroupParameterIndexes = function updateSortGroupParameterIndexes(columns, sortParameters, indexParameterName) {\n            var i;\n            var selector;\n            var isExpanded;\n\n            _iterator2.default.each(columns, function (index, column) {\n              delete column[indexParameterName];\n\n              if (sortParameters) {\n                for (i = 0; i < sortParameters.length; i++) {\n                  selector = sortParameters[i].selector;\n                  isExpanded = sortParameters[i].isExpanded;\n\n                  if (selector === column.dataField || selector === column.name || selector === column.selector || selector === column.calculateCellValue || selector === column.calculateGroupValue) {\n                    column.sortOrder = column.sortOrder || (sortParameters[i].desc ? \"desc\" : \"asc\");\n\n                    if (void 0 !== isExpanded) {\n                      column.autoExpandGroup = isExpanded;\n                    }\n\n                    column[indexParameterName] = i;\n                    break;\n                  }\n                }\n              }\n            });\n          };\n\n          if (dataSource) {\n            sortParameters = (0, _uiGrid_core3.normalizeSortingInfo)(dataSource.sort());\n            groupParameters = (0, _uiGrid_core3.normalizeSortingInfo)(dataSource.group());\n            columnsGroupParameters = that.getGroupDataSourceParameters();\n            columnsSortParameters = that.getSortDataSourceParameters();\n\n            if (!that._columns.length) {\n              _iterator2.default.each(groupParameters, function (index, group) {\n                that._columns.push(group.selector);\n              });\n\n              _iterator2.default.each(sortParameters, function (index, sort) {\n                that._columns.push(sort.selector);\n              });\n\n              assignColumns(that, createColumnsFromOptions(that, that._columns));\n            }\n\n            if ((fromDataSource || !columnsGroupParameters && !that._hasUserState) && !(0, _uiGrid_core3.equalSortParameters)(groupParameters, columnsGroupParameters)) {\n              updateSortGroupParameterIndexes(that._columns, groupParameters, \"groupIndex\");\n\n              if (fromDataSource) {\n                updateColumnChanges(that, \"grouping\");\n                isColumnsChanged = true;\n              }\n            }\n\n            if ((fromDataSource || !columnsSortParameters && !that._hasUserState) && !(0, _uiGrid_core3.equalSortParameters)(sortParameters, columnsSortParameters)) {\n              updateSortGroupParameterIndexes(that._columns, sortParameters, \"sortIndex\");\n\n              if (fromDataSource) {\n                updateColumnChanges(that, \"sorting\");\n                isColumnsChanged = true;\n              }\n            }\n\n            if (isColumnsChanged) {\n              fireColumnsChanged(that);\n            }\n          }\n        },\n        updateFilter: function updateFilter(filter, remoteFiltering, columnIndex, filterValue) {\n          var that = this;\n\n          if (!Array.isArray(filter)) {\n            return filter;\n          }\n\n          var column;\n          var i;\n          filter = (0, _extend.extend)([], filter);\n          columnIndex = void 0 !== filter.columnIndex ? filter.columnIndex : columnIndex;\n          filterValue = void 0 !== filter.filterValue ? filter.filterValue : filterValue;\n\n          if ((0, _type.isString)(filter[0])) {\n            column = that.columnOption(filter[0]);\n\n            if (remoteFiltering) {\n              if ((0, _config2.default)().forceIsoDateParsing && column && column.serializeValue && filter.length > 1) {\n                filter[filter.length - 1] = column.serializeValue(filter[filter.length - 1], \"filter\");\n              }\n            } else {\n              if (column && column.selector) {\n                filter[0] = column.selector;\n                filter[0].columnIndex = column.index;\n              }\n            }\n          } else {\n            if ((0, _type.isFunction)(filter[0])) {\n              filter[0].columnIndex = columnIndex;\n              filter[0].filterValue = filterValue;\n            }\n          }\n\n          for (i = 0; i < filter.length; i++) {\n            filter[i] = that.updateFilter(filter[i], remoteFiltering, columnIndex, filterValue);\n          }\n\n          return filter;\n        },\n        columnCount: function columnCount() {\n          return this._columns ? this._columns.length : 0;\n        },\n        columnOption: function columnOption(identifier, option, value, notFireEvent) {\n          var that = this;\n          var i;\n          var identifierOptionName = (0, _type.isString)(identifier) && identifier.substr(0, identifier.indexOf(\":\"));\n\n          var columns = that._columns.concat(that._commandColumns);\n\n          var column;\n\n          if (void 0 === identifier) {\n            return;\n          }\n\n          if (identifierOptionName) {\n            identifier = identifier.substr(identifierOptionName.length + 1);\n          }\n\n          for (i = 0; i < columns.length; i++) {\n            if (identifierOptionName) {\n              if (\"\" + columns[i][identifierOptionName] === identifier) {\n                column = columns[i];\n                break;\n              }\n            } else {\n              if (columns[i].index === identifier || columns[i].name === identifier || columns[i].dataField === identifier || columns[i].caption === identifier) {\n                column = columns[i];\n                break;\n              }\n            }\n          }\n\n          if (column) {\n            if (1 === arguments.length) {\n              return (0, _extend.extend)({}, column);\n            }\n\n            if ((0, _type.isString)(option)) {\n              if (2 === arguments.length) {\n                return columnOptionCore(that, column, option);\n              } else {\n                columnOptionCore(that, column, option, value, notFireEvent);\n              }\n            } else {\n              if ((0, _type.isObject)(option)) {\n                _iterator2.default.each(option, function (optionName, value) {\n                  columnOptionCore(that, column, optionName, value, notFireEvent);\n                });\n              }\n            }\n\n            fireColumnsChanged(that);\n          }\n        },\n        clearSorting: function clearSorting() {\n          var that = this;\n          var columnCount = this.columnCount();\n          var i;\n          that.beginUpdate();\n\n          for (i = 0; i < columnCount; i++) {\n            that.columnOption(i, \"sortOrder\", void 0);\n          }\n\n          that.endUpdate();\n        },\n        clearGrouping: function clearGrouping() {\n          var that = this;\n          var columnCount = this.columnCount();\n          var i;\n          that.beginUpdate();\n\n          for (i = 0; i < columnCount; i++) {\n            that.columnOption(i, \"groupIndex\", void 0);\n          }\n\n          that.endUpdate();\n        },\n        getVisibleIndex: function getVisibleIndex(index, rowIndex) {\n          var i;\n          var columns = this.getVisibleColumns(rowIndex);\n\n          for (i = columns.length - 1; i >= 0; i--) {\n            if (columns[i].index === index) {\n              return i;\n            }\n          }\n\n          return -1;\n        },\n        getVisibleColumnIndex: function getVisibleColumnIndex(id, rowIndex) {\n          var index = this.columnOption(id, \"index\");\n          return this.getVisibleIndex(index, rowIndex);\n        },\n        addColumn: function addColumn(options) {\n          var that = this;\n          var column = createColumn(that, options);\n          var index = that._columns.length;\n\n          that._columns.push(column);\n\n          if (column.isBand) {\n            that._columns = createColumnsFromOptions(that, that._columns);\n            column = that._columns[index];\n          }\n\n          column.added = options;\n          updateIndexes(that, column);\n          that.updateColumns(that._dataSource);\n        },\n        deleteColumn: function deleteColumn(id) {\n          var that = this;\n          var childIndexes;\n          var column = that.columnOption(id);\n\n          if (column && column.index >= 0) {\n            convertOwnerBandToColumnReference(that._columns);\n\n            that._columns.splice(column.index, 1);\n\n            if (column.isBand) {\n              childIndexes = that.getChildrenByBandColumn(column.index).map(function (column) {\n                return column.index;\n              });\n              that._columns = that._columns.filter(function (column) {\n                return childIndexes.indexOf(column.index) < 0;\n              });\n            }\n\n            updateIndexes(that);\n            that.updateColumns(that._dataSource);\n          }\n        },\n        addCommandColumn: function addCommandColumn(options) {\n          var commandColumn = this._commandColumns.filter(function (column) {\n            return column.command === options.command;\n          })[0];\n\n          if (!commandColumn) {\n            commandColumn = options;\n\n            this._commandColumns.push(commandColumn);\n          }\n        },\n        getUserState: function getUserState() {\n          var columns = this._columns;\n          var result = [];\n          var i;\n\n          function handleStateField(index, value) {\n            if (void 0 !== columns[i][value]) {\n              result[i][value] = columns[i][value];\n            }\n          }\n\n          for (i = 0; i < columns.length; i++) {\n            result[i] = {};\n\n            _iterator2.default.each(USER_STATE_FIELD_NAMES, handleStateField);\n          }\n\n          return result;\n        },\n        setUserState: function setUserState(state) {\n          var that = this;\n          var commonColumnSettings;\n          var dataSource = that._dataSource;\n          var ignoreColumnOptionNames = that.option(\"stateStoring.ignoreColumnOptionNames\");\n\n          if (!ignoreColumnOptionNames) {\n            ignoreColumnOptionNames = [];\n            commonColumnSettings = that.getCommonSettings();\n\n            if (!that.option(\"columnChooser.enabled\")) {\n              ignoreColumnOptionNames.push(\"visible\");\n            }\n\n            if (\"none\" === that.option(\"sorting.mode\")) {\n              ignoreColumnOptionNames.push(\"sortIndex\", \"sortOrder\");\n            }\n\n            if (!commonColumnSettings.allowGrouping) {\n              ignoreColumnOptionNames.push(\"groupIndex\");\n            }\n\n            if (!commonColumnSettings.allowFixing) {\n              ignoreColumnOptionNames.push(\"fixed\", \"fixedPosition\");\n            }\n\n            if (!commonColumnSettings.allowResizing) {\n              ignoreColumnOptionNames.push(\"width\", \"visibleWidth\");\n            }\n\n            var isFilterPanelHidden = !that.option(\"filterPanel.visible\");\n\n            if (!that.option(\"filterRow.visible\") && isFilterPanelHidden) {\n              ignoreColumnOptionNames.push(\"filterValue\", \"selectedFilterOperation\");\n            }\n\n            if (!that.option(\"headerFilter.visible\") && isFilterPanelHidden) {\n              ignoreColumnOptionNames.push(\"filterValues\", \"filterType\");\n            }\n          }\n\n          that._columnsUserState = state;\n          that._ignoreColumnOptionNames = ignoreColumnOptionNames;\n          that._hasUserState = !!state;\n          updateColumnChanges(that, \"filtering\");\n          that.init();\n\n          if (dataSource) {\n            dataSource.sort(that.getSortDataSourceParameters());\n            dataSource.group(that.getGroupDataSourceParameters());\n          }\n        },\n        _createCalculatedColumnOptions: function _createCalculatedColumnOptions(columnOptions, bandColumn) {\n          var calculatedColumnOptions = {};\n          var dataField = columnOptions.dataField;\n          var getter;\n\n          if (Array.isArray(columnOptions.columns) && columnOptions.columns.length || columnOptions.isBand) {\n            calculatedColumnOptions.isBand = true;\n            dataField = null;\n          }\n\n          if (dataField) {\n            if ((0, _type.isString)(dataField)) {\n              getter = _data2.default.compileGetter(dataField);\n              calculatedColumnOptions = {\n                caption: _inflector2.default.captionize(dataField),\n                calculateCellValue: function calculateCellValue(data, skipDeserialization) {\n                  var value = getter(data);\n                  return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value) : value;\n                },\n                setCellValue: defaultSetCellValue,\n                parseValue: function parseValue(text) {\n                  var column = this;\n                  var result;\n                  var parsedValue;\n\n                  if (\"number\" === column.dataType) {\n                    if ((0, _type.isString)(text) && column.format) {\n                      parsedValue = _number2.default.parse(text);\n\n                      if ((0, _type.isNumeric)(parsedValue)) {\n                        result = parsedValue;\n                      }\n                    } else {\n                      if ((0, _type.isDefined)(text) && (0, _type.isNumeric)(text)) {\n                        result = Number(text);\n                      }\n                    }\n                  } else {\n                    if (\"boolean\" === column.dataType) {\n                      if (text === column.trueText) {\n                        result = true;\n                      } else {\n                        if (text === column.falseText) {\n                          result = false;\n                        }\n                      }\n                    } else {\n                      if ((0, _uiGrid_core3.isDateType)(column.dataType)) {\n                        parsedValue = _date2.default.parse(text, column.format);\n\n                        if (parsedValue) {\n                          result = parsedValue;\n                        }\n                      } else {\n                        result = text;\n                      }\n                    }\n                  }\n\n                  return result;\n                }\n              };\n            }\n\n            calculatedColumnOptions.allowFiltering = true;\n          } else {\n            calculatedColumnOptions.allowFiltering = !!columnOptions.calculateFilterExpression;\n          }\n\n          calculatedColumnOptions.calculateFilterExpression = function () {\n            return _filtering2.default.defaultCalculateFilterExpression.apply(this, arguments);\n          };\n\n          calculatedColumnOptions.createFilterExpression = function (filterValue) {\n            var result;\n\n            if (this.calculateFilterExpression) {\n              result = this.calculateFilterExpression.apply(this, arguments);\n            }\n\n            if ((0, _type.isFunction)(result)) {\n              result = [result, \"=\", true];\n            }\n\n            if (result) {\n              result.columnIndex = this.index;\n              result.filterValue = filterValue;\n            }\n\n            return result;\n          };\n\n          if (!dataField || !(0, _type.isString)(dataField)) {\n            (0, _extend.extend)(true, calculatedColumnOptions, {\n              allowSorting: false,\n              allowGrouping: false,\n              calculateCellValue: function calculateCellValue() {\n                return null;\n              }\n            });\n          }\n\n          if (bandColumn) {\n            calculatedColumnOptions.allowFixing = false;\n          }\n\n          if (columnOptions.dataType) {\n            calculatedColumnOptions.userDataType = columnOptions.dataType;\n          }\n\n          if (columnOptions.selectedFilterOperation && !(\"defaultSelectedFilterOperation\" in calculatedColumnOptions)) {\n            calculatedColumnOptions.defaultSelectedFilterOperation = columnOptions.selectedFilterOperation;\n          }\n\n          if (columnOptions.lookup) {\n            calculatedColumnOptions.lookup = {\n              calculateCellValue: function calculateCellValue(value, skipDeserialization) {\n                if (this.valueExpr) {\n                  value = this.valueMap && this.valueMap[value];\n                }\n\n                return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value) : value;\n              },\n              updateValueMap: function updateValueMap() {\n                var calculateValue;\n                var calculateDisplayValue;\n                var item;\n                var i;\n                this.valueMap = {};\n\n                if (this.items) {\n                  calculateValue = _data2.default.compileGetter(this.valueExpr);\n                  calculateDisplayValue = _data2.default.compileGetter(this.displayExpr);\n\n                  for (i = 0; i < this.items.length; i++) {\n                    item = this.items[i];\n                    var displayValue = calculateDisplayValue(item);\n                    this.valueMap[calculateValue(item)] = displayValue;\n                    this.dataType = this.dataType || getValueDataType(displayValue);\n                  }\n                }\n              },\n              update: function update() {\n                var that = this;\n                var dataSource = that.dataSource;\n                var dataSourceOptions;\n\n                if (dataSource) {\n                  if ((0, _type.isFunction)(dataSource) && !(0, _variable_wrapper.isWrapped)(dataSource)) {\n                    dataSource = dataSource({});\n                  }\n\n                  if ((0, _type.isPlainObject)(dataSource) || dataSource instanceof _abstract_store2.default || Array.isArray(dataSource)) {\n                    if (that.valueExpr) {\n                      dataSourceOptions = (0, _data_source.normalizeDataSourceOptions)(dataSource);\n                      dataSourceOptions.paginate = false;\n                      dataSource = new _data_source.DataSource(dataSourceOptions);\n                      return dataSource.load().done(function (data) {\n                        that.items = data;\n                        that.updateValueMap && that.updateValueMap();\n                      });\n                    }\n                  } else {\n                    _ui2.default.log(\"E1016\");\n                  }\n                } else {\n                  that.updateValueMap && that.updateValueMap();\n                }\n              }\n            };\n          }\n\n          calculatedColumnOptions.resizedCallbacks = (0, _callbacks2.default)();\n\n          if (columnOptions.resized) {\n            calculatedColumnOptions.resizedCallbacks.add(columnOptions.resized.bind(columnOptions));\n          }\n\n          _iterator2.default.each(calculatedColumnOptions, function (optionName) {\n            var defaultOptionName;\n\n            if ((0, _type.isFunction)(calculatedColumnOptions[optionName]) && 0 !== optionName.indexOf(\"default\")) {\n              defaultOptionName = \"default\" + optionName.charAt(0).toUpperCase() + optionName.substr(1);\n              calculatedColumnOptions[defaultOptionName] = calculatedColumnOptions[optionName];\n            }\n          });\n\n          return calculatedColumnOptions;\n        },\n        getRowCount: function getRowCount() {\n          this._rowCount = this._rowCount || _getRowCount(this);\n          return this._rowCount;\n        },\n        getRowIndex: function getRowIndex(columnIndex, alwaysGetRowIndex) {\n          var column = this._columns[columnIndex];\n          var bandColumnsCache = this.getBandColumnsCache();\n          return column && (alwaysGetRowIndex || column.visible && !(column.command || (0, _type.isDefined)(column.groupIndex))) ? getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex).length : 0;\n        },\n        getChildrenByBandColumn: function getChildrenByBandColumn(bandColumnIndex, onlyVisibleDirectChildren) {\n          var that = this;\n          var bandColumnsCache = that.getBandColumnsCache();\n\n          var result = _getChildrenByBandColumn(bandColumnIndex, bandColumnsCache.columnChildrenByIndex, !onlyVisibleDirectChildren);\n\n          if (onlyVisibleDirectChildren) {\n            return result.filter(function (column) {\n              return column.visible && !column.command;\n            }).sort(function (column1, column2) {\n              return column1.visibleIndex - column2.visibleIndex;\n            });\n          }\n\n          return result;\n        },\n        isParentBandColumn: function isParentBandColumn(columnIndex, bandColumnIndex) {\n          var result = false;\n          var column = this._columns[columnIndex];\n          var bandColumnsCache = this.getBandColumnsCache();\n          var parentBandColumns = column && getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex);\n\n          if (parentBandColumns) {\n            _iterator2.default.each(parentBandColumns, function (_, bandColumn) {\n              if (bandColumn.index === bandColumnIndex) {\n                result = true;\n                return false;\n              }\n            });\n          }\n\n          return result;\n        },\n        isParentColumnVisible: function isParentColumnVisible(columnIndex) {\n          var result = true;\n          var bandColumnsCache = this.getBandColumnsCache();\n          var bandColumns = columnIndex >= 0 && getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex);\n          bandColumns && _iterator2.default.each(bandColumns, function (_, bandColumn) {\n            result = result && bandColumn.visible;\n            return result;\n          });\n          return result;\n        },\n        getColumnId: function getColumnId(column) {\n          if (column.command && column.type === GROUP_COMMAND_COLUMN_NAME) {\n            if (isCustomCommandColumn(this, column)) {\n              return \"type:\" + column.type;\n            }\n\n            return \"command:\" + column.command;\n          }\n\n          return column.index;\n        }\n      };\n    }())\n  }\n};","map":null,"metadata":{},"sourceType":"script"}