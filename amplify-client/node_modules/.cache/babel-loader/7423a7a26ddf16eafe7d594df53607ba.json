{"ast":null,"code":"/**\r\n * DevExtreme (viz/core/series_family.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar isNumeric = require(\"../../core/utils/type\").isNumeric;\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar each = require(\"../../core/utils/iterator\").each;\n\nvar isDefined = require(\"../../core/utils/type\").isDefined;\n\nvar sign = require(\"../../core/utils/math\").sign;\n\nvar _math = Math;\nvar _round = _math.round;\nvar _abs = _math.abs;\nvar _pow = _math.pow;\nvar _each = each;\n\nvar _noop = require(\"../../core/utils/common\").noop;\n\nvar vizUtils = require(\"./utils\");\n\nvar DEFAULT_BAR_GROUP_PADDING = .3;\nvar _normalizeEnum = vizUtils.normalizeEnum;\n\nfunction validateBarPadding(barPadding) {\n  return barPadding < 0 || barPadding > 1 ? void 0 : barPadding;\n}\n\nfunction validateBarGroupPadding(barGroupPadding) {\n  return barGroupPadding < 0 || barGroupPadding > 1 ? DEFAULT_BAR_GROUP_PADDING : barGroupPadding;\n}\n\nfunction isStackExist(series, arg, equalBarWidth) {\n  return series.some(function (s) {\n    return equalBarWidth && !s.getOptions().ignoreEmptyPoints || s.getPointsByArg(arg, true).some(function (point) {\n      return point.hasValue();\n    });\n  });\n}\n\nfunction correctStackCoordinates(series, currentStacks, arg, stack, parameters, barsArea, seriesStackIndexCallback) {\n  series.forEach(function (series) {\n    var stackIndex = seriesStackIndexCallback(currentStacks.indexOf(stack), currentStacks.length);\n    var points = series.getPointsByArg(arg, true);\n    var barPadding = validateBarPadding(series.getOptions().barPadding);\n    var barWidth = series.getOptions().barWidth;\n    var offset = getOffset(stackIndex, parameters);\n    var width = parameters.width;\n    var extraParameters;\n\n    if (stackIndex === -1) {\n      return;\n    }\n\n    if (isDefined(barPadding) || isDefined(barWidth)) {\n      extraParameters = calculateParams(barsArea, currentStacks.length, 1 - barPadding, barWidth);\n      width = extraParameters.width;\n      offset = getOffset(stackIndex, extraParameters);\n    }\n\n    correctPointCoordinates(points, width, offset);\n  });\n}\n\nfunction adjustBarSeriesDimensionsCore(series, options, seriesStackIndexCallback) {\n  var commonStacks = [];\n  var allArguments = [];\n  var seriesInStacks = {};\n  var barWidth = options.barWidth;\n  var barGroupWidth = options.barGroupWidth;\n  var interval = series[0] && series[0].getArgumentAxis().getTranslator().getInterval();\n  var barsArea = barGroupWidth ? interval > barGroupWidth ? barGroupWidth : interval : interval * (1 - validateBarGroupPadding(options.barGroupPadding));\n  series.forEach(function (s, i) {\n    var stackName = s.getStackName() || s.getBarOverlapGroup() || i.toString();\n    var argument;\n\n    for (argument in s.pointsByArgument) {\n      if (allArguments.indexOf(argument.valueOf()) === -1) {\n        allArguments.push(argument.valueOf());\n      }\n    }\n\n    if (commonStacks.indexOf(stackName) === -1) {\n      commonStacks.push(stackName);\n      seriesInStacks[stackName] = [];\n    }\n\n    seriesInStacks[stackName].push(s);\n  });\n  allArguments.forEach(function (arg) {\n    var currentStacks = commonStacks.reduce(function (stacks, stack) {\n      if (isStackExist(seriesInStacks[stack], arg, options.equalBarWidth)) {\n        stacks.push(stack);\n      }\n\n      return stacks;\n    }, []);\n    var parameters = calculateParams(barsArea, currentStacks.length, barWidth);\n    commonStacks.forEach(function (stack) {\n      correctStackCoordinates(seriesInStacks[stack], currentStacks, arg, stack, parameters, barsArea, seriesStackIndexCallback);\n    });\n  });\n}\n\nfunction calculateParams(barsArea, count, percentWidth, fixedBarWidth) {\n  var spacing;\n  var width;\n\n  if (fixedBarWidth) {\n    width = Math.min(fixedBarWidth, _round(barsArea / count));\n    spacing = count > 1 ? _round((barsArea - width * count) / (count - 1)) : 0;\n  } else {\n    if (isDefined(percentWidth)) {\n      width = _round(barsArea * percentWidth / count);\n      spacing = _round(count > 1 ? (barsArea - barsArea * percentWidth) / (count - 1) : 0);\n    } else {\n      spacing = _round(barsArea / count * .2);\n      width = _round((barsArea - spacing * (count - 1)) / count);\n    }\n  }\n\n  return {\n    width: width > 1 ? width : 1,\n    spacing: spacing,\n    middleIndex: count / 2\n  };\n}\n\nfunction getOffset(stackIndex, parameters) {\n  return (stackIndex - parameters.middleIndex + .5) * parameters.width - (parameters.middleIndex - stackIndex - .5) * parameters.spacing;\n}\n\nfunction correctPointCoordinates(points, width, offset) {\n  _each(points, function (_, point) {\n    point.correctCoordinates({\n      width: width,\n      offset: offset\n    });\n  });\n}\n\nfunction getValueType(value) {\n  return value >= 0 ? \"positive\" : \"negative\";\n}\n\nfunction getVisibleSeries(that) {\n  return that.series.filter(function (s) {\n    return s.isVisible();\n  });\n}\n\nfunction getAbsStackSumByArg(stackKeepers, stackName, argument) {\n  var positiveStackValue = (stackKeepers.positive[stackName] || {})[argument] || 0;\n  var negativeStackValue = -(stackKeepers.negative[stackName] || {})[argument] || 0;\n  return positiveStackValue + negativeStackValue;\n}\n\nfunction getStackSumByArg(stackKeepers, stackName, argument) {\n  var positiveStackValue = (stackKeepers.positive[stackName] || {})[argument] || 0;\n  var negativeStackValue = (stackKeepers.negative[stackName] || {})[argument] || 0;\n  return positiveStackValue + negativeStackValue;\n}\n\nfunction getSeriesStackIndexCallback(inverted) {\n  if (!inverted) {\n    return function (index) {\n      return index;\n    };\n  } else {\n    return function (index, stackCount) {\n      return stackCount - index - 1;\n    };\n  }\n}\n\nfunction isInverted(series) {\n  return series[0] && series[0].getArgumentAxis().getTranslator().isInverted();\n}\n\nfunction adjustBarSeriesDimensions() {\n  var series = getVisibleSeries(this);\n  adjustBarSeriesDimensionsCore(series, this._options, getSeriesStackIndexCallback(isInverted(series)));\n}\n\nfunction getFirstValueSign(series) {\n  var points = series.getPoints();\n  var value;\n\n  for (var i = 0; i < points.length; i++) {\n    var point = points[i];\n    value = point.initialValue && point.initialValue.valueOf();\n\n    if (Math.abs(value) > 0) {\n      break;\n    }\n  }\n\n  return sign(value);\n}\n\nfunction adjustStackedSeriesValues() {\n  var that = this;\n  var negativesAsZeroes = that._options.negativesAsZeroes;\n  var series = getVisibleSeries(that);\n  var stackKeepers = {\n    positive: {},\n    negative: {}\n  };\n  var holesStack = {\n    left: {},\n    right: {}\n  };\n  var lastSeriesInPositiveStack = {};\n  var lastSeriesInNegativeStack = {};\n  series.forEach(function (singleSeries) {\n    var stackName = singleSeries.getStackName() || singleSeries.getBarOverlapGroup();\n    var hole = false;\n    var stack = getFirstValueSign(singleSeries) < 0 ? lastSeriesInNegativeStack : lastSeriesInPositiveStack;\n    singleSeries._prevSeries = stack[stackName];\n    stack[stackName] = singleSeries;\n    singleSeries.holes = extend(true, {}, holesStack);\n    singleSeries.getPoints().forEach(function (point, index, points) {\n      var value = point.initialValue && point.initialValue.valueOf();\n      var argument = point.argument.valueOf();\n      var stacks = value >= 0 ? stackKeepers.positive : stackKeepers.negative;\n      var isNotBarSeries = \"bar\" !== singleSeries.type;\n      var currentStack;\n\n      if (negativesAsZeroes && value < 0) {\n        stacks = stackKeepers.positive;\n        value = 0;\n        point.resetValue();\n      }\n\n      stacks[stackName] = stacks[stackName] || {};\n      currentStack = stacks[stackName];\n\n      if (currentStack[argument]) {\n        if (isNotBarSeries) {\n          point.correctValue(currentStack[argument]);\n        }\n\n        currentStack[argument] += value;\n      } else {\n        currentStack[argument] = value;\n\n        if (isNotBarSeries) {\n          point.resetCorrection();\n        }\n      }\n\n      if (!point.hasValue()) {\n        var prevPoint = points[index - 1];\n\n        if (!hole && prevPoint && prevPoint.hasValue()) {\n          argument = prevPoint.argument.valueOf();\n          prevPoint._skipSetRightHole = true;\n          holesStack.right[argument] = (holesStack.right[argument] || 0) + (prevPoint.value.valueOf() - (isFinite(prevPoint.minValue) ? prevPoint.minValue.valueOf() : 0));\n        }\n\n        hole = true;\n      } else {\n        if (hole) {\n          hole = false;\n          holesStack.left[argument] = (holesStack.left[argument] || 0) + (point.value.valueOf() - (isFinite(point.minValue) ? point.minValue.valueOf() : 0));\n          point._skipSetLeftHole = true;\n        }\n      }\n    });\n  });\n  series.forEach(function (singleSeries) {\n    var holes = singleSeries.holes;\n    singleSeries.getPoints().forEach(function (point) {\n      var argument = point.argument.valueOf();\n      point.resetHoles();\n      !point._skipSetLeftHole && point.setHole(holes.left[argument] || holesStack.left[argument] && 0, \"left\");\n      !point._skipSetRightHole && point.setHole(holes.right[argument] || holesStack.right[argument] && 0, \"right\");\n      point._skipSetLeftHole = null;\n      point._skipSetRightHole = null;\n    });\n  });\n  that._stackKeepers = stackKeepers;\n  series.forEach(function (singleSeries) {\n    singleSeries.getPoints().forEach(function (point) {\n      var argument = point.argument.valueOf();\n      var stackName = singleSeries.getStackName() || singleSeries.getBarOverlapGroup();\n      var absTotal = getAbsStackSumByArg(stackKeepers, stackName, argument);\n      var total = getStackSumByArg(stackKeepers, stackName, argument);\n      point.setPercentValue(absTotal, total, holesStack.left[argument], holesStack.right[argument]);\n    });\n  });\n}\n\nfunction updateStackedSeriesValues() {\n  var that = this;\n  var series = getVisibleSeries(that);\n  var stack = that._stackKeepers;\n  var stackKeepers = {\n    positive: {},\n    negative: {}\n  };\n\n  _each(series, function (_, singleSeries) {\n    var minBarSize = singleSeries.getOptions().minBarSize;\n    var valueAxisTranslator = singleSeries.getValueAxis().getTranslator();\n    var minShownBusinessValue = minBarSize && valueAxisTranslator.getMinBarSize(minBarSize);\n    var stackName = singleSeries.getStackName();\n\n    _each(singleSeries.getPoints(), function (index, point) {\n      if (!point.hasValue()) {\n        return;\n      }\n\n      var value = point.initialValue && point.initialValue.valueOf();\n      var argument = point.argument.valueOf();\n      var updateValue;\n      var valueType;\n      var currentStack;\n\n      if (that.fullStacked) {\n        value = value / getAbsStackSumByArg(stack, stackName, argument) || 0;\n      }\n\n      updateValue = valueAxisTranslator.checkMinBarSize(value, minShownBusinessValue, point.value);\n      valueType = getValueType(updateValue);\n      currentStack = stackKeepers[valueType][stackName] = stackKeepers[valueType][stackName] || {};\n\n      if (currentStack[argument]) {\n        point.minValue = currentStack[argument];\n        currentStack[argument] += updateValue;\n      } else {\n        currentStack[argument] = updateValue;\n      }\n\n      point.value = currentStack[argument];\n    });\n  });\n\n  if (that.fullStacked) {\n    updateFullStackedSeriesValues(series, stackKeepers);\n  }\n}\n\nfunction updateFullStackedSeriesValues(series, stackKeepers) {\n  _each(series, function (_, singleSeries) {\n    var stackName = singleSeries.getStackName ? singleSeries.getStackName() : \"default\";\n\n    _each(singleSeries.getPoints(), function (index, point) {\n      var stackSum = getAbsStackSumByArg(stackKeepers, stackName, point.argument.valueOf());\n      point.value = point.value / stackSum;\n\n      if (isNumeric(point.minValue)) {\n        point.minValue = point.minValue / stackSum;\n      }\n    });\n  });\n}\n\nfunction updateBarSeriesValues() {\n  _each(this.series, function (_, singleSeries) {\n    var minBarSize = singleSeries.getOptions().minBarSize;\n    var valueAxisTranslator = singleSeries.getValueAxis().getTranslator();\n    var minShownBusinessValue = minBarSize && valueAxisTranslator.getMinBarSize(minBarSize);\n\n    if (minShownBusinessValue) {\n      _each(singleSeries.getPoints(), function (index, point) {\n        if (point.hasValue()) {\n          point.value = valueAxisTranslator.checkMinBarSize(point.initialValue, minShownBusinessValue);\n        }\n      });\n    }\n  });\n}\n\nfunction adjustCandlestickSeriesDimensions() {\n  var series = getVisibleSeries(this);\n  adjustBarSeriesDimensionsCore(series, {\n    barWidth: null,\n    equalBarWidth: true,\n    barGroupPadding: .3\n  }, getSeriesStackIndexCallback(isInverted(series)));\n}\n\nfunction adjustBubbleSeriesDimensions() {\n  var series = getVisibleSeries(this);\n\n  if (!series.length) {\n    return;\n  }\n\n  var options = this._options;\n  var visibleAreaX = series[0].getArgumentAxis().getVisibleArea();\n  var visibleAreaY = series[0].getValueAxis().getVisibleArea();\n\n  var min = _math.min(visibleAreaX[1] - visibleAreaX[0], visibleAreaY[1] - visibleAreaY[0]);\n\n  var minBubbleArea = _pow(options.minBubbleSize, 2);\n\n  var maxBubbleArea = _pow(min * options.maxBubbleSize, 2);\n\n  var equalBubbleSize = (min * options.maxBubbleSize + options.minBubbleSize) / 2;\n  var minPointSize = 1 / 0;\n  var maxPointSize = -(1 / 0);\n  var pointSize;\n  var bubbleArea;\n  var sizeProportion;\n  var sizeDispersion;\n  var areaDispersion;\n\n  _each(series, function (_, seriesItem) {\n    _each(seriesItem.getPoints(), function (_, point) {\n      maxPointSize = maxPointSize > point.size ? maxPointSize : point.size;\n      minPointSize = minPointSize < point.size ? minPointSize : point.size;\n    });\n  });\n\n  sizeDispersion = maxPointSize - minPointSize;\n  areaDispersion = _abs(maxBubbleArea - minBubbleArea);\n\n  _each(series, function (_, seriesItem) {\n    _each(seriesItem.getPoints(), function (_, point) {\n      if (maxPointSize === minPointSize) {\n        pointSize = _round(equalBubbleSize);\n      } else {\n        sizeProportion = _abs(point.size - minPointSize) / sizeDispersion;\n        bubbleArea = areaDispersion * sizeProportion + minBubbleArea;\n        pointSize = _round(_math.sqrt(bubbleArea));\n      }\n\n      point.correctCoordinates(pointSize);\n    });\n  });\n}\n\nfunction SeriesFamily(options) {\n  var that = this;\n  that.type = _normalizeEnum(options.type);\n  that.pane = options.pane;\n  that.series = [];\n  that.updateOptions(options);\n\n  switch (that.type) {\n    case \"bar\":\n      that.adjustSeriesDimensions = adjustBarSeriesDimensions;\n      that.updateSeriesValues = updateBarSeriesValues;\n      that.adjustSeriesValues = adjustStackedSeriesValues;\n      break;\n\n    case \"rangebar\":\n      that.adjustSeriesDimensions = adjustBarSeriesDimensions;\n      break;\n\n    case \"fullstackedbar\":\n      that.fullStacked = true;\n      that.adjustSeriesDimensions = adjustBarSeriesDimensions;\n      that.adjustSeriesValues = adjustStackedSeriesValues;\n      that.updateSeriesValues = updateStackedSeriesValues;\n      break;\n\n    case \"stackedbar\":\n      that.adjustSeriesDimensions = adjustBarSeriesDimensions;\n      that.adjustSeriesValues = adjustStackedSeriesValues;\n      that.updateSeriesValues = updateStackedSeriesValues;\n      break;\n\n    case \"fullstackedarea\":\n    case \"fullstackedline\":\n    case \"fullstackedspline\":\n    case \"fullstackedsplinearea\":\n      that.fullStacked = true;\n      that.adjustSeriesValues = adjustStackedSeriesValues;\n      break;\n\n    case \"stackedarea\":\n    case \"stackedsplinearea\":\n    case \"stackedline\":\n    case \"stackedspline\":\n      that.adjustSeriesValues = adjustStackedSeriesValues;\n      break;\n\n    case \"candlestick\":\n    case \"stock\":\n      that.adjustSeriesDimensions = adjustCandlestickSeriesDimensions;\n      break;\n\n    case \"bubble\":\n      that.adjustSeriesDimensions = adjustBubbleSeriesDimensions;\n  }\n}\n\nexports.SeriesFamily = SeriesFamily;\nSeriesFamily.prototype = {\n  constructor: SeriesFamily,\n  adjustSeriesDimensions: _noop,\n  adjustSeriesValues: _noop,\n  updateSeriesValues: _noop,\n  updateOptions: function updateOptions(options) {\n    this._options = options;\n  },\n  dispose: function dispose() {\n    this.series = null;\n  },\n  add: function add(series) {\n    var type = this.type;\n    this.series = vizUtils.map(series, function (singleSeries) {\n      return singleSeries.type === type ? singleSeries : null;\n    });\n  }\n};","map":{"version":3,"sources":["C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/devextreme/viz/core/series_family.js"],"names":["isNumeric","require","extend","each","isDefined","sign","_math","_round","_abs","_pow","_each","_noop","vizUtils","DEFAULT_BAR_GROUP_PADDING","_normalizeEnum","barPadding","barGroupPadding","equalBarWidth","s","point","series","stackIndex","seriesStackIndexCallback","currentStacks","points","validateBarPadding","barWidth","offset","getOffset","width","parameters","extraParameters","calculateParams","correctPointCoordinates","commonStacks","allArguments","seriesInStacks","options","barGroupWidth","interval","barsArea","validateBarGroupPadding","stackName","i","argument","isStackExist","stacks","correctStackCoordinates","Math","spacing","count","middleIndex","value","positiveStackValue","stackKeepers","negativeStackValue","stackCount","getVisibleSeries","adjustBarSeriesDimensionsCore","getSeriesStackIndexCallback","isInverted","that","negativesAsZeroes","positive","negative","holesStack","left","right","lastSeriesInPositiveStack","lastSeriesInNegativeStack","singleSeries","hole","stack","getFirstValueSign","isNotBarSeries","currentStack","prevPoint","index","isFinite","holes","absTotal","getAbsStackSumByArg","total","getStackSumByArg","minBarSize","valueAxisTranslator","minShownBusinessValue","updateValue","valueType","getValueType","updateFullStackedSeriesValues","stackSum","visibleAreaX","visibleAreaY","min","minBubbleArea","maxBubbleArea","equalBubbleSize","minPointSize","maxPointSize","seriesItem","sizeDispersion","areaDispersion","pointSize","sizeProportion","bubbleArea","exports","SeriesFamily","constructor","adjustSeriesDimensions","adjustSeriesValues","updateSeriesValues","updateOptions","dispose","add","type"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (viz/core/series_family.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nvar isNumeric = require(\"../../core/utils/type\").isNumeric;\r\nvar extend = require(\"../../core/utils/extend\").extend;\r\nvar each = require(\"../../core/utils/iterator\").each;\r\nvar isDefined = require(\"../../core/utils/type\").isDefined;\r\nvar sign = require(\"../../core/utils/math\").sign;\r\nvar _math = Math;\r\nvar _round = _math.round;\r\nvar _abs = _math.abs;\r\nvar _pow = _math.pow;\r\nvar _each = each;\r\nvar _noop = require(\"../../core/utils/common\").noop;\r\nvar vizUtils = require(\"./utils\");\r\nvar DEFAULT_BAR_GROUP_PADDING = .3;\r\nvar _normalizeEnum = vizUtils.normalizeEnum;\r\n\r\nfunction validateBarPadding(barPadding) {\r\n    return barPadding < 0 || barPadding > 1 ? void 0 : barPadding\r\n}\r\n\r\nfunction validateBarGroupPadding(barGroupPadding) {\r\n    return barGroupPadding < 0 || barGroupPadding > 1 ? DEFAULT_BAR_GROUP_PADDING : barGroupPadding\r\n}\r\n\r\nfunction isStackExist(series, arg, equalBarWidth) {\r\n    return series.some(function(s) {\r\n        return equalBarWidth && !s.getOptions().ignoreEmptyPoints || s.getPointsByArg(arg, true).some(function(point) {\r\n            return point.hasValue()\r\n        })\r\n    })\r\n}\r\n\r\nfunction correctStackCoordinates(series, currentStacks, arg, stack, parameters, barsArea, seriesStackIndexCallback) {\r\n    series.forEach(function(series) {\r\n        var stackIndex = seriesStackIndexCallback(currentStacks.indexOf(stack), currentStacks.length);\r\n        var points = series.getPointsByArg(arg, true);\r\n        var barPadding = validateBarPadding(series.getOptions().barPadding);\r\n        var barWidth = series.getOptions().barWidth;\r\n        var offset = getOffset(stackIndex, parameters);\r\n        var width = parameters.width;\r\n        var extraParameters;\r\n        if (stackIndex === -1) {\r\n            return\r\n        }\r\n        if (isDefined(barPadding) || isDefined(barWidth)) {\r\n            extraParameters = calculateParams(barsArea, currentStacks.length, 1 - barPadding, barWidth);\r\n            width = extraParameters.width;\r\n            offset = getOffset(stackIndex, extraParameters)\r\n        }\r\n        correctPointCoordinates(points, width, offset)\r\n    })\r\n}\r\n\r\nfunction adjustBarSeriesDimensionsCore(series, options, seriesStackIndexCallback) {\r\n    var commonStacks = [];\r\n    var allArguments = [];\r\n    var seriesInStacks = {};\r\n    var barWidth = options.barWidth;\r\n    var barGroupWidth = options.barGroupWidth;\r\n    var interval = series[0] && series[0].getArgumentAxis().getTranslator().getInterval();\r\n    var barsArea = barGroupWidth ? interval > barGroupWidth ? barGroupWidth : interval : interval * (1 - validateBarGroupPadding(options.barGroupPadding));\r\n    series.forEach(function(s, i) {\r\n        var stackName = s.getStackName() || s.getBarOverlapGroup() || i.toString();\r\n        var argument;\r\n        for (argument in s.pointsByArgument) {\r\n            if (allArguments.indexOf(argument.valueOf()) === -1) {\r\n                allArguments.push(argument.valueOf())\r\n            }\r\n        }\r\n        if (commonStacks.indexOf(stackName) === -1) {\r\n            commonStacks.push(stackName);\r\n            seriesInStacks[stackName] = []\r\n        }\r\n        seriesInStacks[stackName].push(s)\r\n    });\r\n    allArguments.forEach(function(arg) {\r\n        var currentStacks = commonStacks.reduce(function(stacks, stack) {\r\n            if (isStackExist(seriesInStacks[stack], arg, options.equalBarWidth)) {\r\n                stacks.push(stack)\r\n            }\r\n            return stacks\r\n        }, []);\r\n        var parameters = calculateParams(barsArea, currentStacks.length, barWidth);\r\n        commonStacks.forEach(function(stack) {\r\n            correctStackCoordinates(seriesInStacks[stack], currentStacks, arg, stack, parameters, barsArea, seriesStackIndexCallback)\r\n        })\r\n    })\r\n}\r\n\r\nfunction calculateParams(barsArea, count, percentWidth, fixedBarWidth) {\r\n    var spacing;\r\n    var width;\r\n    if (fixedBarWidth) {\r\n        width = Math.min(fixedBarWidth, _round(barsArea / count));\r\n        spacing = count > 1 ? _round((barsArea - width * count) / (count - 1)) : 0\r\n    } else {\r\n        if (isDefined(percentWidth)) {\r\n            width = _round(barsArea * percentWidth / count);\r\n            spacing = _round(count > 1 ? (barsArea - barsArea * percentWidth) / (count - 1) : 0)\r\n        } else {\r\n            spacing = _round(barsArea / count * .2);\r\n            width = _round((barsArea - spacing * (count - 1)) / count)\r\n        }\r\n    }\r\n    return {\r\n        width: width > 1 ? width : 1,\r\n        spacing: spacing,\r\n        middleIndex: count / 2\r\n    }\r\n}\r\n\r\nfunction getOffset(stackIndex, parameters) {\r\n    return (stackIndex - parameters.middleIndex + .5) * parameters.width - (parameters.middleIndex - stackIndex - .5) * parameters.spacing\r\n}\r\n\r\nfunction correctPointCoordinates(points, width, offset) {\r\n    _each(points, function(_, point) {\r\n        point.correctCoordinates({\r\n            width: width,\r\n            offset: offset\r\n        })\r\n    })\r\n}\r\n\r\nfunction getValueType(value) {\r\n    return value >= 0 ? \"positive\" : \"negative\"\r\n}\r\n\r\nfunction getVisibleSeries(that) {\r\n    return that.series.filter(function(s) {\r\n        return s.isVisible()\r\n    })\r\n}\r\n\r\nfunction getAbsStackSumByArg(stackKeepers, stackName, argument) {\r\n    var positiveStackValue = (stackKeepers.positive[stackName] || {})[argument] || 0;\r\n    var negativeStackValue = -(stackKeepers.negative[stackName] || {})[argument] || 0;\r\n    return positiveStackValue + negativeStackValue\r\n}\r\n\r\nfunction getStackSumByArg(stackKeepers, stackName, argument) {\r\n    var positiveStackValue = (stackKeepers.positive[stackName] || {})[argument] || 0;\r\n    var negativeStackValue = (stackKeepers.negative[stackName] || {})[argument] || 0;\r\n    return positiveStackValue + negativeStackValue\r\n}\r\n\r\nfunction getSeriesStackIndexCallback(inverted) {\r\n    if (!inverted) {\r\n        return function(index) {\r\n            return index\r\n        }\r\n    } else {\r\n        return function(index, stackCount) {\r\n            return stackCount - index - 1\r\n        }\r\n    }\r\n}\r\n\r\nfunction isInverted(series) {\r\n    return series[0] && series[0].getArgumentAxis().getTranslator().isInverted()\r\n}\r\n\r\nfunction adjustBarSeriesDimensions() {\r\n    var series = getVisibleSeries(this);\r\n    adjustBarSeriesDimensionsCore(series, this._options, getSeriesStackIndexCallback(isInverted(series)))\r\n}\r\n\r\nfunction getFirstValueSign(series) {\r\n    var points = series.getPoints();\r\n    var value;\r\n    for (var i = 0; i < points.length; i++) {\r\n        var point = points[i];\r\n        value = point.initialValue && point.initialValue.valueOf();\r\n        if (Math.abs(value) > 0) {\r\n            break\r\n        }\r\n    }\r\n    return sign(value)\r\n}\r\n\r\nfunction adjustStackedSeriesValues() {\r\n    var that = this;\r\n    var negativesAsZeroes = that._options.negativesAsZeroes;\r\n    var series = getVisibleSeries(that);\r\n    var stackKeepers = {\r\n        positive: {},\r\n        negative: {}\r\n    };\r\n    var holesStack = {\r\n        left: {},\r\n        right: {}\r\n    };\r\n    var lastSeriesInPositiveStack = {};\r\n    var lastSeriesInNegativeStack = {};\r\n    series.forEach(function(singleSeries) {\r\n        var stackName = singleSeries.getStackName() || singleSeries.getBarOverlapGroup();\r\n        var hole = false;\r\n        var stack = getFirstValueSign(singleSeries) < 0 ? lastSeriesInNegativeStack : lastSeriesInPositiveStack;\r\n        singleSeries._prevSeries = stack[stackName];\r\n        stack[stackName] = singleSeries;\r\n        singleSeries.holes = extend(true, {}, holesStack);\r\n        singleSeries.getPoints().forEach(function(point, index, points) {\r\n            var value = point.initialValue && point.initialValue.valueOf();\r\n            var argument = point.argument.valueOf();\r\n            var stacks = value >= 0 ? stackKeepers.positive : stackKeepers.negative;\r\n            var isNotBarSeries = \"bar\" !== singleSeries.type;\r\n            var currentStack;\r\n            if (negativesAsZeroes && value < 0) {\r\n                stacks = stackKeepers.positive;\r\n                value = 0;\r\n                point.resetValue()\r\n            }\r\n            stacks[stackName] = stacks[stackName] || {};\r\n            currentStack = stacks[stackName];\r\n            if (currentStack[argument]) {\r\n                if (isNotBarSeries) {\r\n                    point.correctValue(currentStack[argument])\r\n                }\r\n                currentStack[argument] += value\r\n            } else {\r\n                currentStack[argument] = value;\r\n                if (isNotBarSeries) {\r\n                    point.resetCorrection()\r\n                }\r\n            }\r\n            if (!point.hasValue()) {\r\n                var prevPoint = points[index - 1];\r\n                if (!hole && prevPoint && prevPoint.hasValue()) {\r\n                    argument = prevPoint.argument.valueOf();\r\n                    prevPoint._skipSetRightHole = true;\r\n                    holesStack.right[argument] = (holesStack.right[argument] || 0) + (prevPoint.value.valueOf() - (isFinite(prevPoint.minValue) ? prevPoint.minValue.valueOf() : 0))\r\n                }\r\n                hole = true\r\n            } else {\r\n                if (hole) {\r\n                    hole = false;\r\n                    holesStack.left[argument] = (holesStack.left[argument] || 0) + (point.value.valueOf() - (isFinite(point.minValue) ? point.minValue.valueOf() : 0));\r\n                    point._skipSetLeftHole = true\r\n                }\r\n            }\r\n        })\r\n    });\r\n    series.forEach(function(singleSeries) {\r\n        var holes = singleSeries.holes;\r\n        singleSeries.getPoints().forEach(function(point) {\r\n            var argument = point.argument.valueOf();\r\n            point.resetHoles();\r\n            !point._skipSetLeftHole && point.setHole(holes.left[argument] || holesStack.left[argument] && 0, \"left\");\r\n            !point._skipSetRightHole && point.setHole(holes.right[argument] || holesStack.right[argument] && 0, \"right\");\r\n            point._skipSetLeftHole = null;\r\n            point._skipSetRightHole = null\r\n        })\r\n    });\r\n    that._stackKeepers = stackKeepers;\r\n    series.forEach(function(singleSeries) {\r\n        singleSeries.getPoints().forEach(function(point) {\r\n            var argument = point.argument.valueOf();\r\n            var stackName = singleSeries.getStackName() || singleSeries.getBarOverlapGroup();\r\n            var absTotal = getAbsStackSumByArg(stackKeepers, stackName, argument);\r\n            var total = getStackSumByArg(stackKeepers, stackName, argument);\r\n            point.setPercentValue(absTotal, total, holesStack.left[argument], holesStack.right[argument])\r\n        })\r\n    })\r\n}\r\n\r\nfunction updateStackedSeriesValues() {\r\n    var that = this;\r\n    var series = getVisibleSeries(that);\r\n    var stack = that._stackKeepers;\r\n    var stackKeepers = {\r\n        positive: {},\r\n        negative: {}\r\n    };\r\n    _each(series, function(_, singleSeries) {\r\n        var minBarSize = singleSeries.getOptions().minBarSize;\r\n        var valueAxisTranslator = singleSeries.getValueAxis().getTranslator();\r\n        var minShownBusinessValue = minBarSize && valueAxisTranslator.getMinBarSize(minBarSize);\r\n        var stackName = singleSeries.getStackName();\r\n        _each(singleSeries.getPoints(), function(index, point) {\r\n            if (!point.hasValue()) {\r\n                return\r\n            }\r\n            var value = point.initialValue && point.initialValue.valueOf();\r\n            var argument = point.argument.valueOf();\r\n            var updateValue;\r\n            var valueType;\r\n            var currentStack;\r\n            if (that.fullStacked) {\r\n                value = value / getAbsStackSumByArg(stack, stackName, argument) || 0\r\n            }\r\n            updateValue = valueAxisTranslator.checkMinBarSize(value, minShownBusinessValue, point.value);\r\n            valueType = getValueType(updateValue);\r\n            currentStack = stackKeepers[valueType][stackName] = stackKeepers[valueType][stackName] || {};\r\n            if (currentStack[argument]) {\r\n                point.minValue = currentStack[argument];\r\n                currentStack[argument] += updateValue\r\n            } else {\r\n                currentStack[argument] = updateValue\r\n            }\r\n            point.value = currentStack[argument]\r\n        })\r\n    });\r\n    if (that.fullStacked) {\r\n        updateFullStackedSeriesValues(series, stackKeepers)\r\n    }\r\n}\r\n\r\nfunction updateFullStackedSeriesValues(series, stackKeepers) {\r\n    _each(series, function(_, singleSeries) {\r\n        var stackName = singleSeries.getStackName ? singleSeries.getStackName() : \"default\";\r\n        _each(singleSeries.getPoints(), function(index, point) {\r\n            var stackSum = getAbsStackSumByArg(stackKeepers, stackName, point.argument.valueOf());\r\n            point.value = point.value / stackSum;\r\n            if (isNumeric(point.minValue)) {\r\n                point.minValue = point.minValue / stackSum\r\n            }\r\n        })\r\n    })\r\n}\r\n\r\nfunction updateBarSeriesValues() {\r\n    _each(this.series, function(_, singleSeries) {\r\n        var minBarSize = singleSeries.getOptions().minBarSize;\r\n        var valueAxisTranslator = singleSeries.getValueAxis().getTranslator();\r\n        var minShownBusinessValue = minBarSize && valueAxisTranslator.getMinBarSize(minBarSize);\r\n        if (minShownBusinessValue) {\r\n            _each(singleSeries.getPoints(), function(index, point) {\r\n                if (point.hasValue()) {\r\n                    point.value = valueAxisTranslator.checkMinBarSize(point.initialValue, minShownBusinessValue)\r\n                }\r\n            })\r\n        }\r\n    })\r\n}\r\n\r\nfunction adjustCandlestickSeriesDimensions() {\r\n    var series = getVisibleSeries(this);\r\n    adjustBarSeriesDimensionsCore(series, {\r\n        barWidth: null,\r\n        equalBarWidth: true,\r\n        barGroupPadding: .3\r\n    }, getSeriesStackIndexCallback(isInverted(series)))\r\n}\r\n\r\nfunction adjustBubbleSeriesDimensions() {\r\n    var series = getVisibleSeries(this);\r\n    if (!series.length) {\r\n        return\r\n    }\r\n    var options = this._options;\r\n    var visibleAreaX = series[0].getArgumentAxis().getVisibleArea();\r\n    var visibleAreaY = series[0].getValueAxis().getVisibleArea();\r\n    var min = _math.min(visibleAreaX[1] - visibleAreaX[0], visibleAreaY[1] - visibleAreaY[0]);\r\n    var minBubbleArea = _pow(options.minBubbleSize, 2);\r\n    var maxBubbleArea = _pow(min * options.maxBubbleSize, 2);\r\n    var equalBubbleSize = (min * options.maxBubbleSize + options.minBubbleSize) / 2;\r\n    var minPointSize = 1 / 0;\r\n    var maxPointSize = -(1 / 0);\r\n    var pointSize;\r\n    var bubbleArea;\r\n    var sizeProportion;\r\n    var sizeDispersion;\r\n    var areaDispersion;\r\n    _each(series, function(_, seriesItem) {\r\n        _each(seriesItem.getPoints(), function(_, point) {\r\n            maxPointSize = maxPointSize > point.size ? maxPointSize : point.size;\r\n            minPointSize = minPointSize < point.size ? minPointSize : point.size\r\n        })\r\n    });\r\n    sizeDispersion = maxPointSize - minPointSize;\r\n    areaDispersion = _abs(maxBubbleArea - minBubbleArea);\r\n    _each(series, function(_, seriesItem) {\r\n        _each(seriesItem.getPoints(), function(_, point) {\r\n            if (maxPointSize === minPointSize) {\r\n                pointSize = _round(equalBubbleSize)\r\n            } else {\r\n                sizeProportion = _abs(point.size - minPointSize) / sizeDispersion;\r\n                bubbleArea = areaDispersion * sizeProportion + minBubbleArea;\r\n                pointSize = _round(_math.sqrt(bubbleArea))\r\n            }\r\n            point.correctCoordinates(pointSize)\r\n        })\r\n    })\r\n}\r\n\r\nfunction SeriesFamily(options) {\r\n    var that = this;\r\n    that.type = _normalizeEnum(options.type);\r\n    that.pane = options.pane;\r\n    that.series = [];\r\n    that.updateOptions(options);\r\n    switch (that.type) {\r\n        case \"bar\":\r\n            that.adjustSeriesDimensions = adjustBarSeriesDimensions;\r\n            that.updateSeriesValues = updateBarSeriesValues;\r\n            that.adjustSeriesValues = adjustStackedSeriesValues;\r\n            break;\r\n        case \"rangebar\":\r\n            that.adjustSeriesDimensions = adjustBarSeriesDimensions;\r\n            break;\r\n        case \"fullstackedbar\":\r\n            that.fullStacked = true;\r\n            that.adjustSeriesDimensions = adjustBarSeriesDimensions;\r\n            that.adjustSeriesValues = adjustStackedSeriesValues;\r\n            that.updateSeriesValues = updateStackedSeriesValues;\r\n            break;\r\n        case \"stackedbar\":\r\n            that.adjustSeriesDimensions = adjustBarSeriesDimensions;\r\n            that.adjustSeriesValues = adjustStackedSeriesValues;\r\n            that.updateSeriesValues = updateStackedSeriesValues;\r\n            break;\r\n        case \"fullstackedarea\":\r\n        case \"fullstackedline\":\r\n        case \"fullstackedspline\":\r\n        case \"fullstackedsplinearea\":\r\n            that.fullStacked = true;\r\n            that.adjustSeriesValues = adjustStackedSeriesValues;\r\n            break;\r\n        case \"stackedarea\":\r\n        case \"stackedsplinearea\":\r\n        case \"stackedline\":\r\n        case \"stackedspline\":\r\n            that.adjustSeriesValues = adjustStackedSeriesValues;\r\n            break;\r\n        case \"candlestick\":\r\n        case \"stock\":\r\n            that.adjustSeriesDimensions = adjustCandlestickSeriesDimensions;\r\n            break;\r\n        case \"bubble\":\r\n            that.adjustSeriesDimensions = adjustBubbleSeriesDimensions\r\n    }\r\n}\r\nexports.SeriesFamily = SeriesFamily;\r\nSeriesFamily.prototype = {\r\n    constructor: SeriesFamily,\r\n    adjustSeriesDimensions: _noop,\r\n    adjustSeriesValues: _noop,\r\n    updateSeriesValues: _noop,\r\n    updateOptions: function(options) {\r\n        this._options = options\r\n    },\r\n    dispose: function() {\r\n        this.series = null\r\n    },\r\n    add: function(series) {\r\n        var type = this.type;\r\n        this.series = vizUtils.map(series, function(singleSeries) {\r\n            return singleSeries.type === type ? singleSeries : null\r\n        })\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}