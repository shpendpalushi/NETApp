{"ast":null,"code":"/**\r\n * DevExtreme (viz/components/data_validator.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar typeUtils = require(\"../../core/utils/type\");\n\nvar STRING = \"string\";\nvar NUMERIC = \"numeric\";\nvar DATETIME = \"datetime\";\nvar DISCRETE = \"discrete\";\nvar SEMIDISCRETE = \"semidiscrete\";\nvar CONTINUOUS = \"continuous\";\nvar LOGARITHMIC = \"logarithmic\";\nvar VALUE_TYPE = \"valueType\";\nvar ARGUMENT_TYPE = \"argumentType\";\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar axisTypeParser = require(\"../core/utils\").enumParser([STRING, NUMERIC, DATETIME]);\n\nvar _getParser = require(\"./parse_utils\").getParser;\n\nvar _isDefined = typeUtils.isDefined;\nvar _isFunction = typeUtils.isFunction;\nvar _isArray = Array.isArray;\nvar _isString = typeUtils.isString;\nvar _isDate = typeUtils.isDate;\nvar _isNumber = typeUtils.isNumeric;\nvar _isObject = typeUtils.isObject;\n\nfunction groupingValues(data, others, valueField, index) {\n  if (index >= 0) {\n    data.slice(index).forEach(function (cell) {\n      if (_isDefined(cell[valueField])) {\n        others[valueField] += cell[valueField];\n        cell[valueField] = void 0;\n      }\n    });\n  }\n}\n\nfunction processGroups(groups) {\n  groups.forEach(function (group) {\n    group.valueType = group.valueAxisType = null;\n    group.series.forEach(function (series) {\n      series.updateDataType({});\n    });\n    group.valueAxis && group.valueAxis.resetTypes(VALUE_TYPE);\n  });\n}\n\nfunction sortValues(data, asc, selector) {\n  var func = asc ? function (a, b) {\n    return a - b;\n  } : function (a, b) {\n    return b - a;\n  };\n  data.sort(function (a, b) {\n    var valA = selector(a);\n    var valB = selector(b);\n    var aa = _isDefined(valA) ? 1 : 0;\n    var bb = _isDefined(valB) ? 1 : 0;\n    return aa && bb ? func(valA, valB) : func(aa, bb);\n  });\n  return data;\n}\n\nfunction resetArgumentAxes(axes) {\n  axes && axes.forEach(function (axis) {\n    axis.resetTypes(ARGUMENT_TYPE);\n  });\n}\n\nfunction parseCategories(categories, parser) {\n  var newArray = [];\n  categories.forEach(function (category) {\n    var parsedCategory = parser(category);\n    void 0 !== parsedCategory && newArray.push(parsedCategory);\n  });\n  return newArray;\n}\n\nfunction parseAxisCategories(groupsData, parsers) {\n  var argumentCategories = groupsData.argumentOptions && groupsData.argumentOptions.categories;\n  groupsData.groups.forEach(function (valueGroup, i) {\n    var categories = valueGroup.valueOptions && valueGroup.valueOptions.categories;\n\n    if (categories) {\n      valueGroup.valueOptions.categories = parseCategories(categories, parsers[i + 1]);\n    }\n  });\n\n  if (argumentCategories) {\n    groupsData.argumentOptions.categories = parseCategories(argumentCategories, parsers[0]);\n  }\n}\n\nfunction eigen(x) {\n  return x;\n}\n\nfunction getType(unit, type) {\n  var result = type;\n\n  if (type === STRING || _isString(unit)) {\n    result = STRING;\n  } else {\n    if (type === DATETIME || _isDate(unit)) {\n      result = DATETIME;\n    } else {\n      if (_isNumber(unit)) {\n        result = NUMERIC;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction correctAxisType(type, axisType, hasCategories, incidentOccurred) {\n  if (type === STRING && (axisType === CONTINUOUS || axisType === LOGARITHMIC || axisType === SEMIDISCRETE)) {\n    incidentOccurred(\"E2002\");\n  }\n\n  return axisType === LOGARITHMIC ? LOGARITHMIC : hasCategories || axisType === DISCRETE || type === STRING ? DISCRETE : axisType === SEMIDISCRETE ? SEMIDISCRETE : CONTINUOUS;\n}\n\nfunction validUnit(unit, field, incidentOccurred) {\n  if (unit) {\n    incidentOccurred(!_isNumber(unit) && !_isDate(unit) && !_isString(unit) ? \"E2003\" : \"E2004\", [field]);\n  }\n}\n\nfunction createParserUnit(type, axisType, incidentOccurred) {\n  var parser = type ? _getParser(type) : eigen;\n  var filterInfinity = axisType !== DISCRETE ? function (x) {\n    return isFinite(x) || void 0 === x ? x : null;\n  } : eigen;\n  return function (unit, field) {\n    var parseUnit = filterInfinity(parser(unit));\n\n    if (void 0 === parseUnit) {\n      validUnit(unit, field, incidentOccurred);\n    }\n\n    return parseUnit;\n  };\n}\n\nfunction prepareParsers(groupsData, incidentOccurred) {\n  var argumentParser = createParserUnit(groupsData.argumentType, groupsData.argumentAxisType, incidentOccurred);\n  var sizeParser;\n  var valueParser;\n  var categoryParsers = [argumentParser];\n  var cache = {};\n  var list = [];\n  groupsData.groups.forEach(function (group, groupIndex) {\n    group.series.forEach(function (series) {\n      valueParser = createParserUnit(group.valueType, group.valueAxisType, incidentOccurred);\n      sizeParser = createParserUnit(NUMERIC, CONTINUOUS, incidentOccurred);\n      cache[series.getArgumentField()] = argumentParser;\n      series.getValueFields().forEach(function (field) {\n        categoryParsers[groupIndex + 1] = valueParser;\n        cache[field] = valueParser;\n      });\n\n      if (series.getSizeField()) {\n        cache[series.getSizeField()] = sizeParser;\n      }\n    });\n  });\n\n  for (var field in cache) {\n    list.push([field, cache[field]]);\n  }\n\n  list.length && parseAxisCategories(groupsData, categoryParsers);\n  return list;\n}\n\nfunction getParsedCell(cell, parsers) {\n  var i;\n  var ii = parsers.length;\n  var obj = extend({}, cell);\n  var field;\n  var value;\n\n  for (i = 0; i < ii; ++i) {\n    field = parsers[i][0];\n    value = cell[field];\n    obj[field] = parsers[i][1](value, field);\n  }\n\n  return obj;\n}\n\nfunction parse(data, parsers) {\n  var parsedData = [];\n  var i;\n  var ii = data.length;\n  parsedData.length = ii;\n\n  for (i = 0; i < ii; ++i) {\n    parsedData[i] = getParsedCell(data[i], parsers);\n  }\n\n  return parsedData;\n}\n\nfunction findIndexByThreshold(data, valueField, threshold) {\n  var i;\n  var ii = data.length;\n  var value;\n\n  for (i = 0; i < ii; ++i) {\n    value = data[i][valueField];\n\n    if (_isDefined(value) && threshold > value) {\n      break;\n    }\n  }\n\n  return i;\n}\n\nfunction groupMinSlices(originalData, argumentField, valueField, smallValuesGrouping) {\n  smallValuesGrouping = smallValuesGrouping || {};\n  var mode = smallValuesGrouping.mode;\n  var others = {};\n  var data;\n\n  if (!mode || \"none\" === mode) {\n    return;\n  }\n\n  others[argumentField] = String(smallValuesGrouping.groupName || \"others\");\n  others[valueField] = 0;\n  data = sortValues(originalData.slice(), false, function (a) {\n    return a[valueField];\n  });\n  groupingValues(data, others, valueField, \"smallValueThreshold\" === mode ? findIndexByThreshold(data, valueField, smallValuesGrouping.threshold) : smallValuesGrouping.topCount);\n  others[valueField] && originalData.push(others);\n}\n\nfunction groupPieData(data, groupsData) {\n  var firstSeries = groupsData.groups[0] && groupsData.groups[0].series[0];\n  var isPie = firstSeries && (\"pie\" === firstSeries.type || \"doughnut\" === firstSeries.type || \"donut\" === firstSeries.type);\n\n  if (!isPie) {\n    return;\n  }\n\n  groupsData.groups.forEach(function (group) {\n    group.series.forEach(function (series) {\n      groupMinSlices(data, series.getArgumentField(), series.getValueFields()[0], series.getOptions().smallValuesGrouping);\n    });\n  });\n}\n\nfunction addUniqueItemToCollection(item, collection, itemsHash) {\n  if (!itemsHash[item]) {\n    collection.push(item);\n    itemsHash[item] = true;\n  }\n}\n\nfunction getUniqueArgumentFields(groupsData) {\n  var uniqueArgumentFields = [];\n  var hash = {};\n  groupsData.groups.forEach(function (group) {\n    group.series.forEach(function (series) {\n      addUniqueItemToCollection(series.getArgumentField(), uniqueArgumentFields, hash);\n    });\n  });\n  return uniqueArgumentFields;\n}\n\nfunction sort(a, b) {\n  var result = a - b;\n\n  if (isNaN(result)) {\n    if (!_isDefined(a)) {\n      return 1;\n    }\n\n    if (!_isDefined(b)) {\n      return -1;\n    }\n\n    return 0;\n  }\n\n  return result;\n}\n\nfunction sortByArgument(data, argumentField) {\n  return data.slice().sort(function (a, b) {\n    return sort(a[argumentField], b[argumentField]);\n  });\n}\n\nfunction sortByCallback(data, callback) {\n  return data.slice().sort(callback);\n}\n\nfunction checkValueTypeOfGroup(group, cell) {\n  group.series.forEach(function (series) {\n    series.getValueFields().forEach(function (field) {\n      group.valueType = getType(cell[field], group.valueType);\n    });\n  });\n  return group.valueType;\n}\n\nfunction getSortByCategories(categories) {\n  var hash = {};\n  categories.forEach(function (value, i) {\n    hash[value] = i;\n  });\n  return function (data, argumentField) {\n    return sortValues(data.slice(), true, function (a) {\n      return hash[a[argumentField]];\n    });\n  };\n}\n\nfunction sortData(data, groupsData, options, uniqueArgumentFields) {\n  var dataByArguments = {};\n  var isDiscrete = groupsData.argumentAxisType === DISCRETE;\n  var userCategories = isDiscrete && groupsData.argumentOptions && groupsData.argumentOptions.categories;\n\n  var sortFunction = function sortFunction(data) {\n    return data;\n  };\n\n  var sortingMethodOption = options.sortingMethod;\n  var reSortCategories;\n\n  if (!userCategories && _isFunction(sortingMethodOption)) {\n    data = sortByCallback(data, sortingMethodOption);\n  }\n\n  if (isDiscrete) {\n    groupsData.categories = getCategories(data, uniqueArgumentFields, userCategories);\n  }\n\n  if (userCategories || !_isFunction(sortingMethodOption) && groupsData.argumentType === STRING && !options._skipArgumentSorting) {\n    sortFunction = getSortByCategories(groupsData.categories);\n  } else {\n    if (true === sortingMethodOption && groupsData.argumentType !== STRING) {\n      sortFunction = sortByArgument;\n      reSortCategories = isDiscrete;\n    }\n  }\n\n  uniqueArgumentFields.forEach(function (field) {\n    dataByArguments[field] = sortFunction(data, field);\n  });\n\n  if (reSortCategories) {\n    groupsData.categories = groupsData.categories.sort(sort);\n  }\n\n  return dataByArguments;\n}\n\nfunction checkItemExistence(collection, item) {\n  return collection.map(function (collectionItem) {\n    return collectionItem.valueOf();\n  }).indexOf(item.valueOf()) === -1;\n}\n\nfunction getCategories(data, uniqueArgumentFields, userCategories) {\n  var categories = userCategories ? userCategories.slice() : [];\n  uniqueArgumentFields.forEach(function (field) {\n    data.forEach(function (item) {\n      var dataItem = item[field];\n      _isDefined(dataItem) && checkItemExistence(categories, dataItem) && categories.push(dataItem);\n    });\n  });\n  return categories;\n}\n\nfunction checkArgumentTypeOfGroup(series, cell, groupsData) {\n  series.forEach(function (currentSeries) {\n    groupsData.argumentType = getType(cell[currentSeries.getArgumentField()], groupsData.argumentType);\n  });\n  return groupsData.argumentType;\n}\n\nfunction checkType(data, groupsData, checkTypeForAllData) {\n  var groupsWithUndefinedValueType = [];\n  var groupsWithUndefinedArgumentType = [];\n  var argumentTypeGroup = groupsData.argumentOptions && axisTypeParser(groupsData.argumentOptions.argumentType);\n  var groupsIndexes;\n  groupsData.groups.forEach(function (group) {\n    if (!group.series.length) {\n      return;\n    }\n\n    var valueTypeGroup = group.valueOptions && axisTypeParser(group.valueOptions.valueType);\n    group.valueType = valueTypeGroup;\n    groupsData.argumentType = argumentTypeGroup;\n    !valueTypeGroup && groupsWithUndefinedValueType.push(group);\n    !argumentTypeGroup && groupsWithUndefinedArgumentType.push(group);\n  });\n\n  if (groupsWithUndefinedValueType.length || groupsWithUndefinedArgumentType.length) {\n    groupsIndexes = groupsWithUndefinedValueType.map(function (_, index) {\n      return index;\n    });\n    data.some(function (cell) {\n      var defineArg;\n      groupsWithUndefinedValueType.forEach(function (group, groupIndex) {\n        if (checkValueTypeOfGroup(group, cell) && groupsIndexes.indexOf(groupIndex) >= 0) {\n          groupsIndexes.splice(groupIndex, 1);\n        }\n      });\n\n      if (!defineArg) {\n        groupsWithUndefinedArgumentType.forEach(function (group) {\n          defineArg = checkArgumentTypeOfGroup(group.series, cell, groupsData);\n        });\n      }\n\n      if (!checkTypeForAllData && defineArg && 0 === groupsIndexes.length) {\n        return true;\n      }\n    });\n  }\n}\n\nfunction checkAxisType(groupsData, incidentOccurred) {\n  var argumentOptions = groupsData.argumentOptions || {};\n  var userArgumentCategories = argumentOptions && argumentOptions.categories || [];\n  var argumentAxisType = correctAxisType(groupsData.argumentType, argumentOptions.type, !!userArgumentCategories.length, incidentOccurred);\n  groupsData.groups.forEach(function (group) {\n    var valueOptions = group.valueOptions || {};\n    var valueCategories = valueOptions.categories || [];\n    var valueAxisType = correctAxisType(group.valueType, valueOptions.type, !!valueCategories.length, incidentOccurred);\n    group.series.forEach(function (series) {\n      var optionsSeries = {};\n      optionsSeries.argumentAxisType = argumentAxisType;\n      optionsSeries.valueAxisType = valueAxisType;\n      groupsData.argumentAxisType = groupsData.argumentAxisType || optionsSeries.argumentAxisType;\n      group.valueAxisType = group.valueAxisType || optionsSeries.valueAxisType;\n      optionsSeries.argumentType = groupsData.argumentType;\n      optionsSeries.valueType = group.valueType;\n      optionsSeries.showZero = valueOptions.showZero;\n      series.updateDataType(optionsSeries);\n    });\n    group.valueAxisType = group.valueAxisType || valueAxisType;\n\n    if (group.valueAxis) {\n      group.valueAxis.setTypes(group.valueAxisType, group.valueType, VALUE_TYPE);\n      group.valueAxis.validate();\n    }\n  });\n  groupsData.argumentAxisType = groupsData.argumentAxisType || argumentAxisType;\n\n  if (groupsData.argumentAxes) {\n    groupsData.argumentAxes.forEach(function (axis) {\n      axis.setTypes(groupsData.argumentAxisType, groupsData.argumentType, ARGUMENT_TYPE);\n      axis.validate();\n    });\n  }\n}\n\nfunction verifyData(source, incidentOccurred) {\n  var data = [];\n\n  var sourceIsDefined = _isDefined(source);\n\n  var hasError = sourceIsDefined && !_isArray(source);\n  var i;\n  var ii;\n  var k;\n  var item;\n\n  if (sourceIsDefined && !hasError) {\n    for (i = 0, ii = source.length, k = 0; i < ii; ++i) {\n      item = source[i];\n\n      if (_isObject(item)) {\n        data[k++] = item;\n      } else {\n        if (item) {\n          hasError = true;\n        }\n      }\n    }\n  }\n\n  if (hasError) {\n    incidentOccurred(\"E2001\");\n  }\n\n  return data;\n}\n\nfunction validateData(data, groupsData, incidentOccurred, options) {\n  var dataByArgumentFields;\n  data = verifyData(data, incidentOccurred);\n  groupsData.argumentType = groupsData.argumentAxisType = null;\n  processGroups(groupsData.groups);\n  resetArgumentAxes(groupsData.argumentAxes);\n  checkType(data, groupsData, options.checkTypeForAllData);\n  checkAxisType(groupsData, incidentOccurred);\n\n  if (options.convertToAxisDataType) {\n    data = parse(data, prepareParsers(groupsData, incidentOccurred));\n  }\n\n  groupPieData(data, groupsData);\n  dataByArgumentFields = sortData(data, groupsData, options, getUniqueArgumentFields(groupsData));\n  return dataByArgumentFields;\n}\n\nexports.validateData = validateData;","map":{"version":3,"sources":["C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/devextreme/viz/components/data_validator.js"],"names":["typeUtils","require","STRING","NUMERIC","DATETIME","DISCRETE","SEMIDISCRETE","CONTINUOUS","LOGARITHMIC","VALUE_TYPE","ARGUMENT_TYPE","extend","axisTypeParser","_getParser","_isDefined","_isFunction","_isArray","Array","_isString","_isDate","_isNumber","_isObject","index","data","cell","others","groups","group","series","func","asc","a","b","valA","selector","valB","aa","bb","axes","axis","newArray","categories","parsedCategory","parser","argumentCategories","groupsData","valueGroup","parseCategories","parsers","i","result","type","axisType","incidentOccurred","hasCategories","filterInfinity","isFinite","parseUnit","validUnit","argumentParser","createParserUnit","categoryParsers","cache","list","valueParser","sizeParser","groupIndex","parseAxisCategories","ii","obj","field","value","parsedData","getParsedCell","threshold","smallValuesGrouping","mode","String","sortValues","originalData","groupingValues","findIndexByThreshold","firstSeries","isPie","groupMinSlices","itemsHash","collection","uniqueArgumentFields","hash","addUniqueItemToCollection","isNaN","sort","getType","dataByArguments","isDiscrete","userCategories","sortFunction","sortingMethodOption","options","sortByCallback","getCategories","getSortByCategories","reSortCategories","collectionItem","item","dataItem","checkItemExistence","currentSeries","groupsWithUndefinedValueType","groupsWithUndefinedArgumentType","argumentTypeGroup","valueTypeGroup","groupsIndexes","checkValueTypeOfGroup","defineArg","checkArgumentTypeOfGroup","argumentOptions","userArgumentCategories","argumentAxisType","correctAxisType","valueOptions","valueCategories","valueAxisType","optionsSeries","sourceIsDefined","hasError","source","k","verifyData","processGroups","resetArgumentAxes","checkType","checkAxisType","parse","prepareParsers","groupPieData","dataByArgumentFields","sortData","getUniqueArgumentFields","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIA,SAAS,GAAGC,OAAO,CAAvB,uBAAuB,CAAvB;;AACA,IAAIC,MAAM,GAAV,QAAA;AACA,IAAIC,OAAO,GAAX,SAAA;AACA,IAAIC,QAAQ,GAAZ,UAAA;AACA,IAAIC,QAAQ,GAAZ,UAAA;AACA,IAAIC,YAAY,GAAhB,cAAA;AACA,IAAIC,UAAU,GAAd,YAAA;AACA,IAAIC,WAAW,GAAf,aAAA;AACA,IAAIC,UAAU,GAAd,WAAA;AACA,IAAIC,aAAa,GAAjB,cAAA;;AACA,IAAIC,MAAM,GAAGV,OAAO,CAAPA,yBAAO,CAAPA,CAAb,MAAA;;AACA,IAAIW,cAAc,GAAGX,OAAO,CAAPA,eAAO,CAAPA,CAAAA,UAAAA,CAAoC,CAAA,MAAA,EAAA,OAAA,EAAzD,QAAyD,CAApCA,CAArB;;AACA,IAAIY,UAAU,GAAGZ,OAAO,CAAPA,eAAO,CAAPA,CAAjB,SAAA;;AACA,IAAIa,UAAU,GAAGd,SAAS,CAA1B,SAAA;AACA,IAAIe,WAAW,GAAGf,SAAS,CAA3B,UAAA;AACA,IAAIgB,QAAQ,GAAGC,KAAK,CAApB,OAAA;AACA,IAAIC,SAAS,GAAGlB,SAAS,CAAzB,QAAA;AACA,IAAImB,OAAO,GAAGnB,SAAS,CAAvB,MAAA;AACA,IAAIoB,SAAS,GAAGpB,SAAS,CAAzB,SAAA;AACA,IAAIqB,SAAS,GAAGrB,SAAS,CAAzB,QAAA;;AAEA,SAAA,cAAA,CAAA,IAAA,EAAA,MAAA,EAAA,UAAA,EAAA,KAAA,EAAyD;AACrD,MAAIsB,KAAK,IAAT,CAAA,EAAgB;AACZC,IAAAA,IAAI,CAAJA,KAAAA,CAAAA,KAAAA,EAAAA,OAAAA,CAA0B,UAAA,IAAA,EAAe;AACrC,UAAIT,UAAU,CAACU,IAAI,CAAnB,UAAmB,CAAL,CAAd,EAAkC;AAC9BC,QAAAA,MAAM,CAANA,UAAM,CAANA,IAAsBD,IAAI,CAA1BC,UAA0B,CAA1BA;AACAD,QAAAA,IAAI,CAAJA,UAAI,CAAJA,GAAmB,KAAnBA,CAAAA;AACH;AAJLD,KAAAA;AAMH;AACJ;;AAED,SAAA,aAAA,CAAA,MAAA,EAA+B;AAC3BG,EAAAA,MAAM,CAANA,OAAAA,CAAe,UAAA,KAAA,EAAgB;AAC3BC,IAAAA,KAAK,CAALA,SAAAA,GAAkBA,KAAK,CAALA,aAAAA,GAAlBA,IAAAA;AACAA,IAAAA,KAAK,CAALA,MAAAA,CAAAA,OAAAA,CAAqB,UAAA,MAAA,EAAiB;AAClCC,MAAAA,MAAM,CAANA,cAAAA,CAAAA,EAAAA;AADJD,KAAAA;AAGAA,IAAAA,KAAK,CAALA,SAAAA,IAAmBA,KAAK,CAALA,SAAAA,CAAAA,UAAAA,CAAnBA,UAAmBA,CAAnBA;AALJD,GAAAA;AAOH;;AAED,SAAA,UAAA,CAAA,IAAA,EAAA,GAAA,EAAA,QAAA,EAAyC;AACrC,MAAIG,IAAI,GAAGC,GAAG,GAAG,UAAA,CAAA,EAAA,CAAA,EAAe;AAC5B,WAAOC,CAAC,GAAR,CAAA;AADU,GAAA,GAEV,UAAA,CAAA,EAAA,CAAA,EAAe;AACf,WAAOC,CAAC,GAAR,CAAA;AAHJ,GAAA;AAKAT,EAAAA,IAAI,CAAJA,IAAAA,CAAU,UAAA,CAAA,EAAA,CAAA,EAAe;AACrB,QAAIU,IAAI,GAAGC,QAAQ,CAAnB,CAAmB,CAAnB;AACA,QAAIC,IAAI,GAAGD,QAAQ,CAAnB,CAAmB,CAAnB;AACA,QAAIE,EAAE,GAAGtB,UAAU,CAAVA,IAAU,CAAVA,GAAAA,CAAAA,GAAT,CAAA;AACA,QAAIuB,EAAE,GAAGvB,UAAU,CAAVA,IAAU,CAAVA,GAAAA,CAAAA,GAAT,CAAA;AACA,WAAOsB,EAAE,IAAFA,EAAAA,GAAWP,IAAI,CAAA,IAAA,EAAfO,IAAe,CAAfA,GAA8BP,IAAI,CAAA,EAAA,EAAzC,EAAyC,CAAzC;AALJN,GAAAA;AAOA,SAAA,IAAA;AACH;;AAED,SAAA,iBAAA,CAAA,IAAA,EAAiC;AAC7Be,EAAAA,IAAI,IAAI,IAAI,CAAJ,OAAA,CAAa,UAAA,IAAA,EAAe;AAChCC,IAAAA,IAAI,CAAJA,UAAAA,CAAAA,aAAAA;AADJD,GAAQ,CAARA;AAGH;;AAED,SAAA,eAAA,CAAA,UAAA,EAAA,MAAA,EAA6C;AACzC,MAAIE,QAAQ,GAAZ,EAAA;AACAC,EAAAA,UAAU,CAAVA,OAAAA,CAAmB,UAAA,QAAA,EAAmB;AAClC,QAAIC,cAAc,GAAGC,MAAM,CAA3B,QAA2B,CAA3B;AACA,SAAA,CAAA,KAAA,cAAA,IAA6BH,QAAQ,CAARA,IAAAA,CAA7B,cAA6BA,CAA7B;AAFJC,GAAAA;AAIA,SAAA,QAAA;AACH;;AAED,SAAA,mBAAA,CAAA,UAAA,EAAA,OAAA,EAAkD;AAC9C,MAAIG,kBAAkB,GAAGC,UAAU,CAAVA,eAAAA,IAA8BA,UAAU,CAAVA,eAAAA,CAAvD,UAAA;AACAA,EAAAA,UAAU,CAAVA,MAAAA,CAAAA,OAAAA,CAA0B,UAAA,UAAA,EAAA,CAAA,EAAwB;AAC9C,QAAIJ,UAAU,GAAGK,UAAU,CAAVA,YAAAA,IAA2BA,UAAU,CAAVA,YAAAA,CAA5C,UAAA;;AACA,QAAA,UAAA,EAAgB;AACZA,MAAAA,UAAU,CAAVA,YAAAA,CAAAA,UAAAA,GAAqCC,eAAe,CAAA,UAAA,EAAaC,OAAO,CAACC,CAAC,GAA1EH,CAAwE,CAApB,CAApDA;AACH;AAJLD,GAAAA;;AAMA,MAAA,kBAAA,EAAwB;AACpBA,IAAAA,UAAU,CAAVA,eAAAA,CAAAA,UAAAA,GAAwCE,eAAe,CAAA,kBAAA,EAAqBC,OAAO,CAAnFH,CAAmF,CAA5B,CAAvDA;AACH;AACJ;;AAED,SAAA,KAAA,CAAA,CAAA,EAAkB;AACd,SAAA,CAAA;AACH;;AAED,SAAA,OAAA,CAAA,IAAA,EAAA,IAAA,EAA6B;AACzB,MAAIK,MAAM,GAAV,IAAA;;AACA,MAAIC,IAAI,KAAJA,MAAAA,IAAmBjC,SAAS,CAAhC,IAAgC,CAAhC,EAAwC;AACpCgC,IAAAA,MAAM,GAANA,MAAAA;AADJ,GAAA,MAEO;AACH,QAAIC,IAAI,KAAJA,QAAAA,IAAqBhC,OAAO,CAAhC,IAAgC,CAAhC,EAAwC;AACpC+B,MAAAA,MAAM,GAANA,QAAAA;AADJ,KAAA,MAEO;AACH,UAAI9B,SAAS,CAAb,IAAa,CAAb,EAAqB;AACjB8B,QAAAA,MAAM,GAANA,OAAAA;AACH;AACJ;AACJ;;AACD,SAAA,MAAA;AACH;;AAED,SAAA,eAAA,CAAA,IAAA,EAAA,QAAA,EAAA,aAAA,EAAA,gBAAA,EAA0E;AACtE,MAAIC,IAAI,KAAJA,MAAAA,KAAoBC,QAAQ,KAARA,UAAAA,IAA2BA,QAAQ,KAAnCA,WAAAA,IAAuDA,QAAQ,KAAvF,YAAID,CAAJ,EAA2G;AACvGE,IAAAA,gBAAgB,CAAhBA,OAAgB,CAAhBA;AACH;;AACD,SAAOD,QAAQ,KAARA,WAAAA,GAAAA,WAAAA,GAAyCE,aAAa,IAAIF,QAAQ,KAAzBE,QAAAA,IAA0CH,IAAI,KAA9CG,MAAAA,GAAAA,QAAAA,GAAuEF,QAAQ,KAARA,YAAAA,GAAAA,YAAAA,GAAvH,UAAA;AACH;;AAED,SAAA,SAAA,CAAA,IAAA,EAAA,KAAA,EAAA,gBAAA,EAAkD;AAC9C,MAAA,IAAA,EAAU;AACNC,IAAAA,gBAAgB,CAAC,CAACjC,SAAS,CAAV,IAAU,CAAV,IAAoB,CAACD,OAAO,CAA5B,IAA4B,CAA5B,IAAsC,CAACD,SAAS,CAAhD,IAAgD,CAAhD,GAAA,OAAA,GAAD,OAAA,EAA6E,CAA7FmC,KAA6F,CAA7E,CAAhBA;AACH;AACJ;;AAED,SAAA,gBAAA,CAAA,IAAA,EAAA,QAAA,EAAA,gBAAA,EAA4D;AACxD,MAAIV,MAAM,GAAGQ,IAAI,GAAGtC,UAAU,CAAb,IAAa,CAAb,GAAjB,KAAA;AACA,MAAI0C,cAAc,GAAG,QAAQ,KAAR,QAAA,GAAwB,UAAA,CAAA,EAAY;AACrD,WAAOC,QAAQ,CAARA,CAAQ,CAARA,IAAe,KAAA,CAAA,KAAfA,CAAAA,GAAAA,CAAAA,GAAP,IAAA;AADiB,GAAA,GAArB,KAAA;AAGA,SAAO,UAAA,IAAA,EAAA,KAAA,EAAsB;AACzB,QAAIC,SAAS,GAAGF,cAAc,CAACZ,MAAM,CAArC,IAAqC,CAAP,CAA9B;;AACA,QAAI,KAAA,CAAA,KAAJ,SAAA,EAA0B;AACtBe,MAAAA,SAAS,CAAA,IAAA,EAAA,KAAA,EAATA,gBAAS,CAATA;AACH;;AACD,WAAA,SAAA;AALJ,GAAA;AAOH;;AAED,SAAA,cAAA,CAAA,UAAA,EAAA,gBAAA,EAAsD;AAClD,MAAIC,cAAc,GAAGC,gBAAgB,CAACf,UAAU,CAAX,YAAA,EAA0BA,UAAU,CAApC,gBAAA,EAArC,gBAAqC,CAArC;AACA,MAAA,UAAA;AACA,MAAA,WAAA;AACA,MAAIgB,eAAe,GAAG,CAAtB,cAAsB,CAAtB;AACA,MAAIC,KAAK,GAAT,EAAA;AACA,MAAIC,IAAI,GAAR,EAAA;AACAlB,EAAAA,UAAU,CAAVA,MAAAA,CAAAA,OAAAA,CAA0B,UAAA,KAAA,EAAA,UAAA,EAA4B;AAClDlB,IAAAA,KAAK,CAALA,MAAAA,CAAAA,OAAAA,CAAqB,UAAA,MAAA,EAAiB;AAClCqC,MAAAA,WAAW,GAAGJ,gBAAgB,CAACjC,KAAK,CAAN,SAAA,EAAkBA,KAAK,CAAvB,aAAA,EAA9BqC,gBAA8B,CAA9BA;AACAC,MAAAA,UAAU,GAAGL,gBAAgB,CAAA,OAAA,EAAA,UAAA,EAA7BK,gBAA6B,CAA7BA;AACAH,MAAAA,KAAK,CAAClC,MAAM,CAAZkC,gBAAMlC,EAAD,CAALkC,GAAAA,cAAAA;AACAlC,MAAAA,MAAM,CAANA,cAAAA,GAAAA,OAAAA,CAAgC,UAAA,KAAA,EAAgB;AAC5CiC,QAAAA,eAAe,CAACK,UAAU,GAA1BL,CAAe,CAAfA,GAAAA,WAAAA;AACAC,QAAAA,KAAK,CAALA,KAAK,CAALA,GAAAA,WAAAA;AAFJlC,OAAAA;;AAIA,UAAIA,MAAM,CAAV,YAAIA,EAAJ,EAA2B;AACvBkC,QAAAA,KAAK,CAAClC,MAAM,CAAZkC,YAAMlC,EAAD,CAALkC,GAAAA,UAAAA;AACH;AAVLnC,KAAAA;AADJkB,GAAAA;;AAcA,OAAK,IAAL,KAAA,IAAA,KAAA,EAAyB;AACrBkB,IAAAA,IAAI,CAAJA,IAAAA,CAAU,CAAA,KAAA,EAAQD,KAAK,CAAvBC,KAAuB,CAAb,CAAVA;AACH;;AACDA,EAAAA,IAAI,CAAJA,MAAAA,IAAeI,mBAAmB,CAAA,UAAA,EAAlCJ,eAAkC,CAAlCA;AACA,SAAA,IAAA;AACH;;AAED,SAAA,aAAA,CAAA,IAAA,EAAA,OAAA,EAAsC;AAClC,MAAA,CAAA;AACA,MAAIK,EAAE,GAAGpB,OAAO,CAAhB,MAAA;AACA,MAAIqB,GAAG,GAAG1D,MAAM,CAAA,EAAA,EAAhB,IAAgB,CAAhB;AACA,MAAA,KAAA;AACA,MAAA,KAAA;;AACA,OAAKsC,CAAC,GAAN,CAAA,EAAYA,CAAC,GAAb,EAAA,EAAoB,EAApB,CAAA,EAAyB;AACrBqB,IAAAA,KAAK,GAAGtB,OAAO,CAAPA,CAAO,CAAPA,CAARsB,CAAQtB,CAARsB;AACAC,IAAAA,KAAK,GAAG/C,IAAI,CAAZ+C,KAAY,CAAZA;AACAF,IAAAA,GAAG,CAAHA,KAAG,CAAHA,GAAarB,OAAO,CAAPA,CAAO,CAAPA,CAAAA,CAAAA,EAAAA,KAAAA,EAAbqB,KAAarB,CAAbqB;AACH;;AACD,SAAA,GAAA;AACH;;AAED,SAAA,KAAA,CAAA,IAAA,EAAA,OAAA,EAA8B;AAC1B,MAAIG,UAAU,GAAd,EAAA;AACA,MAAA,CAAA;AACA,MAAIJ,EAAE,GAAG7C,IAAI,CAAb,MAAA;AACAiD,EAAAA,UAAU,CAAVA,MAAAA,GAAAA,EAAAA;;AACA,OAAKvB,CAAC,GAAN,CAAA,EAAYA,CAAC,GAAb,EAAA,EAAoB,EAApB,CAAA,EAAyB;AACrBuB,IAAAA,UAAU,CAAVA,CAAU,CAAVA,GAAgBC,aAAa,CAAClD,IAAI,CAAL,CAAK,CAAL,EAA7BiD,OAA6B,CAA7BA;AACH;;AACD,SAAA,UAAA;AACH;;AAED,SAAA,oBAAA,CAAA,IAAA,EAAA,UAAA,EAAA,SAAA,EAA2D;AACvD,MAAA,CAAA;AACA,MAAIJ,EAAE,GAAG7C,IAAI,CAAb,MAAA;AACA,MAAA,KAAA;;AACA,OAAK0B,CAAC,GAAN,CAAA,EAAYA,CAAC,GAAb,EAAA,EAAoB,EAApB,CAAA,EAAyB;AACrBsB,IAAAA,KAAK,GAAGhD,IAAI,CAAJA,CAAI,CAAJA,CAARgD,UAAQhD,CAARgD;;AACA,QAAIzD,UAAU,CAAVA,KAAU,CAAVA,IAAqB4D,SAAS,GAAlC,KAAA,EAA4C;AACxC;AACH;AACJ;;AACD,SAAA,CAAA;AACH;;AAED,SAAA,cAAA,CAAA,YAAA,EAAA,aAAA,EAAA,UAAA,EAAA,mBAAA,EAAsF;AAClFC,EAAAA,mBAAmB,GAAGA,mBAAmB,IAAzCA,EAAAA;AACA,MAAIC,IAAI,GAAGD,mBAAmB,CAA9B,IAAA;AACA,MAAIlD,MAAM,GAAV,EAAA;AACA,MAAA,IAAA;;AACA,MAAI,CAAA,IAAA,IAAS,WAAb,IAAA,EAA8B;AAC1B;AACH;;AACDA,EAAAA,MAAM,CAANA,aAAM,CAANA,GAAwBoD,MAAM,CAACF,mBAAmB,CAAnBA,SAAAA,IAA/BlD,QAA8B,CAA9BA;AACAA,EAAAA,MAAM,CAANA,UAAM,CAANA,GAAAA,CAAAA;AACAF,EAAAA,IAAI,GAAGuD,UAAU,CAACC,YAAY,CAAb,KAACA,EAAD,EAAA,KAAA,EAA8B,UAAA,CAAA,EAAY;AACvD,WAAOhD,CAAC,CAAR,UAAQ,CAAR;AADJR,GAAiB,CAAjBA;AAGAyD,EAAAA,cAAc,CAAA,IAAA,EAAA,MAAA,EAAA,UAAA,EAA2B,0BAAA,IAAA,GAAiCC,oBAAoB,CAAA,IAAA,EAAA,UAAA,EAAmBN,mBAAmB,CAA3F,SAAqD,CAArD,GAAyGA,mBAAmB,CAArKK,QAAc,CAAdA;AACAvD,EAAAA,MAAM,CAANA,UAAM,CAANA,IAAsBsD,YAAY,CAAZA,IAAAA,CAAtBtD,MAAsBsD,CAAtBtD;AACH;;AAED,SAAA,YAAA,CAAA,IAAA,EAAA,UAAA,EAAwC;AACpC,MAAIyD,WAAW,GAAGrC,UAAU,CAAVA,MAAAA,CAAAA,CAAAA,KAAwBA,UAAU,CAAVA,MAAAA,CAAAA,CAAAA,EAAAA,MAAAA,CAA1C,CAA0CA,CAA1C;AACA,MAAIsC,KAAK,GAAGD,WAAW,KAAK,UAAUA,WAAW,CAArB,IAAA,IAA8B,eAAeA,WAAW,CAAxD,IAAA,IAAiE,YAAYA,WAAW,CAApH,IAAuB,CAAvB;;AACA,MAAI,CAAJ,KAAA,EAAY;AACR;AACH;;AACDrC,EAAAA,UAAU,CAAVA,MAAAA,CAAAA,OAAAA,CAA0B,UAAA,KAAA,EAAgB;AACtClB,IAAAA,KAAK,CAALA,MAAAA,CAAAA,OAAAA,CAAqB,UAAA,MAAA,EAAiB;AAClCyD,MAAAA,cAAc,CAAA,IAAA,EAAOxD,MAAM,CAAb,gBAAOA,EAAP,EAAkCA,MAAM,CAANA,cAAAA,GAAlC,CAAkCA,CAAlC,EAA8DA,MAAM,CAANA,UAAAA,GAA5EwD,mBAAc,CAAdA;AADJzD,KAAAA;AADJkB,GAAAA;AAKH;;AAED,SAAA,yBAAA,CAAA,IAAA,EAAA,UAAA,EAAA,SAAA,EAAgE;AAC5D,MAAI,CAACwC,SAAS,CAAd,IAAc,CAAd,EAAsB;AAClBC,IAAAA,UAAU,CAAVA,IAAAA,CAAAA,IAAAA;AACAD,IAAAA,SAAS,CAATA,IAAS,CAATA,GAAAA,IAAAA;AACH;AACJ;;AAED,SAAA,uBAAA,CAAA,UAAA,EAA6C;AACzC,MAAIE,oBAAoB,GAAxB,EAAA;AACA,MAAIC,IAAI,GAAR,EAAA;AACA3C,EAAAA,UAAU,CAAVA,MAAAA,CAAAA,OAAAA,CAA0B,UAAA,KAAA,EAAgB;AACtClB,IAAAA,KAAK,CAALA,MAAAA,CAAAA,OAAAA,CAAqB,UAAA,MAAA,EAAiB;AAClC8D,MAAAA,yBAAyB,CAAC7D,MAAM,CAAP,gBAACA,EAAD,EAAA,oBAAA,EAAzB6D,IAAyB,CAAzBA;AADJ9D,KAAAA;AADJkB,GAAAA;AAKA,SAAA,oBAAA;AACH;;AAED,SAAA,IAAA,CAAA,CAAA,EAAA,CAAA,EAAoB;AAChB,MAAIK,MAAM,GAAGnB,CAAC,GAAd,CAAA;;AACA,MAAI2D,KAAK,CAAT,MAAS,CAAT,EAAmB;AACf,QAAI,CAAC5E,UAAU,CAAf,CAAe,CAAf,EAAoB;AAChB,aAAA,CAAA;AACH;;AACD,QAAI,CAACA,UAAU,CAAf,CAAe,CAAf,EAAoB;AAChB,aAAO,CAAP,CAAA;AACH;;AACD,WAAA,CAAA;AACH;;AACD,SAAA,MAAA;AACH;;AAED,SAAA,cAAA,CAAA,IAAA,EAAA,aAAA,EAA6C;AACzC,SAAO,IAAI,CAAJ,KAAA,GAAA,IAAA,CAAkB,UAAA,CAAA,EAAA,CAAA,EAAe;AACpC,WAAO6E,IAAI,CAAC5D,CAAC,CAAF,aAAE,CAAF,EAAmBC,CAAC,CAA/B,aAA+B,CAApB,CAAX;AADJ,GAAO,CAAP;AAGH;;AAED,SAAA,cAAA,CAAA,IAAA,EAAA,QAAA,EAAwC;AACpC,SAAOT,IAAI,CAAJA,KAAAA,GAAAA,IAAAA,CAAP,QAAOA,CAAP;AACH;;AAED,SAAA,qBAAA,CAAA,KAAA,EAAA,IAAA,EAA4C;AACxCI,EAAAA,KAAK,CAALA,MAAAA,CAAAA,OAAAA,CAAqB,UAAA,MAAA,EAAiB;AAClCC,IAAAA,MAAM,CAANA,cAAAA,GAAAA,OAAAA,CAAgC,UAAA,KAAA,EAAgB;AAC5CD,MAAAA,KAAK,CAALA,SAAAA,GAAkBiE,OAAO,CAACpE,IAAI,CAAL,KAAK,CAAL,EAAcG,KAAK,CAA5CA,SAAyB,CAAzBA;AADJC,KAAAA;AADJD,GAAAA;AAKA,SAAOA,KAAK,CAAZ,SAAA;AACH;;AAED,SAAA,mBAAA,CAAA,UAAA,EAAyC;AACrC,MAAI6D,IAAI,GAAR,EAAA;AACA/C,EAAAA,UAAU,CAAVA,OAAAA,CAAmB,UAAA,KAAA,EAAA,CAAA,EAAmB;AAClC+C,IAAAA,IAAI,CAAJA,KAAI,CAAJA,GAAAA,CAAAA;AADJ/C,GAAAA;AAGA,SAAO,UAAA,IAAA,EAAA,aAAA,EAA8B;AACjC,WAAOqC,UAAU,CAACvD,IAAI,CAAL,KAACA,EAAD,EAAA,IAAA,EAAqB,UAAA,CAAA,EAAY;AAC9C,aAAOiE,IAAI,CAACzD,CAAC,CAAb,aAAa,CAAF,CAAX;AADJ,KAAiB,CAAjB;AADJ,GAAA;AAKH;;AAED,SAAA,QAAA,CAAA,IAAA,EAAA,UAAA,EAAA,OAAA,EAAA,oBAAA,EAAmE;AAC/D,MAAI8D,eAAe,GAAnB,EAAA;AACA,MAAIC,UAAU,GAAGjD,UAAU,CAAVA,gBAAAA,KAAjB,QAAA;AACA,MAAIkD,cAAc,GAAGD,UAAU,IAAIjD,UAAU,CAAxBiD,eAAAA,IAA4CjD,UAAU,CAAVA,eAAAA,CAAjE,UAAA;;AACA,MAAImD,YAAY,GAAG,SAAA,YAAA,CAAA,IAAA,EAAe;AAC9B,WAAA,IAAA;AADJ,GAAA;;AAGA,MAAIC,mBAAmB,GAAGC,OAAO,CAAjC,aAAA;AACA,MAAA,gBAAA;;AACA,MAAI,CAAA,cAAA,IAAmBnF,WAAW,CAAlC,mBAAkC,CAAlC,EAAyD;AACrDQ,IAAAA,IAAI,GAAG4E,cAAc,CAAA,IAAA,EAArB5E,mBAAqB,CAArBA;AACH;;AACD,MAAA,UAAA,EAAgB;AACZsB,IAAAA,UAAU,CAAVA,UAAAA,GAAwBuD,aAAa,CAAA,IAAA,EAAA,oBAAA,EAArCvD,cAAqC,CAArCA;AACH;;AACD,MAAIkD,cAAc,IAAI,CAAChF,WAAW,CAAZ,mBAAY,CAAZ,IAAqC8B,UAAU,CAAVA,YAAAA,KAArC,MAAA,IAA2E,CAACqD,OAAO,CAAzG,oBAAA,EAAgI;AAC5HF,IAAAA,YAAY,GAAGK,mBAAmB,CAACxD,UAAU,CAA7CmD,UAAkC,CAAlCA;AADJ,GAAA,MAEO;AACH,QAAI,SAAA,mBAAA,IAAgCnD,UAAU,CAAVA,YAAAA,KAApC,MAAA,EAAwE;AACpEmD,MAAAA,YAAY,GAAZA,cAAAA;AACAM,MAAAA,gBAAgB,GAAhBA,UAAAA;AACH;AACJ;;AACDf,EAAAA,oBAAoB,CAApBA,OAAAA,CAA6B,UAAA,KAAA,EAAgB;AACzCM,IAAAA,eAAe,CAAfA,KAAe,CAAfA,GAAyBG,YAAY,CAAA,IAAA,EAArCH,KAAqC,CAArCA;AADJN,GAAAA;;AAGA,MAAA,gBAAA,EAAsB;AAClB1C,IAAAA,UAAU,CAAVA,UAAAA,GAAwBA,UAAU,CAAVA,UAAAA,CAAAA,IAAAA,CAAxBA,IAAwBA,CAAxBA;AACH;;AACD,SAAA,eAAA;AACH;;AAED,SAAA,kBAAA,CAAA,UAAA,EAAA,IAAA,EAA8C;AAC1C,SAAO,UAAU,CAAV,GAAA,CAAe,UAAA,cAAA,EAAyB;AAC3C,WAAO0D,cAAc,CAArB,OAAOA,EAAP;AADG,GAAA,EAAA,OAAA,CAEIC,IAAI,CAFR,OAEIA,EAFJ,MAEwB,CAF/B,CAAA;AAGH;;AAED,SAAA,aAAA,CAAA,IAAA,EAAA,oBAAA,EAAA,cAAA,EAAmE;AAC/D,MAAI/D,UAAU,GAAGsD,cAAc,GAAGA,cAAc,CAAjB,KAAGA,EAAH,GAA/B,EAAA;AACAR,EAAAA,oBAAoB,CAApBA,OAAAA,CAA6B,UAAA,KAAA,EAAgB;AACzChE,IAAAA,IAAI,CAAJA,OAAAA,CAAa,UAAA,IAAA,EAAe;AACxB,UAAIkF,QAAQ,GAAGD,IAAI,CAAnB,KAAmB,CAAnB;AACA1F,MAAAA,UAAU,CAAVA,QAAU,CAAVA,IAAwB4F,kBAAkB,CAAA,UAAA,EAA1C5F,QAA0C,CAA1CA,IAAoE2B,UAAU,CAAVA,IAAAA,CAApE3B,QAAoE2B,CAApE3B;AAFJS,KAAAA;AADJgE,GAAAA;AAMA,SAAA,UAAA;AACH;;AAED,SAAA,wBAAA,CAAA,MAAA,EAAA,IAAA,EAAA,UAAA,EAA4D;AACxD3D,EAAAA,MAAM,CAANA,OAAAA,CAAe,UAAA,aAAA,EAAwB;AACnCiB,IAAAA,UAAU,CAAVA,YAAAA,GAA0B+C,OAAO,CAACpE,IAAI,CAACmF,aAAa,CAAnB,gBAAMA,EAAD,CAAL,EAAyC9D,UAAU,CAApFA,YAAiC,CAAjCA;AADJjB,GAAAA;AAGA,SAAOiB,UAAU,CAAjB,YAAA;AACH;;AAED,SAAA,SAAA,CAAA,IAAA,EAAA,UAAA,EAAA,mBAAA,EAA0D;AACtD,MAAI+D,4BAA4B,GAAhC,EAAA;AACA,MAAIC,+BAA+B,GAAnC,EAAA;AACA,MAAIC,iBAAiB,GAAGjE,UAAU,CAAVA,eAAAA,IAA8BjC,cAAc,CAACiC,UAAU,CAAVA,eAAAA,CAArE,YAAoE,CAApE;AACA,MAAA,aAAA;AACAA,EAAAA,UAAU,CAAVA,MAAAA,CAAAA,OAAAA,CAA0B,UAAA,KAAA,EAAgB;AACtC,QAAI,CAAClB,KAAK,CAALA,MAAAA,CAAL,MAAA,EAA0B;AACtB;AACH;;AACD,QAAIoF,cAAc,GAAGpF,KAAK,CAALA,YAAAA,IAAsBf,cAAc,CAACe,KAAK,CAALA,YAAAA,CAA1D,SAAyD,CAAzD;AACAA,IAAAA,KAAK,CAALA,SAAAA,GAAAA,cAAAA;AACAkB,IAAAA,UAAU,CAAVA,YAAAA,GAAAA,iBAAAA;AACA,KAAA,cAAA,IAAmB+D,4BAA4B,CAA5BA,IAAAA,CAAnB,KAAmBA,CAAnB;AACA,KAAA,iBAAA,IAAsBC,+BAA+B,CAA/BA,IAAAA,CAAtB,KAAsBA,CAAtB;AARJhE,GAAAA;;AAUA,MAAI+D,4BAA4B,CAA5BA,MAAAA,IAAuCC,+BAA+B,CAA1E,MAAA,EAAmF;AAC/EG,IAAAA,aAAa,GAAG,4BAA4B,CAA5B,GAAA,CAAiC,UAAA,CAAA,EAAA,KAAA,EAAmB;AAChE,aAAA,KAAA;AADJA,KAAgB,CAAhBA;AAGAzF,IAAAA,IAAI,CAAJA,IAAAA,CAAU,UAAA,IAAA,EAAe;AACrB,UAAA,SAAA;AACAqF,MAAAA,4BAA4B,CAA5BA,OAAAA,CAAqC,UAAA,KAAA,EAAA,UAAA,EAA4B;AAC7D,YAAIK,qBAAqB,CAAA,KAAA,EAArBA,IAAqB,CAArBA,IAAsCD,aAAa,CAAbA,OAAAA,CAAAA,UAAAA,KAA1C,CAAA,EAAkF;AAC9EA,UAAAA,aAAa,CAAbA,MAAAA,CAAAA,UAAAA,EAAAA,CAAAA;AACH;AAHLJ,OAAAA;;AAKA,UAAI,CAAJ,SAAA,EAAgB;AACZC,QAAAA,+BAA+B,CAA/BA,OAAAA,CAAwC,UAAA,KAAA,EAAgB;AACpDK,UAAAA,SAAS,GAAGC,wBAAwB,CAACxF,KAAK,CAAN,MAAA,EAAA,IAAA,EAApCuF,UAAoC,CAApCA;AADJL,SAAAA;AAGH;;AACD,UAAI,CAAA,mBAAA,IAAA,SAAA,IAAqC,MAAMG,aAAa,CAA5D,MAAA,EAAqE;AACjE,eAAA,IAAA;AACH;AAdLzF,KAAAA;AAgBH;AACJ;;AAED,SAAA,aAAA,CAAA,UAAA,EAAA,gBAAA,EAAqD;AACjD,MAAI6F,eAAe,GAAGvE,UAAU,CAAVA,eAAAA,IAAtB,EAAA;AACA,MAAIwE,sBAAsB,GAAGD,eAAe,IAAIA,eAAe,CAAlCA,UAAAA,IAA7B,EAAA;AACA,MAAIE,gBAAgB,GAAGC,eAAe,CAAC1E,UAAU,CAAX,YAAA,EAA0BuE,eAAe,CAAzC,IAAA,EAAgD,CAAC,CAACC,sBAAsB,CAAxE,MAAA,EAAtC,gBAAsC,CAAtC;AACAxE,EAAAA,UAAU,CAAVA,MAAAA,CAAAA,OAAAA,CAA0B,UAAA,KAAA,EAAgB;AACtC,QAAI2E,YAAY,GAAG7F,KAAK,CAALA,YAAAA,IAAnB,EAAA;AACA,QAAI8F,eAAe,GAAGD,YAAY,CAAZA,UAAAA,IAAtB,EAAA;AACA,QAAIE,aAAa,GAAGH,eAAe,CAAC5F,KAAK,CAAN,SAAA,EAAkB6F,YAAY,CAA9B,IAAA,EAAqC,CAAC,CAACC,eAAe,CAAtD,MAAA,EAAnC,gBAAmC,CAAnC;AACA9F,IAAAA,KAAK,CAALA,MAAAA,CAAAA,OAAAA,CAAqB,UAAA,MAAA,EAAiB;AAClC,UAAIgG,aAAa,GAAjB,EAAA;AACAA,MAAAA,aAAa,CAAbA,gBAAAA,GAAAA,gBAAAA;AACAA,MAAAA,aAAa,CAAbA,aAAAA,GAAAA,aAAAA;AACA9E,MAAAA,UAAU,CAAVA,gBAAAA,GAA8BA,UAAU,CAAVA,gBAAAA,IAA+B8E,aAAa,CAA1E9E,gBAAAA;AACAlB,MAAAA,KAAK,CAALA,aAAAA,GAAsBA,KAAK,CAALA,aAAAA,IAAuBgG,aAAa,CAA1DhG,aAAAA;AACAgG,MAAAA,aAAa,CAAbA,YAAAA,GAA6B9E,UAAU,CAAvC8E,YAAAA;AACAA,MAAAA,aAAa,CAAbA,SAAAA,GAA0BhG,KAAK,CAA/BgG,SAAAA;AACAA,MAAAA,aAAa,CAAbA,QAAAA,GAAyBH,YAAY,CAArCG,QAAAA;AACA/F,MAAAA,MAAM,CAANA,cAAAA,CAAAA,aAAAA;AATJD,KAAAA;AAWAA,IAAAA,KAAK,CAALA,aAAAA,GAAsBA,KAAK,CAALA,aAAAA,IAAtBA,aAAAA;;AACA,QAAIA,KAAK,CAAT,SAAA,EAAqB;AACjBA,MAAAA,KAAK,CAALA,SAAAA,CAAAA,QAAAA,CAAyBA,KAAK,CAA9BA,aAAAA,EAA8CA,KAAK,CAAnDA,SAAAA,EAAAA,UAAAA;AACAA,MAAAA,KAAK,CAALA,SAAAA,CAAAA,QAAAA;AACH;AAnBLkB,GAAAA;AAqBAA,EAAAA,UAAU,CAAVA,gBAAAA,GAA8BA,UAAU,CAAVA,gBAAAA,IAA9BA,gBAAAA;;AACA,MAAIA,UAAU,CAAd,YAAA,EAA6B;AACzBA,IAAAA,UAAU,CAAVA,YAAAA,CAAAA,OAAAA,CAAgC,UAAA,IAAA,EAAe;AAC3CN,MAAAA,IAAI,CAAJA,QAAAA,CAAcM,UAAU,CAAxBN,gBAAAA,EAA2CM,UAAU,CAArDN,YAAAA,EAAAA,aAAAA;AACAA,MAAAA,IAAI,CAAJA,QAAAA;AAFJM,KAAAA;AAIH;AACJ;;AAED,SAAA,UAAA,CAAA,MAAA,EAAA,gBAAA,EAA8C;AAC1C,MAAItB,IAAI,GAAR,EAAA;;AACA,MAAIqG,eAAe,GAAG9G,UAAU,CAAhC,MAAgC,CAAhC;;AACA,MAAI+G,QAAQ,GAAGD,eAAe,IAAI,CAAC5G,QAAQ,CAA3C,MAA2C,CAA3C;AACA,MAAA,CAAA;AACA,MAAA,EAAA;AACA,MAAA,CAAA;AACA,MAAA,IAAA;;AACA,MAAI4G,eAAe,IAAI,CAAvB,QAAA,EAAkC;AAC9B,SAAK3E,CAAC,GAADA,CAAAA,EAAOmB,EAAE,GAAG0D,MAAM,CAAlB7E,MAAAA,EAA2B8E,CAAC,GAAjC,CAAA,EAAuC9E,CAAC,GAAxC,EAAA,EAA+C,EAA/C,CAAA,EAAoD;AAChDuD,MAAAA,IAAI,GAAGsB,MAAM,CAAbtB,CAAa,CAAbA;;AACA,UAAInF,SAAS,CAAb,IAAa,CAAb,EAAqB;AACjBE,QAAAA,IAAI,CAACwG,CAALxG,EAAI,CAAJA,GAAAA,IAAAA;AADJ,OAAA,MAEO;AACH,YAAA,IAAA,EAAU;AACNsG,UAAAA,QAAQ,GAARA,IAAAA;AACH;AACJ;AACJ;AACJ;;AACD,MAAA,QAAA,EAAc;AACVxE,IAAAA,gBAAgB,CAAhBA,OAAgB,CAAhBA;AACH;;AACD,SAAA,IAAA;AACH;;AAED,SAAA,YAAA,CAAA,IAAA,EAAA,UAAA,EAAA,gBAAA,EAAA,OAAA,EAAmE;AAC/D,MAAA,oBAAA;AACA9B,EAAAA,IAAI,GAAGyG,UAAU,CAAA,IAAA,EAAjBzG,gBAAiB,CAAjBA;AACAsB,EAAAA,UAAU,CAAVA,YAAAA,GAA0BA,UAAU,CAAVA,gBAAAA,GAA1BA,IAAAA;AACAoF,EAAAA,aAAa,CAACpF,UAAU,CAAxBoF,MAAa,CAAbA;AACAC,EAAAA,iBAAiB,CAACrF,UAAU,CAA5BqF,YAAiB,CAAjBA;AACAC,EAAAA,SAAS,CAAA,IAAA,EAAA,UAAA,EAAmBjC,OAAO,CAAnCiC,mBAAS,CAATA;AACAC,EAAAA,aAAa,CAAA,UAAA,EAAbA,gBAAa,CAAbA;;AACA,MAAIlC,OAAO,CAAX,qBAAA,EAAmC;AAC/B3E,IAAAA,IAAI,GAAG8G,KAAK,CAAA,IAAA,EAAOC,cAAc,CAAA,UAAA,EAAjC/G,gBAAiC,CAArB,CAAZA;AACH;;AACDgH,EAAAA,YAAY,CAAA,IAAA,EAAZA,UAAY,CAAZA;AACAC,EAAAA,oBAAoB,GAAGC,QAAQ,CAAA,IAAA,EAAA,UAAA,EAAA,OAAA,EAA4BC,uBAAuB,CAAlFF,UAAkF,CAAnD,CAA/BA;AACA,SAAA,oBAAA;AACH;;AACDG,OAAO,CAAPA,YAAAA,GAAAA,YAAAA","sourcesContent":["/**\r\n * DevExtreme (viz/components/data_validator.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nvar typeUtils = require(\"../../core/utils/type\");\r\nvar STRING = \"string\";\r\nvar NUMERIC = \"numeric\";\r\nvar DATETIME = \"datetime\";\r\nvar DISCRETE = \"discrete\";\r\nvar SEMIDISCRETE = \"semidiscrete\";\r\nvar CONTINUOUS = \"continuous\";\r\nvar LOGARITHMIC = \"logarithmic\";\r\nvar VALUE_TYPE = \"valueType\";\r\nvar ARGUMENT_TYPE = \"argumentType\";\r\nvar extend = require(\"../../core/utils/extend\").extend;\r\nvar axisTypeParser = require(\"../core/utils\").enumParser([STRING, NUMERIC, DATETIME]);\r\nvar _getParser = require(\"./parse_utils\").getParser;\r\nvar _isDefined = typeUtils.isDefined;\r\nvar _isFunction = typeUtils.isFunction;\r\nvar _isArray = Array.isArray;\r\nvar _isString = typeUtils.isString;\r\nvar _isDate = typeUtils.isDate;\r\nvar _isNumber = typeUtils.isNumeric;\r\nvar _isObject = typeUtils.isObject;\r\n\r\nfunction groupingValues(data, others, valueField, index) {\r\n    if (index >= 0) {\r\n        data.slice(index).forEach(function(cell) {\r\n            if (_isDefined(cell[valueField])) {\r\n                others[valueField] += cell[valueField];\r\n                cell[valueField] = void 0\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nfunction processGroups(groups) {\r\n    groups.forEach(function(group) {\r\n        group.valueType = group.valueAxisType = null;\r\n        group.series.forEach(function(series) {\r\n            series.updateDataType({})\r\n        });\r\n        group.valueAxis && group.valueAxis.resetTypes(VALUE_TYPE)\r\n    })\r\n}\r\n\r\nfunction sortValues(data, asc, selector) {\r\n    var func = asc ? function(a, b) {\r\n        return a - b\r\n    } : function(a, b) {\r\n        return b - a\r\n    };\r\n    data.sort(function(a, b) {\r\n        var valA = selector(a);\r\n        var valB = selector(b);\r\n        var aa = _isDefined(valA) ? 1 : 0;\r\n        var bb = _isDefined(valB) ? 1 : 0;\r\n        return aa && bb ? func(valA, valB) : func(aa, bb)\r\n    });\r\n    return data\r\n}\r\n\r\nfunction resetArgumentAxes(axes) {\r\n    axes && axes.forEach(function(axis) {\r\n        axis.resetTypes(ARGUMENT_TYPE)\r\n    })\r\n}\r\n\r\nfunction parseCategories(categories, parser) {\r\n    var newArray = [];\r\n    categories.forEach(function(category) {\r\n        var parsedCategory = parser(category);\r\n        void 0 !== parsedCategory && newArray.push(parsedCategory)\r\n    });\r\n    return newArray\r\n}\r\n\r\nfunction parseAxisCategories(groupsData, parsers) {\r\n    var argumentCategories = groupsData.argumentOptions && groupsData.argumentOptions.categories;\r\n    groupsData.groups.forEach(function(valueGroup, i) {\r\n        var categories = valueGroup.valueOptions && valueGroup.valueOptions.categories;\r\n        if (categories) {\r\n            valueGroup.valueOptions.categories = parseCategories(categories, parsers[i + 1])\r\n        }\r\n    });\r\n    if (argumentCategories) {\r\n        groupsData.argumentOptions.categories = parseCategories(argumentCategories, parsers[0])\r\n    }\r\n}\r\n\r\nfunction eigen(x) {\r\n    return x\r\n}\r\n\r\nfunction getType(unit, type) {\r\n    var result = type;\r\n    if (type === STRING || _isString(unit)) {\r\n        result = STRING\r\n    } else {\r\n        if (type === DATETIME || _isDate(unit)) {\r\n            result = DATETIME\r\n        } else {\r\n            if (_isNumber(unit)) {\r\n                result = NUMERIC\r\n            }\r\n        }\r\n    }\r\n    return result\r\n}\r\n\r\nfunction correctAxisType(type, axisType, hasCategories, incidentOccurred) {\r\n    if (type === STRING && (axisType === CONTINUOUS || axisType === LOGARITHMIC || axisType === SEMIDISCRETE)) {\r\n        incidentOccurred(\"E2002\")\r\n    }\r\n    return axisType === LOGARITHMIC ? LOGARITHMIC : hasCategories || axisType === DISCRETE || type === STRING ? DISCRETE : axisType === SEMIDISCRETE ? SEMIDISCRETE : CONTINUOUS\r\n}\r\n\r\nfunction validUnit(unit, field, incidentOccurred) {\r\n    if (unit) {\r\n        incidentOccurred(!_isNumber(unit) && !_isDate(unit) && !_isString(unit) ? \"E2003\" : \"E2004\", [field])\r\n    }\r\n}\r\n\r\nfunction createParserUnit(type, axisType, incidentOccurred) {\r\n    var parser = type ? _getParser(type) : eigen;\r\n    var filterInfinity = axisType !== DISCRETE ? function(x) {\r\n        return isFinite(x) || void 0 === x ? x : null\r\n    } : eigen;\r\n    return function(unit, field) {\r\n        var parseUnit = filterInfinity(parser(unit));\r\n        if (void 0 === parseUnit) {\r\n            validUnit(unit, field, incidentOccurred)\r\n        }\r\n        return parseUnit\r\n    }\r\n}\r\n\r\nfunction prepareParsers(groupsData, incidentOccurred) {\r\n    var argumentParser = createParserUnit(groupsData.argumentType, groupsData.argumentAxisType, incidentOccurred);\r\n    var sizeParser;\r\n    var valueParser;\r\n    var categoryParsers = [argumentParser];\r\n    var cache = {};\r\n    var list = [];\r\n    groupsData.groups.forEach(function(group, groupIndex) {\r\n        group.series.forEach(function(series) {\r\n            valueParser = createParserUnit(group.valueType, group.valueAxisType, incidentOccurred);\r\n            sizeParser = createParserUnit(NUMERIC, CONTINUOUS, incidentOccurred);\r\n            cache[series.getArgumentField()] = argumentParser;\r\n            series.getValueFields().forEach(function(field) {\r\n                categoryParsers[groupIndex + 1] = valueParser;\r\n                cache[field] = valueParser\r\n            });\r\n            if (series.getSizeField()) {\r\n                cache[series.getSizeField()] = sizeParser\r\n            }\r\n        })\r\n    });\r\n    for (var field in cache) {\r\n        list.push([field, cache[field]])\r\n    }\r\n    list.length && parseAxisCategories(groupsData, categoryParsers);\r\n    return list\r\n}\r\n\r\nfunction getParsedCell(cell, parsers) {\r\n    var i;\r\n    var ii = parsers.length;\r\n    var obj = extend({}, cell);\r\n    var field;\r\n    var value;\r\n    for (i = 0; i < ii; ++i) {\r\n        field = parsers[i][0];\r\n        value = cell[field];\r\n        obj[field] = parsers[i][1](value, field)\r\n    }\r\n    return obj\r\n}\r\n\r\nfunction parse(data, parsers) {\r\n    var parsedData = [];\r\n    var i;\r\n    var ii = data.length;\r\n    parsedData.length = ii;\r\n    for (i = 0; i < ii; ++i) {\r\n        parsedData[i] = getParsedCell(data[i], parsers)\r\n    }\r\n    return parsedData\r\n}\r\n\r\nfunction findIndexByThreshold(data, valueField, threshold) {\r\n    var i;\r\n    var ii = data.length;\r\n    var value;\r\n    for (i = 0; i < ii; ++i) {\r\n        value = data[i][valueField];\r\n        if (_isDefined(value) && threshold > value) {\r\n            break\r\n        }\r\n    }\r\n    return i\r\n}\r\n\r\nfunction groupMinSlices(originalData, argumentField, valueField, smallValuesGrouping) {\r\n    smallValuesGrouping = smallValuesGrouping || {};\r\n    var mode = smallValuesGrouping.mode;\r\n    var others = {};\r\n    var data;\r\n    if (!mode || \"none\" === mode) {\r\n        return\r\n    }\r\n    others[argumentField] = String(smallValuesGrouping.groupName || \"others\");\r\n    others[valueField] = 0;\r\n    data = sortValues(originalData.slice(), false, function(a) {\r\n        return a[valueField]\r\n    });\r\n    groupingValues(data, others, valueField, \"smallValueThreshold\" === mode ? findIndexByThreshold(data, valueField, smallValuesGrouping.threshold) : smallValuesGrouping.topCount);\r\n    others[valueField] && originalData.push(others)\r\n}\r\n\r\nfunction groupPieData(data, groupsData) {\r\n    var firstSeries = groupsData.groups[0] && groupsData.groups[0].series[0];\r\n    var isPie = firstSeries && (\"pie\" === firstSeries.type || \"doughnut\" === firstSeries.type || \"donut\" === firstSeries.type);\r\n    if (!isPie) {\r\n        return\r\n    }\r\n    groupsData.groups.forEach(function(group) {\r\n        group.series.forEach(function(series) {\r\n            groupMinSlices(data, series.getArgumentField(), series.getValueFields()[0], series.getOptions().smallValuesGrouping)\r\n        })\r\n    })\r\n}\r\n\r\nfunction addUniqueItemToCollection(item, collection, itemsHash) {\r\n    if (!itemsHash[item]) {\r\n        collection.push(item);\r\n        itemsHash[item] = true\r\n    }\r\n}\r\n\r\nfunction getUniqueArgumentFields(groupsData) {\r\n    var uniqueArgumentFields = [];\r\n    var hash = {};\r\n    groupsData.groups.forEach(function(group) {\r\n        group.series.forEach(function(series) {\r\n            addUniqueItemToCollection(series.getArgumentField(), uniqueArgumentFields, hash)\r\n        })\r\n    });\r\n    return uniqueArgumentFields\r\n}\r\n\r\nfunction sort(a, b) {\r\n    var result = a - b;\r\n    if (isNaN(result)) {\r\n        if (!_isDefined(a)) {\r\n            return 1\r\n        }\r\n        if (!_isDefined(b)) {\r\n            return -1\r\n        }\r\n        return 0\r\n    }\r\n    return result\r\n}\r\n\r\nfunction sortByArgument(data, argumentField) {\r\n    return data.slice().sort(function(a, b) {\r\n        return sort(a[argumentField], b[argumentField])\r\n    })\r\n}\r\n\r\nfunction sortByCallback(data, callback) {\r\n    return data.slice().sort(callback)\r\n}\r\n\r\nfunction checkValueTypeOfGroup(group, cell) {\r\n    group.series.forEach(function(series) {\r\n        series.getValueFields().forEach(function(field) {\r\n            group.valueType = getType(cell[field], group.valueType)\r\n        })\r\n    });\r\n    return group.valueType\r\n}\r\n\r\nfunction getSortByCategories(categories) {\r\n    var hash = {};\r\n    categories.forEach(function(value, i) {\r\n        hash[value] = i\r\n    });\r\n    return function(data, argumentField) {\r\n        return sortValues(data.slice(), true, function(a) {\r\n            return hash[a[argumentField]]\r\n        })\r\n    }\r\n}\r\n\r\nfunction sortData(data, groupsData, options, uniqueArgumentFields) {\r\n    var dataByArguments = {};\r\n    var isDiscrete = groupsData.argumentAxisType === DISCRETE;\r\n    var userCategories = isDiscrete && groupsData.argumentOptions && groupsData.argumentOptions.categories;\r\n    var sortFunction = function(data) {\r\n        return data\r\n    };\r\n    var sortingMethodOption = options.sortingMethod;\r\n    var reSortCategories;\r\n    if (!userCategories && _isFunction(sortingMethodOption)) {\r\n        data = sortByCallback(data, sortingMethodOption)\r\n    }\r\n    if (isDiscrete) {\r\n        groupsData.categories = getCategories(data, uniqueArgumentFields, userCategories)\r\n    }\r\n    if (userCategories || !_isFunction(sortingMethodOption) && groupsData.argumentType === STRING && !options._skipArgumentSorting) {\r\n        sortFunction = getSortByCategories(groupsData.categories)\r\n    } else {\r\n        if (true === sortingMethodOption && groupsData.argumentType !== STRING) {\r\n            sortFunction = sortByArgument;\r\n            reSortCategories = isDiscrete\r\n        }\r\n    }\r\n    uniqueArgumentFields.forEach(function(field) {\r\n        dataByArguments[field] = sortFunction(data, field)\r\n    });\r\n    if (reSortCategories) {\r\n        groupsData.categories = groupsData.categories.sort(sort)\r\n    }\r\n    return dataByArguments\r\n}\r\n\r\nfunction checkItemExistence(collection, item) {\r\n    return collection.map(function(collectionItem) {\r\n        return collectionItem.valueOf()\r\n    }).indexOf(item.valueOf()) === -1\r\n}\r\n\r\nfunction getCategories(data, uniqueArgumentFields, userCategories) {\r\n    var categories = userCategories ? userCategories.slice() : [];\r\n    uniqueArgumentFields.forEach(function(field) {\r\n        data.forEach(function(item) {\r\n            var dataItem = item[field];\r\n            _isDefined(dataItem) && checkItemExistence(categories, dataItem) && categories.push(dataItem)\r\n        })\r\n    });\r\n    return categories\r\n}\r\n\r\nfunction checkArgumentTypeOfGroup(series, cell, groupsData) {\r\n    series.forEach(function(currentSeries) {\r\n        groupsData.argumentType = getType(cell[currentSeries.getArgumentField()], groupsData.argumentType)\r\n    });\r\n    return groupsData.argumentType\r\n}\r\n\r\nfunction checkType(data, groupsData, checkTypeForAllData) {\r\n    var groupsWithUndefinedValueType = [];\r\n    var groupsWithUndefinedArgumentType = [];\r\n    var argumentTypeGroup = groupsData.argumentOptions && axisTypeParser(groupsData.argumentOptions.argumentType);\r\n    var groupsIndexes;\r\n    groupsData.groups.forEach(function(group) {\r\n        if (!group.series.length) {\r\n            return\r\n        }\r\n        var valueTypeGroup = group.valueOptions && axisTypeParser(group.valueOptions.valueType);\r\n        group.valueType = valueTypeGroup;\r\n        groupsData.argumentType = argumentTypeGroup;\r\n        !valueTypeGroup && groupsWithUndefinedValueType.push(group);\r\n        !argumentTypeGroup && groupsWithUndefinedArgumentType.push(group)\r\n    });\r\n    if (groupsWithUndefinedValueType.length || groupsWithUndefinedArgumentType.length) {\r\n        groupsIndexes = groupsWithUndefinedValueType.map(function(_, index) {\r\n            return index\r\n        });\r\n        data.some(function(cell) {\r\n            var defineArg;\r\n            groupsWithUndefinedValueType.forEach(function(group, groupIndex) {\r\n                if (checkValueTypeOfGroup(group, cell) && groupsIndexes.indexOf(groupIndex) >= 0) {\r\n                    groupsIndexes.splice(groupIndex, 1)\r\n                }\r\n            });\r\n            if (!defineArg) {\r\n                groupsWithUndefinedArgumentType.forEach(function(group) {\r\n                    defineArg = checkArgumentTypeOfGroup(group.series, cell, groupsData)\r\n                })\r\n            }\r\n            if (!checkTypeForAllData && defineArg && 0 === groupsIndexes.length) {\r\n                return true\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nfunction checkAxisType(groupsData, incidentOccurred) {\r\n    var argumentOptions = groupsData.argumentOptions || {};\r\n    var userArgumentCategories = argumentOptions && argumentOptions.categories || [];\r\n    var argumentAxisType = correctAxisType(groupsData.argumentType, argumentOptions.type, !!userArgumentCategories.length, incidentOccurred);\r\n    groupsData.groups.forEach(function(group) {\r\n        var valueOptions = group.valueOptions || {};\r\n        var valueCategories = valueOptions.categories || [];\r\n        var valueAxisType = correctAxisType(group.valueType, valueOptions.type, !!valueCategories.length, incidentOccurred);\r\n        group.series.forEach(function(series) {\r\n            var optionsSeries = {};\r\n            optionsSeries.argumentAxisType = argumentAxisType;\r\n            optionsSeries.valueAxisType = valueAxisType;\r\n            groupsData.argumentAxisType = groupsData.argumentAxisType || optionsSeries.argumentAxisType;\r\n            group.valueAxisType = group.valueAxisType || optionsSeries.valueAxisType;\r\n            optionsSeries.argumentType = groupsData.argumentType;\r\n            optionsSeries.valueType = group.valueType;\r\n            optionsSeries.showZero = valueOptions.showZero;\r\n            series.updateDataType(optionsSeries)\r\n        });\r\n        group.valueAxisType = group.valueAxisType || valueAxisType;\r\n        if (group.valueAxis) {\r\n            group.valueAxis.setTypes(group.valueAxisType, group.valueType, VALUE_TYPE);\r\n            group.valueAxis.validate()\r\n        }\r\n    });\r\n    groupsData.argumentAxisType = groupsData.argumentAxisType || argumentAxisType;\r\n    if (groupsData.argumentAxes) {\r\n        groupsData.argumentAxes.forEach(function(axis) {\r\n            axis.setTypes(groupsData.argumentAxisType, groupsData.argumentType, ARGUMENT_TYPE);\r\n            axis.validate()\r\n        })\r\n    }\r\n}\r\n\r\nfunction verifyData(source, incidentOccurred) {\r\n    var data = [];\r\n    var sourceIsDefined = _isDefined(source);\r\n    var hasError = sourceIsDefined && !_isArray(source);\r\n    var i;\r\n    var ii;\r\n    var k;\r\n    var item;\r\n    if (sourceIsDefined && !hasError) {\r\n        for (i = 0, ii = source.length, k = 0; i < ii; ++i) {\r\n            item = source[i];\r\n            if (_isObject(item)) {\r\n                data[k++] = item\r\n            } else {\r\n                if (item) {\r\n                    hasError = true\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (hasError) {\r\n        incidentOccurred(\"E2001\")\r\n    }\r\n    return data\r\n}\r\n\r\nfunction validateData(data, groupsData, incidentOccurred, options) {\r\n    var dataByArgumentFields;\r\n    data = verifyData(data, incidentOccurred);\r\n    groupsData.argumentType = groupsData.argumentAxisType = null;\r\n    processGroups(groupsData.groups);\r\n    resetArgumentAxes(groupsData.argumentAxes);\r\n    checkType(data, groupsData, options.checkTypeForAllData);\r\n    checkAxisType(groupsData, incidentOccurred);\r\n    if (options.convertToAxisDataType) {\r\n        data = parse(data, prepareParsers(groupsData, incidentOccurred))\r\n    }\r\n    groupPieData(data, groupsData);\r\n    dataByArgumentFields = sortData(data, groupsData, options, getUniqueArgumentFields(groupsData));\r\n    return dataByArgumentFields\r\n}\r\nexports.validateData = validateData;\r\n"]},"metadata":{},"sourceType":"module"}