{"ast":null,"code":"import _classCallCheck from \"C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { CdkTextareaAutosize, AutofillMonitor, TextFieldModule } from '@angular/cdk/text-field';\nimport { Directive, Input, InjectionToken, ElementRef, Optional, Self, Inject, NgZone, HostListener, NgModule } from '@angular/core';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { getSupportedInputTypes, Platform } from '@angular/cdk/platform';\nimport { NgControl, NgForm, FormGroupDirective } from '@angular/forms';\nimport { mixinErrorState, ErrorStateMatcher, MatCommonModule } from '@angular/material/core';\nimport { MatFormFieldControl, MatFormField, MAT_FORM_FIELD, MatFormFieldModule } from '@angular/material/form-field';\nimport { Subject } from 'rxjs';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Directive to automatically resize a textarea to fit its content.\n * @deprecated Use `cdkTextareaAutosize` from `@angular/cdk/text-field` instead.\n * @breaking-change 8.0.0\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/platform';\nimport * as ɵngcc2 from '@angular/forms';\nimport * as ɵngcc3 from '@angular/material/core';\nimport * as ɵngcc4 from '@angular/cdk/text-field';\nimport * as ɵngcc5 from '@angular/material/form-field';\n\nvar MatTextareaAutosize = /*#__PURE__*/function (_CdkTextareaAutosize) {\n  _inherits(MatTextareaAutosize, _CdkTextareaAutosize);\n\n  var _super = _createSuper(MatTextareaAutosize);\n\n  function MatTextareaAutosize() {\n    _classCallCheck(this, MatTextareaAutosize);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(MatTextareaAutosize, [{\n    key: \"matAutosizeMinRows\",\n    get: function get() {\n      return this.minRows;\n    },\n    set: function set(value) {\n      this.minRows = value;\n    }\n  }, {\n    key: \"matAutosizeMaxRows\",\n    get: function get() {\n      return this.maxRows;\n    },\n    set: function set(value) {\n      this.maxRows = value;\n    }\n  }, {\n    key: \"matAutosize\",\n    get: function get() {\n      return this.enabled;\n    },\n    set: function set(value) {\n      this.enabled = value;\n    }\n  }, {\n    key: \"matTextareaAutosize\",\n    get: function get() {\n      return this.enabled;\n    },\n    set: function set(value) {\n      this.enabled = value;\n    }\n  }]);\n\n  return MatTextareaAutosize;\n}(CdkTextareaAutosize);\n\nMatTextareaAutosize.ɵfac = function MatTextareaAutosize_Factory(t) {\n  return ɵMatTextareaAutosize_BaseFactory(t || MatTextareaAutosize);\n};\n\nMatTextareaAutosize.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: MatTextareaAutosize,\n  selectors: [[\"textarea\", \"mat-autosize\", \"\"], [\"textarea\", \"matTextareaAutosize\", \"\"]],\n  hostAttrs: [\"rows\", \"1\", 1, \"cdk-textarea-autosize\", \"mat-autosize\"],\n  inputs: {\n    cdkAutosizeMinRows: \"cdkAutosizeMinRows\",\n    cdkAutosizeMaxRows: \"cdkAutosizeMaxRows\",\n    matAutosizeMinRows: \"matAutosizeMinRows\",\n    matAutosizeMaxRows: \"matAutosizeMaxRows\",\n    matAutosize: [\"mat-autosize\", \"matAutosize\"],\n    matTextareaAutosize: \"matTextareaAutosize\"\n  },\n  exportAs: [\"matTextareaAutosize\"],\n  features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n});\nMatTextareaAutosize.propDecorators = {\n  matAutosizeMinRows: [{\n    type: Input\n  }],\n  matAutosizeMaxRows: [{\n    type: Input\n  }],\n  matAutosize: [{\n    type: Input,\n    args: ['mat-autosize']\n  }],\n  matTextareaAutosize: [{\n    type: Input\n  }]\n};\nvar ɵMatTextareaAutosize_BaseFactory = /*@__PURE__*/ɵngcc0.ɵɵgetInheritedFactory(MatTextareaAutosize);\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(MatTextareaAutosize, [{\n    type: Directive,\n    args: [{\n      selector: 'textarea[mat-autosize], textarea[matTextareaAutosize]',\n      exportAs: 'matTextareaAutosize',\n      inputs: ['cdkAutosizeMinRows', 'cdkAutosizeMaxRows'],\n      host: {\n        'class': 'cdk-textarea-autosize mat-autosize',\n        // Textarea elements that have the directive applied should have a single row by default.\n        // Browsers normally show two rows by default and therefore this limits the minRows binding.\n        'rows': '1'\n      }\n    }]\n  }], null, {\n    matAutosizeMinRows: [{\n      type: Input\n    }],\n    matAutosizeMaxRows: [{\n      type: Input\n    }],\n    matAutosize: [{\n      type: Input,\n      args: ['mat-autosize']\n    }],\n    matTextareaAutosize: [{\n      type: Input\n    }]\n  });\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** @docs-private */\n\n\nfunction getMatInputUnsupportedTypeError(type) {\n  return Error(\"Input type \\\"\".concat(type, \"\\\" isn't supported by matInput.\"));\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * This token is used to inject the object whose value should be set into `MatInput`. If none is\n * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\n * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\n * value to them.\n */\n\n\nvar MAT_INPUT_VALUE_ACCESSOR = new InjectionToken('MAT_INPUT_VALUE_ACCESSOR');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\n\nvar MAT_INPUT_INVALID_TYPES = ['button', 'checkbox', 'file', 'hidden', 'image', 'radio', 'range', 'reset', 'submit'];\nvar nextUniqueId = 0; // Boilerplate for applying mixins to MatInput.\n\n/** @docs-private */\n\nvar MatInputBase = function MatInputBase(_defaultErrorStateMatcher, _parentForm, _parentFormGroup,\n/** @docs-private */\nngControl) {\n  _classCallCheck(this, MatInputBase);\n\n  this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n  this._parentForm = _parentForm;\n  this._parentFormGroup = _parentFormGroup;\n  this.ngControl = ngControl;\n};\n\nvar _MatInputMixinBase = mixinErrorState(MatInputBase);\n/** Directive that allows a native input to work inside a `MatFormField`. */\n\n\nvar MatInput = /*#__PURE__*/function (_MatInputMixinBase2) {\n  _inherits(MatInput, _MatInputMixinBase2);\n\n  var _super2 = _createSuper(MatInput);\n\n  function MatInput(_elementRef, _platform,\n  /** @docs-private */\n  ngControl, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, inputValueAccessor, _autofillMonitor, ngZone, // TODO: Remove this once the legacy appearance has been removed. We only need\n  // to inject the form-field for determining whether the placeholder has been promoted.\n  _formField) {\n    var _this;\n\n    _classCallCheck(this, MatInput);\n\n    _this = _super2.call(this, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n    _this._elementRef = _elementRef;\n    _this._platform = _platform;\n    _this.ngControl = ngControl;\n    _this._autofillMonitor = _autofillMonitor;\n    _this._formField = _formField;\n    _this._uid = \"mat-input-\".concat(nextUniqueId++);\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n\n    _this.focused = false;\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n\n    _this.stateChanges = new Subject();\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n\n    _this.controlType = 'mat-input';\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n\n    _this.autofilled = false;\n    _this._disabled = false;\n    _this._required = false;\n    _this._type = 'text';\n    _this._readonly = false;\n    _this._neverEmptyInputTypes = ['date', 'datetime', 'datetime-local', 'month', 'time', 'week'].filter(function (t) {\n      return getSupportedInputTypes().has(t);\n    });\n    var element = _this._elementRef.nativeElement;\n    var nodeName = element.nodeName.toLowerCase(); // If no input value accessor was explicitly specified, use the element as the input value\n    // accessor.\n\n    _this._inputValueAccessor = inputValueAccessor || element;\n    _this._previousNativeValue = _this.value; // Force setter to be called in case id was not specified.\n\n    _this.id = _this.id; // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n    // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n    // exists on iOS, we only bother to install the listener on iOS.\n\n    if (_platform.IOS) {\n      ngZone.runOutsideAngular(function () {\n        _elementRef.nativeElement.addEventListener('keyup', function (event) {\n          var el = event.target;\n\n          if (!el.value && !el.selectionStart && !el.selectionEnd) {\n            // Note: Just setting `0, 0` doesn't fix the issue. Setting\n            // `1, 1` fixes it for the first time that you type text and\n            // then hold delete. Toggling to `1, 1` and then back to\n            // `0, 0` seems to completely fix it.\n            el.setSelectionRange(1, 1);\n            el.setSelectionRange(0, 0);\n          }\n        });\n      });\n    }\n\n    _this._isServer = !_this._platform.isBrowser;\n    _this._isNativeSelect = nodeName === 'select';\n    _this._isTextarea = nodeName === 'textarea';\n\n    if (_this._isNativeSelect) {\n      _this.controlType = element.multiple ? 'mat-native-select-multiple' : 'mat-native-select';\n    }\n\n    return _this;\n  }\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n\n\n  _createClass(MatInput, [{\n    key: \"ngAfterViewInit\",\n    value: function ngAfterViewInit() {\n      var _this2 = this;\n\n      if (this._platform.isBrowser) {\n        this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(function (event) {\n          _this2.autofilled = event.isAutofilled;\n\n          _this2.stateChanges.next();\n        });\n      }\n    }\n  }, {\n    key: \"ngOnChanges\",\n    value: function ngOnChanges() {\n      this.stateChanges.next();\n    }\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.stateChanges.complete();\n\n      if (this._platform.isBrowser) {\n        this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n      }\n    }\n  }, {\n    key: \"ngDoCheck\",\n    value: function ngDoCheck() {\n      if (this.ngControl) {\n        // We need to re-evaluate this on every change detection cycle, because there are some\n        // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n        // that whatever logic is in here has to be super lean or we risk destroying the performance.\n        this.updateErrorState();\n      } // We need to dirty-check the native element's value, because there are some cases where\n      // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n      // updating the value using `emitEvent: false`).\n\n\n      this._dirtyCheckNativeValue(); // We need to dirty-check and set the placeholder attribute ourselves, because whether it's\n      // present or not depends on a query which is prone to \"changed after checked\" errors.\n\n\n      this._dirtyCheckPlaceholder();\n    }\n    /** Focuses the input. */\n\n  }, {\n    key: \"focus\",\n    value: function focus(options) {\n      this._elementRef.nativeElement.focus(options);\n    } // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\n    // ViewEngine they're overwritten.\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\n\n    /** Callback for the cases where the focused state of the input changes. */\n    // tslint:disable:no-host-decorator-in-concrete\n    // tslint:enable:no-host-decorator-in-concrete\n\n  }, {\n    key: \"_focusChanged\",\n    value: function _focusChanged(isFocused) {\n      if (isFocused !== this.focused && (!this.readonly || !isFocused)) {\n        this.focused = isFocused;\n        this.stateChanges.next();\n      }\n    } // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\n    // ViewEngine they're overwritten.\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\n    // tslint:disable-next-line:no-host-decorator-in-concrete\n\n  }, {\n    key: \"_onInput\",\n    value: function _onInput() {// This is a noop function and is used to let Angular know whenever the value changes.\n      // Angular will run a new change detection each time the `input` event has been dispatched.\n      // It's necessary that Angular recognizes the value change, because when floatingLabel\n      // is set to false and Angular forms aren't used, the placeholder won't recognize the\n      // value changes and will not disappear.\n      // Listening to the input event wouldn't be necessary when the input is using the\n      // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n    }\n    /** Does some manual dirty checking on the native input `placeholder` attribute. */\n\n  }, {\n    key: \"_dirtyCheckPlaceholder\",\n    value: function _dirtyCheckPlaceholder() {\n      var _a, _b; // If we're hiding the native placeholder, it should also be cleared from the DOM, otherwise\n      // screen readers will read it out twice: once from the label and once from the attribute.\n      // TODO: can be removed once we get rid of the `legacy` style for the form field, because it's\n      // the only one that supports promoting the placeholder to a label.\n\n\n      var placeholder = ((_b = (_a = this._formField) === null || _a === void 0 ? void 0 : _a._hideControlPlaceholder) === null || _b === void 0 ? void 0 : _b.call(_a)) ? null : this.placeholder;\n\n      if (placeholder !== this._previousPlaceholder) {\n        var element = this._elementRef.nativeElement;\n        this._previousPlaceholder = placeholder;\n        placeholder ? element.setAttribute('placeholder', placeholder) : element.removeAttribute('placeholder');\n      }\n    }\n    /** Does some manual dirty checking on the native input `value` property. */\n\n  }, {\n    key: \"_dirtyCheckNativeValue\",\n    value: function _dirtyCheckNativeValue() {\n      var newValue = this._elementRef.nativeElement.value;\n\n      if (this._previousNativeValue !== newValue) {\n        this._previousNativeValue = newValue;\n        this.stateChanges.next();\n      }\n    }\n    /** Make sure the input is a supported type. */\n\n  }, {\n    key: \"_validateType\",\n    value: function _validateType() {\n      if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1 && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw getMatInputUnsupportedTypeError(this._type);\n      }\n    }\n    /** Checks whether the input type is one of the types that are never empty. */\n\n  }, {\n    key: \"_isNeverEmpty\",\n    value: function _isNeverEmpty() {\n      return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n    }\n    /** Checks whether the input is invalid based on the native validation. */\n\n  }, {\n    key: \"_isBadInput\",\n    value: function _isBadInput() {\n      // The `validity` property won't be present on platform-server.\n      var validity = this._elementRef.nativeElement.validity;\n      return validity && validity.badInput;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n\n  }, {\n    key: \"setDescribedByIds\",\n\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n    value: function setDescribedByIds(ids) {\n      if (ids.length) {\n        this._elementRef.nativeElement.setAttribute('aria-describedby', ids.join(' '));\n      } else {\n        this._elementRef.nativeElement.removeAttribute('aria-describedby');\n      }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n\n  }, {\n    key: \"onContainerClick\",\n    value: function onContainerClick() {\n      // Do not re-focus the input element if the element is already focused. Otherwise it can happen\n      // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\n      // \"minutes\" field was actually clicked. See: https://github.com/angular/components/issues/12849\n      if (!this.focused) {\n        this.focus();\n      }\n    }\n  }, {\n    key: \"disabled\",\n    get: function get() {\n      if (this.ngControl && this.ngControl.disabled !== null) {\n        return this.ngControl.disabled;\n      }\n\n      return this._disabled;\n    },\n    set: function set(value) {\n      this._disabled = coerceBooleanProperty(value); // Browsers may not fire the blur event if the input is disabled too quickly.\n      // Reset from here to ensure that the element doesn't become stuck.\n\n      if (this.focused) {\n        this.focused = false;\n        this.stateChanges.next();\n      }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    },\n    set: function set(value) {\n      this._id = value || this._uid;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n\n  }, {\n    key: \"required\",\n    get: function get() {\n      return this._required;\n    },\n    set: function set(value) {\n      this._required = coerceBooleanProperty(value);\n    }\n    /** Input type of the element. */\n\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    },\n    set: function set(value) {\n      this._type = value || 'text';\n\n      this._validateType(); // When using Angular inputs, developers are no longer able to set the properties on the native\n      // input element. To ensure that bindings for `type` work, we need to sync the setter\n      // with the native property. Textarea elements don't support the type property or attribute.\n\n\n      if (!this._isTextarea && getSupportedInputTypes().has(this._type)) {\n        this._elementRef.nativeElement.type = this._type;\n      }\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this._inputValueAccessor.value;\n    },\n    set: function set(value) {\n      if (value !== this.value) {\n        this._inputValueAccessor.value = value;\n        this.stateChanges.next();\n      }\n    }\n    /** Whether the element is readonly. */\n\n  }, {\n    key: \"readonly\",\n    get: function get() {\n      return this._readonly;\n    },\n    set: function set(value) {\n      this._readonly = coerceBooleanProperty(value);\n    }\n  }, {\n    key: \"empty\",\n    get: function get() {\n      return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() && !this.autofilled;\n    }\n    /**\n     * Implemented as part of MatFormFieldControl.\n     * @docs-private\n     */\n\n  }, {\n    key: \"shouldLabelFloat\",\n    get: function get() {\n      if (this._isNativeSelect) {\n        // For a single-selection `<select>`, the label should float when the selected option has\n        // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid\n        // overlapping the label with the options.\n        var selectElement = this._elementRef.nativeElement;\n        var firstOption = selectElement.options[0]; // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be\n        // -1 if the `value` is set to something, that isn't in the list of options, at a later point.\n\n        return this.focused || selectElement.multiple || !this.empty || !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label);\n      } else {\n        return this.focused || !this.empty;\n      }\n    }\n  }]);\n\n  return MatInput;\n}(_MatInputMixinBase);\n\nMatInput.ɵfac = function MatInput_Factory(t) {\n  return new (t || MatInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgControl, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.NgForm, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.FormGroupDirective, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.ErrorStateMatcher), ɵngcc0.ɵɵdirectiveInject(MAT_INPUT_VALUE_ACCESSOR, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.AutofillMonitor), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MAT_FORM_FIELD, 8));\n};\n\nMatInput.ɵdir = ɵngcc0.ɵɵdefineDirective({\n  type: MatInput,\n  selectors: [[\"input\", \"matInput\", \"\"], [\"textarea\", \"matInput\", \"\"], [\"select\", \"matNativeControl\", \"\"], [\"input\", \"matNativeControl\", \"\"], [\"textarea\", \"matNativeControl\", \"\"]],\n  hostAttrs: [1, \"mat-input-element\", \"mat-form-field-autofill-control\"],\n  hostVars: 9,\n  hostBindings: function MatInput_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"focus\", function MatInput_focus_HostBindingHandler() {\n        return ctx._focusChanged(true);\n      })(\"blur\", function MatInput_blur_HostBindingHandler() {\n        return ctx._focusChanged(false);\n      })(\"input\", function MatInput_input_HostBindingHandler() {\n        return ctx._onInput();\n      });\n    }\n\n    if (rf & 2) {\n      ɵngcc0.ɵɵhostProperty(\"disabled\", ctx.disabled)(\"required\", ctx.required);\n      ɵngcc0.ɵɵattribute(\"id\", ctx.id)(\"data-placeholder\", ctx.placeholder)(\"readonly\", ctx.readonly && !ctx._isNativeSelect || null)(\"aria-invalid\", ctx.errorState && !ctx.empty)(\"aria-required\", ctx.required);\n      ɵngcc0.ɵɵclassProp(\"mat-input-server\", ctx._isServer);\n    }\n  },\n  inputs: {\n    id: \"id\",\n    disabled: \"disabled\",\n    required: \"required\",\n    type: \"type\",\n    value: \"value\",\n    readonly: \"readonly\",\n    placeholder: \"placeholder\",\n    errorStateMatcher: \"errorStateMatcher\",\n    userAriaDescribedBy: [\"aria-describedby\", \"userAriaDescribedBy\"]\n  },\n  exportAs: [\"matInput\"],\n  features: [ɵngcc0.ɵɵProvidersFeature([{\n    provide: MatFormFieldControl,\n    useExisting: MatInput\n  }]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature]\n});\n\nMatInput.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: Platform\n  }, {\n    type: NgControl,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }]\n  }, {\n    type: NgForm,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: FormGroupDirective,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: ErrorStateMatcher\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [MAT_INPUT_VALUE_ACCESSOR]\n    }]\n  }, {\n    type: AutofillMonitor\n  }, {\n    type: NgZone\n  }, {\n    type: MatFormField,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [MAT_FORM_FIELD]\n    }]\n  }];\n};\n\nMatInput.propDecorators = {\n  disabled: [{\n    type: Input\n  }],\n  id: [{\n    type: Input\n  }],\n  placeholder: [{\n    type: Input\n  }],\n  required: [{\n    type: Input\n  }],\n  type: [{\n    type: Input\n  }],\n  errorStateMatcher: [{\n    type: Input\n  }],\n  userAriaDescribedBy: [{\n    type: Input,\n    args: ['aria-describedby']\n  }],\n  value: [{\n    type: Input\n  }],\n  readonly: [{\n    type: Input\n  }],\n  _focusChanged: [{\n    type: HostListener,\n    args: ['focus', ['true']]\n  }, {\n    type: HostListener,\n    args: ['blur', ['false']]\n  }],\n  _onInput: [{\n    type: HostListener,\n    args: ['input']\n  }]\n};\n/*@__PURE__*/\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(MatInput, [{\n    type: Directive,\n    args: [{\n      selector: \"input[matInput], textarea[matInput], select[matNativeControl],\\n      input[matNativeControl], textarea[matNativeControl]\",\n      exportAs: 'matInput',\n      host: {\n        /**\n         * @breaking-change 8.0.0 remove .mat-form-field-autofill-control in favor of AutofillMonitor.\n         */\n        'class': 'mat-input-element mat-form-field-autofill-control',\n        '[class.mat-input-server]': '_isServer',\n        // Native input properties that are overwritten by Angular inputs need to be synced with\n        // the native input element. Otherwise property bindings for those don't work.\n        '[attr.id]': 'id',\n        // At the time of writing, we have a lot of customer tests that look up the input based on its\n        // placeholder. Since we sometimes omit the placeholder attribute from the DOM to prevent screen\n        // readers from reading it twice, we have to keep it somewhere in the DOM for the lookup.\n        '[attr.data-placeholder]': 'placeholder',\n        '[disabled]': 'disabled',\n        '[required]': 'required',\n        '[attr.readonly]': 'readonly && !_isNativeSelect || null',\n        // Only mark the input as invalid for assistive technology if it has a value since the\n        // state usually overlaps with `aria-required` when the input is empty and can be redundant.\n        '[attr.aria-invalid]': 'errorState && !empty',\n        '[attr.aria-required]': 'required'\n      },\n      providers: [{\n        provide: MatFormFieldControl,\n        useExisting: MatInput\n      }]\n    }]\n  }], function () {\n    return [{\n      type: ɵngcc0.ElementRef\n    }, {\n      type: ɵngcc1.Platform\n    }, {\n      type: ɵngcc2.NgControl,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Self\n      }]\n    }, {\n      type: ɵngcc2.NgForm,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: ɵngcc2.FormGroupDirective,\n      decorators: [{\n        type: Optional\n      }]\n    }, {\n      type: ɵngcc3.ErrorStateMatcher\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Self\n      }, {\n        type: Inject,\n        args: [MAT_INPUT_VALUE_ACCESSOR]\n      }]\n    }, {\n      type: ɵngcc4.AutofillMonitor\n    }, {\n      type: ɵngcc0.NgZone\n    }, {\n      type: ɵngcc5.MatFormField,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [MAT_FORM_FIELD]\n      }]\n    }];\n  }, {\n    id: [{\n      type: Input\n    }],\n    disabled: [{\n      type: Input\n    }],\n    required: [{\n      type: Input\n    }],\n    type: [{\n      type: Input\n    }],\n    value: [{\n      type: Input\n    }],\n    readonly: [{\n      type: Input\n    }],\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\n    // ViewEngine they're overwritten.\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\n\n    /** Callback for the cases where the focused state of the input changes. */\n    // tslint:disable:no-host-decorator-in-concrete\n    // tslint:enable:no-host-decorator-in-concrete\n    _focusChanged: [{\n      type: HostListener,\n      args: ['focus', ['true']]\n    }, {\n      type: HostListener,\n      args: ['blur', ['false']]\n    }],\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\n    // ViewEngine they're overwritten.\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\n    // tslint:disable-next-line:no-host-decorator-in-concrete\n    _onInput: [{\n      type: HostListener,\n      args: ['input']\n    }],\n    placeholder: [{\n      type: Input\n    }],\n    errorStateMatcher: [{\n      type: Input\n    }],\n    userAriaDescribedBy: [{\n      type: Input,\n      args: ['aria-describedby']\n    }]\n  });\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar MatInputModule = function MatInputModule() {\n  _classCallCheck(this, MatInputModule);\n};\n\nMatInputModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: MatInputModule\n});\nMatInputModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n  factory: function MatInputModule_Factory(t) {\n    return new (t || MatInputModule)();\n  },\n  providers: [ErrorStateMatcher],\n  imports: [[TextFieldModule, MatFormFieldModule, MatCommonModule], TextFieldModule, // We re-export the `MatFormFieldModule` since `MatInput` will almost always\n  // be used together with `MatFormField`.\n  MatFormFieldModule]\n});\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatInputModule, {\n    declarations: function declarations() {\n      return [MatInput, MatTextareaAutosize];\n    },\n    imports: function imports() {\n      return [TextFieldModule, MatFormFieldModule, MatCommonModule];\n    },\n    exports: function exports() {\n      return [TextFieldModule, // We re-export the `MatFormFieldModule` since `MatInput` will almost always\n      // be used together with `MatFormField`.\n      MatFormFieldModule, MatInput, MatTextareaAutosize];\n    }\n  });\n})();\n/*@__PURE__*/\n\n\n(function () {\n  ɵngcc0.ɵsetClassMetadata(MatInputModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [MatInput, MatTextareaAutosize],\n      imports: [TextFieldModule, MatFormFieldModule, MatCommonModule],\n      exports: [TextFieldModule, // We re-export the `MatFormFieldModule` since `MatInput` will almost always\n      // be used together with `MatFormField`.\n      MatFormFieldModule, MatInput, MatTextareaAutosize],\n      providers: [ErrorStateMatcher]\n    }]\n  }], null, null);\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { MAT_INPUT_VALUE_ACCESSOR, MatInput, MatInputModule, MatTextareaAutosize, getMatInputUnsupportedTypeError };","map":{"version":3,"sources":["../../../../../../src/material/input/autosize.ts","../../../../../../src/material/input/input-errors.ts","../../../../../../src/material/input/input-value-accessor.ts","../../../../../../src/material/input/input.ts","../../../../../../src/material/input/input-module.ts","../../../../../../src/material/input/public-api.ts","../../../../../../src/material/input/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CdkTextareaAutosize} from '@angular/cdk/text-field';\nimport {Directive, Input} from '@angular/core';\n\n/**\n * Directive to automatically resize a textarea to fit its content.\n * @deprecated Use `cdkTextareaAutosize` from `@angular/cdk/text-field` instead.\n * @breaking-change 8.0.0\n */\n@Directive({\n  selector: 'textarea[mat-autosize], textarea[matTextareaAutosize]',\n  exportAs: 'matTextareaAutosize',\n  inputs: ['cdkAutosizeMinRows', 'cdkAutosizeMaxRows'],\n  host: {\n    'class': 'cdk-textarea-autosize mat-autosize',\n    // Textarea elements that have the directive applied should have a single row by default.\n    // Browsers normally show two rows by default and therefore this limits the minRows binding.\n    'rows': '1',\n  },\n})\nexport class MatTextareaAutosize extends CdkTextareaAutosize {\n  @Input()\n  get matAutosizeMinRows(): number { return this.minRows; }\n  set matAutosizeMinRows(value: number) { this.minRows = value; }\n\n  @Input()\n  get matAutosizeMaxRows(): number { return this.maxRows; }\n  set matAutosizeMaxRows(value: number) { this.maxRows = value; }\n\n  @Input('mat-autosize')\n  get matAutosize(): boolean { return this.enabled; }\n  set matAutosize(value: boolean) { this.enabled = value; }\n\n  @Input()\n  get matTextareaAutosize(): boolean { return this.enabled; }\n  set matTextareaAutosize(value: boolean) { this.enabled = value; }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** @docs-private */\nexport function getMatInputUnsupportedTypeError(type: string): Error {\n  return Error(`Input type \"${type}\" isn't supported by matInput.`);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '@angular/core';\n\n\n/**\n * This token is used to inject the object whose value should be set into `MatInput`. If none is\n * provided, the native `HTMLInputElement` is used. Directives like `MatDatepickerInput` can provide\n * themselves for this token, in order to make `MatInput` delegate the getting and setting of the\n * value to them.\n */\nexport const MAT_INPUT_VALUE_ACCESSOR =\n    new InjectionToken<{value: any}>('MAT_INPUT_VALUE_ACCESSOR');\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BooleanInput, coerceBooleanProperty} from '@angular/cdk/coercion';\nimport {getSupportedInputTypes, Platform} from '@angular/cdk/platform';\nimport {AutofillMonitor} from '@angular/cdk/text-field';\nimport {\n  AfterViewInit,\n  Directive,\n  DoCheck,\n  ElementRef,\n  HostListener,\n  Inject,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  Optional,\n  Self,\n} from '@angular/core';\nimport {FormGroupDirective, NgControl, NgForm} from '@angular/forms';\nimport {\n  CanUpdateErrorState,\n  CanUpdateErrorStateCtor,\n  ErrorStateMatcher,\n  mixinErrorState,\n} from '@angular/material/core';\nimport {MatFormFieldControl, MatFormField, MAT_FORM_FIELD} from '@angular/material/form-field';\nimport {Subject} from 'rxjs';\nimport {getMatInputUnsupportedTypeError} from './input-errors';\nimport {MAT_INPUT_VALUE_ACCESSOR} from './input-value-accessor';\n\n\n// Invalid input type. Using one of these will throw an MatInputUnsupportedTypeError.\nconst MAT_INPUT_INVALID_TYPES = [\n  'button',\n  'checkbox',\n  'file',\n  'hidden',\n  'image',\n  'radio',\n  'range',\n  'reset',\n  'submit'\n];\n\nlet nextUniqueId = 0;\n\n// Boilerplate for applying mixins to MatInput.\n/** @docs-private */\nclass MatInputBase {\n  constructor(public _defaultErrorStateMatcher: ErrorStateMatcher,\n              public _parentForm: NgForm,\n              public _parentFormGroup: FormGroupDirective,\n              /** @docs-private */\n              public ngControl: NgControl) {}\n}\nconst _MatInputMixinBase: CanUpdateErrorStateCtor & typeof MatInputBase =\n    mixinErrorState(MatInputBase);\n\n/** Directive that allows a native input to work inside a `MatFormField`. */\n@Directive({\n  selector: `input[matInput], textarea[matInput], select[matNativeControl],\n      input[matNativeControl], textarea[matNativeControl]`,\n  exportAs: 'matInput',\n  host: {\n    /**\n     * @breaking-change 8.0.0 remove .mat-form-field-autofill-control in favor of AutofillMonitor.\n     */\n    'class': 'mat-input-element mat-form-field-autofill-control',\n    '[class.mat-input-server]': '_isServer',\n    // Native input properties that are overwritten by Angular inputs need to be synced with\n    // the native input element. Otherwise property bindings for those don't work.\n    '[attr.id]': 'id',\n    // At the time of writing, we have a lot of customer tests that look up the input based on its\n    // placeholder. Since we sometimes omit the placeholder attribute from the DOM to prevent screen\n    // readers from reading it twice, we have to keep it somewhere in the DOM for the lookup.\n    '[attr.data-placeholder]': 'placeholder',\n    '[disabled]': 'disabled',\n    '[required]': 'required',\n    '[attr.readonly]': 'readonly && !_isNativeSelect || null',\n    // Only mark the input as invalid for assistive technology if it has a value since the\n    // state usually overlaps with `aria-required` when the input is empty and can be redundant.\n    '[attr.aria-invalid]': 'errorState && !empty',\n    '[attr.aria-required]': 'required',\n  },\n  providers: [{provide: MatFormFieldControl, useExisting: MatInput}],\n})\nexport class MatInput extends _MatInputMixinBase implements MatFormFieldControl<any>, OnChanges,\n    OnDestroy, AfterViewInit, DoCheck, CanUpdateErrorState {\n  protected _uid = `mat-input-${nextUniqueId++}`;\n  protected _previousNativeValue: any;\n  private _inputValueAccessor: {value: any};\n  private _previousPlaceholder: string | null;\n\n  /** Whether the component is being rendered on the server. */\n  readonly _isServer: boolean;\n\n  /** Whether the component is a native html select. */\n  readonly _isNativeSelect: boolean;\n\n  /** Whether the component is a textarea. */\n  readonly _isTextarea: boolean;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  focused: boolean = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  readonly stateChanges: Subject<void> = new Subject<void>();\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  controlType: string = 'mat-input';\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  autofilled = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get disabled(): boolean {\n    if (this.ngControl && this.ngControl.disabled !== null) {\n      return this.ngControl.disabled;\n    }\n    return this._disabled;\n  }\n  set disabled(value: boolean) {\n    this._disabled = coerceBooleanProperty(value);\n\n    // Browsers may not fire the blur event if the input is disabled too quickly.\n    // Reset from here to ensure that the element doesn't become stuck.\n    if (this.focused) {\n      this.focused = false;\n      this.stateChanges.next();\n    }\n  }\n  protected _disabled = false;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get id(): string { return this._id; }\n  set id(value: string) { this._id = value || this._uid; }\n  protected _id: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input() placeholder: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get required(): boolean { return this._required; }\n  set required(value: boolean) { this._required = coerceBooleanProperty(value); }\n  protected _required = false;\n\n  /** Input type of the element. */\n  @Input()\n  get type(): string { return this._type; }\n  set type(value: string) {\n    this._type = value || 'text';\n    this._validateType();\n\n    // When using Angular inputs, developers are no longer able to set the properties on the native\n    // input element. To ensure that bindings for `type` work, we need to sync the setter\n    // with the native property. Textarea elements don't support the type property or attribute.\n    if (!this._isTextarea && getSupportedInputTypes().has(this._type)) {\n      (this._elementRef.nativeElement as HTMLInputElement).type = this._type;\n    }\n  }\n  protected _type = 'text';\n\n  /** An object used to control when error messages are shown. */\n  @Input() errorStateMatcher: ErrorStateMatcher;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input('aria-describedby') userAriaDescribedBy: string;\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  @Input()\n  get value(): string { return this._inputValueAccessor.value; }\n  set value(value: string) {\n    if (value !== this.value) {\n      this._inputValueAccessor.value = value;\n      this.stateChanges.next();\n    }\n  }\n\n  /** Whether the element is readonly. */\n  @Input()\n  get readonly(): boolean { return this._readonly; }\n  set readonly(value: boolean) { this._readonly = coerceBooleanProperty(value); }\n  private _readonly = false;\n\n  protected _neverEmptyInputTypes = [\n    'date',\n    'datetime',\n    'datetime-local',\n    'month',\n    'time',\n    'week'\n  ].filter(t => getSupportedInputTypes().has(t));\n\n  constructor(\n      protected _elementRef: ElementRef<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>,\n      protected _platform: Platform,\n      /** @docs-private */\n      @Optional() @Self() public ngControl: NgControl,\n      @Optional() _parentForm: NgForm,\n      @Optional() _parentFormGroup: FormGroupDirective,\n      _defaultErrorStateMatcher: ErrorStateMatcher,\n      @Optional() @Self() @Inject(MAT_INPUT_VALUE_ACCESSOR) inputValueAccessor: any,\n      private _autofillMonitor: AutofillMonitor,\n      ngZone: NgZone,\n      // TODO: Remove this once the legacy appearance has been removed. We only need\n      // to inject the form-field for determining whether the placeholder has been promoted.\n      @Optional() @Inject(MAT_FORM_FIELD) private _formField?: MatFormField) {\n\n    super(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n\n    const element = this._elementRef.nativeElement;\n    const nodeName = element.nodeName.toLowerCase();\n\n    // If no input value accessor was explicitly specified, use the element as the input value\n    // accessor.\n    this._inputValueAccessor = inputValueAccessor || element;\n\n    this._previousNativeValue = this.value;\n\n    // Force setter to be called in case id was not specified.\n    this.id = this.id;\n\n    // On some versions of iOS the caret gets stuck in the wrong place when holding down the delete\n    // key. In order to get around this we need to \"jiggle\" the caret loose. Since this bug only\n    // exists on iOS, we only bother to install the listener on iOS.\n    if (_platform.IOS) {\n      ngZone.runOutsideAngular(() => {\n        _elementRef.nativeElement.addEventListener('keyup', (event: Event) => {\n          let el = event.target as HTMLInputElement;\n          if (!el.value && !el.selectionStart && !el.selectionEnd) {\n            // Note: Just setting `0, 0` doesn't fix the issue. Setting\n            // `1, 1` fixes it for the first time that you type text and\n            // then hold delete. Toggling to `1, 1` and then back to\n            // `0, 0` seems to completely fix it.\n            el.setSelectionRange(1, 1);\n            el.setSelectionRange(0, 0);\n          }\n        });\n      });\n    }\n\n    this._isServer = !this._platform.isBrowser;\n    this._isNativeSelect = nodeName === 'select';\n    this._isTextarea = nodeName === 'textarea';\n\n    if (this._isNativeSelect) {\n      this.controlType = (element as HTMLSelectElement).multiple ? 'mat-native-select-multiple' :\n                                                                   'mat-native-select';\n    }\n  }\n\n  ngAfterViewInit() {\n    if (this._platform.isBrowser) {\n      this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(event => {\n        this.autofilled = event.isAutofilled;\n        this.stateChanges.next();\n      });\n    }\n  }\n\n  ngOnChanges() {\n    this.stateChanges.next();\n  }\n\n  ngOnDestroy() {\n    this.stateChanges.complete();\n\n    if (this._platform.isBrowser) {\n      this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);\n    }\n  }\n\n  ngDoCheck() {\n    if (this.ngControl) {\n      // We need to re-evaluate this on every change detection cycle, because there are some\n      // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n      // that whatever logic is in here has to be super lean or we risk destroying the performance.\n      this.updateErrorState();\n    }\n\n    // We need to dirty-check the native element's value, because there are some cases where\n    // we won't be notified when it changes (e.g. the consumer isn't using forms or they're\n    // updating the value using `emitEvent: false`).\n    this._dirtyCheckNativeValue();\n\n    // We need to dirty-check and set the placeholder attribute ourselves, because whether it's\n    // present or not depends on a query which is prone to \"changed after checked\" errors.\n    this._dirtyCheckPlaceholder();\n  }\n\n  /** Focuses the input. */\n  focus(options?: FocusOptions): void {\n    this._elementRef.nativeElement.focus(options);\n  }\n\n  // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\n  // In Ivy the `host` bindings will be merged when this class is extended, whereas in\n  // ViewEngine they're overwritten.\n  // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\n  /** Callback for the cases where the focused state of the input changes. */\n  // tslint:disable:no-host-decorator-in-concrete\n  @HostListener('focus', ['true'])\n  @HostListener('blur', ['false'])\n  // tslint:enable:no-host-decorator-in-concrete\n  _focusChanged(isFocused: boolean) {\n    if (isFocused !== this.focused && (!this.readonly || !isFocused)) {\n      this.focused = isFocused;\n      this.stateChanges.next();\n    }\n  }\n\n  // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\n  // In Ivy the `host` bindings will be merged when this class is extended, whereas in\n  // ViewEngine they're overwritten.\n  // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\n  // tslint:disable-next-line:no-host-decorator-in-concrete\n  @HostListener('input')\n  _onInput() {\n    // This is a noop function and is used to let Angular know whenever the value changes.\n    // Angular will run a new change detection each time the `input` event has been dispatched.\n    // It's necessary that Angular recognizes the value change, because when floatingLabel\n    // is set to false and Angular forms aren't used, the placeholder won't recognize the\n    // value changes and will not disappear.\n    // Listening to the input event wouldn't be necessary when the input is using the\n    // FormsModule or ReactiveFormsModule, because Angular forms also listens to input events.\n  }\n\n  /** Does some manual dirty checking on the native input `placeholder` attribute. */\n  private _dirtyCheckPlaceholder() {\n    // If we're hiding the native placeholder, it should also be cleared from the DOM, otherwise\n    // screen readers will read it out twice: once from the label and once from the attribute.\n    // TODO: can be removed once we get rid of the `legacy` style for the form field, because it's\n    // the only one that supports promoting the placeholder to a label.\n    const placeholder = this._formField?._hideControlPlaceholder?.() ? null : this.placeholder;\n    if (placeholder !== this._previousPlaceholder) {\n      const element = this._elementRef.nativeElement;\n      this._previousPlaceholder = placeholder;\n      placeholder ?\n          element.setAttribute('placeholder', placeholder) : element.removeAttribute('placeholder');\n    }\n  }\n\n  /** Does some manual dirty checking on the native input `value` property. */\n  protected _dirtyCheckNativeValue() {\n    const newValue = this._elementRef.nativeElement.value;\n\n    if (this._previousNativeValue !== newValue) {\n      this._previousNativeValue = newValue;\n      this.stateChanges.next();\n    }\n  }\n\n  /** Make sure the input is a supported type. */\n  protected _validateType() {\n    if (MAT_INPUT_INVALID_TYPES.indexOf(this._type) > -1 &&\n      (typeof ngDevMode === 'undefined' || ngDevMode)) {\n      throw getMatInputUnsupportedTypeError(this._type);\n    }\n  }\n\n  /** Checks whether the input type is one of the types that are never empty. */\n  protected _isNeverEmpty() {\n    return this._neverEmptyInputTypes.indexOf(this._type) > -1;\n  }\n\n  /** Checks whether the input is invalid based on the native validation. */\n  protected _isBadInput() {\n    // The `validity` property won't be present on platform-server.\n    let validity = (this._elementRef.nativeElement as HTMLInputElement).validity;\n    return validity && validity.badInput;\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get empty(): boolean {\n    return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() &&\n        !this.autofilled;\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  get shouldLabelFloat(): boolean {\n    if (this._isNativeSelect) {\n      // For a single-selection `<select>`, the label should float when the selected option has\n      // a non-empty display value. For a `<select multiple>`, the label *always* floats to avoid\n      // overlapping the label with the options.\n      const selectElement = this._elementRef.nativeElement as HTMLSelectElement;\n      const firstOption: HTMLOptionElement | undefined = selectElement.options[0];\n\n      // On most browsers the `selectedIndex` will always be 0, however on IE and Edge it'll be\n      // -1 if the `value` is set to something, that isn't in the list of options, at a later point.\n      return this.focused || selectElement.multiple || !this.empty ||\n             !!(selectElement.selectedIndex > -1 && firstOption && firstOption.label);\n    } else {\n      return this.focused || !this.empty;\n    }\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  setDescribedByIds(ids: string[]) {\n    if (ids.length) {\n      this._elementRef.nativeElement.setAttribute('aria-describedby', ids.join(' '));\n    } else {\n      this._elementRef.nativeElement.removeAttribute('aria-describedby');\n    }\n  }\n\n  /**\n   * Implemented as part of MatFormFieldControl.\n   * @docs-private\n   */\n  onContainerClick() {\n    // Do not re-focus the input element if the element is already focused. Otherwise it can happen\n    // that someone clicks on a time input and the cursor resets to the \"hours\" field while the\n    // \"minutes\" field was actually clicked. See: https://github.com/angular/components/issues/12849\n    if (!this.focused) {\n      this.focus();\n    }\n  }\n\n  static ngAcceptInputType_disabled: BooleanInput;\n  static ngAcceptInputType_readonly: BooleanInput;\n  static ngAcceptInputType_required: BooleanInput;\n\n  // Accept `any` to avoid conflicts with other directives on `<input>` that may\n  // accept different types.\n  static ngAcceptInputType_value: any;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {TextFieldModule} from '@angular/cdk/text-field';\nimport {NgModule} from '@angular/core';\nimport {ErrorStateMatcher, MatCommonModule} from '@angular/material/core';\nimport {MatFormFieldModule} from '@angular/material/form-field';\nimport {MatTextareaAutosize} from './autosize';\nimport {MatInput} from './input';\n\n@NgModule({\n  declarations: [MatInput, MatTextareaAutosize],\n  imports: [\n    TextFieldModule,\n    MatFormFieldModule,\n    MatCommonModule,\n  ],\n  exports: [\n    TextFieldModule,\n    // We re-export the `MatFormFieldModule` since `MatInput` will almost always\n    // be used together with `MatFormField`.\n    MatFormFieldModule,\n    MatInput,\n    MatTextareaAutosize,\n  ],\n  providers: [ErrorStateMatcher],\n})\nexport class MatInputModule {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport * from './autosize';\nexport * from './input';\nexport * from './input-errors';\nexport * from './input-module';\nexport * from './input-value-accessor';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"]},"metadata":{},"sourceType":"module"}