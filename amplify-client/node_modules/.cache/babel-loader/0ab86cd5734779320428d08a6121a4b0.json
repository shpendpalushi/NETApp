{"ast":null,"code":"/**\r\n * DevExtreme (viz/axes/xy_axes.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _range = require(\"../translators/range\");\n\nvar _range2 = _interopRequireDefault(_range);\n\nvar _format_helper = require(\"../../format_helper\");\n\nvar _date = require(\"../../core/utils/date\");\n\nvar _date2 = _interopRequireDefault(_date);\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _datetime_breaks = require(\"./datetime_breaks\");\n\nvar _common = require(\"../../core/utils/common\");\n\nvar _utils = require(\"../core/utils\");\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _axes_constants = require(\"./axes_constants\");\n\nvar _axes_constants2 = _interopRequireDefault(_axes_constants);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nvar getNextDateUnit = _date2.default.getNextDateUnit;\nvar correctDateWithUnitBeginning = _date2.default.correctDateWithUnitBeginning;\nvar _math = Math;\nvar _max = _math.max;\nvar TOP = _axes_constants2.default.top;\nvar BOTTOM = _axes_constants2.default.bottom;\nvar LEFT = _axes_constants2.default.left;\nvar RIGHT = _axes_constants2.default.right;\nvar CENTER = _axes_constants2.default.center;\nvar SCALE_BREAK_OFFSET = 3;\nvar RANGE_RATIO = .3;\nvar WAVED_LINE_CENTER = 2;\nvar WAVED_LINE_TOP = 0;\nvar WAVED_LINE_BOTTOM = 4;\nvar WAVED_LINE_LENGTH = 24;\nvar TICKS_CORRECTIONS = {\n  left: -1,\n  top: -1,\n  right: 0,\n  bottom: 0,\n  center: -.5\n};\n\nfunction prepareDatesDifferences(datesDifferences, tickInterval) {\n  var dateUnitInterval;\n  var i;\n\n  if (\"week\" === tickInterval) {\n    tickInterval = \"day\";\n  }\n\n  if (\"quarter\" === tickInterval) {\n    tickInterval = \"month\";\n  }\n\n  if (datesDifferences[tickInterval]) {\n    for (i = 0; i < _date2.default.dateUnitIntervals.length; i++) {\n      dateUnitInterval = _date2.default.dateUnitIntervals[i];\n\n      if (datesDifferences[dateUnitInterval]) {\n        datesDifferences[dateUnitInterval] = false;\n        datesDifferences.count--;\n      }\n\n      if (dateUnitInterval === tickInterval) {\n        break;\n      }\n    }\n  }\n}\n\nfunction sortingBreaks(breaks) {\n  return breaks.sort(function (a, b) {\n    return a.from - b.from;\n  });\n}\n\nfunction filterBreaks(breaks, viewport, breakStyle) {\n  var minVisible = viewport.minVisible;\n  var maxVisible = viewport.maxVisible;\n  var breakSize = breakStyle ? breakStyle.width : 0;\n  return breaks.reduce(function (result, currentBreak) {\n    var from = currentBreak.from;\n    var to = currentBreak.to;\n    var lastResult = result[result.length - 1];\n    var newBreak;\n\n    if (!(0, _type.isDefined)(from) || !(0, _type.isDefined)(to)) {\n      return result;\n    }\n\n    if (from > to) {\n      to = [from, from = to][0];\n    }\n\n    if (result.length && from < lastResult.to) {\n      if (to > lastResult.to) {\n        lastResult.to = to > maxVisible ? maxVisible : to;\n\n        if (lastResult.gapSize) {\n          lastResult.gapSize = void 0;\n          lastResult.cumulativeWidth += breakSize;\n        }\n      }\n    } else {\n      if ((from >= minVisible && from < maxVisible || to <= maxVisible && to > minVisible) && to - from < maxVisible - minVisible) {\n        from = from >= minVisible ? from : minVisible;\n        to = to <= maxVisible ? to : maxVisible;\n        newBreak = {\n          from: from,\n          to: to,\n          cumulativeWidth: (lastResult ? lastResult.cumulativeWidth : 0) + breakSize\n        };\n\n        if (currentBreak.gapSize) {\n          newBreak.gapSize = _date2.default.convertMillisecondsToDateUnits(to - from);\n          newBreak.cumulativeWidth = lastResult ? lastResult.cumulativeWidth : 0;\n        }\n\n        result.push(newBreak);\n      }\n    }\n\n    return result;\n  }, []);\n}\n\nfunction getMarkerDates(min, max, markerInterval) {\n  var origMin = min;\n  var dates;\n  min = correctDateWithUnitBeginning(min, markerInterval);\n  max = correctDateWithUnitBeginning(max, markerInterval);\n  dates = _date2.default.getSequenceByInterval(min, max, markerInterval);\n\n  if (dates.length && origMin > dates[0]) {\n    dates = dates.slice(1);\n  }\n\n  return dates;\n}\n\nfunction getStripHorizontalAlignmentPosition(alignment) {\n  var position = \"start\";\n\n  if (\"center\" === alignment) {\n    position = \"center\";\n  }\n\n  if (\"right\" === alignment) {\n    position = \"end\";\n  }\n\n  return position;\n}\n\nfunction getStripVerticalAlignmentPosition(alignment) {\n  var position = \"start\";\n\n  if (\"center\" === alignment) {\n    position = \"center\";\n  }\n\n  if (\"bottom\" === alignment) {\n    position = \"end\";\n  }\n\n  return position;\n}\n\nfunction getMarkerInterval(tickInterval) {\n  var markerInterval = getNextDateUnit(tickInterval);\n\n  if (\"quarter\" === markerInterval) {\n    markerInterval = getNextDateUnit(markerInterval);\n  }\n\n  return markerInterval;\n}\n\nfunction getMarkerFormat(curDate, prevDate, tickInterval, markerInterval) {\n  var format = markerInterval;\n\n  var datesDifferences = prevDate && _date2.default.getDatesDifferences(prevDate, curDate);\n\n  if (prevDate && \"year\" !== tickInterval) {\n    prepareDatesDifferences(datesDifferences, tickInterval);\n    format = (0, _format_helper.getDateFormatByDifferences)(datesDifferences);\n  }\n\n  return format;\n}\n\nfunction getMaxSide(act, boxes) {\n  return boxes.reduce(function (prevValue, box) {\n    return _max(prevValue, act(box));\n  }, 0);\n}\n\nfunction getDistanceByAngle(bBox, rotationAngle) {\n  rotationAngle = _math.abs(rotationAngle);\n  rotationAngle = rotationAngle % 180 >= 90 ? 90 - rotationAngle % 90 : rotationAngle % 90;\n  var a = rotationAngle * (_math.PI / 180);\n\n  if (a >= _math.atan(bBox.height / bBox.width)) {\n    return bBox.height / _math.abs(_math.sin(a));\n  } else {\n    return bBox.width;\n  }\n}\n\nfunction getMaxConstantLinePadding(constantLines) {\n  return constantLines.reduce(function (padding, options) {\n    return _max(padding, options.paddingTopBottom);\n  }, 0);\n}\n\nfunction getConstantLineLabelMarginForVerticalAlignment(constantLines, alignment, labelHeight) {\n  return constantLines.some(function (options) {\n    return options.label.verticalAlignment === alignment;\n  }) && labelHeight || 0;\n}\n\nfunction getLeftMargin(bBox) {\n  return _math.abs(bBox.x) || 0;\n}\n\nfunction getRightMargin(bBox) {\n  return _math.abs(bBox.width - _math.abs(bBox.x)) || 0;\n}\n\nfunction generateRangesOnPoints(points, edgePoints, getRange) {\n  var i;\n  var length;\n  var maxRange = null;\n  var ranges = [];\n  var curValue;\n  var prevValue;\n  var curRange;\n\n  for (i = 1, length = points.length; i < length; i++) {\n    curValue = points[i];\n    prevValue = points[i - 1];\n    curRange = getRange(curValue, prevValue);\n\n    if (edgePoints.indexOf(curValue) >= 0) {\n      if (!maxRange || curRange > maxRange.length) {\n        maxRange = {\n          start: curValue,\n          end: prevValue,\n          length: curRange\n        };\n      }\n    } else {\n      if (maxRange && curRange < maxRange.length) {\n        ranges.push(maxRange);\n      } else {\n        ranges.push({\n          start: curValue,\n          end: prevValue,\n          length: curRange\n        });\n      }\n\n      maxRange = null;\n    }\n  }\n\n  if (maxRange) {\n    ranges.push(maxRange);\n  }\n\n  return ranges;\n}\n\nfunction generateAutoBreaks(_ref, series, _ref2) {\n  var logarithmBase = _ref.logarithmBase,\n      type = _ref.type,\n      maxAutoBreakCount = _ref.maxAutoBreakCount;\n  var minVisible = _ref2.minVisible,\n      maxVisible = _ref2.maxVisible;\n  var breaks = [];\n  var getRange = \"logarithmic\" === type ? function (min, max) {\n    return _utils2.default.getLog(max / min, logarithmBase);\n  } : function (min, max) {\n    return max - min;\n  };\n  var visibleRange = getRange(minVisible, maxVisible);\n  var points = series.reduce(function (result, s) {\n    var points = s.getPointsInViewPort();\n    result[0] = result[0].concat(points[0]);\n    result[1] = result[1].concat(points[1]);\n    return result;\n  }, [[], []]);\n  var sortedAllPoints = points[0].concat(points[1]).sort(function (a, b) {\n    return b - a;\n  });\n  var edgePoints = points[1].filter(function (p) {\n    return points[0].indexOf(p) < 0;\n  });\n  var minDiff = RANGE_RATIO * visibleRange;\n  var ranges = generateRangesOnPoints(sortedAllPoints, edgePoints, getRange).sort(function (a, b) {\n    return b.length - a.length;\n  });\n  var epsilon = _math.min.apply(null, ranges.map(function (r) {\n    return r.length;\n  })) / 1e3;\n\n  var _maxAutoBreakCount = (0, _type.isDefined)(maxAutoBreakCount) ? _math.min(maxAutoBreakCount, ranges.length) : ranges.length;\n\n  for (var i = 0; i < _maxAutoBreakCount; i++) {\n    if (ranges[i].length >= minDiff) {\n      if (visibleRange <= ranges[i].length) {\n        break;\n      }\n\n      visibleRange -= ranges[i].length;\n\n      if (visibleRange > epsilon || visibleRange < -epsilon) {\n        breaks.push({\n          from: ranges[i].start,\n          to: ranges[i].end\n        });\n        minDiff = RANGE_RATIO * visibleRange;\n      }\n    } else {\n      break;\n    }\n  }\n\n  sortingBreaks(breaks);\n  return breaks;\n}\n\nmodule.exports = {\n  linear: {\n    _getStep: function _getStep(boxes, rotationAngle) {\n      var spacing = this._options.label.minSpacing;\n      var func = this._isHorizontal ? function (box) {\n        return box.width + spacing;\n      } : function (box) {\n        return box.height;\n      };\n      var maxLabelLength = getMaxSide(func, boxes);\n\n      if (rotationAngle) {\n        maxLabelLength = getDistanceByAngle({\n          width: maxLabelLength,\n          height: this._getMaxLabelHeight(boxes, 0)\n        }, rotationAngle);\n      }\n\n      return _axes_constants2.default.getTicksCountInRange(this._majorTicks, this._isHorizontal ? \"x\" : \"y\", maxLabelLength);\n    },\n    _getMaxLabelHeight: function _getMaxLabelHeight(boxes, spacing) {\n      return getMaxSide(function (box) {\n        return box.height;\n      }, boxes) + spacing;\n    },\n    _validateOverlappingMode: function _validateOverlappingMode(mode, displayMode) {\n      if (this._isHorizontal && (\"rotate\" === displayMode || \"stagger\" === displayMode) || !this._isHorizontal) {\n        return _axes_constants2.default.validateOverlappingMode(mode);\n      }\n\n      return mode;\n    },\n    _validateDisplayMode: function _validateDisplayMode(mode) {\n      return this._isHorizontal ? mode : \"standard\";\n    },\n    getMarkerTrackers: function getMarkerTrackers() {\n      return this._markerTrackers;\n    },\n    _getSharpParam: function _getSharpParam(opposite) {\n      return this._isHorizontal ^ opposite ? \"h\" : \"v\";\n    },\n    _createAxisElement: function _createAxisElement() {\n      return this._renderer.path([], \"line\");\n    },\n    _updateAxisElementPosition: function _updateAxisElementPosition() {\n      var axisCoord = this._axisPosition;\n\n      var canvas = this._getCanvasStartEnd();\n\n      this._axisElement.attr({\n        points: this._isHorizontal ? [canvas.start, axisCoord, canvas.end, axisCoord] : [axisCoord, canvas.start, axisCoord, canvas.end]\n      });\n    },\n    _getTranslatedCoord: function _getTranslatedCoord(value, offset) {\n      return this._translator.translate(value, offset);\n    },\n    _initAxisPositions: function _initAxisPositions() {\n      var that = this;\n      var position = that._options.position;\n      that._axisPosition = that._orthogonalPositions[\"top\" === position || \"left\" === position ? \"start\" : \"end\"];\n    },\n    _getTickMarkPoints: function _getTickMarkPoints(coords, length, tickOptions) {\n      var isHorizontal = this._isHorizontal;\n      var options = this._options;\n      var tickStartCoord;\n\n      if ((0, _type.isDefined)(options.tickOrientation)) {\n        tickStartCoord = TICKS_CORRECTIONS[options.tickOrientation] * length;\n      } else {\n        var shift = tickOptions.shift || 0;\n\n        if (\"left\" === options.position || \"top\" === options.position) {\n          shift = -shift;\n        }\n\n        tickStartCoord = shift + this.getTickStartPositionShift(length);\n      }\n\n      return [coords.x + (isHorizontal ? 0 : tickStartCoord), coords.y + (isHorizontal ? tickStartCoord : 0), coords.x + (isHorizontal ? 0 : tickStartCoord + length), coords.y + (isHorizontal ? tickStartCoord + length : 0)];\n    },\n    getTickStartPositionShift: function getTickStartPositionShift(length) {\n      var options = this._options;\n      return length % 2 === 1 ? options.width % 2 === 0 && (\"left\" === options.position || \"top\" === options.position) || options.width % 2 === 1 && (\"right\" === options.position || \"bottom\" === options.position) ? Math.floor(-length / 2) : -Math.floor(length / 2) : -length / 2 + (options.width % 2 === 0 ? 0 : \"bottom\" === options.position || \"right\" === options.position ? -1 : 1);\n    },\n    _getTitleCoords: function _getTitleCoords() {\n      var that = this;\n      var horizontal = that._isHorizontal;\n      var x = that._axisPosition;\n      var y = that._axisPosition;\n      var align = that._options.title.alignment;\n\n      var canvas = that._getCanvasStartEnd();\n\n      var fromStartToEnd = horizontal || that._options.position === LEFT;\n      var canvasStart = fromStartToEnd ? canvas.start : canvas.end;\n      var canvasEnd = fromStartToEnd ? canvas.end : canvas.start;\n      var coord = align === LEFT ? canvasStart : align === RIGHT ? canvasEnd : canvas.start + (canvas.end - canvas.start) / 2;\n\n      if (horizontal) {\n        x = coord;\n      } else {\n        y = coord;\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    },\n    _drawTitleText: function _drawTitleText(group, coords) {\n      var options = this._options;\n      var titleOptions = options.title;\n      var attrs = {\n        opacity: titleOptions.opacity,\n        align: titleOptions.alignment,\n        \"class\": titleOptions.cssClass\n      };\n\n      if (!titleOptions.text || !group) {\n        return;\n      }\n\n      coords = coords || this._getTitleCoords();\n\n      if (!this._isHorizontal) {\n        attrs.rotate = options.position === LEFT ? 270 : 90;\n      }\n\n      var text = this._renderer.text(titleOptions.text, coords.x, coords.y).css(_utils2.default.patchFontOptions(titleOptions.font)).attr(attrs).append(group);\n\n      this._checkTitleOverflow(text);\n\n      return text;\n    },\n    _updateTitleCoords: function _updateTitleCoords() {\n      this._title && this._title.element.attr(this._getTitleCoords());\n    },\n    _drawTitle: function _drawTitle() {\n      var title = this._drawTitleText(this._axisTitleGroup);\n\n      if (title) {\n        this._title = {\n          element: title\n        };\n      }\n    },\n    _measureTitle: function _measureTitle() {\n      if (this._title) {\n        if (this._title.bBox && !this._title.originalSize) {\n          this._title.originalSize = this._title.bBox;\n        }\n\n        this._title.bBox = this._title.element.getBBox();\n      }\n    },\n    _drawDateMarker: function _drawDateMarker(date, options, range) {\n      var that = this;\n      var markerOptions = that._options.marker;\n\n      var invert = that._translator.getBusinessRange().invert;\n\n      var textIndent = markerOptions.width + markerOptions.textLeftIndent;\n      var text;\n      var pathElement;\n\n      if (null === options.x) {\n        return;\n      }\n\n      if (!options.withoutStick) {\n        pathElement = that._renderer.path([options.x, options.y, options.x, options.y + markerOptions.separatorHeight], \"line\").attr({\n          \"stroke-width\": markerOptions.width,\n          stroke: markerOptions.color,\n          \"stroke-opacity\": markerOptions.opacity,\n          sharp: \"h\"\n        }).append(that._axisElementsGroup);\n      }\n\n      text = String(that.formatLabel(date, options.labelOptions, range));\n      return {\n        date: date,\n        x: options.x,\n        y: options.y,\n        cropped: options.withoutStick,\n        label: that._renderer.text(text, options.x, options.y).css(_utils2.default.patchFontOptions(markerOptions.label.font)).append(that._axisElementsGroup),\n        line: pathElement,\n        getEnd: function getEnd() {\n          return this.x + (invert ? -1 : 1) * (textIndent + this.labelBBox.width);\n        },\n        setTitle: function setTitle() {\n          this.title = text;\n        },\n        hideLabel: function hideLabel() {\n          this.label.dispose();\n          this.label = null;\n          this.title = text;\n        },\n        hide: function hide() {\n          if (pathElement) {\n            pathElement.dispose();\n            pathElement = null;\n          }\n\n          this.label.dispose();\n          this.label = null;\n          this.hidden = true;\n        }\n      };\n    },\n    _drawDateMarkers: function _drawDateMarkers() {\n      var that = this;\n      var options = that._options;\n      var translator = that._translator;\n\n      var viewport = that._getViewportRange();\n\n      var minBound = viewport.minVisible;\n      var tickInterval;\n      var markerInterval;\n      var markerDates;\n      var dateMarkers = [];\n      var markersAreaTop;\n      var dateMarker;\n\n      function draw(markerDate, format, withoutStick) {\n        return that._drawDateMarker(markerDate, {\n          x: translator.translate(markerDate),\n          y: markersAreaTop,\n          labelOptions: that._getLabelFormatOptions(format),\n          withoutStick: withoutStick\n        }, viewport);\n      }\n\n      if (viewport.isEmpty() || !options.marker.visible || \"datetime\" !== options.argumentType || \"discrete\" === options.type || that._majorTicks.length <= 1) {\n        return [];\n      }\n\n      markersAreaTop = that._axisPosition + options.marker.topIndent;\n      tickInterval = _date2.default.getDateUnitInterval(this._tickInterval);\n      markerInterval = getMarkerInterval(tickInterval);\n      markerDates = getMarkerDates(minBound, viewport.maxVisible, markerInterval);\n\n      if (markerDates.length > 1 || 1 === markerDates.length && minBound < markerDates[0]) {\n        dateMarkers = markerDates.reduce(function (markers, curDate, i, dates) {\n          var marker = draw(curDate, getMarkerFormat(curDate, dates[i - 1] || minBound < curDate && minBound, tickInterval, markerInterval));\n          marker && markers.push(marker);\n          return markers;\n        }, []);\n\n        if (minBound < markerDates[0]) {\n          dateMarker = draw(minBound, getMarkerFormat(minBound, markerDates[0], tickInterval, markerInterval), true);\n          dateMarker && dateMarkers.unshift(dateMarker);\n        }\n      }\n\n      return dateMarkers;\n    },\n    _adjustDateMarkers: function _adjustDateMarkers(offset) {\n      offset = offset || 0;\n      var that = this;\n      var markerOptions = this._options.marker;\n      var textIndent = markerOptions.width + markerOptions.textLeftIndent;\n\n      var invert = this._translator.getBusinessRange().invert;\n\n      var canvas = that._getCanvasStartEnd();\n\n      var dateMarkers = this._dateMarkers;\n\n      if (!dateMarkers.length) {\n        return offset;\n      }\n\n      if (dateMarkers[0].cropped) {\n        if (!this._checkMarkersPosition(invert, dateMarkers[1], dateMarkers[0])) {\n          dateMarkers[0].hideLabel();\n        }\n      }\n\n      var prevDateMarker;\n      dateMarkers.forEach(function (marker, i, markers) {\n        if (marker.cropped) {\n          return;\n        }\n\n        if (invert ? marker.getEnd() < canvas.end : marker.getEnd() > canvas.end) {\n          marker.hideLabel();\n        } else {\n          if (that._checkMarkersPosition(invert, marker, prevDateMarker)) {\n            prevDateMarker = marker;\n          } else {\n            marker.hide();\n          }\n        }\n      });\n\n      this._dateMarkers.forEach(function (marker) {\n        if (marker.label) {\n          var labelBBox = marker.labelBBox;\n          var dy = marker.y + markerOptions.textTopIndent - labelBBox.y;\n          marker.label.attr({\n            translateX: invert ? marker.x - textIndent - labelBBox.x - labelBBox.width : marker.x + textIndent - labelBBox.x,\n            translateY: dy + offset\n          });\n        }\n\n        if (marker.line) {\n          marker.line.attr({\n            translateY: offset\n          });\n        }\n      });\n\n      that._initializeMarkersTrackers(offset);\n\n      return offset + markerOptions.topIndent + markerOptions.separatorHeight;\n    },\n    _checkMarkersPosition: function _checkMarkersPosition(invert, dateMarker, prevDateMarker) {\n      if (void 0 === prevDateMarker) {\n        return true;\n      }\n\n      return invert ? dateMarker.x < prevDateMarker.getEnd() : dateMarker.x > prevDateMarker.getEnd();\n    },\n    _initializeMarkersTrackers: function _initializeMarkersTrackers(offset) {\n      var that = this;\n      var separatorHeight = that._options.marker.separatorHeight;\n      var renderer = that._renderer;\n\n      var businessRange = this._translator.getBusinessRange();\n\n      var canvas = that._getCanvasStartEnd();\n\n      var group = that._axisElementsGroup;\n      that._markerTrackers = this._dateMarkers.filter(function (marker) {\n        return !marker.hidden;\n      }).map(function (marker, i, markers) {\n        var nextMarker = markers[i + 1] || {\n          x: canvas.end,\n          date: businessRange.max\n        };\n        var x = marker.x;\n        var y = marker.y + offset;\n        var markerTracker = renderer.path([x, y, x, y + separatorHeight, nextMarker.x, y + separatorHeight, nextMarker.x, y, x, y], \"area\").attr({\n          \"stroke-width\": 1,\n          stroke: \"grey\",\n          fill: \"grey\",\n          opacity: 1e-4\n        }).append(group);\n        markerTracker.data(\"range\", {\n          startValue: marker.date,\n          endValue: nextMarker.date\n        });\n\n        if (marker.title) {\n          markerTracker.setTitle(marker.title);\n        }\n\n        return markerTracker;\n      });\n    },\n    _getLabelFormatOptions: function _getLabelFormatOptions(formatString) {\n      var that = this;\n      var markerLabelOptions = that._markerLabelOptions;\n\n      if (!markerLabelOptions) {\n        that._markerLabelOptions = markerLabelOptions = (0, _extend.extend)(true, {}, that._options.marker.label);\n      }\n\n      if (!(0, _type.isDefined)(that._options.marker.label.format)) {\n        markerLabelOptions.format = formatString;\n      }\n\n      return markerLabelOptions;\n    },\n    _adjustConstantLineLabels: function _adjustConstantLineLabels(constantLines) {\n      var that = this;\n      var axisPosition = that._options.position;\n      var canvas = that.getCanvas();\n      var canvasLeft = canvas.left;\n      var canvasRight = canvas.width - canvas.right;\n      var canvasTop = canvas.top;\n      var canvasBottom = canvas.height - canvas.bottom;\n      var verticalCenter = canvasTop + (canvasBottom - canvasTop) / 2;\n      var horizontalCenter = canvasLeft + (canvasRight - canvasLeft) / 2;\n      var maxLabel = 0;\n      constantLines.forEach(function (item) {\n        var isHorizontal = that._isHorizontal;\n        var linesOptions = item.options;\n        var paddingTopBottom = linesOptions.paddingTopBottom;\n        var paddingLeftRight = linesOptions.paddingLeftRight;\n        var labelOptions = linesOptions.label;\n        var labelVerticalAlignment = labelOptions.verticalAlignment;\n        var labelHorizontalAlignment = labelOptions.horizontalAlignment;\n        var labelIsInside = \"inside\" === labelOptions.position;\n        var label = item.label;\n        var box = item.labelBBox;\n        var translateX;\n        var translateY;\n\n        if (null === label || box.isEmpty) {\n          return;\n        }\n\n        if (isHorizontal) {\n          if (labelIsInside) {\n            if (labelHorizontalAlignment === LEFT) {\n              translateX = item.coord - paddingLeftRight - box.x - box.width;\n            } else {\n              translateX = item.coord + paddingLeftRight - box.x;\n            }\n\n            switch (labelVerticalAlignment) {\n              case CENTER:\n                translateY = verticalCenter - box.y - box.height / 2;\n                break;\n\n              case BOTTOM:\n                translateY = canvasBottom - paddingTopBottom - box.y - box.height;\n                break;\n\n              default:\n                translateY = canvasTop + paddingTopBottom - box.y;\n            }\n          } else {\n            if (axisPosition === labelVerticalAlignment) {\n              maxLabel = _max(maxLabel, box.height + paddingTopBottom);\n            }\n\n            translateX = item.coord - box.x - box.width / 2;\n\n            if (labelVerticalAlignment === BOTTOM) {\n              translateY = canvasBottom + paddingTopBottom - box.y;\n            } else {\n              translateY = canvasTop - paddingTopBottom - box.y - box.height;\n            }\n          }\n        } else {\n          if (labelIsInside) {\n            if (labelVerticalAlignment === BOTTOM) {\n              translateY = item.coord + paddingTopBottom - box.y;\n            } else {\n              translateY = item.coord - paddingTopBottom - box.y - box.height;\n            }\n\n            switch (labelHorizontalAlignment) {\n              case CENTER:\n                translateX = horizontalCenter - box.x - box.width / 2;\n                break;\n\n              case RIGHT:\n                translateX = canvasRight - paddingLeftRight - box.x - box.width;\n                break;\n\n              default:\n                translateX = canvasLeft + paddingLeftRight - box.x;\n            }\n          } else {\n            if (axisPosition === labelHorizontalAlignment) {\n              maxLabel = _max(maxLabel, box.width + paddingLeftRight);\n            }\n\n            translateY = item.coord - box.y - box.height / 2;\n\n            if (labelHorizontalAlignment === RIGHT) {\n              translateX = canvasRight + paddingLeftRight - box.x;\n            } else {\n              translateX = canvasLeft - paddingLeftRight - box.x - box.width;\n            }\n          }\n        }\n\n        label.attr({\n          translateX: translateX,\n          translateY: translateY\n        });\n      });\n      return maxLabel;\n    },\n    _drawConstantLinesForEstimating: function _drawConstantLinesForEstimating(constantLines) {\n      var that = this;\n      var renderer = this._renderer;\n      var group = renderer.g();\n      constantLines.forEach(function (options) {\n        that._drawConstantLineLabelText(options.label.text, 0, 0, options.label, group).attr({\n          align: \"center\"\n        });\n      });\n      return group.append(renderer.root);\n    },\n    _estimateLabelHeight: function _estimateLabelHeight(bBox, labelOptions) {\n      var height = bBox.height;\n      var drawingType = labelOptions.drawingType;\n\n      if (\"stagger\" === this._validateDisplayMode(drawingType) || \"stagger\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\n        height = 2 * height + labelOptions.staggeringSpacing;\n      }\n\n      if (\"rotate\" === this._validateDisplayMode(drawingType) || \"rotate\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\n        var sinCos = _utils2.default.getCosAndSin(labelOptions.rotationAngle);\n\n        height = height * sinCos.cos + bBox.width * sinCos.sin;\n      }\n\n      return height && (height + labelOptions.indentFromAxis || 0) || 0;\n    },\n    estimateMargins: function estimateMargins(canvas) {\n      this.updateCanvas(canvas);\n      var that = this;\n\n      var range = that._getViewportRange();\n\n      var ticksData = this._createTicksAndLabelFormat(range);\n\n      var ticks = ticksData.ticks;\n      var tickInterval = ticksData.tickInterval;\n      var options = this._options;\n\n      var constantLineOptions = that._outsideConstantLines.filter(function (l) {\n        return l.labelOptions.visible;\n      }).map(function (l) {\n        return l.options;\n      });\n\n      var rootElement = that._renderer.root;\n      var labelIsVisible = options.label.visible && !range.isEmpty() && ticks.length;\n      var labelValue = labelIsVisible && that.formatLabel(ticks[ticks.length - 1], options.label, void 0, void 0, tickInterval, ticks);\n\n      var labelElement = labelIsVisible && that._renderer.text(labelValue, 0, 0).css(that._textFontStyles).attr(that._textOptions).append(rootElement);\n\n      var titleElement = that._drawTitleText(rootElement, {\n        x: 0,\n        y: 0\n      });\n\n      var constantLinesLabelsElement = that._drawConstantLinesForEstimating(constantLineOptions);\n\n      var labelBox = labelElement && labelElement.getBBox() || {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n      var titleBox = titleElement && titleElement.getBBox() || {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n      var constantLinesBox = constantLinesLabelsElement.getBBox();\n      var titleHeight = titleBox.height ? titleBox.height + options.title.margin : 0;\n\n      var labelHeight = that._estimateLabelHeight(labelBox, options.label);\n\n      var constantLinesHeight = constantLinesBox.height ? constantLinesBox.height + getMaxConstantLinePadding(constantLineOptions) : 0;\n      var height = labelHeight + titleHeight;\n      var margins = {\n        left: _max(getLeftMargin(labelBox), getLeftMargin(constantLinesBox)),\n        right: _max(getRightMargin(labelBox), getRightMargin(constantLinesBox)),\n        top: (\"top\" === options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"top\", constantLinesHeight),\n        bottom: (\"top\" !== options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"bottom\", constantLinesHeight)\n      };\n      labelElement && labelElement.remove();\n      titleElement && titleElement.remove();\n      constantLinesLabelsElement && constantLinesLabelsElement.remove();\n      return margins;\n    },\n    _checkAlignmentConstantLineLabels: function _checkAlignmentConstantLineLabels(labelOptions) {\n      var position = labelOptions.position;\n      var verticalAlignment = (labelOptions.verticalAlignment || \"\").toLowerCase();\n      var horizontalAlignment = (labelOptions.horizontalAlignment || \"\").toLowerCase();\n\n      if (this._isHorizontal) {\n        if (\"outside\" === position) {\n          verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\n          horizontalAlignment = CENTER;\n        } else {\n          verticalAlignment = verticalAlignment === CENTER ? CENTER : verticalAlignment === BOTTOM ? BOTTOM : TOP;\n          horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT;\n        }\n      } else {\n        if (\"outside\" === position) {\n          verticalAlignment = CENTER;\n          horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT;\n        } else {\n          verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\n          horizontalAlignment = horizontalAlignment === RIGHT ? RIGHT : horizontalAlignment === CENTER ? CENTER : LEFT;\n        }\n      }\n\n      labelOptions.verticalAlignment = verticalAlignment;\n      labelOptions.horizontalAlignment = horizontalAlignment;\n    },\n    _getConstantLineLabelsCoords: function _getConstantLineLabelsCoords(value, lineLabelOptions) {\n      var that = this;\n      var x = value;\n      var y = value;\n\n      if (that._isHorizontal) {\n        y = that._orthogonalPositions[\"top\" === lineLabelOptions.verticalAlignment ? \"start\" : \"end\"];\n      } else {\n        x = that._orthogonalPositions[\"right\" === lineLabelOptions.horizontalAlignment ? \"end\" : \"start\"];\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    },\n    _getAdjustedStripLabelCoords: function _getAdjustedStripLabelCoords(strip) {\n      var stripOptions = strip.options;\n      var paddingTopBottom = stripOptions.paddingTopBottom;\n      var paddingLeftRight = stripOptions.paddingLeftRight;\n      var horizontalAlignment = stripOptions.label.horizontalAlignment;\n      var verticalAlignment = stripOptions.label.verticalAlignment;\n      var box = strip.labelBBox;\n      var labelHeight = box.height;\n      var labelWidth = box.width;\n      var labelCoords = strip.labelCoords;\n      var y = labelCoords.y - box.y;\n      var x = labelCoords.x - box.x;\n\n      if (verticalAlignment === TOP) {\n        y += paddingTopBottom;\n      } else {\n        if (verticalAlignment === CENTER) {\n          y -= labelHeight / 2;\n        } else {\n          if (verticalAlignment === BOTTOM) {\n            y -= paddingTopBottom + labelHeight;\n          }\n        }\n      }\n\n      if (horizontalAlignment === LEFT) {\n        x += paddingLeftRight;\n      } else {\n        if (horizontalAlignment === CENTER) {\n          x -= labelWidth / 2;\n        } else {\n          if (horizontalAlignment === RIGHT) {\n            x -= paddingLeftRight + labelWidth;\n          }\n        }\n      }\n\n      return {\n        translateX: x,\n        translateY: y\n      };\n    },\n    _adjustTitle: function _adjustTitle(offset) {\n      offset = offset || 0;\n\n      if (!this._title) {\n        return;\n      }\n\n      var that = this;\n      var options = that._options;\n      var position = options.position;\n      var margin = options.title.margin;\n      var title = that._title;\n      var boxTitle = title.bBox;\n      var x = boxTitle.x;\n      var y = boxTitle.y;\n      var width = boxTitle.width;\n      var height = boxTitle.height;\n      var axisPosition = that._axisPosition;\n      var loCoord = axisPosition - margin - offset;\n      var hiCoord = axisPosition + margin + offset;\n      var params = {};\n\n      if (that._isHorizontal) {\n        if (position === TOP) {\n          params.translateY = loCoord - (y + height);\n        } else {\n          params.translateY = hiCoord - y;\n        }\n      } else {\n        if (position === LEFT) {\n          params.translateX = loCoord - (x + width);\n        } else {\n          params.translateX = hiCoord - x;\n        }\n      }\n\n      title.element.attr(params);\n    },\n    _checkTitleOverflow: function _checkTitleOverflow(titleElement) {\n      if (!this._title && !titleElement) {\n        return;\n      }\n\n      var canvasLength = this._getScreenDelta();\n\n      var title = titleElement ? {\n        bBox: titleElement.getBBox(),\n        element: titleElement\n      } : this._title;\n      var titleOptions = this._options.title;\n      var boxTitle = title.bBox;\n\n      if ((this._isHorizontal ? boxTitle.width : boxTitle.height) > canvasLength) {\n        title.element.setMaxSize(canvasLength, void 0, {\n          wordWrap: titleOptions.wordWrap || \"none\",\n          textOverflow: titleOptions.textOverflow || \"ellipsis\"\n        });\n        this._wrapped = titleOptions.wordWrap && \"none\" !== titleOptions.wordWrap;\n      } else {\n        var moreThanOriginalSize = title.originalSize && canvasLength > (this._isHorizontal ? title.originalSize.width : title.originalSize.height);\n        !this._wrapped && moreThanOriginalSize && title.element.restoreText();\n      }\n    },\n    coordsIn: function coordsIn(x, y) {\n      var canvas = this.getCanvas();\n      var isHorizontal = this._options.isHorizontal;\n      var position = this._options.position;\n      var coord = isHorizontal ? y : x;\n\n      if (isHorizontal && (x < canvas.left || x > canvas.width - canvas.right) || !isHorizontal && (y < canvas.top || y > canvas.height - canvas.bottom)) {\n        return false;\n      }\n\n      if (isHorizontal && position === _axes_constants2.default.top || !isHorizontal && position === _axes_constants2.default.left) {\n        return coord < canvas[position];\n      }\n\n      return coord > canvas[isHorizontal ? \"height\" : \"width\"] - canvas[position];\n    },\n    _boundaryTicksVisibility: {\n      min: true,\n      max: true\n    },\n    adjust: function adjust(alignToBounds) {\n      var that = this;\n      var seriesData = that._seriesData;\n      var viewport = {\n        min: seriesData.min,\n        max: seriesData.max\n      };\n\n      if (!alignToBounds) {\n        viewport = that._series.filter(function (s) {\n          return s.isVisible();\n        }).reduce(function (range, s) {\n          var seriesRange = s.getViewport();\n          range.min = (0, _type.isDefined)(seriesRange.min) ? range.min < seriesRange.min ? range.min : seriesRange.min : range.min;\n          range.max = (0, _type.isDefined)(seriesRange.max) ? range.max > seriesRange.max ? range.max : seriesRange.max : range.max;\n\n          if (s.showZero) {\n            range = new _range2.default.Range(range);\n            range.correctValueZeroLevel();\n          }\n\n          return range;\n        }, {});\n      }\n\n      if ((0, _type.isDefined)(viewport.min) && (0, _type.isDefined)(viewport.max)) {\n        seriesData.minVisible = viewport.min;\n        seriesData.maxVisible = viewport.max;\n      }\n\n      that._translator.updateBusinessRange(that.adjustViewport(seriesData));\n\n      that._breaks = that._getScaleBreaks(that._options, {\n        minVisible: seriesData.minVisible,\n        maxVisible: seriesData.maxVisible\n      }, that._series, that.isArgumentAxis);\n    },\n    hasWrap: function hasWrap() {\n      return this._wrapped;\n    },\n    getAxisPosition: function getAxisPosition() {\n      return this._axisPosition;\n    },\n    _getStick: function _getStick() {\n      return !this._options.valueMarginsEnabled;\n    },\n    _getStripLabelCoords: function _getStripLabelCoords(from, to, stripLabelOptions) {\n      var that = this;\n      var orthogonalPositions = that._orthogonalPositions;\n      var isHorizontal = that._isHorizontal;\n      var horizontalAlignment = stripLabelOptions.horizontalAlignment;\n      var verticalAlignment = stripLabelOptions.verticalAlignment;\n      var x;\n      var y;\n\n      if (isHorizontal) {\n        if (horizontalAlignment === CENTER) {\n          x = from + (to - from) / 2;\n        } else {\n          if (horizontalAlignment === LEFT) {\n            x = from;\n          } else {\n            if (horizontalAlignment === RIGHT) {\n              x = to;\n            }\n          }\n        }\n\n        y = orthogonalPositions[getStripVerticalAlignmentPosition(verticalAlignment)];\n      } else {\n        x = orthogonalPositions[getStripHorizontalAlignmentPosition(horizontalAlignment)];\n\n        if (verticalAlignment === TOP) {\n          y = from;\n        } else {\n          if (verticalAlignment === CENTER) {\n            y = to + (from - to) / 2;\n          } else {\n            if (verticalAlignment === BOTTOM) {\n              y = to;\n            }\n          }\n        }\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    },\n    _getTranslatedValue: function _getTranslatedValue(value, offset) {\n      var pos1 = this._translator.translate(value, offset, \"semidiscrete\" === this._options.type && this._options.tickInterval);\n\n      var pos2 = this._axisPosition;\n      var isHorizontal = this._isHorizontal;\n      return {\n        x: isHorizontal ? pos1 : pos2,\n        y: isHorizontal ? pos2 : pos1\n      };\n    },\n    areCoordsOutsideAxis: function areCoordsOutsideAxis(coords) {\n      var coord = this._isHorizontal ? coords.x : coords.y;\n      var visibleArea = this.getVisibleArea();\n\n      if (coord < visibleArea[0] || coord > visibleArea[1]) {\n        return true;\n      }\n\n      return false;\n    },\n    _getSkippedCategory: function _getSkippedCategory(ticks) {\n      var skippedCategory;\n\n      if (this._options.type === _axes_constants2.default.discrete && this._tickOffset && 0 !== ticks.length) {\n        skippedCategory = ticks[ticks.length - 1];\n      }\n\n      return skippedCategory;\n    },\n    _getScaleBreaks: function _getScaleBreaks(axisOptions, viewport, series, isArgumentAxis) {\n      var that = this;\n      var breaks = (axisOptions.breaks || []).map(function (b) {\n        return {\n          from: that.parser(b.startValue),\n          to: that.parser(b.endValue)\n        };\n      });\n\n      if (\"discrete\" !== axisOptions.type && \"datetime\" === axisOptions.dataType && axisOptions.workdaysOnly) {\n        breaks = breaks.concat((0, _datetime_breaks.generateDateBreaks)(viewport.minVisible, viewport.maxVisible, axisOptions.workWeek, axisOptions.singleWorkdays, axisOptions.holidays));\n      }\n\n      if (!isArgumentAxis && \"discrete\" !== axisOptions.type && \"datetime\" !== axisOptions.dataType && axisOptions.autoBreaksEnabled && 0 !== axisOptions.maxAutoBreakCount) {\n        breaks = breaks.concat(generateAutoBreaks(axisOptions, series, viewport));\n      }\n\n      return filterBreaks(sortingBreaks(breaks), viewport, axisOptions.breakStyle);\n    },\n    _drawBreak: function _drawBreak(translatedEnd, positionFrom, positionTo, width, options, group) {\n      var that = this;\n      var breakStart = translatedEnd - (!that._translator.isInverted() ? width + 1 : 0);\n      var attr = {\n        \"stroke-width\": 1,\n        stroke: options.borderColor,\n        sharp: !options.isWaved ? options.isHorizontal ? \"h\" : \"v\" : void 0\n      };\n      var spaceAttr = {\n        stroke: options.color,\n        \"stroke-width\": width\n      };\n      var getPoints = that._isHorizontal ? rotateLine : function (p) {\n        return p;\n      };\n      var drawer = getLineDrawer(that._renderer, group, getPoints, positionFrom, breakStart, positionTo, options.isWaved);\n      drawer(width / 2, spaceAttr);\n      drawer(0, attr);\n      drawer(width, attr);\n    },\n    _createBreakClipRect: function _createBreakClipRect(from, to) {\n      var that = this;\n      var canvas = that._canvas;\n      var clipWidth = to - from;\n      var clipRect;\n\n      if (that._isHorizontal) {\n        clipRect = that._renderer.clipRect(canvas.left, from, canvas.width, clipWidth);\n      } else {\n        clipRect = that._renderer.clipRect(from, canvas.top, clipWidth, canvas.height);\n      }\n\n      that._breaksElements = that._breaksElements || [];\n\n      that._breaksElements.push(clipRect);\n\n      return clipRect.id;\n    },\n    _createBreaksGroup: function _createBreaksGroup(clipFrom, clipTo) {\n      var that = this;\n\n      var group = that._renderer.g().attr({\n        \"class\": that._axisCssPrefix + \"breaks\",\n        \"clip-path\": that._createBreakClipRect(clipFrom, clipTo)\n      }).append(that._scaleBreaksGroup);\n\n      that._breaksElements = that._breaksElements || [];\n\n      that._breaksElements.push(group);\n\n      return group;\n    },\n    _disposeBreaksGroup: function _disposeBreaksGroup() {\n      (this._breaksElements || []).forEach(function (clipRect) {\n        clipRect.dispose();\n      });\n      this._breaksElements = null;\n    },\n    drawScaleBreaks: function drawScaleBreaks(customCanvas) {\n      var that = this;\n      var options = that._options;\n      var breakStyle = options.breakStyle;\n      var position = options.position;\n      var positionFrom;\n      var positionTo;\n      var breaks = that._translator.getBusinessRange().breaks || [];\n      var additionGroup;\n      var additionBreakFrom;\n      var additionBreakTo;\n      var mainGroup;\n      var breakOptions;\n\n      that._disposeBreaksGroup();\n\n      if (!(breaks && breaks.length)) {\n        return;\n      }\n\n      breakOptions = {\n        color: that._options.containerColor,\n        borderColor: breakStyle.color,\n        isHorizontal: that._isHorizontal,\n        isWaved: \"straight\" !== breakStyle.line.toLowerCase()\n      };\n\n      if (customCanvas) {\n        positionFrom = customCanvas.start;\n        positionTo = customCanvas.end;\n      } else {\n        positionFrom = that._orthogonalPositions.start - (options.visible && !that._axisShift && (\"left\" === position || \"top\" === position) ? SCALE_BREAK_OFFSET : 0);\n        positionTo = that._orthogonalPositions.end + (options.visible && (\"right\" === position || \"bottom\" === position) ? SCALE_BREAK_OFFSET : 0);\n      }\n\n      mainGroup = that._createBreaksGroup(positionFrom, positionTo);\n\n      if (that._axisShift && options.visible) {\n        additionBreakFrom = that._axisPosition - that._axisShift - SCALE_BREAK_OFFSET;\n        additionBreakTo = additionBreakFrom + 2 * SCALE_BREAK_OFFSET;\n        additionGroup = that._createBreaksGroup(additionBreakFrom, additionBreakTo);\n      }\n\n      breaks.forEach(function (br) {\n        if (!br.gapSize) {\n          var breakCoord = that._getTranslatedCoord(br.to);\n\n          that._drawBreak(breakCoord, positionFrom, positionTo, breakStyle.width, breakOptions, mainGroup);\n\n          if (that._axisShift && options.visible) {\n            that._drawBreak(breakCoord, additionBreakFrom, additionBreakTo, breakStyle.width, breakOptions, additionGroup);\n          }\n        }\n      });\n    },\n    _getSpiderCategoryOption: _common.noop,\n    shift: function shift(margins) {\n      var that = this;\n      var options = that._options;\n      var isHorizontal = options.isHorizontal;\n      var axesSpacing = that.getMultipleAxesSpacing();\n      var constantLinesGroups = that._axisConstantLineGroups;\n\n      function shiftGroup(side, group) {\n        var attr = {\n          translateX: 0,\n          translateY: 0\n        };\n        var shift = margins[side] ? margins[side] + axesSpacing : 0;\n        attr[isHorizontal ? \"translateY\" : \"translateX\"] = (\"left\" === side || \"top\" === side ? -1 : 1) * shift;\n        (group[side] || group).attr(attr);\n        return shift;\n      }\n\n      that._axisShift = shiftGroup(options.position, that._axisGroup);\n      (isHorizontal ? [\"top\", \"bottom\"] : [\"left\", \"right\"]).forEach(function (side) {\n        shiftGroup(side, constantLinesGroups.above);\n        shiftGroup(side, constantLinesGroups.under);\n      });\n    }\n  }\n};\n\nfunction getLineDrawer(renderer, root, rotatePoints, positionFrom, breakStart, positionTo, isWaved) {\n  var elementType = isWaved ? \"bezier\" : \"line\";\n  var group = renderer.g().append(root);\n  return function (offset, attr) {\n    renderer.path(rotatePoints(getPoints(positionFrom, breakStart, positionTo, offset, isWaved)), elementType).attr(attr).append(group);\n  };\n}\n\nfunction getPoints(positionFrom, breakStart, positionTo, offset, isWaved) {\n  if (!isWaved) {\n    return [positionFrom, breakStart + offset, positionTo, breakStart + offset];\n  }\n\n  breakStart += offset;\n  var currentPosition;\n  var topPoint = breakStart + WAVED_LINE_TOP;\n  var centerPoint = breakStart + WAVED_LINE_CENTER;\n  var bottomPoint = breakStart + WAVED_LINE_BOTTOM;\n  var points = [[positionFrom, centerPoint]];\n\n  for (currentPosition = positionFrom; currentPosition < positionTo + WAVED_LINE_LENGTH; currentPosition += WAVED_LINE_LENGTH) {\n    points.push([currentPosition + 6, topPoint, currentPosition + 6, topPoint, currentPosition + 12, centerPoint, currentPosition + 18, bottomPoint, currentPosition + 18, bottomPoint, currentPosition + 24, centerPoint]);\n  }\n\n  return [].concat.apply([], points);\n}\n\nfunction rotateLine(lineCoords) {\n  var points = [];\n  var i;\n\n  for (i = 0; i < lineCoords.length; i += 2) {\n    points.push(lineCoords[i + 1]);\n    points.push(lineCoords[i]);\n  }\n\n  return points;\n}","map":{"version":3,"sources":["C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/devextreme/viz/axes/xy_axes.js"],"names":["_range","require","_range2","_interopRequireDefault","_format_helper","_date","_date2","_extend","_datetime_breaks","_common","_utils","_utils2","_type","_axes_constants","_axes_constants2","obj","getNextDateUnit","correctDateWithUnitBeginning","_math","_max","TOP","BOTTOM","LEFT","RIGHT","CENTER","SCALE_BREAK_OFFSET","RANGE_RATIO","WAVED_LINE_CENTER","WAVED_LINE_TOP","WAVED_LINE_BOTTOM","WAVED_LINE_LENGTH","TICKS_CORRECTIONS","left","top","right","bottom","center","tickInterval","datesDifferences","i","dateUnitInterval","a","b","minVisible","viewport","maxVisible","breakSize","breakStyle","from","currentBreak","to","lastResult","result","newBreak","cumulativeWidth","origMin","min","max","dates","position","markerInterval","format","prevDate","prepareDatesDifferences","act","rotationAngle","bBox","options","maxRange","ranges","length","points","curValue","prevValue","curRange","getRange","edgePoints","start","end","logarithmBase","_ref","type","maxAutoBreakCount","_ref2","breaks","visibleRange","s","sortedAllPoints","minDiff","epsilon","r","_maxAutoBreakCount","sortingBreaks","module","linear","_getStep","spacing","func","box","maxLabelLength","getMaxSide","getDistanceByAngle","width","height","_getMaxLabelHeight","_validateOverlappingMode","_validateDisplayMode","getMarkerTrackers","_getSharpParam","_createAxisElement","_updateAxisElementPosition","axisCoord","canvas","_getTranslatedCoord","_initAxisPositions","that","_getTickMarkPoints","isHorizontal","tickStartCoord","shift","tickOptions","coords","getTickStartPositionShift","Math","_getTitleCoords","horizontal","x","y","align","fromStartToEnd","canvasStart","canvasEnd","coord","_drawTitleText","titleOptions","attrs","opacity","cssClass","text","_updateTitleCoords","_drawTitle","title","element","_measureTitle","_drawDateMarker","markerOptions","invert","textIndent","pathElement","stroke","sharp","String","date","cropped","label","line","getEnd","setTitle","hideLabel","hide","_drawDateMarkers","translator","minBound","dateMarkers","labelOptions","withoutStick","markersAreaTop","getMarkerInterval","markerDates","getMarkerDates","marker","draw","getMarkerFormat","markers","dateMarker","_adjustDateMarkers","offset","prevDateMarker","labelBBox","dy","translateX","translateY","_checkMarkersPosition","_initializeMarkersTrackers","separatorHeight","renderer","businessRange","group","nextMarker","markerTracker","fill","startValue","endValue","_getLabelFormatOptions","markerLabelOptions","_adjustConstantLineLabels","axisPosition","canvasLeft","canvasRight","canvasTop","canvasBottom","verticalCenter","horizontalCenter","maxLabel","constantLines","linesOptions","item","paddingTopBottom","paddingLeftRight","labelVerticalAlignment","labelHorizontalAlignment","labelIsInside","_drawConstantLinesForEstimating","_estimateLabelHeight","drawingType","sinCos","estimateMargins","range","ticksData","ticks","constantLineOptions","l","rootElement","labelIsVisible","labelValue","labelElement","titleElement","constantLinesLabelsElement","labelBox","titleBox","constantLinesBox","titleHeight","labelHeight","constantLinesHeight","getMaxConstantLinePadding","margins","getLeftMargin","getRightMargin","getConstantLineLabelMarginForVerticalAlignment","_checkAlignmentConstantLineLabels","verticalAlignment","horizontalAlignment","_getConstantLineLabelsCoords","lineLabelOptions","_getAdjustedStripLabelCoords","stripOptions","strip","labelWidth","labelCoords","_adjustTitle","margin","boxTitle","loCoord","hiCoord","params","_checkTitleOverflow","canvasLength","wordWrap","textOverflow","moreThanOriginalSize","coordsIn","_boundaryTicksVisibility","adjust","seriesData","seriesRange","hasWrap","getAxisPosition","_getStick","_getStripLabelCoords","orthogonalPositions","stripLabelOptions","getStripVerticalAlignmentPosition","getStripHorizontalAlignmentPosition","_getTranslatedValue","pos1","pos2","areCoordsOutsideAxis","visibleArea","_getSkippedCategory","skippedCategory","_getScaleBreaks","axisOptions","generateAutoBreaks","filterBreaks","_drawBreak","breakStart","translatedEnd","attr","spaceAttr","getPoints","drawer","getLineDrawer","_createBreakClipRect","clipWidth","clipRect","_createBreaksGroup","_disposeBreaksGroup","drawScaleBreaks","breakOptions","color","borderColor","isWaved","positionFrom","customCanvas","positionTo","mainGroup","additionBreakFrom","additionBreakTo","additionGroup","br","breakCoord","_getSpiderCategoryOption","axesSpacing","constantLinesGroups","shiftGroup","elementType","rotatePoints","topPoint","centerPoint","bottomPoint","currentPosition","lineCoords"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (viz/axes/xy_axes.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nvar _range = require(\"../translators/range\");\r\nvar _range2 = _interopRequireDefault(_range);\r\nvar _format_helper = require(\"../../format_helper\");\r\nvar _date = require(\"../../core/utils/date\");\r\nvar _date2 = _interopRequireDefault(_date);\r\nvar _extend = require(\"../../core/utils/extend\");\r\nvar _datetime_breaks = require(\"./datetime_breaks\");\r\nvar _common = require(\"../../core/utils/common\");\r\nvar _utils = require(\"../core/utils\");\r\nvar _utils2 = _interopRequireDefault(_utils);\r\nvar _type = require(\"../../core/utils/type\");\r\nvar _axes_constants = require(\"./axes_constants\");\r\nvar _axes_constants2 = _interopRequireDefault(_axes_constants);\r\n\r\nfunction _interopRequireDefault(obj) {\r\n    return obj && obj.__esModule ? obj : {\r\n        \"default\": obj\r\n    }\r\n}\r\nvar getNextDateUnit = _date2.default.getNextDateUnit;\r\nvar correctDateWithUnitBeginning = _date2.default.correctDateWithUnitBeginning;\r\nvar _math = Math;\r\nvar _max = _math.max;\r\nvar TOP = _axes_constants2.default.top;\r\nvar BOTTOM = _axes_constants2.default.bottom;\r\nvar LEFT = _axes_constants2.default.left;\r\nvar RIGHT = _axes_constants2.default.right;\r\nvar CENTER = _axes_constants2.default.center;\r\nvar SCALE_BREAK_OFFSET = 3;\r\nvar RANGE_RATIO = .3;\r\nvar WAVED_LINE_CENTER = 2;\r\nvar WAVED_LINE_TOP = 0;\r\nvar WAVED_LINE_BOTTOM = 4;\r\nvar WAVED_LINE_LENGTH = 24;\r\nvar TICKS_CORRECTIONS = {\r\n    left: -1,\r\n    top: -1,\r\n    right: 0,\r\n    bottom: 0,\r\n    center: -.5\r\n};\r\n\r\nfunction prepareDatesDifferences(datesDifferences, tickInterval) {\r\n    var dateUnitInterval;\r\n    var i;\r\n    if (\"week\" === tickInterval) {\r\n        tickInterval = \"day\"\r\n    }\r\n    if (\"quarter\" === tickInterval) {\r\n        tickInterval = \"month\"\r\n    }\r\n    if (datesDifferences[tickInterval]) {\r\n        for (i = 0; i < _date2.default.dateUnitIntervals.length; i++) {\r\n            dateUnitInterval = _date2.default.dateUnitIntervals[i];\r\n            if (datesDifferences[dateUnitInterval]) {\r\n                datesDifferences[dateUnitInterval] = false;\r\n                datesDifferences.count--\r\n            }\r\n            if (dateUnitInterval === tickInterval) {\r\n                break\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction sortingBreaks(breaks) {\r\n    return breaks.sort(function(a, b) {\r\n        return a.from - b.from\r\n    })\r\n}\r\n\r\nfunction filterBreaks(breaks, viewport, breakStyle) {\r\n    var minVisible = viewport.minVisible;\r\n    var maxVisible = viewport.maxVisible;\r\n    var breakSize = breakStyle ? breakStyle.width : 0;\r\n    return breaks.reduce(function(result, currentBreak) {\r\n        var from = currentBreak.from;\r\n        var to = currentBreak.to;\r\n        var lastResult = result[result.length - 1];\r\n        var newBreak;\r\n        if (!(0, _type.isDefined)(from) || !(0, _type.isDefined)(to)) {\r\n            return result\r\n        }\r\n        if (from > to) {\r\n            to = [from, from = to][0]\r\n        }\r\n        if (result.length && from < lastResult.to) {\r\n            if (to > lastResult.to) {\r\n                lastResult.to = to > maxVisible ? maxVisible : to;\r\n                if (lastResult.gapSize) {\r\n                    lastResult.gapSize = void 0;\r\n                    lastResult.cumulativeWidth += breakSize\r\n                }\r\n            }\r\n        } else {\r\n            if ((from >= minVisible && from < maxVisible || to <= maxVisible && to > minVisible) && to - from < maxVisible - minVisible) {\r\n                from = from >= minVisible ? from : minVisible;\r\n                to = to <= maxVisible ? to : maxVisible;\r\n                newBreak = {\r\n                    from: from,\r\n                    to: to,\r\n                    cumulativeWidth: (lastResult ? lastResult.cumulativeWidth : 0) + breakSize\r\n                };\r\n                if (currentBreak.gapSize) {\r\n                    newBreak.gapSize = _date2.default.convertMillisecondsToDateUnits(to - from);\r\n                    newBreak.cumulativeWidth = lastResult ? lastResult.cumulativeWidth : 0\r\n                }\r\n                result.push(newBreak)\r\n            }\r\n        }\r\n        return result\r\n    }, [])\r\n}\r\n\r\nfunction getMarkerDates(min, max, markerInterval) {\r\n    var origMin = min;\r\n    var dates;\r\n    min = correctDateWithUnitBeginning(min, markerInterval);\r\n    max = correctDateWithUnitBeginning(max, markerInterval);\r\n    dates = _date2.default.getSequenceByInterval(min, max, markerInterval);\r\n    if (dates.length && origMin > dates[0]) {\r\n        dates = dates.slice(1)\r\n    }\r\n    return dates\r\n}\r\n\r\nfunction getStripHorizontalAlignmentPosition(alignment) {\r\n    var position = \"start\";\r\n    if (\"center\" === alignment) {\r\n        position = \"center\"\r\n    }\r\n    if (\"right\" === alignment) {\r\n        position = \"end\"\r\n    }\r\n    return position\r\n}\r\n\r\nfunction getStripVerticalAlignmentPosition(alignment) {\r\n    var position = \"start\";\r\n    if (\"center\" === alignment) {\r\n        position = \"center\"\r\n    }\r\n    if (\"bottom\" === alignment) {\r\n        position = \"end\"\r\n    }\r\n    return position\r\n}\r\n\r\nfunction getMarkerInterval(tickInterval) {\r\n    var markerInterval = getNextDateUnit(tickInterval);\r\n    if (\"quarter\" === markerInterval) {\r\n        markerInterval = getNextDateUnit(markerInterval)\r\n    }\r\n    return markerInterval\r\n}\r\n\r\nfunction getMarkerFormat(curDate, prevDate, tickInterval, markerInterval) {\r\n    var format = markerInterval;\r\n    var datesDifferences = prevDate && _date2.default.getDatesDifferences(prevDate, curDate);\r\n    if (prevDate && \"year\" !== tickInterval) {\r\n        prepareDatesDifferences(datesDifferences, tickInterval);\r\n        format = (0, _format_helper.getDateFormatByDifferences)(datesDifferences)\r\n    }\r\n    return format\r\n}\r\n\r\nfunction getMaxSide(act, boxes) {\r\n    return boxes.reduce(function(prevValue, box) {\r\n        return _max(prevValue, act(box))\r\n    }, 0)\r\n}\r\n\r\nfunction getDistanceByAngle(bBox, rotationAngle) {\r\n    rotationAngle = _math.abs(rotationAngle);\r\n    rotationAngle = rotationAngle % 180 >= 90 ? 90 - rotationAngle % 90 : rotationAngle % 90;\r\n    var a = rotationAngle * (_math.PI / 180);\r\n    if (a >= _math.atan(bBox.height / bBox.width)) {\r\n        return bBox.height / _math.abs(_math.sin(a))\r\n    } else {\r\n        return bBox.width\r\n    }\r\n}\r\n\r\nfunction getMaxConstantLinePadding(constantLines) {\r\n    return constantLines.reduce(function(padding, options) {\r\n        return _max(padding, options.paddingTopBottom)\r\n    }, 0)\r\n}\r\n\r\nfunction getConstantLineLabelMarginForVerticalAlignment(constantLines, alignment, labelHeight) {\r\n    return constantLines.some(function(options) {\r\n        return options.label.verticalAlignment === alignment\r\n    }) && labelHeight || 0\r\n}\r\n\r\nfunction getLeftMargin(bBox) {\r\n    return _math.abs(bBox.x) || 0\r\n}\r\n\r\nfunction getRightMargin(bBox) {\r\n    return _math.abs(bBox.width - _math.abs(bBox.x)) || 0\r\n}\r\n\r\nfunction generateRangesOnPoints(points, edgePoints, getRange) {\r\n    var i;\r\n    var length;\r\n    var maxRange = null;\r\n    var ranges = [];\r\n    var curValue;\r\n    var prevValue;\r\n    var curRange;\r\n    for (i = 1, length = points.length; i < length; i++) {\r\n        curValue = points[i];\r\n        prevValue = points[i - 1];\r\n        curRange = getRange(curValue, prevValue);\r\n        if (edgePoints.indexOf(curValue) >= 0) {\r\n            if (!maxRange || curRange > maxRange.length) {\r\n                maxRange = {\r\n                    start: curValue,\r\n                    end: prevValue,\r\n                    length: curRange\r\n                }\r\n            }\r\n        } else {\r\n            if (maxRange && curRange < maxRange.length) {\r\n                ranges.push(maxRange)\r\n            } else {\r\n                ranges.push({\r\n                    start: curValue,\r\n                    end: prevValue,\r\n                    length: curRange\r\n                })\r\n            }\r\n            maxRange = null\r\n        }\r\n    }\r\n    if (maxRange) {\r\n        ranges.push(maxRange)\r\n    }\r\n    return ranges\r\n}\r\n\r\nfunction generateAutoBreaks(_ref, series, _ref2) {\r\n    var logarithmBase = _ref.logarithmBase,\r\n        type = _ref.type,\r\n        maxAutoBreakCount = _ref.maxAutoBreakCount;\r\n    var minVisible = _ref2.minVisible,\r\n        maxVisible = _ref2.maxVisible;\r\n    var breaks = [];\r\n    var getRange = \"logarithmic\" === type ? function(min, max) {\r\n        return _utils2.default.getLog(max / min, logarithmBase)\r\n    } : function(min, max) {\r\n        return max - min\r\n    };\r\n    var visibleRange = getRange(minVisible, maxVisible);\r\n    var points = series.reduce(function(result, s) {\r\n        var points = s.getPointsInViewPort();\r\n        result[0] = result[0].concat(points[0]);\r\n        result[1] = result[1].concat(points[1]);\r\n        return result\r\n    }, [\r\n        [],\r\n        []\r\n    ]);\r\n    var sortedAllPoints = points[0].concat(points[1]).sort(function(a, b) {\r\n        return b - a\r\n    });\r\n    var edgePoints = points[1].filter(function(p) {\r\n        return points[0].indexOf(p) < 0\r\n    });\r\n    var minDiff = RANGE_RATIO * visibleRange;\r\n    var ranges = generateRangesOnPoints(sortedAllPoints, edgePoints, getRange).sort(function(a, b) {\r\n        return b.length - a.length\r\n    });\r\n    var epsilon = _math.min.apply(null, ranges.map(function(r) {\r\n        return r.length\r\n    })) / 1e3;\r\n    var _maxAutoBreakCount = (0, _type.isDefined)(maxAutoBreakCount) ? _math.min(maxAutoBreakCount, ranges.length) : ranges.length;\r\n    for (var i = 0; i < _maxAutoBreakCount; i++) {\r\n        if (ranges[i].length >= minDiff) {\r\n            if (visibleRange <= ranges[i].length) {\r\n                break\r\n            }\r\n            visibleRange -= ranges[i].length;\r\n            if (visibleRange > epsilon || visibleRange < -epsilon) {\r\n                breaks.push({\r\n                    from: ranges[i].start,\r\n                    to: ranges[i].end\r\n                });\r\n                minDiff = RANGE_RATIO * visibleRange\r\n            }\r\n        } else {\r\n            break\r\n        }\r\n    }\r\n    sortingBreaks(breaks);\r\n    return breaks\r\n}\r\nmodule.exports = {\r\n    linear: {\r\n        _getStep: function(boxes, rotationAngle) {\r\n            var spacing = this._options.label.minSpacing;\r\n            var func = this._isHorizontal ? function(box) {\r\n                return box.width + spacing\r\n            } : function(box) {\r\n                return box.height\r\n            };\r\n            var maxLabelLength = getMaxSide(func, boxes);\r\n            if (rotationAngle) {\r\n                maxLabelLength = getDistanceByAngle({\r\n                    width: maxLabelLength,\r\n                    height: this._getMaxLabelHeight(boxes, 0)\r\n                }, rotationAngle)\r\n            }\r\n            return _axes_constants2.default.getTicksCountInRange(this._majorTicks, this._isHorizontal ? \"x\" : \"y\", maxLabelLength)\r\n        },\r\n        _getMaxLabelHeight: function(boxes, spacing) {\r\n            return getMaxSide(function(box) {\r\n                return box.height\r\n            }, boxes) + spacing\r\n        },\r\n        _validateOverlappingMode: function(mode, displayMode) {\r\n            if (this._isHorizontal && (\"rotate\" === displayMode || \"stagger\" === displayMode) || !this._isHorizontal) {\r\n                return _axes_constants2.default.validateOverlappingMode(mode)\r\n            }\r\n            return mode\r\n        },\r\n        _validateDisplayMode: function(mode) {\r\n            return this._isHorizontal ? mode : \"standard\"\r\n        },\r\n        getMarkerTrackers: function() {\r\n            return this._markerTrackers\r\n        },\r\n        _getSharpParam: function(opposite) {\r\n            return this._isHorizontal ^ opposite ? \"h\" : \"v\"\r\n        },\r\n        _createAxisElement: function() {\r\n            return this._renderer.path([], \"line\")\r\n        },\r\n        _updateAxisElementPosition: function() {\r\n            var axisCoord = this._axisPosition;\r\n            var canvas = this._getCanvasStartEnd();\r\n            this._axisElement.attr({\r\n                points: this._isHorizontal ? [canvas.start, axisCoord, canvas.end, axisCoord] : [axisCoord, canvas.start, axisCoord, canvas.end]\r\n            })\r\n        },\r\n        _getTranslatedCoord: function(value, offset) {\r\n            return this._translator.translate(value, offset)\r\n        },\r\n        _initAxisPositions: function() {\r\n            var that = this;\r\n            var position = that._options.position;\r\n            that._axisPosition = that._orthogonalPositions[\"top\" === position || \"left\" === position ? \"start\" : \"end\"]\r\n        },\r\n        _getTickMarkPoints: function(coords, length, tickOptions) {\r\n            var isHorizontal = this._isHorizontal;\r\n            var options = this._options;\r\n            var tickStartCoord;\r\n            if ((0, _type.isDefined)(options.tickOrientation)) {\r\n                tickStartCoord = TICKS_CORRECTIONS[options.tickOrientation] * length\r\n            } else {\r\n                var shift = tickOptions.shift || 0;\r\n                if (\"left\" === options.position || \"top\" === options.position) {\r\n                    shift = -shift\r\n                }\r\n                tickStartCoord = shift + this.getTickStartPositionShift(length)\r\n            }\r\n            return [coords.x + (isHorizontal ? 0 : tickStartCoord), coords.y + (isHorizontal ? tickStartCoord : 0), coords.x + (isHorizontal ? 0 : tickStartCoord + length), coords.y + (isHorizontal ? tickStartCoord + length : 0)]\r\n        },\r\n        getTickStartPositionShift: function(length) {\r\n            var options = this._options;\r\n            return length % 2 === 1 ? options.width % 2 === 0 && (\"left\" === options.position || \"top\" === options.position) || options.width % 2 === 1 && (\"right\" === options.position || \"bottom\" === options.position) ? Math.floor(-length / 2) : -Math.floor(length / 2) : -length / 2 + (options.width % 2 === 0 ? 0 : \"bottom\" === options.position || \"right\" === options.position ? -1 : 1)\r\n        },\r\n        _getTitleCoords: function() {\r\n            var that = this;\r\n            var horizontal = that._isHorizontal;\r\n            var x = that._axisPosition;\r\n            var y = that._axisPosition;\r\n            var align = that._options.title.alignment;\r\n            var canvas = that._getCanvasStartEnd();\r\n            var fromStartToEnd = horizontal || that._options.position === LEFT;\r\n            var canvasStart = fromStartToEnd ? canvas.start : canvas.end;\r\n            var canvasEnd = fromStartToEnd ? canvas.end : canvas.start;\r\n            var coord = align === LEFT ? canvasStart : align === RIGHT ? canvasEnd : canvas.start + (canvas.end - canvas.start) / 2;\r\n            if (horizontal) {\r\n                x = coord\r\n            } else {\r\n                y = coord\r\n            }\r\n            return {\r\n                x: x,\r\n                y: y\r\n            }\r\n        },\r\n        _drawTitleText: function(group, coords) {\r\n            var options = this._options;\r\n            var titleOptions = options.title;\r\n            var attrs = {\r\n                opacity: titleOptions.opacity,\r\n                align: titleOptions.alignment,\r\n                \"class\": titleOptions.cssClass\r\n            };\r\n            if (!titleOptions.text || !group) {\r\n                return\r\n            }\r\n            coords = coords || this._getTitleCoords();\r\n            if (!this._isHorizontal) {\r\n                attrs.rotate = options.position === LEFT ? 270 : 90\r\n            }\r\n            var text = this._renderer.text(titleOptions.text, coords.x, coords.y).css(_utils2.default.patchFontOptions(titleOptions.font)).attr(attrs).append(group);\r\n            this._checkTitleOverflow(text);\r\n            return text\r\n        },\r\n        _updateTitleCoords: function() {\r\n            this._title && this._title.element.attr(this._getTitleCoords())\r\n        },\r\n        _drawTitle: function() {\r\n            var title = this._drawTitleText(this._axisTitleGroup);\r\n            if (title) {\r\n                this._title = {\r\n                    element: title\r\n                }\r\n            }\r\n        },\r\n        _measureTitle: function() {\r\n            if (this._title) {\r\n                if (this._title.bBox && !this._title.originalSize) {\r\n                    this._title.originalSize = this._title.bBox\r\n                }\r\n                this._title.bBox = this._title.element.getBBox()\r\n            }\r\n        },\r\n        _drawDateMarker: function(date, options, range) {\r\n            var that = this;\r\n            var markerOptions = that._options.marker;\r\n            var invert = that._translator.getBusinessRange().invert;\r\n            var textIndent = markerOptions.width + markerOptions.textLeftIndent;\r\n            var text;\r\n            var pathElement;\r\n            if (null === options.x) {\r\n                return\r\n            }\r\n            if (!options.withoutStick) {\r\n                pathElement = that._renderer.path([options.x, options.y, options.x, options.y + markerOptions.separatorHeight], \"line\").attr({\r\n                    \"stroke-width\": markerOptions.width,\r\n                    stroke: markerOptions.color,\r\n                    \"stroke-opacity\": markerOptions.opacity,\r\n                    sharp: \"h\"\r\n                }).append(that._axisElementsGroup)\r\n            }\r\n            text = String(that.formatLabel(date, options.labelOptions, range));\r\n            return {\r\n                date: date,\r\n                x: options.x,\r\n                y: options.y,\r\n                cropped: options.withoutStick,\r\n                label: that._renderer.text(text, options.x, options.y).css(_utils2.default.patchFontOptions(markerOptions.label.font)).append(that._axisElementsGroup),\r\n                line: pathElement,\r\n                getEnd: function() {\r\n                    return this.x + (invert ? -1 : 1) * (textIndent + this.labelBBox.width)\r\n                },\r\n                setTitle: function() {\r\n                    this.title = text\r\n                },\r\n                hideLabel: function() {\r\n                    this.label.dispose();\r\n                    this.label = null;\r\n                    this.title = text\r\n                },\r\n                hide: function() {\r\n                    if (pathElement) {\r\n                        pathElement.dispose();\r\n                        pathElement = null\r\n                    }\r\n                    this.label.dispose();\r\n                    this.label = null;\r\n                    this.hidden = true\r\n                }\r\n            }\r\n        },\r\n        _drawDateMarkers: function() {\r\n            var that = this;\r\n            var options = that._options;\r\n            var translator = that._translator;\r\n            var viewport = that._getViewportRange();\r\n            var minBound = viewport.minVisible;\r\n            var tickInterval;\r\n            var markerInterval;\r\n            var markerDates;\r\n            var dateMarkers = [];\r\n            var markersAreaTop;\r\n            var dateMarker;\r\n\r\n            function draw(markerDate, format, withoutStick) {\r\n                return that._drawDateMarker(markerDate, {\r\n                    x: translator.translate(markerDate),\r\n                    y: markersAreaTop,\r\n                    labelOptions: that._getLabelFormatOptions(format),\r\n                    withoutStick: withoutStick\r\n                }, viewport)\r\n            }\r\n            if (viewport.isEmpty() || !options.marker.visible || \"datetime\" !== options.argumentType || \"discrete\" === options.type || that._majorTicks.length <= 1) {\r\n                return []\r\n            }\r\n            markersAreaTop = that._axisPosition + options.marker.topIndent;\r\n            tickInterval = _date2.default.getDateUnitInterval(this._tickInterval);\r\n            markerInterval = getMarkerInterval(tickInterval);\r\n            markerDates = getMarkerDates(minBound, viewport.maxVisible, markerInterval);\r\n            if (markerDates.length > 1 || 1 === markerDates.length && minBound < markerDates[0]) {\r\n                dateMarkers = markerDates.reduce(function(markers, curDate, i, dates) {\r\n                    var marker = draw(curDate, getMarkerFormat(curDate, dates[i - 1] || minBound < curDate && minBound, tickInterval, markerInterval));\r\n                    marker && markers.push(marker);\r\n                    return markers\r\n                }, []);\r\n                if (minBound < markerDates[0]) {\r\n                    dateMarker = draw(minBound, getMarkerFormat(minBound, markerDates[0], tickInterval, markerInterval), true);\r\n                    dateMarker && dateMarkers.unshift(dateMarker)\r\n                }\r\n            }\r\n            return dateMarkers\r\n        },\r\n        _adjustDateMarkers: function(offset) {\r\n            offset = offset || 0;\r\n            var that = this;\r\n            var markerOptions = this._options.marker;\r\n            var textIndent = markerOptions.width + markerOptions.textLeftIndent;\r\n            var invert = this._translator.getBusinessRange().invert;\r\n            var canvas = that._getCanvasStartEnd();\r\n            var dateMarkers = this._dateMarkers;\r\n            if (!dateMarkers.length) {\r\n                return offset\r\n            }\r\n            if (dateMarkers[0].cropped) {\r\n                if (!this._checkMarkersPosition(invert, dateMarkers[1], dateMarkers[0])) {\r\n                    dateMarkers[0].hideLabel()\r\n                }\r\n            }\r\n            var prevDateMarker;\r\n            dateMarkers.forEach(function(marker, i, markers) {\r\n                if (marker.cropped) {\r\n                    return\r\n                }\r\n                if (invert ? marker.getEnd() < canvas.end : marker.getEnd() > canvas.end) {\r\n                    marker.hideLabel()\r\n                } else {\r\n                    if (that._checkMarkersPosition(invert, marker, prevDateMarker)) {\r\n                        prevDateMarker = marker\r\n                    } else {\r\n                        marker.hide()\r\n                    }\r\n                }\r\n            });\r\n            this._dateMarkers.forEach(function(marker) {\r\n                if (marker.label) {\r\n                    var labelBBox = marker.labelBBox;\r\n                    var dy = marker.y + markerOptions.textTopIndent - labelBBox.y;\r\n                    marker.label.attr({\r\n                        translateX: invert ? marker.x - textIndent - labelBBox.x - labelBBox.width : marker.x + textIndent - labelBBox.x,\r\n                        translateY: dy + offset\r\n                    })\r\n                }\r\n                if (marker.line) {\r\n                    marker.line.attr({\r\n                        translateY: offset\r\n                    })\r\n                }\r\n            });\r\n            that._initializeMarkersTrackers(offset);\r\n            return offset + markerOptions.topIndent + markerOptions.separatorHeight\r\n        },\r\n        _checkMarkersPosition: function(invert, dateMarker, prevDateMarker) {\r\n            if (void 0 === prevDateMarker) {\r\n                return true\r\n            }\r\n            return invert ? dateMarker.x < prevDateMarker.getEnd() : dateMarker.x > prevDateMarker.getEnd()\r\n        },\r\n        _initializeMarkersTrackers: function(offset) {\r\n            var that = this;\r\n            var separatorHeight = that._options.marker.separatorHeight;\r\n            var renderer = that._renderer;\r\n            var businessRange = this._translator.getBusinessRange();\r\n            var canvas = that._getCanvasStartEnd();\r\n            var group = that._axisElementsGroup;\r\n            that._markerTrackers = this._dateMarkers.filter(function(marker) {\r\n                return !marker.hidden\r\n            }).map(function(marker, i, markers) {\r\n                var nextMarker = markers[i + 1] || {\r\n                    x: canvas.end,\r\n                    date: businessRange.max\r\n                };\r\n                var x = marker.x;\r\n                var y = marker.y + offset;\r\n                var markerTracker = renderer.path([x, y, x, y + separatorHeight, nextMarker.x, y + separatorHeight, nextMarker.x, y, x, y], \"area\").attr({\r\n                    \"stroke-width\": 1,\r\n                    stroke: \"grey\",\r\n                    fill: \"grey\",\r\n                    opacity: 1e-4\r\n                }).append(group);\r\n                markerTracker.data(\"range\", {\r\n                    startValue: marker.date,\r\n                    endValue: nextMarker.date\r\n                });\r\n                if (marker.title) {\r\n                    markerTracker.setTitle(marker.title)\r\n                }\r\n                return markerTracker\r\n            })\r\n        },\r\n        _getLabelFormatOptions: function(formatString) {\r\n            var that = this;\r\n            var markerLabelOptions = that._markerLabelOptions;\r\n            if (!markerLabelOptions) {\r\n                that._markerLabelOptions = markerLabelOptions = (0, _extend.extend)(true, {}, that._options.marker.label)\r\n            }\r\n            if (!(0, _type.isDefined)(that._options.marker.label.format)) {\r\n                markerLabelOptions.format = formatString\r\n            }\r\n            return markerLabelOptions\r\n        },\r\n        _adjustConstantLineLabels: function(constantLines) {\r\n            var that = this;\r\n            var axisPosition = that._options.position;\r\n            var canvas = that.getCanvas();\r\n            var canvasLeft = canvas.left;\r\n            var canvasRight = canvas.width - canvas.right;\r\n            var canvasTop = canvas.top;\r\n            var canvasBottom = canvas.height - canvas.bottom;\r\n            var verticalCenter = canvasTop + (canvasBottom - canvasTop) / 2;\r\n            var horizontalCenter = canvasLeft + (canvasRight - canvasLeft) / 2;\r\n            var maxLabel = 0;\r\n            constantLines.forEach(function(item) {\r\n                var isHorizontal = that._isHorizontal;\r\n                var linesOptions = item.options;\r\n                var paddingTopBottom = linesOptions.paddingTopBottom;\r\n                var paddingLeftRight = linesOptions.paddingLeftRight;\r\n                var labelOptions = linesOptions.label;\r\n                var labelVerticalAlignment = labelOptions.verticalAlignment;\r\n                var labelHorizontalAlignment = labelOptions.horizontalAlignment;\r\n                var labelIsInside = \"inside\" === labelOptions.position;\r\n                var label = item.label;\r\n                var box = item.labelBBox;\r\n                var translateX;\r\n                var translateY;\r\n                if (null === label || box.isEmpty) {\r\n                    return\r\n                }\r\n                if (isHorizontal) {\r\n                    if (labelIsInside) {\r\n                        if (labelHorizontalAlignment === LEFT) {\r\n                            translateX = item.coord - paddingLeftRight - box.x - box.width\r\n                        } else {\r\n                            translateX = item.coord + paddingLeftRight - box.x\r\n                        }\r\n                        switch (labelVerticalAlignment) {\r\n                            case CENTER:\r\n                                translateY = verticalCenter - box.y - box.height / 2;\r\n                                break;\r\n                            case BOTTOM:\r\n                                translateY = canvasBottom - paddingTopBottom - box.y - box.height;\r\n                                break;\r\n                            default:\r\n                                translateY = canvasTop + paddingTopBottom - box.y\r\n                        }\r\n                    } else {\r\n                        if (axisPosition === labelVerticalAlignment) {\r\n                            maxLabel = _max(maxLabel, box.height + paddingTopBottom)\r\n                        }\r\n                        translateX = item.coord - box.x - box.width / 2;\r\n                        if (labelVerticalAlignment === BOTTOM) {\r\n                            translateY = canvasBottom + paddingTopBottom - box.y\r\n                        } else {\r\n                            translateY = canvasTop - paddingTopBottom - box.y - box.height\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (labelIsInside) {\r\n                        if (labelVerticalAlignment === BOTTOM) {\r\n                            translateY = item.coord + paddingTopBottom - box.y\r\n                        } else {\r\n                            translateY = item.coord - paddingTopBottom - box.y - box.height\r\n                        }\r\n                        switch (labelHorizontalAlignment) {\r\n                            case CENTER:\r\n                                translateX = horizontalCenter - box.x - box.width / 2;\r\n                                break;\r\n                            case RIGHT:\r\n                                translateX = canvasRight - paddingLeftRight - box.x - box.width;\r\n                                break;\r\n                            default:\r\n                                translateX = canvasLeft + paddingLeftRight - box.x\r\n                        }\r\n                    } else {\r\n                        if (axisPosition === labelHorizontalAlignment) {\r\n                            maxLabel = _max(maxLabel, box.width + paddingLeftRight)\r\n                        }\r\n                        translateY = item.coord - box.y - box.height / 2;\r\n                        if (labelHorizontalAlignment === RIGHT) {\r\n                            translateX = canvasRight + paddingLeftRight - box.x\r\n                        } else {\r\n                            translateX = canvasLeft - paddingLeftRight - box.x - box.width\r\n                        }\r\n                    }\r\n                }\r\n                label.attr({\r\n                    translateX: translateX,\r\n                    translateY: translateY\r\n                })\r\n            });\r\n            return maxLabel\r\n        },\r\n        _drawConstantLinesForEstimating: function(constantLines) {\r\n            var that = this;\r\n            var renderer = this._renderer;\r\n            var group = renderer.g();\r\n            constantLines.forEach(function(options) {\r\n                that._drawConstantLineLabelText(options.label.text, 0, 0, options.label, group).attr({\r\n                    align: \"center\"\r\n                })\r\n            });\r\n            return group.append(renderer.root)\r\n        },\r\n        _estimateLabelHeight: function(bBox, labelOptions) {\r\n            var height = bBox.height;\r\n            var drawingType = labelOptions.drawingType;\r\n            if (\"stagger\" === this._validateDisplayMode(drawingType) || \"stagger\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\r\n                height = 2 * height + labelOptions.staggeringSpacing\r\n            }\r\n            if (\"rotate\" === this._validateDisplayMode(drawingType) || \"rotate\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\r\n                var sinCos = _utils2.default.getCosAndSin(labelOptions.rotationAngle);\r\n                height = height * sinCos.cos + bBox.width * sinCos.sin\r\n            }\r\n            return height && (height + labelOptions.indentFromAxis || 0) || 0\r\n        },\r\n        estimateMargins: function(canvas) {\r\n            this.updateCanvas(canvas);\r\n            var that = this;\r\n            var range = that._getViewportRange();\r\n            var ticksData = this._createTicksAndLabelFormat(range);\r\n            var ticks = ticksData.ticks;\r\n            var tickInterval = ticksData.tickInterval;\r\n            var options = this._options;\r\n            var constantLineOptions = that._outsideConstantLines.filter(function(l) {\r\n                return l.labelOptions.visible\r\n            }).map(function(l) {\r\n                return l.options\r\n            });\r\n            var rootElement = that._renderer.root;\r\n            var labelIsVisible = options.label.visible && !range.isEmpty() && ticks.length;\r\n            var labelValue = labelIsVisible && that.formatLabel(ticks[ticks.length - 1], options.label, void 0, void 0, tickInterval, ticks);\r\n            var labelElement = labelIsVisible && that._renderer.text(labelValue, 0, 0).css(that._textFontStyles).attr(that._textOptions).append(rootElement);\r\n            var titleElement = that._drawTitleText(rootElement, {\r\n                x: 0,\r\n                y: 0\r\n            });\r\n            var constantLinesLabelsElement = that._drawConstantLinesForEstimating(constantLineOptions);\r\n            var labelBox = labelElement && labelElement.getBBox() || {\r\n                x: 0,\r\n                y: 0,\r\n                width: 0,\r\n                height: 0\r\n            };\r\n            var titleBox = titleElement && titleElement.getBBox() || {\r\n                x: 0,\r\n                y: 0,\r\n                width: 0,\r\n                height: 0\r\n            };\r\n            var constantLinesBox = constantLinesLabelsElement.getBBox();\r\n            var titleHeight = titleBox.height ? titleBox.height + options.title.margin : 0;\r\n            var labelHeight = that._estimateLabelHeight(labelBox, options.label);\r\n            var constantLinesHeight = constantLinesBox.height ? constantLinesBox.height + getMaxConstantLinePadding(constantLineOptions) : 0;\r\n            var height = labelHeight + titleHeight;\r\n            var margins = {\r\n                left: _max(getLeftMargin(labelBox), getLeftMargin(constantLinesBox)),\r\n                right: _max(getRightMargin(labelBox), getRightMargin(constantLinesBox)),\r\n                top: (\"top\" === options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"top\", constantLinesHeight),\r\n                bottom: (\"top\" !== options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"bottom\", constantLinesHeight)\r\n            };\r\n            labelElement && labelElement.remove();\r\n            titleElement && titleElement.remove();\r\n            constantLinesLabelsElement && constantLinesLabelsElement.remove();\r\n            return margins\r\n        },\r\n        _checkAlignmentConstantLineLabels: function(labelOptions) {\r\n            var position = labelOptions.position;\r\n            var verticalAlignment = (labelOptions.verticalAlignment || \"\").toLowerCase();\r\n            var horizontalAlignment = (labelOptions.horizontalAlignment || \"\").toLowerCase();\r\n            if (this._isHorizontal) {\r\n                if (\"outside\" === position) {\r\n                    verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\r\n                    horizontalAlignment = CENTER\r\n                } else {\r\n                    verticalAlignment = verticalAlignment === CENTER ? CENTER : verticalAlignment === BOTTOM ? BOTTOM : TOP;\r\n                    horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT\r\n                }\r\n            } else {\r\n                if (\"outside\" === position) {\r\n                    verticalAlignment = CENTER;\r\n                    horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT\r\n                } else {\r\n                    verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\r\n                    horizontalAlignment = horizontalAlignment === RIGHT ? RIGHT : horizontalAlignment === CENTER ? CENTER : LEFT\r\n                }\r\n            }\r\n            labelOptions.verticalAlignment = verticalAlignment;\r\n            labelOptions.horizontalAlignment = horizontalAlignment\r\n        },\r\n        _getConstantLineLabelsCoords: function(value, lineLabelOptions) {\r\n            var that = this;\r\n            var x = value;\r\n            var y = value;\r\n            if (that._isHorizontal) {\r\n                y = that._orthogonalPositions[\"top\" === lineLabelOptions.verticalAlignment ? \"start\" : \"end\"]\r\n            } else {\r\n                x = that._orthogonalPositions[\"right\" === lineLabelOptions.horizontalAlignment ? \"end\" : \"start\"]\r\n            }\r\n            return {\r\n                x: x,\r\n                y: y\r\n            }\r\n        },\r\n        _getAdjustedStripLabelCoords: function(strip) {\r\n            var stripOptions = strip.options;\r\n            var paddingTopBottom = stripOptions.paddingTopBottom;\r\n            var paddingLeftRight = stripOptions.paddingLeftRight;\r\n            var horizontalAlignment = stripOptions.label.horizontalAlignment;\r\n            var verticalAlignment = stripOptions.label.verticalAlignment;\r\n            var box = strip.labelBBox;\r\n            var labelHeight = box.height;\r\n            var labelWidth = box.width;\r\n            var labelCoords = strip.labelCoords;\r\n            var y = labelCoords.y - box.y;\r\n            var x = labelCoords.x - box.x;\r\n            if (verticalAlignment === TOP) {\r\n                y += paddingTopBottom\r\n            } else {\r\n                if (verticalAlignment === CENTER) {\r\n                    y -= labelHeight / 2\r\n                } else {\r\n                    if (verticalAlignment === BOTTOM) {\r\n                        y -= paddingTopBottom + labelHeight\r\n                    }\r\n                }\r\n            }\r\n            if (horizontalAlignment === LEFT) {\r\n                x += paddingLeftRight\r\n            } else {\r\n                if (horizontalAlignment === CENTER) {\r\n                    x -= labelWidth / 2\r\n                } else {\r\n                    if (horizontalAlignment === RIGHT) {\r\n                        x -= paddingLeftRight + labelWidth\r\n                    }\r\n                }\r\n            }\r\n            return {\r\n                translateX: x,\r\n                translateY: y\r\n            }\r\n        },\r\n        _adjustTitle: function(offset) {\r\n            offset = offset || 0;\r\n            if (!this._title) {\r\n                return\r\n            }\r\n            var that = this;\r\n            var options = that._options;\r\n            var position = options.position;\r\n            var margin = options.title.margin;\r\n            var title = that._title;\r\n            var boxTitle = title.bBox;\r\n            var x = boxTitle.x;\r\n            var y = boxTitle.y;\r\n            var width = boxTitle.width;\r\n            var height = boxTitle.height;\r\n            var axisPosition = that._axisPosition;\r\n            var loCoord = axisPosition - margin - offset;\r\n            var hiCoord = axisPosition + margin + offset;\r\n            var params = {};\r\n            if (that._isHorizontal) {\r\n                if (position === TOP) {\r\n                    params.translateY = loCoord - (y + height)\r\n                } else {\r\n                    params.translateY = hiCoord - y\r\n                }\r\n            } else {\r\n                if (position === LEFT) {\r\n                    params.translateX = loCoord - (x + width)\r\n                } else {\r\n                    params.translateX = hiCoord - x\r\n                }\r\n            }\r\n            title.element.attr(params)\r\n        },\r\n        _checkTitleOverflow: function(titleElement) {\r\n            if (!this._title && !titleElement) {\r\n                return\r\n            }\r\n            var canvasLength = this._getScreenDelta();\r\n            var title = titleElement ? {\r\n                bBox: titleElement.getBBox(),\r\n                element: titleElement\r\n            } : this._title;\r\n            var titleOptions = this._options.title;\r\n            var boxTitle = title.bBox;\r\n            if ((this._isHorizontal ? boxTitle.width : boxTitle.height) > canvasLength) {\r\n                title.element.setMaxSize(canvasLength, void 0, {\r\n                    wordWrap: titleOptions.wordWrap || \"none\",\r\n                    textOverflow: titleOptions.textOverflow || \"ellipsis\"\r\n                });\r\n                this._wrapped = titleOptions.wordWrap && \"none\" !== titleOptions.wordWrap\r\n            } else {\r\n                var moreThanOriginalSize = title.originalSize && canvasLength > (this._isHorizontal ? title.originalSize.width : title.originalSize.height);\r\n                !this._wrapped && moreThanOriginalSize && title.element.restoreText()\r\n            }\r\n        },\r\n        coordsIn: function(x, y) {\r\n            var canvas = this.getCanvas();\r\n            var isHorizontal = this._options.isHorizontal;\r\n            var position = this._options.position;\r\n            var coord = isHorizontal ? y : x;\r\n            if (isHorizontal && (x < canvas.left || x > canvas.width - canvas.right) || !isHorizontal && (y < canvas.top || y > canvas.height - canvas.bottom)) {\r\n                return false\r\n            }\r\n            if (isHorizontal && position === _axes_constants2.default.top || !isHorizontal && position === _axes_constants2.default.left) {\r\n                return coord < canvas[position]\r\n            }\r\n            return coord > canvas[isHorizontal ? \"height\" : \"width\"] - canvas[position]\r\n        },\r\n        _boundaryTicksVisibility: {\r\n            min: true,\r\n            max: true\r\n        },\r\n        adjust: function(alignToBounds) {\r\n            var that = this;\r\n            var seriesData = that._seriesData;\r\n            var viewport = {\r\n                min: seriesData.min,\r\n                max: seriesData.max\r\n            };\r\n            if (!alignToBounds) {\r\n                viewport = that._series.filter(function(s) {\r\n                    return s.isVisible()\r\n                }).reduce(function(range, s) {\r\n                    var seriesRange = s.getViewport();\r\n                    range.min = (0, _type.isDefined)(seriesRange.min) ? range.min < seriesRange.min ? range.min : seriesRange.min : range.min;\r\n                    range.max = (0, _type.isDefined)(seriesRange.max) ? range.max > seriesRange.max ? range.max : seriesRange.max : range.max;\r\n                    if (s.showZero) {\r\n                        range = new _range2.default.Range(range);\r\n                        range.correctValueZeroLevel()\r\n                    }\r\n                    return range\r\n                }, {})\r\n            }\r\n            if ((0, _type.isDefined)(viewport.min) && (0, _type.isDefined)(viewport.max)) {\r\n                seriesData.minVisible = viewport.min;\r\n                seriesData.maxVisible = viewport.max\r\n            }\r\n            that._translator.updateBusinessRange(that.adjustViewport(seriesData));\r\n            that._breaks = that._getScaleBreaks(that._options, {\r\n                minVisible: seriesData.minVisible,\r\n                maxVisible: seriesData.maxVisible\r\n            }, that._series, that.isArgumentAxis)\r\n        },\r\n        hasWrap: function() {\r\n            return this._wrapped\r\n        },\r\n        getAxisPosition: function() {\r\n            return this._axisPosition\r\n        },\r\n        _getStick: function() {\r\n            return !this._options.valueMarginsEnabled\r\n        },\r\n        _getStripLabelCoords: function(from, to, stripLabelOptions) {\r\n            var that = this;\r\n            var orthogonalPositions = that._orthogonalPositions;\r\n            var isHorizontal = that._isHorizontal;\r\n            var horizontalAlignment = stripLabelOptions.horizontalAlignment;\r\n            var verticalAlignment = stripLabelOptions.verticalAlignment;\r\n            var x;\r\n            var y;\r\n            if (isHorizontal) {\r\n                if (horizontalAlignment === CENTER) {\r\n                    x = from + (to - from) / 2\r\n                } else {\r\n                    if (horizontalAlignment === LEFT) {\r\n                        x = from\r\n                    } else {\r\n                        if (horizontalAlignment === RIGHT) {\r\n                            x = to\r\n                        }\r\n                    }\r\n                }\r\n                y = orthogonalPositions[getStripVerticalAlignmentPosition(verticalAlignment)]\r\n            } else {\r\n                x = orthogonalPositions[getStripHorizontalAlignmentPosition(horizontalAlignment)];\r\n                if (verticalAlignment === TOP) {\r\n                    y = from\r\n                } else {\r\n                    if (verticalAlignment === CENTER) {\r\n                        y = to + (from - to) / 2\r\n                    } else {\r\n                        if (verticalAlignment === BOTTOM) {\r\n                            y = to\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return {\r\n                x: x,\r\n                y: y\r\n            }\r\n        },\r\n        _getTranslatedValue: function(value, offset) {\r\n            var pos1 = this._translator.translate(value, offset, \"semidiscrete\" === this._options.type && this._options.tickInterval);\r\n            var pos2 = this._axisPosition;\r\n            var isHorizontal = this._isHorizontal;\r\n            return {\r\n                x: isHorizontal ? pos1 : pos2,\r\n                y: isHorizontal ? pos2 : pos1\r\n            }\r\n        },\r\n        areCoordsOutsideAxis: function(coords) {\r\n            var coord = this._isHorizontal ? coords.x : coords.y;\r\n            var visibleArea = this.getVisibleArea();\r\n            if (coord < visibleArea[0] || coord > visibleArea[1]) {\r\n                return true\r\n            }\r\n            return false\r\n        },\r\n        _getSkippedCategory: function(ticks) {\r\n            var skippedCategory;\r\n            if (this._options.type === _axes_constants2.default.discrete && this._tickOffset && 0 !== ticks.length) {\r\n                skippedCategory = ticks[ticks.length - 1]\r\n            }\r\n            return skippedCategory\r\n        },\r\n        _getScaleBreaks: function(axisOptions, viewport, series, isArgumentAxis) {\r\n            var that = this;\r\n            var breaks = (axisOptions.breaks || []).map(function(b) {\r\n                return {\r\n                    from: that.parser(b.startValue),\r\n                    to: that.parser(b.endValue)\r\n                }\r\n            });\r\n            if (\"discrete\" !== axisOptions.type && \"datetime\" === axisOptions.dataType && axisOptions.workdaysOnly) {\r\n                breaks = breaks.concat((0, _datetime_breaks.generateDateBreaks)(viewport.minVisible, viewport.maxVisible, axisOptions.workWeek, axisOptions.singleWorkdays, axisOptions.holidays))\r\n            }\r\n            if (!isArgumentAxis && \"discrete\" !== axisOptions.type && \"datetime\" !== axisOptions.dataType && axisOptions.autoBreaksEnabled && 0 !== axisOptions.maxAutoBreakCount) {\r\n                breaks = breaks.concat(generateAutoBreaks(axisOptions, series, viewport))\r\n            }\r\n            return filterBreaks(sortingBreaks(breaks), viewport, axisOptions.breakStyle)\r\n        },\r\n        _drawBreak: function(translatedEnd, positionFrom, positionTo, width, options, group) {\r\n            var that = this;\r\n            var breakStart = translatedEnd - (!that._translator.isInverted() ? width + 1 : 0);\r\n            var attr = {\r\n                \"stroke-width\": 1,\r\n                stroke: options.borderColor,\r\n                sharp: !options.isWaved ? options.isHorizontal ? \"h\" : \"v\" : void 0\r\n            };\r\n            var spaceAttr = {\r\n                stroke: options.color,\r\n                \"stroke-width\": width\r\n            };\r\n            var getPoints = that._isHorizontal ? rotateLine : function(p) {\r\n                return p\r\n            };\r\n            var drawer = getLineDrawer(that._renderer, group, getPoints, positionFrom, breakStart, positionTo, options.isWaved);\r\n            drawer(width / 2, spaceAttr);\r\n            drawer(0, attr);\r\n            drawer(width, attr)\r\n        },\r\n        _createBreakClipRect: function(from, to) {\r\n            var that = this;\r\n            var canvas = that._canvas;\r\n            var clipWidth = to - from;\r\n            var clipRect;\r\n            if (that._isHorizontal) {\r\n                clipRect = that._renderer.clipRect(canvas.left, from, canvas.width, clipWidth)\r\n            } else {\r\n                clipRect = that._renderer.clipRect(from, canvas.top, clipWidth, canvas.height)\r\n            }\r\n            that._breaksElements = that._breaksElements || [];\r\n            that._breaksElements.push(clipRect);\r\n            return clipRect.id\r\n        },\r\n        _createBreaksGroup: function(clipFrom, clipTo) {\r\n            var that = this;\r\n            var group = that._renderer.g().attr({\r\n                \"class\": that._axisCssPrefix + \"breaks\",\r\n                \"clip-path\": that._createBreakClipRect(clipFrom, clipTo)\r\n            }).append(that._scaleBreaksGroup);\r\n            that._breaksElements = that._breaksElements || [];\r\n            that._breaksElements.push(group);\r\n            return group\r\n        },\r\n        _disposeBreaksGroup: function() {\r\n            (this._breaksElements || []).forEach(function(clipRect) {\r\n                clipRect.dispose()\r\n            });\r\n            this._breaksElements = null\r\n        },\r\n        drawScaleBreaks: function(customCanvas) {\r\n            var that = this;\r\n            var options = that._options;\r\n            var breakStyle = options.breakStyle;\r\n            var position = options.position;\r\n            var positionFrom;\r\n            var positionTo;\r\n            var breaks = that._translator.getBusinessRange().breaks || [];\r\n            var additionGroup;\r\n            var additionBreakFrom;\r\n            var additionBreakTo;\r\n            var mainGroup;\r\n            var breakOptions;\r\n            that._disposeBreaksGroup();\r\n            if (!(breaks && breaks.length)) {\r\n                return\r\n            }\r\n            breakOptions = {\r\n                color: that._options.containerColor,\r\n                borderColor: breakStyle.color,\r\n                isHorizontal: that._isHorizontal,\r\n                isWaved: \"straight\" !== breakStyle.line.toLowerCase()\r\n            };\r\n            if (customCanvas) {\r\n                positionFrom = customCanvas.start;\r\n                positionTo = customCanvas.end\r\n            } else {\r\n                positionFrom = that._orthogonalPositions.start - (options.visible && !that._axisShift && (\"left\" === position || \"top\" === position) ? SCALE_BREAK_OFFSET : 0);\r\n                positionTo = that._orthogonalPositions.end + (options.visible && (\"right\" === position || \"bottom\" === position) ? SCALE_BREAK_OFFSET : 0)\r\n            }\r\n            mainGroup = that._createBreaksGroup(positionFrom, positionTo);\r\n            if (that._axisShift && options.visible) {\r\n                additionBreakFrom = that._axisPosition - that._axisShift - SCALE_BREAK_OFFSET;\r\n                additionBreakTo = additionBreakFrom + 2 * SCALE_BREAK_OFFSET;\r\n                additionGroup = that._createBreaksGroup(additionBreakFrom, additionBreakTo)\r\n            }\r\n            breaks.forEach(function(br) {\r\n                if (!br.gapSize) {\r\n                    var breakCoord = that._getTranslatedCoord(br.to);\r\n                    that._drawBreak(breakCoord, positionFrom, positionTo, breakStyle.width, breakOptions, mainGroup);\r\n                    if (that._axisShift && options.visible) {\r\n                        that._drawBreak(breakCoord, additionBreakFrom, additionBreakTo, breakStyle.width, breakOptions, additionGroup)\r\n                    }\r\n                }\r\n            })\r\n        },\r\n        _getSpiderCategoryOption: _common.noop,\r\n        shift: function(margins) {\r\n            var that = this;\r\n            var options = that._options;\r\n            var isHorizontal = options.isHorizontal;\r\n            var axesSpacing = that.getMultipleAxesSpacing();\r\n            var constantLinesGroups = that._axisConstantLineGroups;\r\n\r\n            function shiftGroup(side, group) {\r\n                var attr = {\r\n                    translateX: 0,\r\n                    translateY: 0\r\n                };\r\n                var shift = margins[side] ? margins[side] + axesSpacing : 0;\r\n                attr[isHorizontal ? \"translateY\" : \"translateX\"] = (\"left\" === side || \"top\" === side ? -1 : 1) * shift;\r\n                (group[side] || group).attr(attr);\r\n                return shift\r\n            }\r\n            that._axisShift = shiftGroup(options.position, that._axisGroup);\r\n            (isHorizontal ? [\"top\", \"bottom\"] : [\"left\", \"right\"]).forEach(function(side) {\r\n                shiftGroup(side, constantLinesGroups.above);\r\n                shiftGroup(side, constantLinesGroups.under)\r\n            })\r\n        }\r\n    }\r\n};\r\n\r\nfunction getLineDrawer(renderer, root, rotatePoints, positionFrom, breakStart, positionTo, isWaved) {\r\n    var elementType = isWaved ? \"bezier\" : \"line\";\r\n    var group = renderer.g().append(root);\r\n    return function(offset, attr) {\r\n        renderer.path(rotatePoints(getPoints(positionFrom, breakStart, positionTo, offset, isWaved)), elementType).attr(attr).append(group)\r\n    }\r\n}\r\n\r\nfunction getPoints(positionFrom, breakStart, positionTo, offset, isWaved) {\r\n    if (!isWaved) {\r\n        return [positionFrom, breakStart + offset, positionTo, breakStart + offset]\r\n    }\r\n    breakStart += offset;\r\n    var currentPosition;\r\n    var topPoint = breakStart + WAVED_LINE_TOP;\r\n    var centerPoint = breakStart + WAVED_LINE_CENTER;\r\n    var bottomPoint = breakStart + WAVED_LINE_BOTTOM;\r\n    var points = [\r\n        [positionFrom, centerPoint]\r\n    ];\r\n    for (currentPosition = positionFrom; currentPosition < positionTo + WAVED_LINE_LENGTH; currentPosition += WAVED_LINE_LENGTH) {\r\n        points.push([currentPosition + 6, topPoint, currentPosition + 6, topPoint, currentPosition + 12, centerPoint, currentPosition + 18, bottomPoint, currentPosition + 18, bottomPoint, currentPosition + 24, centerPoint])\r\n    }\r\n    return [].concat.apply([], points)\r\n}\r\n\r\nfunction rotateLine(lineCoords) {\r\n    var points = [];\r\n    var i;\r\n    for (i = 0; i < lineCoords.length; i += 2) {\r\n        points.push(lineCoords[i + 1]);\r\n        points.push(lineCoords[i])\r\n    }\r\n    return points\r\n}\r\n"]},"metadata":{},"sourceType":"module"}