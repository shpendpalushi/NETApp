{"ast":null,"code":"/**\r\n * DevExtreme (viz/series/line_series.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar series = require(\"./scatter_series\");\n\nvar chartScatterSeries = series.chart;\nvar polarScatterSeries = series.polar;\n\nvar objectUtils = require(\"../../core/utils/object\");\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar each = require(\"../../core/utils/iterator\").each;\n\nvar vizUtils = require(\"../core/utils\");\n\nvar mathUtils = require(\"../../core/utils/math\");\n\nvar normalizeAngle = vizUtils.normalizeAngle;\nvar DISCRETE = \"discrete\";\nvar _map = vizUtils.map;\nvar _extend = extend;\nvar _each = each;\nexports.chart = {};\nexports.polar = {};\n\nfunction clonePoint(point, newX, newY, newAngle) {\n  var p = objectUtils.clone(point);\n  p.x = newX;\n  p.y = newY;\n  p.angle = newAngle;\n  return p;\n}\n\nfunction getTangentPoint(point, prevPoint, centerPoint, tan, nextStepAngle) {\n  var correctAngle = point.angle + nextStepAngle;\n  var cosSin = vizUtils.getCosAndSin(correctAngle);\n  var x = centerPoint.x + (point.radius + tan * nextStepAngle) * cosSin.cos;\n  var y = centerPoint.y - (point.radius + tan * nextStepAngle) * cosSin.sin;\n  return clonePoint(prevPoint, x, y, correctAngle);\n}\n\nfunction obtainCubicBezierTCoef(p, p0, p1, p2, p3) {\n  var d = p0 - p;\n  var c = 3 * p1 - 3 * p0;\n  var b = 3 * p2 - 6 * p1 + 3 * p0;\n  var a = p3 - 3 * p2 + 3 * p1 - p0;\n  return mathUtils.solveCubicEquation(a, b, c, d);\n}\n\nvar lineMethods = {\n  autoHidePointMarkersEnabled: function autoHidePointMarkersEnabled() {\n    return true;\n  },\n  _applyGroupSettings: function _applyGroupSettings(style, settings, group) {\n    var that = this;\n    settings = _extend(settings, style);\n\n    that._applyElementsClipRect(settings);\n\n    group.attr(settings);\n  },\n  _setGroupsSettings: function _setGroupsSettings(animationEnabled) {\n    var that = this;\n    var style = that._styles.normal;\n\n    that._applyGroupSettings(style.elements, {\n      \"class\": \"dxc-elements\"\n    }, that._elementsGroup);\n\n    that._bordersGroup && that._applyGroupSettings(style.border, {\n      \"class\": \"dxc-borders\"\n    }, that._bordersGroup);\n\n    chartScatterSeries._setGroupsSettings.call(that, animationEnabled);\n\n    animationEnabled && that._markersGroup && that._markersGroup.attr({\n      opacity: .001\n    });\n  },\n  _createGroups: function _createGroups() {\n    var that = this;\n\n    that._createGroup(\"_elementsGroup\", that, that._group);\n\n    that._areBordersVisible() && that._createGroup(\"_bordersGroup\", that, that._group);\n\n    chartScatterSeries._createGroups.call(that);\n  },\n  _areBordersVisible: function _areBordersVisible() {\n    return false;\n  },\n  _getDefaultSegment: function _getDefaultSegment(segment) {\n    return {\n      line: _map(segment.line || [], function (pt) {\n        return pt.getDefaultCoords();\n      })\n    };\n  },\n  _prepareSegment: function _prepareSegment(points) {\n    return {\n      line: points\n    };\n  },\n  _parseLineOptions: function _parseLineOptions(options, defaultColor) {\n    return {\n      stroke: options.color || defaultColor,\n      \"stroke-width\": options.width,\n      dashStyle: options.dashStyle || \"solid\"\n    };\n  },\n  _parseStyle: function _parseStyle(options, defaultColor) {\n    return {\n      elements: this._parseLineOptions(options, defaultColor)\n    };\n  },\n  _applyStyle: function _applyStyle(style) {\n    var that = this;\n    that._elementsGroup && that._elementsGroup.attr(style.elements);\n\n    _each(that._graphics || [], function (_, graphic) {\n      graphic.line && graphic.line.attr({\n        \"stroke-width\": style.elements[\"stroke-width\"]\n      }).sharp();\n    });\n  },\n  _drawElement: function _drawElement(segment, group) {\n    return {\n      line: this._createMainElement(segment.line, {\n        \"stroke-width\": this._styles.normal.elements[\"stroke-width\"]\n      }).append(group)\n    };\n  },\n  _removeElement: function _removeElement(element) {\n    element.line.remove();\n  },\n  _updateElement: function _updateElement(element, segment, animate, animationComplete) {\n    var params = {\n      points: segment.line\n    };\n    var lineElement = element.line;\n    animate ? lineElement.animate(params, {}, animationComplete) : lineElement.attr(params);\n  },\n  _animateComplete: function _animateComplete() {\n    var that = this;\n\n    chartScatterSeries._animateComplete.call(that);\n\n    that._markersGroup && that._markersGroup.animate({\n      opacity: 1\n    }, {\n      duration: that._defaultDuration\n    });\n  },\n  _animate: function _animate() {\n    var that = this;\n    var lastIndex = that._graphics.length - 1;\n\n    _each(that._graphics || [], function (i, elem) {\n      var complete;\n\n      if (i === lastIndex) {\n        complete = function complete() {\n          that._animateComplete();\n        };\n      }\n\n      that._updateElement(elem, that._segments[i], true, complete);\n    });\n  },\n  _drawPoint: function _drawPoint(options) {\n    chartScatterSeries._drawPoint.call(this, {\n      point: options.point,\n      groups: options.groups\n    });\n  },\n  _createMainElement: function _createMainElement(points, settings) {\n    return this._renderer.path(points, \"line\").attr(settings).sharp();\n  },\n  _sortPoints: function _sortPoints(points, rotated) {\n    return rotated ? points.sort(function (p1, p2) {\n      return p2.y - p1.y;\n    }) : points.sort(function (p1, p2) {\n      return p1.x - p2.x;\n    });\n  },\n  _drawSegment: function _drawSegment(points, animationEnabled, segmentCount, lastSegment) {\n    var that = this;\n    var rotated = that._options.rotated;\n    var forceDefaultSegment = false;\n\n    var segment = that._prepareSegment(points, rotated, lastSegment);\n\n    that._segments.push(segment);\n\n    if (!that._graphics[segmentCount]) {\n      that._graphics[segmentCount] = that._drawElement(animationEnabled ? that._getDefaultSegment(segment) : segment, that._elementsGroup);\n    } else {\n      if (!animationEnabled) {\n        that._updateElement(that._graphics[segmentCount], segment);\n      } else {\n        if (forceDefaultSegment) {\n          that._updateElement(that._graphics[segmentCount], that._getDefaultSegment(segment));\n        }\n      }\n    }\n  },\n  _getTrackerSettings: function _getTrackerSettings() {\n    var that = this;\n    var defaultTrackerWidth = that._defaultTrackerWidth;\n    var strokeWidthFromElements = that._styles.normal.elements[\"stroke-width\"];\n    return {\n      \"stroke-width\": strokeWidthFromElements > defaultTrackerWidth ? strokeWidthFromElements : defaultTrackerWidth,\n      fill: \"none\"\n    };\n  },\n  _getMainPointsFromSegment: function _getMainPointsFromSegment(segment) {\n    return segment.line;\n  },\n  _drawTrackerElement: function _drawTrackerElement(segment) {\n    return this._createMainElement(this._getMainPointsFromSegment(segment), this._getTrackerSettings(segment));\n  },\n  _updateTrackerElement: function _updateTrackerElement(segment, element) {\n    var settings = this._getTrackerSettings(segment);\n\n    settings.points = this._getMainPointsFromSegment(segment);\n    element.attr(settings);\n  },\n  checkSeriesViewportCoord: function checkSeriesViewportCoord(axis, coord) {\n    if (0 === this._points.length) {\n      return false;\n    }\n\n    var range = axis.isArgumentAxis ? this.getArgumentRange() : this.getViewport();\n    var min = axis.getTranslator().translate(range.categories ? range.categories[0] : range.min);\n    var max = axis.getTranslator().translate(range.categories ? range.categories[range.categories.length - 1] : range.max);\n    var rotated = this.getOptions().rotated;\n    var inverted = axis.getOptions().inverted;\n    return axis.isArgumentAxis && (!rotated && !inverted || rotated && inverted) || !axis.isArgumentAxis && (rotated && !inverted || !rotated && inverted) ? coord >= min && coord <= max : coord >= max && coord <= min;\n  },\n  getSeriesPairCoord: function getSeriesPairCoord(coord, isArgument) {\n    var that = this;\n    var oppositeCoord = null;\n    var nearestPoints = this.getNearestPointsByCoord(coord, isArgument);\n    var needValueCoord = isArgument && !that._options.rotated || !isArgument && that._options.rotated;\n\n    for (var i = 0; i < nearestPoints.length; i++) {\n      var p = nearestPoints[i];\n      var k = (p[1].vy - p[0].vy) / (p[1].vx - p[0].vx);\n      var b = p[0].vy - p[0].vx * k;\n      var tmpCoord = void 0;\n\n      if (p[1].vx - p[0].vx === 0) {\n        tmpCoord = needValueCoord ? p[0].vy : p[0].vx;\n      } else {\n        tmpCoord = needValueCoord ? k * coord + b : (coord - b) / k;\n      }\n\n      if (this.checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\n        oppositeCoord = tmpCoord;\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  }\n};\n\nvar lineSeries = exports.chart.line = _extend({}, chartScatterSeries, lineMethods, {\n  getPointCenterByArg: function getPointCenterByArg(arg) {\n    var value = this.getArgumentAxis().getTranslator().translate(arg);\n    return {\n      x: value,\n      y: value\n    };\n  }\n});\n\nexports.chart.stepline = _extend({}, lineSeries, {\n  _calculateStepLinePoints: function _calculateStepLinePoints(points) {\n    var segment = [];\n    var coordName = this._options.rotated ? \"x\" : \"y\";\n\n    _each(points, function (i, pt) {\n      var point;\n\n      if (!i) {\n        segment.push(pt);\n        return;\n      }\n\n      var step = segment[segment.length - 1][coordName];\n\n      if (step !== pt[coordName]) {\n        point = objectUtils.clone(pt);\n        point[coordName] = step;\n        segment.push(point);\n      }\n\n      segment.push(pt);\n    });\n\n    return segment;\n  },\n  _prepareSegment: function _prepareSegment(points) {\n    return lineSeries._prepareSegment(this._calculateStepLinePoints(points));\n  },\n  getSeriesPairCoord: function getSeriesPairCoord(coord, isArgument) {\n    var oppositeCoord;\n    var rotated = this._options.rotated;\n    var isOpposite = !isArgument && !rotated || isArgument && rotated;\n    var coordName = !isOpposite ? \"vx\" : \"vy\";\n    var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\n    var nearestPoints = this.getNearestPointsByCoord(coord, isArgument);\n\n    for (var i = 0; i < nearestPoints.length; i++) {\n      var p = nearestPoints[i];\n      var tmpCoord = void 0;\n\n      if (isArgument) {\n        tmpCoord = coord !== p[1][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName];\n      } else {\n        tmpCoord = coord === p[0][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName];\n      }\n\n      if (this.checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\n        oppositeCoord = tmpCoord;\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  }\n});\nexports.chart.spline = _extend({}, lineSeries, {\n  _calculateBezierPoints: function _calculateBezierPoints(src, rotated) {\n    var bezierPoints = [];\n    var pointsCopy = src;\n\n    var checkExtremum = function checkExtremum(otherPointCoord, pointCoord, controlCoord) {\n      return otherPointCoord > pointCoord && controlCoord > otherPointCoord || otherPointCoord < pointCoord && controlCoord < otherPointCoord ? otherPointCoord : controlCoord;\n    };\n\n    if (1 !== pointsCopy.length) {\n      pointsCopy.forEach(function (curPoint, i) {\n        var leftControlX;\n        var leftControlY;\n        var rightControlX;\n        var rightControlY;\n        var prevPoint = pointsCopy[i - 1];\n        var nextPoint = pointsCopy[i + 1];\n        var xCur;\n        var yCur;\n        var x1;\n        var x2;\n        var y1;\n        var y2;\n        var lambda = .5;\n        var curIsExtremum;\n        var leftPoint;\n        var rightPoint;\n        var a;\n        var b;\n        var c;\n        var xc;\n        var yc;\n        var shift;\n\n        if (!i || i === pointsCopy.length - 1) {\n          bezierPoints.push(curPoint, curPoint);\n          return;\n        }\n\n        xCur = curPoint.x;\n        yCur = curPoint.y;\n        x1 = prevPoint.x;\n        x2 = nextPoint.x;\n        y1 = prevPoint.y;\n        y2 = nextPoint.y;\n        curIsExtremum = !!(!rotated && (yCur <= prevPoint.y && yCur <= nextPoint.y || yCur >= prevPoint.y && yCur >= nextPoint.y) || rotated && (xCur <= prevPoint.x && xCur <= nextPoint.x || xCur >= prevPoint.x && xCur >= nextPoint.x));\n\n        if (curIsExtremum) {\n          if (!rotated) {\n            rightControlY = leftControlY = yCur;\n            rightControlX = (xCur + nextPoint.x) / 2;\n            leftControlX = (xCur + prevPoint.x) / 2;\n          } else {\n            rightControlX = leftControlX = xCur;\n            rightControlY = (yCur + nextPoint.y) / 2;\n            leftControlY = (yCur + prevPoint.y) / 2;\n          }\n        } else {\n          a = y2 - y1;\n          b = x1 - x2;\n          c = y1 * x2 - x1 * y2;\n\n          if (!rotated) {\n            if (!b) {\n              bezierPoints.push(curPoint, curPoint, curPoint);\n              return;\n            }\n\n            xc = xCur;\n            yc = -1 * (a * xc + c) / b;\n            shift = yc - yCur;\n            y1 -= shift;\n            y2 -= shift;\n          } else {\n            if (!a) {\n              bezierPoints.push(curPoint, curPoint, curPoint);\n              return;\n            }\n\n            yc = yCur;\n            xc = -1 * (b * yc + c) / a;\n            shift = xc - xCur;\n            x1 -= shift;\n            x2 -= shift;\n          }\n\n          rightControlX = (xCur + lambda * x2) / (1 + lambda);\n          rightControlY = (yCur + lambda * y2) / (1 + lambda);\n          leftControlX = (xCur + lambda * x1) / (1 + lambda);\n          leftControlY = (yCur + lambda * y1) / (1 + lambda);\n        }\n\n        if (!rotated) {\n          leftControlY = checkExtremum(prevPoint.y, yCur, leftControlY);\n          rightControlY = checkExtremum(nextPoint.y, yCur, rightControlY);\n        } else {\n          leftControlX = checkExtremum(prevPoint.x, xCur, leftControlX);\n          rightControlX = checkExtremum(nextPoint.x, xCur, rightControlX);\n        }\n\n        leftPoint = clonePoint(curPoint, leftControlX, leftControlY);\n        rightPoint = clonePoint(curPoint, rightControlX, rightControlY);\n        bezierPoints.push(leftPoint, curPoint, rightPoint);\n      });\n    } else {\n      bezierPoints.push(pointsCopy[0]);\n    }\n\n    return bezierPoints;\n  },\n  _prepareSegment: function _prepareSegment(points, rotated) {\n    return lineSeries._prepareSegment(this._calculateBezierPoints(points, rotated));\n  },\n  _createMainElement: function _createMainElement(points, settings) {\n    return this._renderer.path(points, \"bezier\").attr(settings).sharp();\n  },\n  getSeriesPairCoord: function getSeriesPairCoord(coord, isArgument) {\n    var that = this;\n    var oppositeCoord = null;\n    var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;\n    var coordName = !isOpposite ? \"vx\" : \"vy\";\n    var bezierCoordName = !isOpposite ? \"x\" : \"y\";\n    var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\n    var bezierOppositeCoordName = !isOpposite ? \"y\" : \"x\";\n    var axis = !isArgument ? that.getArgumentAxis() : that.getValueAxis();\n    var visibleArea = axis.getVisibleArea();\n    var nearestPoints = this.getNearestPointsByCoord(coord, isArgument);\n\n    var _loop = function _loop(i) {\n      var p = nearestPoints[i];\n\n      if (1 === p.length) {\n        visibleArea[0] <= p[0][oppositeCoordName] && visibleArea[1] >= p[0][oppositeCoordName] && (oppositeCoord = p[0][oppositeCoordName]);\n      } else {\n        var ts = obtainCubicBezierTCoef(coord, p[0][coordName], p[1][bezierCoordName], p[2][bezierCoordName], p[3][coordName]);\n        ts.forEach(function (t) {\n          if (t >= 0 && t <= 1) {\n            var tmpCoord = Math.pow(1 - t, 3) * p[0][oppositeCoordName] + 3 * Math.pow(1 - t, 2) * t * p[1][bezierOppositeCoordName] + 3 * (1 - t) * t * t * p[2][bezierOppositeCoordName] + t * t * t * p[3][oppositeCoordName];\n\n            if (visibleArea[0] <= tmpCoord && visibleArea[1] >= tmpCoord) {\n              oppositeCoord = tmpCoord;\n            }\n          }\n        });\n      }\n\n      if (null !== oppositeCoord) {\n        return \"break\";\n      }\n    };\n\n    for (var i = 0; i < nearestPoints.length; i++) {\n      var _ret = _loop(i);\n\n      if (\"break\" === _ret) {\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  },\n  getNearestPointsByCoord: function getNearestPointsByCoord(coord, isArgument) {\n    var that = this;\n    var rotated = that.getOptions().rotated;\n    var isOpposite = !isArgument && !rotated || isArgument && rotated;\n    var coordName = isOpposite ? \"vy\" : \"vx\";\n    var points = that.getVisiblePoints();\n    var allPoints = that.getPoints();\n    var bezierPoints = that._segments.length > 0 ? that._segments.reduce(function (a, seg) {\n      return a.concat(seg.line);\n    }, []) : [];\n    var nearestPoints = [];\n\n    if (that.isVisible() && allPoints.length > 0) {\n      if (allPoints.length > 1) {\n        that.findNeighborPointsByCoord(coord, coordName, points.slice(0), allPoints, function (point, nextPoint) {\n          var index = bezierPoints.indexOf(point);\n          nearestPoints.push([point, bezierPoints[index + 1], bezierPoints[index + 2], nextPoint]);\n        });\n      } else {\n        if (allPoints[0][coordName] === coord) {\n          nearestPoints.push([allPoints[0]]);\n        }\n      }\n    }\n\n    return nearestPoints;\n  }\n});\nexports.polar.line = _extend({}, polarScatterSeries, lineMethods, {\n  _sortPoints: function _sortPoints(points) {\n    return points;\n  },\n  _prepareSegment: function _prepareSegment(points, rotated, lastSegment) {\n    var preparedPoints = [];\n    var centerPoint = this.getValueAxis().getCenter();\n    var i;\n    lastSegment && this._closeSegment(points);\n\n    if (this.argumentAxisType !== DISCRETE && this.valueAxisType !== DISCRETE) {\n      for (i = 1; i < points.length; i++) {\n        preparedPoints = preparedPoints.concat(this._getTangentPoints(points[i], points[i - 1], centerPoint));\n      }\n\n      if (!preparedPoints.length) {\n        preparedPoints = points;\n      }\n    } else {\n      return lineSeries._prepareSegment.call(this, points);\n    }\n\n    return {\n      line: preparedPoints\n    };\n  },\n  _getRemainingAngle: function _getRemainingAngle(angle) {\n    var normAngle = normalizeAngle(angle);\n    return angle >= 0 ? 360 - normAngle : -normAngle;\n  },\n  _closeSegment: function _closeSegment(points) {\n    var point;\n    var differenceAngle;\n\n    if (this._segments.length) {\n      point = this._segments[0].line[0];\n    } else {\n      point = clonePoint(points[0], points[0].x, points[0].y, points[0].angle);\n    }\n\n    if (points[points.length - 1].angle !== point.angle) {\n      if (normalizeAngle(Math.round(points[points.length - 1].angle)) === normalizeAngle(Math.round(point.angle))) {\n        point.angle = points[points.length - 1].angle;\n      } else {\n        differenceAngle = points[points.length - 1].angle - point.angle;\n        point.angle = points[points.length - 1].angle + this._getRemainingAngle(differenceAngle);\n      }\n\n      points.push(point);\n    }\n  },\n  _getTangentPoints: function _getTangentPoints(point, prevPoint, centerPoint) {\n    var tangentPoints = [];\n    var betweenAngle = Math.round(prevPoint.angle - point.angle);\n    var tan = (prevPoint.radius - point.radius) / betweenAngle;\n    var i;\n\n    if (0 === betweenAngle) {\n      tangentPoints = [prevPoint, point];\n    } else {\n      if (betweenAngle > 0) {\n        for (i = betweenAngle; i >= 0; i--) {\n          tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, i));\n        }\n      } else {\n        for (i = 0; i >= betweenAngle; i--) {\n          tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, betweenAngle - i));\n        }\n      }\n    }\n\n    return tangentPoints;\n  }\n});","map":{"version":3,"sources":["C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/devextreme/viz/series/line_series.js"],"names":["series","require","chartScatterSeries","polarScatterSeries","objectUtils","extend","each","vizUtils","mathUtils","normalizeAngle","DISCRETE","_map","_extend","_each","exports","p","correctAngle","point","cosSin","x","centerPoint","tan","y","clonePoint","d","p0","c","b","a","p3","lineMethods","autoHidePointMarkersEnabled","_applyGroupSettings","that","settings","group","_setGroupsSettings","style","animationEnabled","opacity","_createGroups","_areBordersVisible","_getDefaultSegment","line","segment","pt","_prepareSegment","points","_parseLineOptions","stroke","options","dashStyle","_parseStyle","elements","_applyStyle","graphic","_drawElement","_removeElement","element","_updateElement","params","lineElement","animate","_animateComplete","duration","_defaultDuration","_animate","lastIndex","i","complete","_drawPoint","groups","_createMainElement","_sortPoints","rotated","p2","p1","_drawSegment","forceDefaultSegment","_getTrackerSettings","defaultTrackerWidth","strokeWidthFromElements","fill","_getMainPointsFromSegment","_drawTrackerElement","_updateTrackerElement","checkSeriesViewportCoord","range","axis","min","max","inverted","coord","getSeriesPairCoord","oppositeCoord","nearestPoints","needValueCoord","isArgument","k","tmpCoord","lineSeries","getPointCenterByArg","value","_calculateStepLinePoints","coordName","step","isOpposite","oppositeCoordName","_calculateBezierPoints","bezierPoints","pointsCopy","checkExtremum","otherPointCoord","controlCoord","prevPoint","nextPoint","lambda","xCur","curPoint","yCur","x1","x2","y1","y2","curIsExtremum","rightControlY","leftControlY","rightControlX","leftControlX","xc","yc","shift","leftPoint","rightPoint","bezierCoordName","bezierOppositeCoordName","visibleArea","_loop","ts","obtainCubicBezierTCoef","t","Math","_ret","getNearestPointsByCoord","allPoints","seg","index","preparedPoints","lastSegment","_getRemainingAngle","normAngle","angle","_closeSegment","differenceAngle","_getTangentPoints","tangentPoints","betweenAngle","getTangentPoint"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (viz/series/line_series.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nvar series = require(\"./scatter_series\");\r\nvar chartScatterSeries = series.chart;\r\nvar polarScatterSeries = series.polar;\r\nvar objectUtils = require(\"../../core/utils/object\");\r\nvar extend = require(\"../../core/utils/extend\").extend;\r\nvar each = require(\"../../core/utils/iterator\").each;\r\nvar vizUtils = require(\"../core/utils\");\r\nvar mathUtils = require(\"../../core/utils/math\");\r\nvar normalizeAngle = vizUtils.normalizeAngle;\r\nvar DISCRETE = \"discrete\";\r\nvar _map = vizUtils.map;\r\nvar _extend = extend;\r\nvar _each = each;\r\nexports.chart = {};\r\nexports.polar = {};\r\n\r\nfunction clonePoint(point, newX, newY, newAngle) {\r\n    var p = objectUtils.clone(point);\r\n    p.x = newX;\r\n    p.y = newY;\r\n    p.angle = newAngle;\r\n    return p\r\n}\r\n\r\nfunction getTangentPoint(point, prevPoint, centerPoint, tan, nextStepAngle) {\r\n    var correctAngle = point.angle + nextStepAngle;\r\n    var cosSin = vizUtils.getCosAndSin(correctAngle);\r\n    var x = centerPoint.x + (point.radius + tan * nextStepAngle) * cosSin.cos;\r\n    var y = centerPoint.y - (point.radius + tan * nextStepAngle) * cosSin.sin;\r\n    return clonePoint(prevPoint, x, y, correctAngle)\r\n}\r\n\r\nfunction obtainCubicBezierTCoef(p, p0, p1, p2, p3) {\r\n    var d = p0 - p;\r\n    var c = 3 * p1 - 3 * p0;\r\n    var b = 3 * p2 - 6 * p1 + 3 * p0;\r\n    var a = p3 - 3 * p2 + 3 * p1 - p0;\r\n    return mathUtils.solveCubicEquation(a, b, c, d)\r\n}\r\nvar lineMethods = {\r\n    autoHidePointMarkersEnabled: function() {\r\n        return true\r\n    },\r\n    _applyGroupSettings: function(style, settings, group) {\r\n        var that = this;\r\n        settings = _extend(settings, style);\r\n        that._applyElementsClipRect(settings);\r\n        group.attr(settings)\r\n    },\r\n    _setGroupsSettings: function(animationEnabled) {\r\n        var that = this;\r\n        var style = that._styles.normal;\r\n        that._applyGroupSettings(style.elements, {\r\n            \"class\": \"dxc-elements\"\r\n        }, that._elementsGroup);\r\n        that._bordersGroup && that._applyGroupSettings(style.border, {\r\n            \"class\": \"dxc-borders\"\r\n        }, that._bordersGroup);\r\n        chartScatterSeries._setGroupsSettings.call(that, animationEnabled);\r\n        animationEnabled && that._markersGroup && that._markersGroup.attr({\r\n            opacity: .001\r\n        })\r\n    },\r\n    _createGroups: function() {\r\n        var that = this;\r\n        that._createGroup(\"_elementsGroup\", that, that._group);\r\n        that._areBordersVisible() && that._createGroup(\"_bordersGroup\", that, that._group);\r\n        chartScatterSeries._createGroups.call(that)\r\n    },\r\n    _areBordersVisible: function() {\r\n        return false\r\n    },\r\n    _getDefaultSegment: function(segment) {\r\n        return {\r\n            line: _map(segment.line || [], function(pt) {\r\n                return pt.getDefaultCoords()\r\n            })\r\n        }\r\n    },\r\n    _prepareSegment: function(points) {\r\n        return {\r\n            line: points\r\n        }\r\n    },\r\n    _parseLineOptions: function(options, defaultColor) {\r\n        return {\r\n            stroke: options.color || defaultColor,\r\n            \"stroke-width\": options.width,\r\n            dashStyle: options.dashStyle || \"solid\"\r\n        }\r\n    },\r\n    _parseStyle: function(options, defaultColor) {\r\n        return {\r\n            elements: this._parseLineOptions(options, defaultColor)\r\n        }\r\n    },\r\n    _applyStyle: function(style) {\r\n        var that = this;\r\n        that._elementsGroup && that._elementsGroup.attr(style.elements);\r\n        _each(that._graphics || [], function(_, graphic) {\r\n            graphic.line && graphic.line.attr({\r\n                \"stroke-width\": style.elements[\"stroke-width\"]\r\n            }).sharp()\r\n        })\r\n    },\r\n    _drawElement: function(segment, group) {\r\n        return {\r\n            line: this._createMainElement(segment.line, {\r\n                \"stroke-width\": this._styles.normal.elements[\"stroke-width\"]\r\n            }).append(group)\r\n        }\r\n    },\r\n    _removeElement: function(element) {\r\n        element.line.remove()\r\n    },\r\n    _updateElement: function(element, segment, animate, animationComplete) {\r\n        var params = {\r\n            points: segment.line\r\n        };\r\n        var lineElement = element.line;\r\n        animate ? lineElement.animate(params, {}, animationComplete) : lineElement.attr(params)\r\n    },\r\n    _animateComplete: function() {\r\n        var that = this;\r\n        chartScatterSeries._animateComplete.call(that);\r\n        that._markersGroup && that._markersGroup.animate({\r\n            opacity: 1\r\n        }, {\r\n            duration: that._defaultDuration\r\n        })\r\n    },\r\n    _animate: function() {\r\n        var that = this;\r\n        var lastIndex = that._graphics.length - 1;\r\n        _each(that._graphics || [], function(i, elem) {\r\n            var complete;\r\n            if (i === lastIndex) {\r\n                complete = function() {\r\n                    that._animateComplete()\r\n                }\r\n            }\r\n            that._updateElement(elem, that._segments[i], true, complete)\r\n        })\r\n    },\r\n    _drawPoint: function(options) {\r\n        chartScatterSeries._drawPoint.call(this, {\r\n            point: options.point,\r\n            groups: options.groups\r\n        })\r\n    },\r\n    _createMainElement: function(points, settings) {\r\n        return this._renderer.path(points, \"line\").attr(settings).sharp()\r\n    },\r\n    _sortPoints: function(points, rotated) {\r\n        return rotated ? points.sort(function(p1, p2) {\r\n            return p2.y - p1.y\r\n        }) : points.sort(function(p1, p2) {\r\n            return p1.x - p2.x\r\n        })\r\n    },\r\n    _drawSegment: function(points, animationEnabled, segmentCount, lastSegment) {\r\n        var that = this;\r\n        var rotated = that._options.rotated;\r\n        var forceDefaultSegment = false;\r\n        var segment = that._prepareSegment(points, rotated, lastSegment);\r\n        that._segments.push(segment);\r\n        if (!that._graphics[segmentCount]) {\r\n            that._graphics[segmentCount] = that._drawElement(animationEnabled ? that._getDefaultSegment(segment) : segment, that._elementsGroup)\r\n        } else {\r\n            if (!animationEnabled) {\r\n                that._updateElement(that._graphics[segmentCount], segment)\r\n            } else {\r\n                if (forceDefaultSegment) {\r\n                    that._updateElement(that._graphics[segmentCount], that._getDefaultSegment(segment))\r\n                }\r\n            }\r\n        }\r\n    },\r\n    _getTrackerSettings: function() {\r\n        var that = this;\r\n        var defaultTrackerWidth = that._defaultTrackerWidth;\r\n        var strokeWidthFromElements = that._styles.normal.elements[\"stroke-width\"];\r\n        return {\r\n            \"stroke-width\": strokeWidthFromElements > defaultTrackerWidth ? strokeWidthFromElements : defaultTrackerWidth,\r\n            fill: \"none\"\r\n        }\r\n    },\r\n    _getMainPointsFromSegment: function(segment) {\r\n        return segment.line\r\n    },\r\n    _drawTrackerElement: function(segment) {\r\n        return this._createMainElement(this._getMainPointsFromSegment(segment), this._getTrackerSettings(segment))\r\n    },\r\n    _updateTrackerElement: function(segment, element) {\r\n        var settings = this._getTrackerSettings(segment);\r\n        settings.points = this._getMainPointsFromSegment(segment);\r\n        element.attr(settings)\r\n    },\r\n    checkSeriesViewportCoord: function(axis, coord) {\r\n        if (0 === this._points.length) {\r\n            return false\r\n        }\r\n        var range = axis.isArgumentAxis ? this.getArgumentRange() : this.getViewport();\r\n        var min = axis.getTranslator().translate(range.categories ? range.categories[0] : range.min);\r\n        var max = axis.getTranslator().translate(range.categories ? range.categories[range.categories.length - 1] : range.max);\r\n        var rotated = this.getOptions().rotated;\r\n        var inverted = axis.getOptions().inverted;\r\n        return axis.isArgumentAxis && (!rotated && !inverted || rotated && inverted) || !axis.isArgumentAxis && (rotated && !inverted || !rotated && inverted) ? coord >= min && coord <= max : coord >= max && coord <= min\r\n    },\r\n    getSeriesPairCoord: function(coord, isArgument) {\r\n        var that = this;\r\n        var oppositeCoord = null;\r\n        var nearestPoints = this.getNearestPointsByCoord(coord, isArgument);\r\n        var needValueCoord = isArgument && !that._options.rotated || !isArgument && that._options.rotated;\r\n        for (var i = 0; i < nearestPoints.length; i++) {\r\n            var p = nearestPoints[i];\r\n            var k = (p[1].vy - p[0].vy) / (p[1].vx - p[0].vx);\r\n            var b = p[0].vy - p[0].vx * k;\r\n            var tmpCoord = void 0;\r\n            if (p[1].vx - p[0].vx === 0) {\r\n                tmpCoord = needValueCoord ? p[0].vy : p[0].vx\r\n            } else {\r\n                tmpCoord = needValueCoord ? k * coord + b : (coord - b) / k\r\n            }\r\n            if (this.checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\r\n                oppositeCoord = tmpCoord;\r\n                break\r\n            }\r\n        }\r\n        return oppositeCoord\r\n    }\r\n};\r\nvar lineSeries = exports.chart.line = _extend({}, chartScatterSeries, lineMethods, {\r\n    getPointCenterByArg: function(arg) {\r\n        var value = this.getArgumentAxis().getTranslator().translate(arg);\r\n        return {\r\n            x: value,\r\n            y: value\r\n        }\r\n    }\r\n});\r\nexports.chart.stepline = _extend({}, lineSeries, {\r\n    _calculateStepLinePoints: function(points) {\r\n        var segment = [];\r\n        var coordName = this._options.rotated ? \"x\" : \"y\";\r\n        _each(points, function(i, pt) {\r\n            var point;\r\n            if (!i) {\r\n                segment.push(pt);\r\n                return\r\n            }\r\n            var step = segment[segment.length - 1][coordName];\r\n            if (step !== pt[coordName]) {\r\n                point = objectUtils.clone(pt);\r\n                point[coordName] = step;\r\n                segment.push(point)\r\n            }\r\n            segment.push(pt)\r\n        });\r\n        return segment\r\n    },\r\n    _prepareSegment: function(points) {\r\n        return lineSeries._prepareSegment(this._calculateStepLinePoints(points))\r\n    },\r\n    getSeriesPairCoord: function(coord, isArgument) {\r\n        var oppositeCoord;\r\n        var rotated = this._options.rotated;\r\n        var isOpposite = !isArgument && !rotated || isArgument && rotated;\r\n        var coordName = !isOpposite ? \"vx\" : \"vy\";\r\n        var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\r\n        var nearestPoints = this.getNearestPointsByCoord(coord, isArgument);\r\n        for (var i = 0; i < nearestPoints.length; i++) {\r\n            var p = nearestPoints[i];\r\n            var tmpCoord = void 0;\r\n            if (isArgument) {\r\n                tmpCoord = coord !== p[1][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName]\r\n            } else {\r\n                tmpCoord = coord === p[0][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName]\r\n            }\r\n            if (this.checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\r\n                oppositeCoord = tmpCoord;\r\n                break\r\n            }\r\n        }\r\n        return oppositeCoord\r\n    }\r\n});\r\nexports.chart.spline = _extend({}, lineSeries, {\r\n    _calculateBezierPoints: function(src, rotated) {\r\n        var bezierPoints = [];\r\n        var pointsCopy = src;\r\n        var checkExtremum = function(otherPointCoord, pointCoord, controlCoord) {\r\n            return otherPointCoord > pointCoord && controlCoord > otherPointCoord || otherPointCoord < pointCoord && controlCoord < otherPointCoord ? otherPointCoord : controlCoord\r\n        };\r\n        if (1 !== pointsCopy.length) {\r\n            pointsCopy.forEach(function(curPoint, i) {\r\n                var leftControlX;\r\n                var leftControlY;\r\n                var rightControlX;\r\n                var rightControlY;\r\n                var prevPoint = pointsCopy[i - 1];\r\n                var nextPoint = pointsCopy[i + 1];\r\n                var xCur;\r\n                var yCur;\r\n                var x1;\r\n                var x2;\r\n                var y1;\r\n                var y2;\r\n                var lambda = .5;\r\n                var curIsExtremum;\r\n                var leftPoint;\r\n                var rightPoint;\r\n                var a;\r\n                var b;\r\n                var c;\r\n                var xc;\r\n                var yc;\r\n                var shift;\r\n                if (!i || i === pointsCopy.length - 1) {\r\n                    bezierPoints.push(curPoint, curPoint);\r\n                    return\r\n                }\r\n                xCur = curPoint.x;\r\n                yCur = curPoint.y;\r\n                x1 = prevPoint.x;\r\n                x2 = nextPoint.x;\r\n                y1 = prevPoint.y;\r\n                y2 = nextPoint.y;\r\n                curIsExtremum = !!(!rotated && (yCur <= prevPoint.y && yCur <= nextPoint.y || yCur >= prevPoint.y && yCur >= nextPoint.y) || rotated && (xCur <= prevPoint.x && xCur <= nextPoint.x || xCur >= prevPoint.x && xCur >= nextPoint.x));\r\n                if (curIsExtremum) {\r\n                    if (!rotated) {\r\n                        rightControlY = leftControlY = yCur;\r\n                        rightControlX = (xCur + nextPoint.x) / 2;\r\n                        leftControlX = (xCur + prevPoint.x) / 2\r\n                    } else {\r\n                        rightControlX = leftControlX = xCur;\r\n                        rightControlY = (yCur + nextPoint.y) / 2;\r\n                        leftControlY = (yCur + prevPoint.y) / 2\r\n                    }\r\n                } else {\r\n                    a = y2 - y1;\r\n                    b = x1 - x2;\r\n                    c = y1 * x2 - x1 * y2;\r\n                    if (!rotated) {\r\n                        if (!b) {\r\n                            bezierPoints.push(curPoint, curPoint, curPoint);\r\n                            return\r\n                        }\r\n                        xc = xCur;\r\n                        yc = -1 * (a * xc + c) / b;\r\n                        shift = yc - yCur;\r\n                        y1 -= shift;\r\n                        y2 -= shift\r\n                    } else {\r\n                        if (!a) {\r\n                            bezierPoints.push(curPoint, curPoint, curPoint);\r\n                            return\r\n                        }\r\n                        yc = yCur;\r\n                        xc = -1 * (b * yc + c) / a;\r\n                        shift = xc - xCur;\r\n                        x1 -= shift;\r\n                        x2 -= shift\r\n                    }\r\n                    rightControlX = (xCur + lambda * x2) / (1 + lambda);\r\n                    rightControlY = (yCur + lambda * y2) / (1 + lambda);\r\n                    leftControlX = (xCur + lambda * x1) / (1 + lambda);\r\n                    leftControlY = (yCur + lambda * y1) / (1 + lambda)\r\n                }\r\n                if (!rotated) {\r\n                    leftControlY = checkExtremum(prevPoint.y, yCur, leftControlY);\r\n                    rightControlY = checkExtremum(nextPoint.y, yCur, rightControlY)\r\n                } else {\r\n                    leftControlX = checkExtremum(prevPoint.x, xCur, leftControlX);\r\n                    rightControlX = checkExtremum(nextPoint.x, xCur, rightControlX)\r\n                }\r\n                leftPoint = clonePoint(curPoint, leftControlX, leftControlY);\r\n                rightPoint = clonePoint(curPoint, rightControlX, rightControlY);\r\n                bezierPoints.push(leftPoint, curPoint, rightPoint)\r\n            })\r\n        } else {\r\n            bezierPoints.push(pointsCopy[0])\r\n        }\r\n        return bezierPoints\r\n    },\r\n    _prepareSegment: function(points, rotated) {\r\n        return lineSeries._prepareSegment(this._calculateBezierPoints(points, rotated))\r\n    },\r\n    _createMainElement: function(points, settings) {\r\n        return this._renderer.path(points, \"bezier\").attr(settings).sharp()\r\n    },\r\n    getSeriesPairCoord: function(coord, isArgument) {\r\n        var that = this;\r\n        var oppositeCoord = null;\r\n        var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;\r\n        var coordName = !isOpposite ? \"vx\" : \"vy\";\r\n        var bezierCoordName = !isOpposite ? \"x\" : \"y\";\r\n        var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\r\n        var bezierOppositeCoordName = !isOpposite ? \"y\" : \"x\";\r\n        var axis = !isArgument ? that.getArgumentAxis() : that.getValueAxis();\r\n        var visibleArea = axis.getVisibleArea();\r\n        var nearestPoints = this.getNearestPointsByCoord(coord, isArgument);\r\n        var _loop = function(i) {\r\n            var p = nearestPoints[i];\r\n            if (1 === p.length) {\r\n                visibleArea[0] <= p[0][oppositeCoordName] && visibleArea[1] >= p[0][oppositeCoordName] && (oppositeCoord = p[0][oppositeCoordName])\r\n            } else {\r\n                var ts = obtainCubicBezierTCoef(coord, p[0][coordName], p[1][bezierCoordName], p[2][bezierCoordName], p[3][coordName]);\r\n                ts.forEach(function(t) {\r\n                    if (t >= 0 && t <= 1) {\r\n                        var tmpCoord = Math.pow(1 - t, 3) * p[0][oppositeCoordName] + 3 * Math.pow(1 - t, 2) * t * p[1][bezierOppositeCoordName] + 3 * (1 - t) * t * t * p[2][bezierOppositeCoordName] + t * t * t * p[3][oppositeCoordName];\r\n                        if (visibleArea[0] <= tmpCoord && visibleArea[1] >= tmpCoord) {\r\n                            oppositeCoord = tmpCoord\r\n                        }\r\n                    }\r\n                })\r\n            }\r\n            if (null !== oppositeCoord) {\r\n                return \"break\"\r\n            }\r\n        };\r\n        for (var i = 0; i < nearestPoints.length; i++) {\r\n            var _ret = _loop(i);\r\n            if (\"break\" === _ret) {\r\n                break\r\n            }\r\n        }\r\n        return oppositeCoord\r\n    },\r\n    getNearestPointsByCoord: function(coord, isArgument) {\r\n        var that = this;\r\n        var rotated = that.getOptions().rotated;\r\n        var isOpposite = !isArgument && !rotated || isArgument && rotated;\r\n        var coordName = isOpposite ? \"vy\" : \"vx\";\r\n        var points = that.getVisiblePoints();\r\n        var allPoints = that.getPoints();\r\n        var bezierPoints = that._segments.length > 0 ? that._segments.reduce(function(a, seg) {\r\n            return a.concat(seg.line)\r\n        }, []) : [];\r\n        var nearestPoints = [];\r\n        if (that.isVisible() && allPoints.length > 0) {\r\n            if (allPoints.length > 1) {\r\n                that.findNeighborPointsByCoord(coord, coordName, points.slice(0), allPoints, function(point, nextPoint) {\r\n                    var index = bezierPoints.indexOf(point);\r\n                    nearestPoints.push([point, bezierPoints[index + 1], bezierPoints[index + 2], nextPoint])\r\n                })\r\n            } else {\r\n                if (allPoints[0][coordName] === coord) {\r\n                    nearestPoints.push([allPoints[0]])\r\n                }\r\n            }\r\n        }\r\n        return nearestPoints\r\n    }\r\n});\r\nexports.polar.line = _extend({}, polarScatterSeries, lineMethods, {\r\n    _sortPoints: function(points) {\r\n        return points\r\n    },\r\n    _prepareSegment: function(points, rotated, lastSegment) {\r\n        var preparedPoints = [];\r\n        var centerPoint = this.getValueAxis().getCenter();\r\n        var i;\r\n        lastSegment && this._closeSegment(points);\r\n        if (this.argumentAxisType !== DISCRETE && this.valueAxisType !== DISCRETE) {\r\n            for (i = 1; i < points.length; i++) {\r\n                preparedPoints = preparedPoints.concat(this._getTangentPoints(points[i], points[i - 1], centerPoint))\r\n            }\r\n            if (!preparedPoints.length) {\r\n                preparedPoints = points\r\n            }\r\n        } else {\r\n            return lineSeries._prepareSegment.call(this, points)\r\n        }\r\n        return {\r\n            line: preparedPoints\r\n        }\r\n    },\r\n    _getRemainingAngle: function(angle) {\r\n        var normAngle = normalizeAngle(angle);\r\n        return angle >= 0 ? 360 - normAngle : -normAngle\r\n    },\r\n    _closeSegment: function(points) {\r\n        var point;\r\n        var differenceAngle;\r\n        if (this._segments.length) {\r\n            point = this._segments[0].line[0]\r\n        } else {\r\n            point = clonePoint(points[0], points[0].x, points[0].y, points[0].angle)\r\n        }\r\n        if (points[points.length - 1].angle !== point.angle) {\r\n            if (normalizeAngle(Math.round(points[points.length - 1].angle)) === normalizeAngle(Math.round(point.angle))) {\r\n                point.angle = points[points.length - 1].angle\r\n            } else {\r\n                differenceAngle = points[points.length - 1].angle - point.angle;\r\n                point.angle = points[points.length - 1].angle + this._getRemainingAngle(differenceAngle)\r\n            }\r\n            points.push(point)\r\n        }\r\n    },\r\n    _getTangentPoints: function(point, prevPoint, centerPoint) {\r\n        var tangentPoints = [];\r\n        var betweenAngle = Math.round(prevPoint.angle - point.angle);\r\n        var tan = (prevPoint.radius - point.radius) / betweenAngle;\r\n        var i;\r\n        if (0 === betweenAngle) {\r\n            tangentPoints = [prevPoint, point]\r\n        } else {\r\n            if (betweenAngle > 0) {\r\n                for (i = betweenAngle; i >= 0; i--) {\r\n                    tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, i))\r\n                }\r\n            } else {\r\n                for (i = 0; i >= betweenAngle; i--) {\r\n                    tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, betweenAngle - i))\r\n                }\r\n            }\r\n        }\r\n        return tangentPoints\r\n    }\r\n});\r\n"]},"metadata":{},"sourceType":"module"}