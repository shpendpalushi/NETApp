{"ast":null,"code":"/**\r\n * DevExtreme (viz/series/stacked_series.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _noop = require(\"../../core/utils/common\").noop;\n\nvar _extend = require(\"../../core/utils/extend\").extend;\n\nvar each = require(\"../../core/utils/iterator\").each;\n\nvar areaSeries = require(\"./area_series\").chart;\n\nvar chartAreaSeries = areaSeries.area;\n\nvar barSeries = require(\"./bar_series\");\n\nvar chartBarSeries = barSeries.chart.bar;\n\nvar lineSeries = require(\"./line_series\").chart;\n\nvar vizUtils = require(\"../core/utils\");\n\nvar objectUtils = require(\"../../core/utils/object\");\n\nvar baseStackedSeries = {\n  _calculateErrorBars: _noop,\n  _updateOptions: function _updateOptions(options) {\n    this._stackName = \"axis_\" + (options.axis || \"default\");\n  }\n};\nexports.chart = {};\nexports.polar = {};\nexports.chart.stackedline = _extend({}, lineSeries.line, baseStackedSeries, {});\nexports.chart.stackedspline = _extend({}, lineSeries.spline, baseStackedSeries, {});\nexports.chart.fullstackedline = _extend({}, lineSeries.line, baseStackedSeries, {\n  getValueRangeInitialValue: areaSeries.area.getValueRangeInitialValue\n});\nexports.chart.fullstackedspline = _extend({}, lineSeries.spline, baseStackedSeries, {\n  getValueRangeInitialValue: areaSeries.area.getValueRangeInitialValue\n});\n\nvar stackedBar = exports.chart.stackedbar = _extend({}, chartBarSeries, baseStackedSeries, {\n  _updateOptions: function _updateOptions(options) {\n    baseStackedSeries._updateOptions.call(this, options);\n\n    this._stackName = this._stackName + \"_stack_\" + (options.stack || \"default\");\n  }\n});\n\nexports.chart.fullstackedbar = _extend({}, chartBarSeries, baseStackedSeries, {\n  _updateOptions: stackedBar._updateOptions\n});\n\nfunction clonePoint(point, value, minValue, position) {\n  point = objectUtils.clone(point);\n  point.value = value;\n  point.minValue = minValue;\n  point.translate();\n  point.argument = point.argument + position;\n  return point;\n}\n\nfunction preparePointsForStackedAreaSegment(points) {\n  var i = 0;\n  var p;\n  var result = [];\n  var array;\n  var len = points.length;\n\n  while (i < len) {\n    p = points[i];\n    array = [p];\n\n    if (p.leftHole) {\n      array = [clonePoint(p, p.leftHole, p.minLeftHole, \"left\"), p];\n    }\n\n    if (p.rightHole) {\n      array.push(clonePoint(p, p.rightHole, p.minRightHole, \"right\"));\n    }\n\n    result.push(array);\n    i++;\n  }\n\n  return [].concat.apply([], result);\n}\n\nexports.chart.stackedarea = _extend({}, chartAreaSeries, baseStackedSeries, {\n  _prepareSegment: function _prepareSegment(points, rotated) {\n    return chartAreaSeries._prepareSegment.call(this, preparePointsForStackedAreaSegment(points), rotated);\n  },\n  _appendInGroup: function _appendInGroup() {\n    this._group.append(this._extGroups.seriesGroup).toBackground();\n  }\n});\n\nfunction getPointsByArgFromPrevSeries(prevSeries, argument) {\n  var result;\n\n  while (!result && prevSeries) {\n    result = prevSeries._segmentByArg && prevSeries._segmentByArg[argument];\n    prevSeries = prevSeries._prevSeries;\n  }\n\n  return result;\n}\n\nexports.chart.stackedsplinearea = _extend({}, areaSeries.splinearea, baseStackedSeries, {\n  _prepareSegment: function _prepareSegment(points, rotated) {\n    var that = this;\n    var areaSegment;\n    points = preparePointsForStackedAreaSegment(points);\n\n    if (!this._prevSeries || 1 === points.length) {\n      areaSegment = areaSeries.splinearea._prepareSegment.call(this, points, rotated);\n    } else {\n      var forwardPoints = lineSeries.spline._calculateBezierPoints(points, rotated);\n\n      var backwardPoints = vizUtils.map(points, function (p) {\n        var point = p.getCoords(true);\n        point.argument = p.argument;\n        return point;\n      });\n      var prevSeriesForwardPoints = [];\n      var pointByArg = {};\n      var i = 0;\n      var len = that._prevSeries._segments.length;\n\n      while (i < len) {\n        prevSeriesForwardPoints = prevSeriesForwardPoints.concat(that._prevSeries._segments[i].line);\n        i++;\n      }\n\n      each(prevSeriesForwardPoints, function (_, p) {\n        if (null !== p.argument) {\n          var argument = p.argument.valueOf();\n\n          if (!pointByArg[argument]) {\n            pointByArg[argument] = [p];\n          } else {\n            pointByArg[argument].push(p);\n          }\n        }\n      });\n      that._prevSeries._segmentByArg = pointByArg;\n      backwardPoints = lineSeries.spline._calculateBezierPoints(backwardPoints, rotated);\n      each(backwardPoints, function (i, p) {\n        var argument = p.argument.valueOf();\n        var prevSeriesPoints;\n\n        if (i % 3 === 0) {\n          prevSeriesPoints = pointByArg[argument] || getPointsByArgFromPrevSeries(that._prevSeries, argument);\n\n          if (prevSeriesPoints) {\n            backwardPoints[i - 1] && prevSeriesPoints[0] && (backwardPoints[i - 1] = prevSeriesPoints[0]);\n            backwardPoints[i + 1] && (backwardPoints[i + 1] = prevSeriesPoints[2] || p);\n          }\n        }\n      });\n      areaSegment = {\n        line: forwardPoints,\n        area: forwardPoints.concat(backwardPoints.reverse())\n      };\n\n      that._areaPointsToSplineAreaPoints(areaSegment.area);\n    }\n\n    return areaSegment;\n  },\n  _appendInGroup: exports.chart.stackedarea._appendInGroup\n});\nexports.chart.fullstackedarea = _extend({}, chartAreaSeries, baseStackedSeries, {\n  _prepareSegment: exports.chart.stackedarea._prepareSegment,\n  _appendInGroup: exports.chart.stackedarea._appendInGroup\n});\nexports.chart.fullstackedsplinearea = _extend({}, areaSeries.splinearea, baseStackedSeries, {\n  _prepareSegment: exports.chart.stackedsplinearea._prepareSegment,\n  _appendInGroup: exports.chart.stackedarea._appendInGroup\n});\nexports.polar.stackedbar = _extend({}, barSeries.polar.bar, baseStackedSeries, {});","map":{"version":3,"sources":["C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/devextreme/viz/series/stacked_series.js"],"names":["_noop","require","_extend","each","areaSeries","chartAreaSeries","barSeries","chartBarSeries","lineSeries","vizUtils","objectUtils","baseStackedSeries","_calculateErrorBars","_updateOptions","options","exports","getValueRangeInitialValue","stackedBar","point","i","result","len","points","p","array","clonePoint","_prepareSegment","preparePointsForStackedAreaSegment","_appendInGroup","prevSeries","that","areaSegment","forwardPoints","backwardPoints","prevSeriesForwardPoints","pointByArg","argument","prevSeriesPoints","getPointsByArgFromPrevSeries","line","area"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (viz/series/stacked_series.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nvar _noop = require(\"../../core/utils/common\").noop;\r\nvar _extend = require(\"../../core/utils/extend\").extend;\r\nvar each = require(\"../../core/utils/iterator\").each;\r\nvar areaSeries = require(\"./area_series\").chart;\r\nvar chartAreaSeries = areaSeries.area;\r\nvar barSeries = require(\"./bar_series\");\r\nvar chartBarSeries = barSeries.chart.bar;\r\nvar lineSeries = require(\"./line_series\").chart;\r\nvar vizUtils = require(\"../core/utils\");\r\nvar objectUtils = require(\"../../core/utils/object\");\r\nvar baseStackedSeries = {\r\n    _calculateErrorBars: _noop,\r\n    _updateOptions: function(options) {\r\n        this._stackName = \"axis_\" + (options.axis || \"default\")\r\n    }\r\n};\r\nexports.chart = {};\r\nexports.polar = {};\r\nexports.chart.stackedline = _extend({}, lineSeries.line, baseStackedSeries, {});\r\nexports.chart.stackedspline = _extend({}, lineSeries.spline, baseStackedSeries, {});\r\nexports.chart.fullstackedline = _extend({}, lineSeries.line, baseStackedSeries, {\r\n    getValueRangeInitialValue: areaSeries.area.getValueRangeInitialValue\r\n});\r\nexports.chart.fullstackedspline = _extend({}, lineSeries.spline, baseStackedSeries, {\r\n    getValueRangeInitialValue: areaSeries.area.getValueRangeInitialValue\r\n});\r\nvar stackedBar = exports.chart.stackedbar = _extend({}, chartBarSeries, baseStackedSeries, {\r\n    _updateOptions: function(options) {\r\n        baseStackedSeries._updateOptions.call(this, options);\r\n        this._stackName = this._stackName + \"_stack_\" + (options.stack || \"default\")\r\n    }\r\n});\r\nexports.chart.fullstackedbar = _extend({}, chartBarSeries, baseStackedSeries, {\r\n    _updateOptions: stackedBar._updateOptions\r\n});\r\n\r\nfunction clonePoint(point, value, minValue, position) {\r\n    point = objectUtils.clone(point);\r\n    point.value = value;\r\n    point.minValue = minValue;\r\n    point.translate();\r\n    point.argument = point.argument + position;\r\n    return point\r\n}\r\n\r\nfunction preparePointsForStackedAreaSegment(points) {\r\n    var i = 0;\r\n    var p;\r\n    var result = [];\r\n    var array;\r\n    var len = points.length;\r\n    while (i < len) {\r\n        p = points[i];\r\n        array = [p];\r\n        if (p.leftHole) {\r\n            array = [clonePoint(p, p.leftHole, p.minLeftHole, \"left\"), p]\r\n        }\r\n        if (p.rightHole) {\r\n            array.push(clonePoint(p, p.rightHole, p.minRightHole, \"right\"))\r\n        }\r\n        result.push(array);\r\n        i++\r\n    }\r\n    return [].concat.apply([], result)\r\n}\r\nexports.chart.stackedarea = _extend({}, chartAreaSeries, baseStackedSeries, {\r\n    _prepareSegment: function(points, rotated) {\r\n        return chartAreaSeries._prepareSegment.call(this, preparePointsForStackedAreaSegment(points), rotated)\r\n    },\r\n    _appendInGroup: function() {\r\n        this._group.append(this._extGroups.seriesGroup).toBackground()\r\n    }\r\n});\r\n\r\nfunction getPointsByArgFromPrevSeries(prevSeries, argument) {\r\n    var result;\r\n    while (!result && prevSeries) {\r\n        result = prevSeries._segmentByArg && prevSeries._segmentByArg[argument];\r\n        prevSeries = prevSeries._prevSeries\r\n    }\r\n    return result\r\n}\r\nexports.chart.stackedsplinearea = _extend({}, areaSeries.splinearea, baseStackedSeries, {\r\n    _prepareSegment: function(points, rotated) {\r\n        var that = this;\r\n        var areaSegment;\r\n        points = preparePointsForStackedAreaSegment(points);\r\n        if (!this._prevSeries || 1 === points.length) {\r\n            areaSegment = areaSeries.splinearea._prepareSegment.call(this, points, rotated)\r\n        } else {\r\n            var forwardPoints = lineSeries.spline._calculateBezierPoints(points, rotated);\r\n            var backwardPoints = vizUtils.map(points, function(p) {\r\n                var point = p.getCoords(true);\r\n                point.argument = p.argument;\r\n                return point\r\n            });\r\n            var prevSeriesForwardPoints = [];\r\n            var pointByArg = {};\r\n            var i = 0;\r\n            var len = that._prevSeries._segments.length;\r\n            while (i < len) {\r\n                prevSeriesForwardPoints = prevSeriesForwardPoints.concat(that._prevSeries._segments[i].line);\r\n                i++\r\n            }\r\n            each(prevSeriesForwardPoints, function(_, p) {\r\n                if (null !== p.argument) {\r\n                    var argument = p.argument.valueOf();\r\n                    if (!pointByArg[argument]) {\r\n                        pointByArg[argument] = [p]\r\n                    } else {\r\n                        pointByArg[argument].push(p)\r\n                    }\r\n                }\r\n            });\r\n            that._prevSeries._segmentByArg = pointByArg;\r\n            backwardPoints = lineSeries.spline._calculateBezierPoints(backwardPoints, rotated);\r\n            each(backwardPoints, function(i, p) {\r\n                var argument = p.argument.valueOf();\r\n                var prevSeriesPoints;\r\n                if (i % 3 === 0) {\r\n                    prevSeriesPoints = pointByArg[argument] || getPointsByArgFromPrevSeries(that._prevSeries, argument);\r\n                    if (prevSeriesPoints) {\r\n                        backwardPoints[i - 1] && prevSeriesPoints[0] && (backwardPoints[i - 1] = prevSeriesPoints[0]);\r\n                        backwardPoints[i + 1] && (backwardPoints[i + 1] = prevSeriesPoints[2] || p)\r\n                    }\r\n                }\r\n            });\r\n            areaSegment = {\r\n                line: forwardPoints,\r\n                area: forwardPoints.concat(backwardPoints.reverse())\r\n            };\r\n            that._areaPointsToSplineAreaPoints(areaSegment.area)\r\n        }\r\n        return areaSegment\r\n    },\r\n    _appendInGroup: exports.chart.stackedarea._appendInGroup\r\n});\r\nexports.chart.fullstackedarea = _extend({}, chartAreaSeries, baseStackedSeries, {\r\n    _prepareSegment: exports.chart.stackedarea._prepareSegment,\r\n    _appendInGroup: exports.chart.stackedarea._appendInGroup\r\n});\r\nexports.chart.fullstackedsplinearea = _extend({}, areaSeries.splinearea, baseStackedSeries, {\r\n    _prepareSegment: exports.chart.stackedsplinearea._prepareSegment,\r\n    _appendInGroup: exports.chart.stackedarea._appendInGroup\r\n});\r\nexports.polar.stackedbar = _extend({}, barSeries.polar.bar, baseStackedSeries, {});\r\n"]},"metadata":{},"sourceType":"module"}