{"ast":null,"code":"/**\r\n * DevExtreme (viz/series/helpers/range_data_calculator.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _utils = require(\"../../core/utils\");\n\nvar _type = require(\"../../../core/utils/type\");\n\nvar _common = require(\"../../../core/utils/common\");\n\nvar DISCRETE = \"discrete\";\nvar abs = Math.abs,\n    floor = Math.floor,\n    ceil = Math.ceil,\n    min = Math.min;\n\nfunction continuousRangeCalculator(range, minValue, maxValue) {\n  range.min = range.min < minValue ? range.min : minValue;\n  range.max = range.max > maxValue ? range.max : maxValue;\n}\n\nfunction createGetLogFunction(axisType, axis) {\n  if (\"logarithmic\" !== axisType) {\n    return null;\n  }\n\n  var base = axis.getOptions().logarithmBase;\n  return function (value) {\n    var log = (0, _utils.getLog)(abs(value), base);\n    var round = log < 0 ? floor : ceil;\n    return round(log);\n  };\n}\n\nfunction getRangeCalculator(axisType, axis, getLog) {\n  var rangeCalculator = continuousRangeCalculator;\n\n  if (axisType === DISCRETE) {\n    rangeCalculator = function rangeCalculator(range, minValue, maxValue) {\n      if (minValue !== maxValue) {\n        range.categories.push(maxValue);\n      }\n\n      range.categories.push(minValue);\n    };\n  } else {\n    if (axis) {\n      rangeCalculator = function rangeCalculator(range, value) {\n        var interval = axis.calculateInterval(value, range.prevValue);\n        var minInterval = range.interval;\n        range.interval = (minInterval < interval ? minInterval : interval) || minInterval;\n        range.prevValue = value;\n        continuousRangeCalculator(range, value, value);\n      };\n    }\n  }\n\n  if (getLog) {\n    return function (range, minValue, maxValue) {\n      var minArgs = [];\n      rangeCalculator(range, minValue, maxValue);\n      0 !== minValue && minArgs.push(getLog(minValue));\n      0 !== maxValue && minArgs.push(getLog(maxValue));\n      var linearThreshold = min.apply(null, minArgs);\n      range.linearThreshold = range.linearThreshold < linearThreshold ? range.linearThreshold : linearThreshold;\n    };\n  }\n\n  return rangeCalculator;\n}\n\nfunction getInitialRange(axisType, dataType, firstValue) {\n  var range = {\n    axisType: axisType,\n    dataType: dataType\n  };\n\n  if (axisType === DISCRETE) {\n    range.categories = [];\n  } else {\n    range.min = firstValue;\n    range.max = firstValue;\n  }\n\n  return range;\n}\n\nfunction processCategories(range) {\n  if (range.categories) {\n    range.categories = (0, _utils.unique)(range.categories);\n  }\n\n  return range;\n}\n\nfunction getValueForArgument(point, extraPoint, x, range) {\n  if (extraPoint && (0, _type.isDefined)(extraPoint.value)) {\n    var y1 = point.value;\n    var y2 = extraPoint.value;\n    var x1 = point.argument;\n    var x2 = extraPoint.argument;\n    var r = (x - x1) * (y2 - y1) / (x2 - x1) + y1.valueOf();\n    return \"datetime\" === range.dataType ? new Date(r) : r;\n  } else {\n    return point.value;\n  }\n}\n\nfunction calculateRangeBetweenPoints(rangeCalculator, range, point, prevPoint, bound) {\n  var value = getValueForArgument(point, prevPoint, bound, range);\n  rangeCalculator(range, value, value);\n}\n\nfunction isLineSeries(series) {\n  return series.type.toLowerCase().indexOf(\"line\") >= 0 || series.type.toLowerCase().indexOf(\"area\") >= 0;\n}\n\nfunction getViewportReducer(series) {\n  var rangeCalculator = getRangeCalculator(series.valueAxisType);\n  var argumentAxis = series.getArgumentAxis();\n  var viewport = argumentAxis && series.getArgumentAxis().visualRange() || {};\n  var viewportFilter;\n  var calculatePointBetweenPoints = isLineSeries(series) ? calculateRangeBetweenPoints : _common.noop;\n\n  if (argumentAxis && argumentAxis.getMarginOptions().checkInterval) {\n    var range = series.getArgumentAxis().getTranslator().getBusinessRange();\n    var add = (0, _utils.getAddFunction)(range, false);\n    var interval = range.interval;\n\n    if (isFinite(interval) && (0, _type.isDefined)(viewport.startValue) && (0, _type.isDefined)(viewport.endValue)) {\n      viewport.startValue = add(viewport.startValue, interval, -1);\n      viewport.endValue = add(viewport.endValue, interval);\n    }\n  }\n\n  viewportFilter = getViewPortFilter(viewport);\n  return function (range, point, index, points) {\n    var argument = point.argument;\n\n    if (!point.hasValue()) {\n      return range;\n    }\n\n    if (viewportFilter(argument)) {\n      if (!range.startCalc) {\n        range.startCalc = true;\n        calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue);\n      }\n\n      rangeCalculator(range, point.getMinValue(), point.getMaxValue());\n    } else {\n      if (!viewport.categories && (0, _type.isDefined)(viewport.startValue) && argument > viewport.startValue) {\n        if (!range.startCalc) {\n          calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue);\n        }\n\n        range.endCalc = true;\n        calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.endValue);\n      }\n    }\n\n    return range;\n  };\n}\n\nfunction getViewPortFilter(viewport) {\n  if (viewport.categories) {\n    var dictionary = viewport.categories.reduce(function (result, category) {\n      result[category.valueOf()] = true;\n      return result;\n    }, {});\n    return function (argument) {\n      return (0, _type.isDefined)(argument) && dictionary[argument.valueOf()];\n    };\n  }\n\n  if (!(0, _type.isDefined)(viewport.startValue) && !(0, _type.isDefined)(viewport.endValue)) {\n    return function () {\n      return true;\n    };\n  }\n\n  if (!(0, _type.isDefined)(viewport.endValue)) {\n    return function (argument) {\n      return argument >= viewport.startValue;\n    };\n  }\n\n  if (!(0, _type.isDefined)(viewport.startValue)) {\n    return function (argument) {\n      return argument <= viewport.endValue;\n    };\n  }\n\n  return function (argument) {\n    return argument >= viewport.startValue && argument <= viewport.endValue;\n  };\n}\n\nmodule.exports = {\n  getViewPortFilter: getViewPortFilter,\n  getArgumentRange: function getArgumentRange(series) {\n    var data = series._data || [];\n    var range = {};\n\n    if (data.length) {\n      if (series.argumentAxisType === DISCRETE) {\n        range = {\n          categories: data.map(function (item) {\n            return item.argument;\n          })\n        };\n      } else {\n        var interval;\n\n        if (data.length > 1) {\n          var i1 = series.getArgumentAxis().calculateInterval(data[0].argument, data[1].argument);\n          var i2 = series.getArgumentAxis().calculateInterval(data[data.length - 1].argument, data[data.length - 2].argument);\n          interval = min(i1, i2);\n        }\n\n        range = {\n          min: data[0].argument,\n          max: data[data.length - 1].argument,\n          interval: interval\n        };\n      }\n    }\n\n    return processCategories(range);\n  },\n  getRangeData: function getRangeData(series) {\n    var points = series.getPoints();\n    var useAggregation = series.useAggregation();\n    var argumentCalculator = getRangeCalculator(series.argumentAxisType, points.length > 1 && series.getArgumentAxis(), createGetLogFunction(series.argumentAxisType, series.getArgumentAxis()));\n    var valueRangeCalculator = getRangeCalculator(series.valueAxisType, null, createGetLogFunction(series.valueAxisType, series.getValueAxis()));\n    var viewportReducer = getViewportReducer(series);\n    var range = points.reduce(function (range, point, index, points) {\n      var argument = point.argument;\n\n      if (!point.isArgumentCorrect()) {\n        return range;\n      }\n\n      argumentCalculator(range.arg, argument, argument);\n\n      if (point.hasValue()) {\n        valueRangeCalculator(range.val, point.getMinValue(), point.getMaxValue());\n        viewportReducer(range.viewport, point, index, points);\n      }\n\n      return range;\n    }, {\n      arg: getInitialRange(series.argumentAxisType, series.argumentType),\n      val: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0),\n      viewport: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0)\n    });\n\n    if (useAggregation) {\n      var argumentRange = this.getArgumentRange(series);\n\n      if (series.argumentAxisType === DISCRETE) {\n        range.arg = argumentRange;\n      } else {\n        var viewport = series.getArgumentAxis().getViewport();\n\n        if ((0, _type.isDefined)(viewport.startValue) || (0, _type.isDefined)(viewport.length)) {\n          argumentCalculator(range.arg, argumentRange.min, argumentRange.min);\n        }\n\n        if ((0, _type.isDefined)(viewport.endValue) || (0, _type.isDefined)(viewport.length) && (0, _type.isDefined)(viewport.startValue)) {\n          argumentCalculator(range.arg, argumentRange.max, argumentRange.max);\n        }\n      }\n    }\n\n    processCategories(range.arg);\n    processCategories(range.val);\n    return range;\n  },\n  getViewport: function getViewport(series) {\n    var points = series.getPoints();\n    var range = {};\n    var reducer;\n    reducer = getViewportReducer(series);\n    range = getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0);\n    points.some(function (point, index) {\n      reducer(range, point, index, points);\n      return range.endCalc;\n    });\n    return range;\n  },\n  getPointsInViewPort: function getPointsInViewPort(series) {\n    var argumentViewPortFilter = getViewPortFilter(series.getArgumentAxis().visualRange() || {});\n    var valueViewPort = series.getValueAxis().visualRange() || {};\n    var valueViewPortFilter = getViewPortFilter(valueViewPort);\n    var points = series.getPoints();\n\n    var addValue = function addValue(values, point, isEdge) {\n      var minValue = point.getMinValue();\n      var maxValue = point.getMaxValue();\n      var isMinValueInViewPort = valueViewPortFilter(minValue);\n      var isMaxValueInViewPort = valueViewPortFilter(maxValue);\n\n      if (isMinValueInViewPort) {\n        values.push(minValue);\n      }\n\n      if (maxValue !== minValue && isMaxValueInViewPort) {\n        values.push(maxValue);\n      }\n\n      if (isEdge && !isMinValueInViewPort && !isMaxValueInViewPort) {\n        if (!values.length) {\n          values.push(valueViewPort.startValue);\n        } else {\n          values.push(valueViewPort.endValue);\n        }\n      }\n    };\n\n    var addEdgePoints = isLineSeries(series) ? function (result, points, index) {\n      var point = points[index];\n      var prevPoint = points[index - 1];\n      var nextPoint = points[index + 1];\n\n      if (nextPoint && argumentViewPortFilter(nextPoint.argument)) {\n        addValue(result[1], point, true);\n      }\n\n      if (prevPoint && argumentViewPortFilter(prevPoint.argument)) {\n        addValue(result[1], point, true);\n      }\n    } : _common.noop;\n\n    var checkPointInViewport = function checkPointInViewport(result, point, index) {\n      if (argumentViewPortFilter(point.argument)) {\n        addValue(result[0], point);\n      } else {\n        addEdgePoints(result, points, index);\n      }\n\n      return result;\n    };\n\n    return points.reduce(checkPointInViewport, [[], []]);\n  }\n};","map":{"version":3,"sources":["C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/devextreme/viz/series/helpers/range_data_calculator.js"],"names":["_utils","require","_type","_common","DISCRETE","abs","Math","floor","ceil","min","range","base","axis","log","round","rangeCalculator","axisType","minValue","interval","minInterval","continuousRangeCalculator","minArgs","getLog","linearThreshold","dataType","extraPoint","y1","point","y2","x1","x2","r","x","value","getValueForArgument","series","getRangeCalculator","argumentAxis","viewport","calculatePointBetweenPoints","isLineSeries","add","isFinite","viewportFilter","getViewPortFilter","argument","points","index","dictionary","result","category","module","getArgumentRange","data","categories","item","i1","i2","max","processCategories","getRangeData","useAggregation","argumentCalculator","createGetLogFunction","valueRangeCalculator","viewportReducer","getViewportReducer","arg","getInitialRange","val","argumentRange","getViewport","reducer","getPointsInViewPort","argumentViewPortFilter","valueViewPort","valueViewPortFilter","addValue","maxValue","isMinValueInViewPort","isMaxValueInViewPort","values","isEdge","addEdgePoints","prevPoint","nextPoint","checkPointInViewport"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (viz/series/helpers/range_data_calculator.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nvar _utils = require(\"../../core/utils\");\r\nvar _type = require(\"../../../core/utils/type\");\r\nvar _common = require(\"../../../core/utils/common\");\r\nvar DISCRETE = \"discrete\";\r\nvar abs = Math.abs,\r\n    floor = Math.floor,\r\n    ceil = Math.ceil,\r\n    min = Math.min;\r\n\r\nfunction continuousRangeCalculator(range, minValue, maxValue) {\r\n    range.min = range.min < minValue ? range.min : minValue;\r\n    range.max = range.max > maxValue ? range.max : maxValue\r\n}\r\n\r\nfunction createGetLogFunction(axisType, axis) {\r\n    if (\"logarithmic\" !== axisType) {\r\n        return null\r\n    }\r\n    var base = axis.getOptions().logarithmBase;\r\n    return function(value) {\r\n        var log = (0, _utils.getLog)(abs(value), base);\r\n        var round = log < 0 ? floor : ceil;\r\n        return round(log)\r\n    }\r\n}\r\n\r\nfunction getRangeCalculator(axisType, axis, getLog) {\r\n    var rangeCalculator = continuousRangeCalculator;\r\n    if (axisType === DISCRETE) {\r\n        rangeCalculator = function(range, minValue, maxValue) {\r\n            if (minValue !== maxValue) {\r\n                range.categories.push(maxValue)\r\n            }\r\n            range.categories.push(minValue)\r\n        }\r\n    } else {\r\n        if (axis) {\r\n            rangeCalculator = function(range, value) {\r\n                var interval = axis.calculateInterval(value, range.prevValue);\r\n                var minInterval = range.interval;\r\n                range.interval = (minInterval < interval ? minInterval : interval) || minInterval;\r\n                range.prevValue = value;\r\n                continuousRangeCalculator(range, value, value)\r\n            }\r\n        }\r\n    }\r\n    if (getLog) {\r\n        return function(range, minValue, maxValue) {\r\n            var minArgs = [];\r\n            rangeCalculator(range, minValue, maxValue);\r\n            0 !== minValue && minArgs.push(getLog(minValue));\r\n            0 !== maxValue && minArgs.push(getLog(maxValue));\r\n            var linearThreshold = min.apply(null, minArgs);\r\n            range.linearThreshold = range.linearThreshold < linearThreshold ? range.linearThreshold : linearThreshold\r\n        }\r\n    }\r\n    return rangeCalculator\r\n}\r\n\r\nfunction getInitialRange(axisType, dataType, firstValue) {\r\n    var range = {\r\n        axisType: axisType,\r\n        dataType: dataType\r\n    };\r\n    if (axisType === DISCRETE) {\r\n        range.categories = []\r\n    } else {\r\n        range.min = firstValue;\r\n        range.max = firstValue\r\n    }\r\n    return range\r\n}\r\n\r\nfunction processCategories(range) {\r\n    if (range.categories) {\r\n        range.categories = (0, _utils.unique)(range.categories)\r\n    }\r\n    return range\r\n}\r\n\r\nfunction getValueForArgument(point, extraPoint, x, range) {\r\n    if (extraPoint && (0, _type.isDefined)(extraPoint.value)) {\r\n        var y1 = point.value;\r\n        var y2 = extraPoint.value;\r\n        var x1 = point.argument;\r\n        var x2 = extraPoint.argument;\r\n        var r = (x - x1) * (y2 - y1) / (x2 - x1) + y1.valueOf();\r\n        return \"datetime\" === range.dataType ? new Date(r) : r\r\n    } else {\r\n        return point.value\r\n    }\r\n}\r\n\r\nfunction calculateRangeBetweenPoints(rangeCalculator, range, point, prevPoint, bound) {\r\n    var value = getValueForArgument(point, prevPoint, bound, range);\r\n    rangeCalculator(range, value, value)\r\n}\r\n\r\nfunction isLineSeries(series) {\r\n    return series.type.toLowerCase().indexOf(\"line\") >= 0 || series.type.toLowerCase().indexOf(\"area\") >= 0\r\n}\r\n\r\nfunction getViewportReducer(series) {\r\n    var rangeCalculator = getRangeCalculator(series.valueAxisType);\r\n    var argumentAxis = series.getArgumentAxis();\r\n    var viewport = argumentAxis && series.getArgumentAxis().visualRange() || {};\r\n    var viewportFilter;\r\n    var calculatePointBetweenPoints = isLineSeries(series) ? calculateRangeBetweenPoints : _common.noop;\r\n    if (argumentAxis && argumentAxis.getMarginOptions().checkInterval) {\r\n        var range = series.getArgumentAxis().getTranslator().getBusinessRange();\r\n        var add = (0, _utils.getAddFunction)(range, false);\r\n        var interval = range.interval;\r\n        if (isFinite(interval) && (0, _type.isDefined)(viewport.startValue) && (0, _type.isDefined)(viewport.endValue)) {\r\n            viewport.startValue = add(viewport.startValue, interval, -1);\r\n            viewport.endValue = add(viewport.endValue, interval)\r\n        }\r\n    }\r\n    viewportFilter = getViewPortFilter(viewport);\r\n    return function(range, point, index, points) {\r\n        var argument = point.argument;\r\n        if (!point.hasValue()) {\r\n            return range\r\n        }\r\n        if (viewportFilter(argument)) {\r\n            if (!range.startCalc) {\r\n                range.startCalc = true;\r\n                calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue)\r\n            }\r\n            rangeCalculator(range, point.getMinValue(), point.getMaxValue())\r\n        } else {\r\n            if (!viewport.categories && (0, _type.isDefined)(viewport.startValue) && argument > viewport.startValue) {\r\n                if (!range.startCalc) {\r\n                    calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.startValue)\r\n                }\r\n                range.endCalc = true;\r\n                calculatePointBetweenPoints(rangeCalculator, range, point, points[index - 1], viewport.endValue)\r\n            }\r\n        }\r\n        return range\r\n    }\r\n}\r\n\r\nfunction getViewPortFilter(viewport) {\r\n    if (viewport.categories) {\r\n        var dictionary = viewport.categories.reduce(function(result, category) {\r\n            result[category.valueOf()] = true;\r\n            return result\r\n        }, {});\r\n        return function(argument) {\r\n            return (0, _type.isDefined)(argument) && dictionary[argument.valueOf()]\r\n        }\r\n    }\r\n    if (!(0, _type.isDefined)(viewport.startValue) && !(0, _type.isDefined)(viewport.endValue)) {\r\n        return function() {\r\n            return true\r\n        }\r\n    }\r\n    if (!(0, _type.isDefined)(viewport.endValue)) {\r\n        return function(argument) {\r\n            return argument >= viewport.startValue\r\n        }\r\n    }\r\n    if (!(0, _type.isDefined)(viewport.startValue)) {\r\n        return function(argument) {\r\n            return argument <= viewport.endValue\r\n        }\r\n    }\r\n    return function(argument) {\r\n        return argument >= viewport.startValue && argument <= viewport.endValue\r\n    }\r\n}\r\nmodule.exports = {\r\n    getViewPortFilter: getViewPortFilter,\r\n    getArgumentRange: function(series) {\r\n        var data = series._data || [];\r\n        var range = {};\r\n        if (data.length) {\r\n            if (series.argumentAxisType === DISCRETE) {\r\n                range = {\r\n                    categories: data.map(function(item) {\r\n                        return item.argument\r\n                    })\r\n                }\r\n            } else {\r\n                var interval;\r\n                if (data.length > 1) {\r\n                    var i1 = series.getArgumentAxis().calculateInterval(data[0].argument, data[1].argument);\r\n                    var i2 = series.getArgumentAxis().calculateInterval(data[data.length - 1].argument, data[data.length - 2].argument);\r\n                    interval = min(i1, i2)\r\n                }\r\n                range = {\r\n                    min: data[0].argument,\r\n                    max: data[data.length - 1].argument,\r\n                    interval: interval\r\n                }\r\n            }\r\n        }\r\n        return processCategories(range)\r\n    },\r\n    getRangeData: function(series) {\r\n        var points = series.getPoints();\r\n        var useAggregation = series.useAggregation();\r\n        var argumentCalculator = getRangeCalculator(series.argumentAxisType, points.length > 1 && series.getArgumentAxis(), createGetLogFunction(series.argumentAxisType, series.getArgumentAxis()));\r\n        var valueRangeCalculator = getRangeCalculator(series.valueAxisType, null, createGetLogFunction(series.valueAxisType, series.getValueAxis()));\r\n        var viewportReducer = getViewportReducer(series);\r\n        var range = points.reduce(function(range, point, index, points) {\r\n            var argument = point.argument;\r\n            if (!point.isArgumentCorrect()) {\r\n                return range\r\n            }\r\n            argumentCalculator(range.arg, argument, argument);\r\n            if (point.hasValue()) {\r\n                valueRangeCalculator(range.val, point.getMinValue(), point.getMaxValue());\r\n                viewportReducer(range.viewport, point, index, points)\r\n            }\r\n            return range\r\n        }, {\r\n            arg: getInitialRange(series.argumentAxisType, series.argumentType),\r\n            val: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0),\r\n            viewport: getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0)\r\n        });\r\n        if (useAggregation) {\r\n            var argumentRange = this.getArgumentRange(series);\r\n            if (series.argumentAxisType === DISCRETE) {\r\n                range.arg = argumentRange\r\n            } else {\r\n                var viewport = series.getArgumentAxis().getViewport();\r\n                if ((0, _type.isDefined)(viewport.startValue) || (0, _type.isDefined)(viewport.length)) {\r\n                    argumentCalculator(range.arg, argumentRange.min, argumentRange.min)\r\n                }\r\n                if ((0, _type.isDefined)(viewport.endValue) || (0, _type.isDefined)(viewport.length) && (0, _type.isDefined)(viewport.startValue)) {\r\n                    argumentCalculator(range.arg, argumentRange.max, argumentRange.max)\r\n                }\r\n            }\r\n        }\r\n        processCategories(range.arg);\r\n        processCategories(range.val);\r\n        return range\r\n    },\r\n    getViewport: function(series) {\r\n        var points = series.getPoints();\r\n        var range = {};\r\n        var reducer;\r\n        reducer = getViewportReducer(series);\r\n        range = getInitialRange(series.valueAxisType, series.valueType, points.length ? series.getValueRangeInitialValue() : void 0);\r\n        points.some(function(point, index) {\r\n            reducer(range, point, index, points);\r\n            return range.endCalc\r\n        });\r\n        return range\r\n    },\r\n    getPointsInViewPort: function(series) {\r\n        var argumentViewPortFilter = getViewPortFilter(series.getArgumentAxis().visualRange() || {});\r\n        var valueViewPort = series.getValueAxis().visualRange() || {};\r\n        var valueViewPortFilter = getViewPortFilter(valueViewPort);\r\n        var points = series.getPoints();\r\n        var addValue = function(values, point, isEdge) {\r\n            var minValue = point.getMinValue();\r\n            var maxValue = point.getMaxValue();\r\n            var isMinValueInViewPort = valueViewPortFilter(minValue);\r\n            var isMaxValueInViewPort = valueViewPortFilter(maxValue);\r\n            if (isMinValueInViewPort) {\r\n                values.push(minValue)\r\n            }\r\n            if (maxValue !== minValue && isMaxValueInViewPort) {\r\n                values.push(maxValue)\r\n            }\r\n            if (isEdge && !isMinValueInViewPort && !isMaxValueInViewPort) {\r\n                if (!values.length) {\r\n                    values.push(valueViewPort.startValue)\r\n                } else {\r\n                    values.push(valueViewPort.endValue)\r\n                }\r\n            }\r\n        };\r\n        var addEdgePoints = isLineSeries(series) ? function(result, points, index) {\r\n            var point = points[index];\r\n            var prevPoint = points[index - 1];\r\n            var nextPoint = points[index + 1];\r\n            if (nextPoint && argumentViewPortFilter(nextPoint.argument)) {\r\n                addValue(result[1], point, true)\r\n            }\r\n            if (prevPoint && argumentViewPortFilter(prevPoint.argument)) {\r\n                addValue(result[1], point, true)\r\n            }\r\n        } : _common.noop;\r\n        var checkPointInViewport = function(result, point, index) {\r\n            if (argumentViewPortFilter(point.argument)) {\r\n                addValue(result[0], point)\r\n            } else {\r\n                addEdgePoints(result, points, index)\r\n            }\r\n            return result\r\n        };\r\n        return points.reduce(checkPointInViewport, [\r\n            [],\r\n            []\r\n        ])\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"module"}