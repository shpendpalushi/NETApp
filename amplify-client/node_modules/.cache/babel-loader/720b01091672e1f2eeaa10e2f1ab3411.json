{"ast":null,"code":"/**\r\n * DevExtreme (viz/series/area_series.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar objectUtils = require(\"../../core/utils/object\");\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar scatterSeries = require(\"./scatter_series\").chart;\n\nvar lineSeries = require(\"./line_series\");\n\nvar chartLineSeries = lineSeries.chart.line;\nvar polarLineSeries = lineSeries.polar.line;\n\nvar _map = require(\"../core/utils\").map;\n\nvar _extend = extend;\nvar calculateBezierPoints = lineSeries.chart.spline._calculateBezierPoints;\nexports.chart = {};\nexports.polar = {};\nvar baseAreaMethods = {\n  _createBorderElement: chartLineSeries._createMainElement,\n  _createLegendState: function _createLegendState(styleOptions, defaultColor) {\n    return {\n      fill: styleOptions.color || defaultColor,\n      opacity: styleOptions.opacity,\n      hatching: styleOptions.hatching\n    };\n  },\n  getValueRangeInitialValue: function getValueRangeInitialValue() {\n    if (\"logarithmic\" !== this.valueAxisType && \"datetime\" !== this.valueType && false !== this.showZero) {\n      return 0;\n    } else {\n      return scatterSeries.getValueRangeInitialValue.call(this);\n    }\n  },\n  _getDefaultSegment: function _getDefaultSegment(segment) {\n    var defaultSegment = chartLineSeries._getDefaultSegment(segment);\n\n    defaultSegment.area = defaultSegment.line.concat(defaultSegment.line.slice().reverse());\n    return defaultSegment;\n  },\n  _updateElement: function _updateElement(element, segment, animate, complete) {\n    var lineParams = {\n      points: segment.line\n    };\n    var areaParams = {\n      points: segment.area\n    };\n    var borderElement = element.line;\n\n    if (animate) {\n      borderElement && borderElement.animate(lineParams);\n      element.area.animate(areaParams, {}, complete);\n    } else {\n      borderElement && borderElement.attr(lineParams);\n      element.area.attr(areaParams);\n    }\n  },\n  _removeElement: function _removeElement(element) {\n    element.line && element.line.remove();\n    element.area.remove();\n  },\n  _drawElement: function _drawElement(segment) {\n    return {\n      line: this._bordersGroup && this._createBorderElement(segment.line, {\n        \"stroke-width\": this._styles.normal.border[\"stroke-width\"]\n      }).append(this._bordersGroup),\n      area: this._createMainElement(segment.area).append(this._elementsGroup)\n    };\n  },\n  _applyStyle: function _applyStyle(style) {\n    var that = this;\n    that._elementsGroup && that._elementsGroup.smartAttr(style.elements);\n    that._bordersGroup && that._bordersGroup.attr(style.border);\n    (that._graphics || []).forEach(function (graphic) {\n      graphic.line && graphic.line.attr({\n        \"stroke-width\": style.border[\"stroke-width\"]\n      }).sharp();\n    });\n  },\n  _parseStyle: function _parseStyle(options, defaultColor, defaultBorderColor) {\n    var borderOptions = options.border || {};\n\n    var borderStyle = chartLineSeries._parseLineOptions(borderOptions, defaultBorderColor);\n\n    borderStyle.stroke = borderOptions.visible && borderStyle[\"stroke-width\"] ? borderStyle.stroke : \"none\";\n    borderStyle[\"stroke-width\"] = borderStyle[\"stroke-width\"] || 1;\n    return {\n      border: borderStyle,\n      elements: {\n        stroke: \"none\",\n        fill: options.color || defaultColor,\n        hatching: options.hatching,\n        opacity: options.opacity\n      }\n    };\n  },\n  _areBordersVisible: function _areBordersVisible() {\n    var options = this._options;\n    return options.border.visible || options.hoverStyle.border.visible || options.selectionStyle.border.visible;\n  },\n  _createMainElement: function _createMainElement(points, settings) {\n    return this._renderer.path(points, \"area\").attr(settings);\n  },\n  _getTrackerSettings: function _getTrackerSettings(segment) {\n    return {\n      \"stroke-width\": segment.singlePointSegment ? this._defaultTrackerWidth : 0\n    };\n  },\n  _getMainPointsFromSegment: function _getMainPointsFromSegment(segment) {\n    return segment.area;\n  }\n};\n\nfunction createAreaPoints(points) {\n  return _map(points, function (pt) {\n    return pt.getCoords();\n  }).concat(_map(points.slice().reverse(), function (pt) {\n    return pt.getCoords(true);\n  }));\n}\n\nvar areaSeries = exports.chart.area = _extend({}, chartLineSeries, baseAreaMethods, {\n  _prepareSegment: function _prepareSegment(points, rotated) {\n    var that = this;\n\n    var processedPoints = that._processSinglePointsAreaSegment(points, rotated);\n\n    var areaPoints = createAreaPoints(processedPoints);\n    var argAxis = that.getArgumentAxis();\n\n    if (argAxis.getAxisPosition) {\n      var argAxisPosition = argAxis.getAxisPosition();\n      var axisOptions = argAxis.getOptions();\n      var edgeOffset = (!rotated ? -1 : 1) * Math.round(axisOptions.width / 2);\n\n      if (axisOptions.visible) {\n        areaPoints.forEach(function (p, i) {\n          if (p) {\n            var index = 1 === points.length ? 0 : i < points.length ? i : areaPoints.length - 1 - i;\n            rotated && p.x === points[index].defaultX && p.x === argAxisPosition - argAxis.getAxisShift() && (p.x += edgeOffset);\n            !rotated && p.y === points[index].defaultY && p.y === argAxisPosition - argAxis.getAxisShift() && (p.y += edgeOffset);\n          }\n        });\n      }\n    }\n\n    return {\n      line: processedPoints,\n      area: areaPoints,\n      singlePointSegment: processedPoints !== points\n    };\n  },\n  _processSinglePointsAreaSegment: function _processSinglePointsAreaSegment(points, rotated) {\n    if (points && 1 === points.length) {\n      var p = points[0];\n      var p1 = objectUtils.clone(p);\n      p1[rotated ? \"y\" : \"x\"] += 1;\n      p1.argument = null;\n      return [p, p1];\n    }\n\n    return points;\n  }\n});\n\nexports.polar.area = _extend({}, polarLineSeries, baseAreaMethods, {\n  _prepareSegment: function _prepareSegment(points, rotated, lastSegment) {\n    lastSegment && polarLineSeries._closeSegment.call(this, points);\n    return areaSeries._prepareSegment.call(this, points);\n  },\n  _processSinglePointsAreaSegment: function _processSinglePointsAreaSegment(points) {\n    return lineSeries.polar.line._prepareSegment.call(this, points).line;\n  }\n});\nexports.chart.steparea = _extend({}, areaSeries, {\n  _prepareSegment: function _prepareSegment(points, rotated) {\n    var stepLineSeries = lineSeries.chart.stepline;\n    points = areaSeries._processSinglePointsAreaSegment(points, rotated);\n    return areaSeries._prepareSegment.call(this, stepLineSeries._calculateStepLinePoints.call(this, points), rotated);\n  },\n  getSeriesPairCoord: lineSeries.chart.stepline.getSeriesPairCoord\n});\nexports.chart.splinearea = _extend({}, areaSeries, {\n  _areaPointsToSplineAreaPoints: function _areaPointsToSplineAreaPoints(areaPoints) {\n    var previousMiddlePoint = areaPoints[areaPoints.length / 2 - 1];\n    var middlePoint = areaPoints[areaPoints.length / 2];\n    areaPoints.splice(areaPoints.length / 2, 0, {\n      x: previousMiddlePoint.x,\n      y: previousMiddlePoint.y\n    }, {\n      x: middlePoint.x,\n      y: middlePoint.y\n    });\n  },\n  _prepareSegment: function _prepareSegment(points, rotated) {\n    var processedPoints = areaSeries._processSinglePointsAreaSegment(points, rotated);\n\n    var areaSegment = areaSeries._prepareSegment.call(this, calculateBezierPoints(processedPoints, rotated));\n\n    this._areaPointsToSplineAreaPoints(areaSegment.area);\n\n    areaSegment.singlePointSegment = processedPoints !== points;\n    return areaSegment;\n  },\n  _getDefaultSegment: function _getDefaultSegment(segment) {\n    var areaDefaultSegment = areaSeries._getDefaultSegment(segment);\n\n    this._areaPointsToSplineAreaPoints(areaDefaultSegment.area);\n\n    return areaDefaultSegment;\n  },\n  _createMainElement: function _createMainElement(points, settings) {\n    return this._renderer.path(points, \"bezierarea\").attr(settings);\n  },\n  _createBorderElement: lineSeries.chart.spline._createMainElement,\n  getSeriesPairCoord: lineSeries.chart.spline.getSeriesPairCoord,\n  getNearestPointsByCoord: lineSeries.chart.spline.getNearestPointsByCoord,\n  obtainCubicBezierTCoef: lineSeries.chart.spline.obtainCubicBezierTCoef\n});","map":{"version":3,"sources":["C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/devextreme/viz/series/area_series.js"],"names":["objectUtils","require","extend","scatterSeries","lineSeries","chartLineSeries","polarLineSeries","_map","_extend","calculateBezierPoints","exports","baseAreaMethods","_createBorderElement","_createLegendState","fill","styleOptions","opacity","hatching","getValueRangeInitialValue","_getDefaultSegment","defaultSegment","_updateElement","lineParams","points","segment","line","areaParams","area","borderElement","element","_removeElement","_drawElement","_applyStyle","that","style","graphic","_parseStyle","borderOptions","options","borderStyle","border","elements","stroke","_areBordersVisible","_createMainElement","_getTrackerSettings","_getMainPointsFromSegment","pt","areaSeries","_prepareSegment","processedPoints","areaPoints","createAreaPoints","argAxis","argAxisPosition","axisOptions","edgeOffset","Math","index","i","rotated","p","singlePointSegment","_processSinglePointsAreaSegment","p1","lastSegment","stepLineSeries","getSeriesPairCoord","_areaPointsToSplineAreaPoints","previousMiddlePoint","middlePoint","x","y","areaSegment","areaDefaultSegment","getNearestPointsByCoord","obtainCubicBezierTCoef"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (viz/series/area_series.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nvar objectUtils = require(\"../../core/utils/object\");\r\nvar extend = require(\"../../core/utils/extend\").extend;\r\nvar scatterSeries = require(\"./scatter_series\").chart;\r\nvar lineSeries = require(\"./line_series\");\r\nvar chartLineSeries = lineSeries.chart.line;\r\nvar polarLineSeries = lineSeries.polar.line;\r\nvar _map = require(\"../core/utils\").map;\r\nvar _extend = extend;\r\nvar calculateBezierPoints = lineSeries.chart.spline._calculateBezierPoints;\r\nexports.chart = {};\r\nexports.polar = {};\r\nvar baseAreaMethods = {\r\n    _createBorderElement: chartLineSeries._createMainElement,\r\n    _createLegendState: function(styleOptions, defaultColor) {\r\n        return {\r\n            fill: styleOptions.color || defaultColor,\r\n            opacity: styleOptions.opacity,\r\n            hatching: styleOptions.hatching\r\n        }\r\n    },\r\n    getValueRangeInitialValue: function() {\r\n        if (\"logarithmic\" !== this.valueAxisType && \"datetime\" !== this.valueType && false !== this.showZero) {\r\n            return 0\r\n        } else {\r\n            return scatterSeries.getValueRangeInitialValue.call(this)\r\n        }\r\n    },\r\n    _getDefaultSegment: function(segment) {\r\n        var defaultSegment = chartLineSeries._getDefaultSegment(segment);\r\n        defaultSegment.area = defaultSegment.line.concat(defaultSegment.line.slice().reverse());\r\n        return defaultSegment\r\n    },\r\n    _updateElement: function(element, segment, animate, complete) {\r\n        var lineParams = {\r\n            points: segment.line\r\n        };\r\n        var areaParams = {\r\n            points: segment.area\r\n        };\r\n        var borderElement = element.line;\r\n        if (animate) {\r\n            borderElement && borderElement.animate(lineParams);\r\n            element.area.animate(areaParams, {}, complete)\r\n        } else {\r\n            borderElement && borderElement.attr(lineParams);\r\n            element.area.attr(areaParams)\r\n        }\r\n    },\r\n    _removeElement: function(element) {\r\n        element.line && element.line.remove();\r\n        element.area.remove()\r\n    },\r\n    _drawElement: function(segment) {\r\n        return {\r\n            line: this._bordersGroup && this._createBorderElement(segment.line, {\r\n                \"stroke-width\": this._styles.normal.border[\"stroke-width\"]\r\n            }).append(this._bordersGroup),\r\n            area: this._createMainElement(segment.area).append(this._elementsGroup)\r\n        }\r\n    },\r\n    _applyStyle: function(style) {\r\n        var that = this;\r\n        that._elementsGroup && that._elementsGroup.smartAttr(style.elements);\r\n        that._bordersGroup && that._bordersGroup.attr(style.border);\r\n        (that._graphics || []).forEach(function(graphic) {\r\n            graphic.line && graphic.line.attr({\r\n                \"stroke-width\": style.border[\"stroke-width\"]\r\n            }).sharp()\r\n        })\r\n    },\r\n    _parseStyle: function(options, defaultColor, defaultBorderColor) {\r\n        var borderOptions = options.border || {};\r\n        var borderStyle = chartLineSeries._parseLineOptions(borderOptions, defaultBorderColor);\r\n        borderStyle.stroke = borderOptions.visible && borderStyle[\"stroke-width\"] ? borderStyle.stroke : \"none\";\r\n        borderStyle[\"stroke-width\"] = borderStyle[\"stroke-width\"] || 1;\r\n        return {\r\n            border: borderStyle,\r\n            elements: {\r\n                stroke: \"none\",\r\n                fill: options.color || defaultColor,\r\n                hatching: options.hatching,\r\n                opacity: options.opacity\r\n            }\r\n        }\r\n    },\r\n    _areBordersVisible: function() {\r\n        var options = this._options;\r\n        return options.border.visible || options.hoverStyle.border.visible || options.selectionStyle.border.visible\r\n    },\r\n    _createMainElement: function(points, settings) {\r\n        return this._renderer.path(points, \"area\").attr(settings)\r\n    },\r\n    _getTrackerSettings: function(segment) {\r\n        return {\r\n            \"stroke-width\": segment.singlePointSegment ? this._defaultTrackerWidth : 0\r\n        }\r\n    },\r\n    _getMainPointsFromSegment: function(segment) {\r\n        return segment.area\r\n    }\r\n};\r\n\r\nfunction createAreaPoints(points) {\r\n    return _map(points, function(pt) {\r\n        return pt.getCoords()\r\n    }).concat(_map(points.slice().reverse(), function(pt) {\r\n        return pt.getCoords(true)\r\n    }))\r\n}\r\nvar areaSeries = exports.chart.area = _extend({}, chartLineSeries, baseAreaMethods, {\r\n    _prepareSegment: function(points, rotated) {\r\n        var that = this;\r\n        var processedPoints = that._processSinglePointsAreaSegment(points, rotated);\r\n        var areaPoints = createAreaPoints(processedPoints);\r\n        var argAxis = that.getArgumentAxis();\r\n        if (argAxis.getAxisPosition) {\r\n            var argAxisPosition = argAxis.getAxisPosition();\r\n            var axisOptions = argAxis.getOptions();\r\n            var edgeOffset = (!rotated ? -1 : 1) * Math.round(axisOptions.width / 2);\r\n            if (axisOptions.visible) {\r\n                areaPoints.forEach(function(p, i) {\r\n                    if (p) {\r\n                        var index = 1 === points.length ? 0 : i < points.length ? i : areaPoints.length - 1 - i;\r\n                        rotated && p.x === points[index].defaultX && p.x === argAxisPosition - argAxis.getAxisShift() && (p.x += edgeOffset);\r\n                        !rotated && p.y === points[index].defaultY && p.y === argAxisPosition - argAxis.getAxisShift() && (p.y += edgeOffset)\r\n                    }\r\n                })\r\n            }\r\n        }\r\n        return {\r\n            line: processedPoints,\r\n            area: areaPoints,\r\n            singlePointSegment: processedPoints !== points\r\n        }\r\n    },\r\n    _processSinglePointsAreaSegment: function(points, rotated) {\r\n        if (points && 1 === points.length) {\r\n            var p = points[0];\r\n            var p1 = objectUtils.clone(p);\r\n            p1[rotated ? \"y\" : \"x\"] += 1;\r\n            p1.argument = null;\r\n            return [p, p1]\r\n        }\r\n        return points\r\n    }\r\n});\r\nexports.polar.area = _extend({}, polarLineSeries, baseAreaMethods, {\r\n    _prepareSegment: function(points, rotated, lastSegment) {\r\n        lastSegment && polarLineSeries._closeSegment.call(this, points);\r\n        return areaSeries._prepareSegment.call(this, points)\r\n    },\r\n    _processSinglePointsAreaSegment: function(points) {\r\n        return lineSeries.polar.line._prepareSegment.call(this, points).line\r\n    }\r\n});\r\nexports.chart.steparea = _extend({}, areaSeries, {\r\n    _prepareSegment: function(points, rotated) {\r\n        var stepLineSeries = lineSeries.chart.stepline;\r\n        points = areaSeries._processSinglePointsAreaSegment(points, rotated);\r\n        return areaSeries._prepareSegment.call(this, stepLineSeries._calculateStepLinePoints.call(this, points), rotated)\r\n    },\r\n    getSeriesPairCoord: lineSeries.chart.stepline.getSeriesPairCoord\r\n});\r\nexports.chart.splinearea = _extend({}, areaSeries, {\r\n    _areaPointsToSplineAreaPoints: function(areaPoints) {\r\n        var previousMiddlePoint = areaPoints[areaPoints.length / 2 - 1];\r\n        var middlePoint = areaPoints[areaPoints.length / 2];\r\n        areaPoints.splice(areaPoints.length / 2, 0, {\r\n            x: previousMiddlePoint.x,\r\n            y: previousMiddlePoint.y\r\n        }, {\r\n            x: middlePoint.x,\r\n            y: middlePoint.y\r\n        })\r\n    },\r\n    _prepareSegment: function(points, rotated) {\r\n        var processedPoints = areaSeries._processSinglePointsAreaSegment(points, rotated);\r\n        var areaSegment = areaSeries._prepareSegment.call(this, calculateBezierPoints(processedPoints, rotated));\r\n        this._areaPointsToSplineAreaPoints(areaSegment.area);\r\n        areaSegment.singlePointSegment = processedPoints !== points;\r\n        return areaSegment\r\n    },\r\n    _getDefaultSegment: function(segment) {\r\n        var areaDefaultSegment = areaSeries._getDefaultSegment(segment);\r\n        this._areaPointsToSplineAreaPoints(areaDefaultSegment.area);\r\n        return areaDefaultSegment\r\n    },\r\n    _createMainElement: function(points, settings) {\r\n        return this._renderer.path(points, \"bezierarea\").attr(settings)\r\n    },\r\n    _createBorderElement: lineSeries.chart.spline._createMainElement,\r\n    getSeriesPairCoord: lineSeries.chart.spline.getSeriesPairCoord,\r\n    getNearestPointsByCoord: lineSeries.chart.spline.getNearestPointsByCoord,\r\n    obtainCubicBezierTCoef: lineSeries.chart.spline.obtainCubicBezierTCoef\r\n});\r\n"]},"metadata":{},"sourceType":"module"}