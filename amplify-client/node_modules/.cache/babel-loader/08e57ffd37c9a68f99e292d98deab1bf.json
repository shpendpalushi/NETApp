{"ast":null,"code":"/**\r\n * DevExtreme (viz/series/pie_series.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar noop = require(\"../../core/utils/common\").noop;\n\nvar each = require(\"../../core/utils/iterator\").each;\n\nvar scatterSeries = require(\"./scatter_series\");\n\nvar vizUtils = require(\"../core/utils\");\n\nvar extend = require(\"../../core/utils/extend\").extend;\n\nvar chartScatterSeries = scatterSeries.chart;\n\nvar barSeries = require(\"./bar_series\").chart.bar;\n\nvar _extend = extend;\nvar _each = each;\nvar _noop = noop;\nvar _map = vizUtils.map;\nvar _isFinite = isFinite;\nvar _max = Math.max;\nvar ANIMATION_DURATION = .7;\nvar INSIDE = \"inside\";\nexports.pie = _extend({}, barSeries, {\n  _setGroupsSettings: function _setGroupsSettings() {\n    chartScatterSeries._setGroupsSettings.apply(this, arguments);\n\n    this._labelsGroup.attr({\n      \"pointer-events\": null\n    });\n  },\n  _createErrorBarGroup: _noop,\n  _drawPoint: function _drawPoint(options) {\n    var point = options.point;\n    var legendCallback = this._legendCallback;\n\n    chartScatterSeries._drawPoint.call(this, options);\n\n    !point.isVisible() && point.setInvisibility();\n    point.isSelected() && legendCallback();\n  },\n  _getOldPoint: function _getOldPoint(data, oldPointsByArgument, index) {\n    var point = (this._points || [])[index];\n\n    if (point) {\n      oldPointsByArgument[point.argument.valueOf()] = oldPointsByArgument[point.argument.valueOf()].filter(function (p) {\n        return p !== point;\n      });\n    }\n\n    return point;\n  },\n  adjustLabels: function adjustLabels(moveLabelsFromCenter) {\n    return (this._points || []).reduce(function (r, p) {\n      if (p._label.isVisible()) {\n        p.setLabelTrackerData();\n        r = p.applyWordWrap(moveLabelsFromCenter) || r;\n        p.updateLabelCoord(moveLabelsFromCenter);\n        return r;\n      }\n    }, false);\n  },\n  _applyElementsClipRect: _noop,\n  getColor: _noop,\n  areErrorBarsVisible: _noop,\n  drawLabelsWOPoints: function drawLabelsWOPoints() {\n    var that = this;\n\n    if (that._options.label.position === INSIDE) {\n      return false;\n    }\n\n    that._labelsGroup.append(that._extGroups.labelsGroup);\n\n    (that._points || []).forEach(function (point) {\n      point.drawLabel();\n    });\n    return true;\n  },\n  getPointsCount: function getPointsCount() {\n    var _this = this;\n\n    return this._data.filter(function (d) {\n      return _this._checkData(d);\n    }).length;\n  },\n  setMaxPointsCount: function setMaxPointsCount(count) {\n    this._pointsCount = count;\n  },\n  _getCreatingPointOptions: function _getCreatingPointOptions(data, dataIndex) {\n    return this._getPointOptions(data, dataIndex);\n  },\n  _updateOptions: function _updateOptions(options) {\n    this.labelSpace = 0;\n    this.innerRadius = \"pie\" === this.type ? 0 : options.innerRadius;\n  },\n  _checkData: function _checkData(data, skippedFields) {\n    var base = barSeries._checkData.call(this, data, skippedFields, {\n      value: this.getValueFields()[0]\n    });\n\n    return this._options.paintNullPoints ? base : base && null !== data.value;\n  },\n  _createGroups: chartScatterSeries._createGroups,\n  _setMarkerGroupSettings: function _setMarkerGroupSettings() {\n    this._markersGroup.attr({\n      \"class\": \"dxc-markers\"\n    });\n  },\n  _getMainColor: function _getMainColor(data, point) {\n    var pointsByArg = this.getPointsByArg(data.argument);\n    var argumentIndex = point ? pointsByArg.indexOf(point) : pointsByArg.length;\n    return this._options.mainSeriesColor(data.argument, argumentIndex, this._pointsCount);\n  },\n  _getPointOptions: function _getPointOptions(data) {\n    return this._parsePointOptions(this._preparePointOptions(), this._options.label, data);\n  },\n  _getRangeData: function _getRangeData() {\n    return this._rangeData;\n  },\n  _createPointStyles: function _createPointStyles(pointOptions, data, point) {\n    var that = this;\n\n    var mainColor = pointOptions.color || that._getMainColor(data, point);\n\n    return {\n      normal: that._parsePointStyle(pointOptions, mainColor, mainColor),\n      hover: that._parsePointStyle(pointOptions.hoverStyle, mainColor, mainColor),\n      selection: that._parsePointStyle(pointOptions.selectionStyle, mainColor, mainColor),\n      legendStyles: {\n        normal: that._createLegendState(pointOptions, mainColor),\n        hover: that._createLegendState(pointOptions.hoverStyle, mainColor),\n        selection: that._createLegendState(pointOptions.selectionStyle, mainColor)\n      }\n    };\n  },\n  _getArrangeMinShownValue: function _getArrangeMinShownValue(points, total) {\n    var minSegmentSize = this._options.minSegmentSize;\n    var totalMinSegmentSize = 0;\n    var totalNotMinValues = 0;\n    total = total || points.length;\n\n    _each(points, function (_, point) {\n      if (point.isVisible()) {\n        if (point.normalInitialValue < minSegmentSize * total / 360) {\n          totalMinSegmentSize += minSegmentSize;\n        } else {\n          totalNotMinValues += point.normalInitialValue;\n        }\n      }\n    });\n\n    return totalMinSegmentSize < 360 ? minSegmentSize * totalNotMinValues / (360 - totalMinSegmentSize) : 0;\n  },\n  _applyArrangeCorrection: function _applyArrangeCorrection(points, minShownValue, total) {\n    var options = this._options;\n    var isClockWise = \"anticlockwise\" !== options.segmentsDirection;\n    var shiftedAngle = _isFinite(options.startAngle) ? vizUtils.normalizeAngle(options.startAngle) : 0;\n    var minSegmentSize = options.minSegmentSize;\n    var percent;\n    var correction = 0;\n    var zeroTotalCorrection = 0;\n\n    if (0 === total) {\n      total = points.filter(function (el) {\n        return el.isVisible();\n      }).length;\n      zeroTotalCorrection = 1;\n    }\n\n    _each(isClockWise ? points : points.concat([]).reverse(), function (_, point) {\n      var val = point.isVisible() ? zeroTotalCorrection || point.normalInitialValue : 0;\n      var updatedZeroValue;\n\n      if (minSegmentSize && point.isVisible() && val < minShownValue) {\n        updatedZeroValue = minShownValue;\n      }\n\n      percent = val / total;\n      point.correctValue(correction, percent, zeroTotalCorrection + (updatedZeroValue || 0));\n      point.shiftedAngle = shiftedAngle;\n      correction += updatedZeroValue || val;\n    });\n\n    this._rangeData = {\n      val: {\n        min: 0,\n        max: correction\n      }\n    };\n  },\n  _removePoint: function _removePoint(point) {\n    var points = this.getPointsByArg(point.argument);\n    points.splice(points.indexOf(point), 1);\n    point.dispose();\n  },\n  arrangePoints: function arrangePoints() {\n    var that = this;\n    var originalPoints = that._points || [];\n    var minSegmentSize = that._options.minSegmentSize;\n    var minShownValue;\n    var total;\n    var isAllPointsNegative = true;\n    var points;\n    var i = 0;\n    var len = originalPoints.length;\n    var maxValue;\n\n    while (i < len && isAllPointsNegative) {\n      isAllPointsNegative = originalPoints[i].value <= 0;\n      i++;\n    }\n\n    points = that._points = _map(originalPoints, function (point) {\n      if (null === point.value || !isAllPointsNegative && point.value < 0) {\n        that._removePoint(point);\n\n        return null;\n      } else {\n        return point;\n      }\n    });\n    maxValue = points.reduce(function (max, p) {\n      return _max(max, Math.abs(p.initialValue));\n    }, 0);\n    points.forEach(function (p) {\n      p.normalInitialValue = p.initialValue / (0 !== maxValue ? maxValue : 1);\n    });\n    total = points.reduce(function (total, point) {\n      return total + (point.isVisible() ? point.normalInitialValue : 0);\n    }, 0);\n\n    if (minSegmentSize) {\n      minShownValue = this._getArrangeMinShownValue(points, total);\n    }\n\n    that._applyArrangeCorrection(points, minShownValue, total);\n  },\n  correctPosition: function correctPosition(correction, canvas) {\n    _each(this._points, function (_, point) {\n      point.correctPosition(correction);\n    });\n\n    this.setVisibleArea(canvas);\n  },\n  correctRadius: function correctRadius(correction) {\n    this._points.forEach(function (point) {\n      point.correctRadius(correction);\n    });\n  },\n  correctLabelRadius: function correctLabelRadius(labelRadius) {\n    this._points.forEach(function (point) {\n      point.correctLabelRadius(labelRadius);\n    });\n  },\n  setVisibleArea: function setVisibleArea(canvas) {\n    this._visibleArea = {\n      minX: canvas.left,\n      maxX: canvas.width - canvas.right,\n      minY: canvas.top,\n      maxY: canvas.height - canvas.bottom\n    };\n  },\n  _applyVisibleArea: _noop,\n  _animate: function _animate(firstDrawing) {\n    var that = this;\n    var points = that._points;\n    var pointsCount = points && points.length;\n\n    var completeFunc = function completeFunc() {\n      that._animateComplete();\n    };\n\n    var animatePoint;\n\n    if (firstDrawing) {\n      animatePoint = function animatePoint(p, i) {\n        p.animate(i === pointsCount - 1 ? completeFunc : void 0, ANIMATION_DURATION, (1 - ANIMATION_DURATION) * i / (pointsCount - 1));\n      };\n    } else {\n      animatePoint = function animatePoint(p, i) {\n        p.animate(i === pointsCount - 1 ? completeFunc : void 0);\n      };\n    }\n\n    points.forEach(animatePoint);\n  },\n  getVisiblePoints: function getVisiblePoints() {\n    return _map(this._points, function (p) {\n      return p.isVisible() ? p : null;\n    });\n  },\n  getPointsByKeys: function getPointsByKeys(arg, argumentIndex) {\n    var pointsByArg = this.getPointsByArg(arg);\n    return pointsByArg[argumentIndex] && [pointsByArg[argumentIndex]] || [];\n  }\n});\nexports.doughnut = exports.donut = exports.pie;","map":{"version":3,"sources":["C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/devextreme/viz/series/pie_series.js"],"names":["noop","require","each","scatterSeries","vizUtils","extend","chartScatterSeries","barSeries","_extend","_each","_noop","_map","_isFinite","_max","Math","ANIMATION_DURATION","INSIDE","exports","_setGroupsSettings","_createErrorBarGroup","_drawPoint","point","options","legendCallback","_getOldPoint","oldPointsByArgument","p","adjustLabels","r","_applyElementsClipRect","getColor","areErrorBarsVisible","drawLabelsWOPoints","that","getPointsCount","_this","setMaxPointsCount","_getCreatingPointOptions","_updateOptions","_checkData","base","value","data","_createGroups","_setMarkerGroupSettings","_getMainColor","pointsByArg","argumentIndex","_getPointOptions","_getRangeData","_createPointStyles","mainColor","pointOptions","normal","hover","selection","legendStyles","_getArrangeMinShownValue","minSegmentSize","totalMinSegmentSize","totalNotMinValues","total","points","_applyArrangeCorrection","isClockWise","shiftedAngle","correction","zeroTotalCorrection","el","val","updatedZeroValue","percent","min","max","_removePoint","arrangePoints","originalPoints","isAllPointsNegative","i","len","maxValue","minShownValue","correctPosition","correctRadius","correctLabelRadius","setVisibleArea","minX","canvas","maxX","minY","maxY","bottom","_applyVisibleArea","_animate","pointsCount","completeFunc","animatePoint","getVisiblePoints","getPointsByKeys"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (viz/series/pie_series.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nvar noop = require(\"../../core/utils/common\").noop;\r\nvar each = require(\"../../core/utils/iterator\").each;\r\nvar scatterSeries = require(\"./scatter_series\");\r\nvar vizUtils = require(\"../core/utils\");\r\nvar extend = require(\"../../core/utils/extend\").extend;\r\nvar chartScatterSeries = scatterSeries.chart;\r\nvar barSeries = require(\"./bar_series\").chart.bar;\r\nvar _extend = extend;\r\nvar _each = each;\r\nvar _noop = noop;\r\nvar _map = vizUtils.map;\r\nvar _isFinite = isFinite;\r\nvar _max = Math.max;\r\nvar ANIMATION_DURATION = .7;\r\nvar INSIDE = \"inside\";\r\nexports.pie = _extend({}, barSeries, {\r\n    _setGroupsSettings: function() {\r\n        chartScatterSeries._setGroupsSettings.apply(this, arguments);\r\n        this._labelsGroup.attr({\r\n            \"pointer-events\": null\r\n        })\r\n    },\r\n    _createErrorBarGroup: _noop,\r\n    _drawPoint: function(options) {\r\n        var point = options.point;\r\n        var legendCallback = this._legendCallback;\r\n        chartScatterSeries._drawPoint.call(this, options);\r\n        !point.isVisible() && point.setInvisibility();\r\n        point.isSelected() && legendCallback()\r\n    },\r\n    _getOldPoint: function(data, oldPointsByArgument, index) {\r\n        var point = (this._points || [])[index];\r\n        if (point) {\r\n            oldPointsByArgument[point.argument.valueOf()] = oldPointsByArgument[point.argument.valueOf()].filter(function(p) {\r\n                return p !== point\r\n            })\r\n        }\r\n        return point\r\n    },\r\n    adjustLabels: function(moveLabelsFromCenter) {\r\n        return (this._points || []).reduce(function(r, p) {\r\n            if (p._label.isVisible()) {\r\n                p.setLabelTrackerData();\r\n                r = p.applyWordWrap(moveLabelsFromCenter) || r;\r\n                p.updateLabelCoord(moveLabelsFromCenter);\r\n                return r\r\n            }\r\n        }, false)\r\n    },\r\n    _applyElementsClipRect: _noop,\r\n    getColor: _noop,\r\n    areErrorBarsVisible: _noop,\r\n    drawLabelsWOPoints: function() {\r\n        var that = this;\r\n        if (that._options.label.position === INSIDE) {\r\n            return false\r\n        }\r\n        that._labelsGroup.append(that._extGroups.labelsGroup);\r\n        (that._points || []).forEach(function(point) {\r\n            point.drawLabel()\r\n        });\r\n        return true\r\n    },\r\n    getPointsCount: function() {\r\n        var _this = this;\r\n        return this._data.filter(function(d) {\r\n            return _this._checkData(d)\r\n        }).length\r\n    },\r\n    setMaxPointsCount: function(count) {\r\n        this._pointsCount = count\r\n    },\r\n    _getCreatingPointOptions: function(data, dataIndex) {\r\n        return this._getPointOptions(data, dataIndex)\r\n    },\r\n    _updateOptions: function(options) {\r\n        this.labelSpace = 0;\r\n        this.innerRadius = \"pie\" === this.type ? 0 : options.innerRadius\r\n    },\r\n    _checkData: function(data, skippedFields) {\r\n        var base = barSeries._checkData.call(this, data, skippedFields, {\r\n            value: this.getValueFields()[0]\r\n        });\r\n        return this._options.paintNullPoints ? base : base && null !== data.value\r\n    },\r\n    _createGroups: chartScatterSeries._createGroups,\r\n    _setMarkerGroupSettings: function() {\r\n        this._markersGroup.attr({\r\n            \"class\": \"dxc-markers\"\r\n        })\r\n    },\r\n    _getMainColor: function(data, point) {\r\n        var pointsByArg = this.getPointsByArg(data.argument);\r\n        var argumentIndex = point ? pointsByArg.indexOf(point) : pointsByArg.length;\r\n        return this._options.mainSeriesColor(data.argument, argumentIndex, this._pointsCount)\r\n    },\r\n    _getPointOptions: function(data) {\r\n        return this._parsePointOptions(this._preparePointOptions(), this._options.label, data)\r\n    },\r\n    _getRangeData: function() {\r\n        return this._rangeData\r\n    },\r\n    _createPointStyles: function(pointOptions, data, point) {\r\n        var that = this;\r\n        var mainColor = pointOptions.color || that._getMainColor(data, point);\r\n        return {\r\n            normal: that._parsePointStyle(pointOptions, mainColor, mainColor),\r\n            hover: that._parsePointStyle(pointOptions.hoverStyle, mainColor, mainColor),\r\n            selection: that._parsePointStyle(pointOptions.selectionStyle, mainColor, mainColor),\r\n            legendStyles: {\r\n                normal: that._createLegendState(pointOptions, mainColor),\r\n                hover: that._createLegendState(pointOptions.hoverStyle, mainColor),\r\n                selection: that._createLegendState(pointOptions.selectionStyle, mainColor)\r\n            }\r\n        }\r\n    },\r\n    _getArrangeMinShownValue: function(points, total) {\r\n        var minSegmentSize = this._options.minSegmentSize;\r\n        var totalMinSegmentSize = 0;\r\n        var totalNotMinValues = 0;\r\n        total = total || points.length;\r\n        _each(points, function(_, point) {\r\n            if (point.isVisible()) {\r\n                if (point.normalInitialValue < minSegmentSize * total / 360) {\r\n                    totalMinSegmentSize += minSegmentSize\r\n                } else {\r\n                    totalNotMinValues += point.normalInitialValue\r\n                }\r\n            }\r\n        });\r\n        return totalMinSegmentSize < 360 ? minSegmentSize * totalNotMinValues / (360 - totalMinSegmentSize) : 0\r\n    },\r\n    _applyArrangeCorrection: function(points, minShownValue, total) {\r\n        var options = this._options;\r\n        var isClockWise = \"anticlockwise\" !== options.segmentsDirection;\r\n        var shiftedAngle = _isFinite(options.startAngle) ? vizUtils.normalizeAngle(options.startAngle) : 0;\r\n        var minSegmentSize = options.minSegmentSize;\r\n        var percent;\r\n        var correction = 0;\r\n        var zeroTotalCorrection = 0;\r\n        if (0 === total) {\r\n            total = points.filter(function(el) {\r\n                return el.isVisible()\r\n            }).length;\r\n            zeroTotalCorrection = 1\r\n        }\r\n        _each(isClockWise ? points : points.concat([]).reverse(), function(_, point) {\r\n            var val = point.isVisible() ? zeroTotalCorrection || point.normalInitialValue : 0;\r\n            var updatedZeroValue;\r\n            if (minSegmentSize && point.isVisible() && val < minShownValue) {\r\n                updatedZeroValue = minShownValue\r\n            }\r\n            percent = val / total;\r\n            point.correctValue(correction, percent, zeroTotalCorrection + (updatedZeroValue || 0));\r\n            point.shiftedAngle = shiftedAngle;\r\n            correction += updatedZeroValue || val\r\n        });\r\n        this._rangeData = {\r\n            val: {\r\n                min: 0,\r\n                max: correction\r\n            }\r\n        }\r\n    },\r\n    _removePoint: function(point) {\r\n        var points = this.getPointsByArg(point.argument);\r\n        points.splice(points.indexOf(point), 1);\r\n        point.dispose()\r\n    },\r\n    arrangePoints: function() {\r\n        var that = this;\r\n        var originalPoints = that._points || [];\r\n        var minSegmentSize = that._options.minSegmentSize;\r\n        var minShownValue;\r\n        var total;\r\n        var isAllPointsNegative = true;\r\n        var points;\r\n        var i = 0;\r\n        var len = originalPoints.length;\r\n        var maxValue;\r\n        while (i < len && isAllPointsNegative) {\r\n            isAllPointsNegative = originalPoints[i].value <= 0;\r\n            i++\r\n        }\r\n        points = that._points = _map(originalPoints, function(point) {\r\n            if (null === point.value || !isAllPointsNegative && point.value < 0) {\r\n                that._removePoint(point);\r\n                return null\r\n            } else {\r\n                return point\r\n            }\r\n        });\r\n        maxValue = points.reduce(function(max, p) {\r\n            return _max(max, Math.abs(p.initialValue))\r\n        }, 0);\r\n        points.forEach(function(p) {\r\n            p.normalInitialValue = p.initialValue / (0 !== maxValue ? maxValue : 1)\r\n        });\r\n        total = points.reduce(function(total, point) {\r\n            return total + (point.isVisible() ? point.normalInitialValue : 0)\r\n        }, 0);\r\n        if (minSegmentSize) {\r\n            minShownValue = this._getArrangeMinShownValue(points, total)\r\n        }\r\n        that._applyArrangeCorrection(points, minShownValue, total)\r\n    },\r\n    correctPosition: function(correction, canvas) {\r\n        _each(this._points, function(_, point) {\r\n            point.correctPosition(correction)\r\n        });\r\n        this.setVisibleArea(canvas)\r\n    },\r\n    correctRadius: function(correction) {\r\n        this._points.forEach(function(point) {\r\n            point.correctRadius(correction)\r\n        })\r\n    },\r\n    correctLabelRadius: function(labelRadius) {\r\n        this._points.forEach(function(point) {\r\n            point.correctLabelRadius(labelRadius)\r\n        })\r\n    },\r\n    setVisibleArea: function(canvas) {\r\n        this._visibleArea = {\r\n            minX: canvas.left,\r\n            maxX: canvas.width - canvas.right,\r\n            minY: canvas.top,\r\n            maxY: canvas.height - canvas.bottom\r\n        }\r\n    },\r\n    _applyVisibleArea: _noop,\r\n    _animate: function(firstDrawing) {\r\n        var that = this;\r\n        var points = that._points;\r\n        var pointsCount = points && points.length;\r\n        var completeFunc = function() {\r\n            that._animateComplete()\r\n        };\r\n        var animatePoint;\r\n        if (firstDrawing) {\r\n            animatePoint = function(p, i) {\r\n                p.animate(i === pointsCount - 1 ? completeFunc : void 0, ANIMATION_DURATION, (1 - ANIMATION_DURATION) * i / (pointsCount - 1))\r\n            }\r\n        } else {\r\n            animatePoint = function(p, i) {\r\n                p.animate(i === pointsCount - 1 ? completeFunc : void 0)\r\n            }\r\n        }\r\n        points.forEach(animatePoint)\r\n    },\r\n    getVisiblePoints: function() {\r\n        return _map(this._points, function(p) {\r\n            return p.isVisible() ? p : null\r\n        })\r\n    },\r\n    getPointsByKeys: function(arg, argumentIndex) {\r\n        var pointsByArg = this.getPointsByArg(arg);\r\n        return pointsByArg[argumentIndex] && [pointsByArg[argumentIndex]] || []\r\n    }\r\n});\r\nexports.doughnut = exports.donut = exports.pie;\r\n"]},"metadata":{},"sourceType":"module"}