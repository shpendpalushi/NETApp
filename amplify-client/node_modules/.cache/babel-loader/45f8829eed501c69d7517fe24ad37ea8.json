{"ast":null,"code":"/**\r\n * DevExtreme (viz/chart_components/multi_axes_synchronizer.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _console = require(\"../../core/utils/console\");\n\nvar _type = require(\"../../core/utils/type\");\n\nvar _iterator = require(\"../../core/utils/iterator\");\n\nvar _utils = require(\"../core/utils\");\n\nvar _math2 = require(\"../../core/utils/math\");\n\nvar _math = Math;\nvar _floor = _math.floor;\nvar _max = _math.max;\nvar _abs = _math.abs;\n\nfunction getValueAxesPerPanes(valueAxes) {\n  var result = {};\n  valueAxes.forEach(function (axis) {\n    var pane = axis.pane;\n\n    if (!result[pane]) {\n      result[pane] = [];\n    }\n\n    result[pane].push(axis);\n  });\n  return result;\n}\n\nvar linearConverter = {\n  transform: function transform(v, b) {\n    return (0, _math2.adjust)((0, _utils.getLog)(v, b));\n  },\n  addInterval: function addInterval(v, i) {\n    return (0, _math2.adjust)(v + i);\n  },\n  getInterval: function getInterval(base, tickInterval) {\n    return tickInterval;\n  }\n};\nvar logConverter = {\n  transform: function transform(v, b) {\n    return (0, _math2.adjust)((0, _utils.raiseTo)(v, b));\n  },\n  addInterval: function addInterval(v, i) {\n    return (0, _math2.adjust)(v * i);\n  },\n  getInterval: function getInterval(base, tickInterval) {\n    return _math.pow(base, tickInterval);\n  }\n};\n\nfunction convertAxisInfo(axisInfo, converter) {\n  if (!axisInfo.isLogarithmic) {\n    return;\n  }\n\n  var base = axisInfo.logarithmicBase;\n  var tickValues = axisInfo.tickValues;\n  var tick;\n  var ticks = [];\n  var interval;\n  axisInfo.minValue = converter.transform(axisInfo.minValue, base);\n  axisInfo.oldMinValue = converter.transform(axisInfo.oldMinValue, base);\n  axisInfo.maxValue = converter.transform(axisInfo.maxValue, base);\n  axisInfo.oldMaxValue = converter.transform(axisInfo.oldMaxValue, base);\n  axisInfo.tickInterval = _math.round(axisInfo.tickInterval);\n\n  if (axisInfo.tickInterval < 1) {\n    axisInfo.tickInterval = 1;\n  }\n\n  interval = converter.getInterval(base, axisInfo.tickInterval);\n  tick = converter.transform(tickValues[0], base);\n\n  while (ticks.length < tickValues.length) {\n    ticks.push(tick);\n    tick = converter.addInterval(tick, interval);\n  }\n\n  ticks.tickInterval = axisInfo.tickInterval;\n  axisInfo.tickValues = ticks;\n}\n\nfunction populateAxesInfo(axes) {\n  return axes.reduce(function (result, axis) {\n    var ticksValues = axis.getTicksValues();\n    var majorTicks = ticksValues.majorTicksValues;\n    var options = axis.getOptions();\n    var businessRange = axis.getTranslator().getBusinessRange();\n    var visibleArea = axis.getVisibleArea();\n    var axisInfo;\n    var tickInterval = axis._tickInterval;\n    var synchronizedValue = options.synchronizedValue;\n\n    if (majorTicks && majorTicks.length > 0 && (0, _type.isNumeric)(majorTicks[0]) && \"discrete\" !== options.type && !businessRange.isEmpty() && !(businessRange.breaks && businessRange.breaks.length) && \"zoom\" !== axis.getViewport().action) {\n      axis.applyMargins();\n      var startValue = axis.getTranslator().from(visibleArea[0]);\n      var endValue = axis.getTranslator().from(visibleArea[1]);\n      var minValue = startValue < endValue ? startValue : endValue;\n      var maxValue = startValue < endValue ? endValue : startValue;\n\n      if (minValue === maxValue && (0, _type.isDefined)(synchronizedValue)) {\n        tickInterval = _abs(majorTicks[0] - synchronizedValue) || 1;\n        minValue = majorTicks[0] - tickInterval;\n        maxValue = majorTicks[0] + tickInterval;\n      }\n\n      axisInfo = {\n        axis: axis,\n        isLogarithmic: \"logarithmic\" === options.type,\n        logarithmicBase: businessRange.base,\n        tickValues: majorTicks,\n        minorValues: ticksValues.minorTicksValues,\n        minorTickInterval: axis._minorTickInterval,\n        minValue: minValue,\n        oldMinValue: minValue,\n        maxValue: maxValue,\n        oldMaxValue: maxValue,\n        inverted: businessRange.invert,\n        tickInterval: tickInterval,\n        synchronizedValue: synchronizedValue\n      };\n      convertAxisInfo(axisInfo, linearConverter);\n      result.push(axisInfo);\n    }\n\n    return result;\n  }, []);\n}\n\nfunction updateTickValues(axesInfo) {\n  var maxTicksCount = axesInfo.reduce(function (max, axisInfo) {\n    return _max(max, axisInfo.tickValues.length);\n  }, 0);\n  axesInfo.forEach(function (axisInfo) {\n    var ticksMultiplier;\n    var ticksCount;\n    var additionalStartTicksCount = 0;\n    var synchronizedValue = axisInfo.synchronizedValue;\n    var tickValues = axisInfo.tickValues;\n    var tickInterval = axisInfo.tickInterval;\n\n    if ((0, _type.isDefined)(synchronizedValue)) {\n      axisInfo.baseTickValue = axisInfo.invertedBaseTickValue = synchronizedValue;\n      axisInfo.tickValues = [axisInfo.baseTickValue];\n    } else {\n      if (tickValues.length > 1 && tickInterval) {\n        ticksMultiplier = _floor((maxTicksCount + 1) / tickValues.length);\n        ticksCount = ticksMultiplier > 1 ? _floor((maxTicksCount + 1) / ticksMultiplier) : maxTicksCount;\n        additionalStartTicksCount = _floor((ticksCount - tickValues.length) / 2);\n\n        while (additionalStartTicksCount > 0 && 0 !== tickValues[0]) {\n          tickValues.unshift((0, _math2.adjust)(tickValues[0] - tickInterval));\n          additionalStartTicksCount--;\n        }\n\n        while (tickValues.length < ticksCount) {\n          tickValues.push((0, _math2.adjust)(tickValues[tickValues.length - 1] + tickInterval));\n        }\n\n        axisInfo.tickInterval = tickInterval / ticksMultiplier;\n      }\n\n      axisInfo.baseTickValue = tickValues[0];\n      axisInfo.invertedBaseTickValue = tickValues[tickValues.length - 1];\n    }\n  });\n}\n\nfunction getAxisRange(axisInfo) {\n  return axisInfo.maxValue - axisInfo.minValue || 1;\n}\n\nfunction getMainAxisInfo(axesInfo) {\n  for (var i = 0; i < axesInfo.length; i++) {\n    if (!axesInfo[i].stubData) {\n      return axesInfo[i];\n    }\n  }\n\n  return null;\n}\n\nfunction correctMinMaxValues(axesInfo) {\n  var mainAxisInfo = getMainAxisInfo(axesInfo);\n  var mainAxisInfoTickInterval = mainAxisInfo.tickInterval;\n  axesInfo.forEach(function (axisInfo) {\n    var scale;\n    var move;\n    var mainAxisBaseValueOffset;\n    var valueFromAxisInfo;\n\n    if (axisInfo !== mainAxisInfo) {\n      if (mainAxisInfoTickInterval && axisInfo.tickInterval) {\n        if (axisInfo.stubData && (0, _type.isDefined)(axisInfo.synchronizedValue)) {\n          axisInfo.oldMinValue = axisInfo.minValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.minValue) / mainAxisInfoTickInterval * axisInfo.tickInterval;\n          axisInfo.oldMaxValue = axisInfo.maxValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.maxValue) / mainAxisInfoTickInterval * axisInfo.tickInterval;\n        }\n\n        scale = mainAxisInfoTickInterval / getAxisRange(mainAxisInfo) / axisInfo.tickInterval * getAxisRange(axisInfo);\n        axisInfo.maxValue = axisInfo.minValue + getAxisRange(axisInfo) / scale;\n      }\n\n      if (mainAxisInfo.inverted && !axisInfo.inverted || !mainAxisInfo.inverted && axisInfo.inverted) {\n        mainAxisBaseValueOffset = mainAxisInfo.maxValue - mainAxisInfo.invertedBaseTickValue;\n      } else {\n        mainAxisBaseValueOffset = mainAxisInfo.baseTickValue - mainAxisInfo.minValue;\n      }\n\n      valueFromAxisInfo = getAxisRange(axisInfo);\n      move = (mainAxisBaseValueOffset / getAxisRange(mainAxisInfo) - (axisInfo.baseTickValue - axisInfo.minValue) / valueFromAxisInfo) * valueFromAxisInfo;\n      axisInfo.minValue -= move;\n      axisInfo.maxValue -= move;\n    }\n  });\n}\n\nfunction calculatePaddings(axesInfo) {\n  var minPadding;\n  var maxPadding;\n  var startPadding = 0;\n  var endPadding = 0;\n  axesInfo.forEach(function (axisInfo) {\n    var inverted = axisInfo.inverted;\n    minPadding = axisInfo.minValue > axisInfo.oldMinValue ? (axisInfo.minValue - axisInfo.oldMinValue) / getAxisRange(axisInfo) : 0;\n    maxPadding = axisInfo.maxValue < axisInfo.oldMaxValue ? (axisInfo.oldMaxValue - axisInfo.maxValue) / getAxisRange(axisInfo) : 0;\n    startPadding = _max(startPadding, inverted ? maxPadding : minPadding);\n    endPadding = _max(endPadding, inverted ? minPadding : maxPadding);\n  });\n  return {\n    start: startPadding,\n    end: endPadding\n  };\n}\n\nfunction correctMinMaxValuesByPaddings(axesInfo, paddings) {\n  axesInfo.forEach(function (info) {\n    var range = getAxisRange(info);\n    var inverted = info.inverted;\n    info.minValue = (0, _math2.adjust)(info.minValue - paddings[inverted ? \"end\" : \"start\"] * range);\n    info.maxValue = (0, _math2.adjust)(info.maxValue + paddings[inverted ? \"start\" : \"end\"] * range);\n  });\n}\n\nfunction updateTickValuesIfSynchronizedValueUsed(axesInfo) {\n  var hasSynchronizedValue = false;\n  axesInfo.forEach(function (info) {\n    hasSynchronizedValue = hasSynchronizedValue || (0, _type.isDefined)(info.synchronizedValue);\n  });\n  axesInfo.forEach(function (info) {\n    var tickInterval = info.tickInterval;\n    var tickValues = info.tickValues;\n    var maxValue = info.maxValue;\n    var minValue = info.minValue;\n    var tick;\n\n    if (hasSynchronizedValue && tickInterval) {\n      while ((tick = (0, _math2.adjust)(tickValues[0] - tickInterval)) >= minValue) {\n        tickValues.unshift(tick);\n      }\n\n      tick = tickValues[tickValues.length - 1];\n\n      while ((tick = (0, _math2.adjust)(tick + tickInterval)) <= maxValue) {\n        tickValues.push(tick);\n      }\n    }\n\n    while (tickValues[0] + tickInterval / 10 < minValue) {\n      tickValues.shift();\n    }\n\n    while (tickValues[tickValues.length - 1] - tickInterval / 10 > maxValue) {\n      tickValues.pop();\n    }\n  });\n}\n\nfunction applyMinMaxValues(axesInfo) {\n  axesInfo.forEach(function (info) {\n    var axis = info.axis;\n    var range = axis.getTranslator().getBusinessRange();\n\n    if (range.min === range.minVisible) {\n      range.min = info.minValue;\n    }\n\n    if (range.max === range.maxVisible) {\n      range.max = info.maxValue;\n    }\n\n    range.minVisible = info.minValue;\n    range.maxVisible = info.maxValue;\n\n    if (range.min > range.minVisible) {\n      range.min = range.minVisible;\n    }\n\n    if (range.max < range.maxVisible) {\n      range.max = range.maxVisible;\n    }\n\n    axis.getTranslator().updateBusinessRange(range);\n    axis.setTicks({\n      majorTicks: info.tickValues,\n      minorTicks: info.minorValues\n    });\n  });\n}\n\nfunction correctAfterSynchronize(axesInfo) {\n  var invalidAxisInfo = [];\n  var correctValue;\n  axesInfo.forEach(function (info) {\n    if (info.oldMaxValue - info.oldMinValue === 0) {\n      invalidAxisInfo.push(info);\n    } else {\n      if (!(0, _type.isDefined)(correctValue) && !(0, _type.isDefined)(info.synchronizedValue)) {\n        correctValue = _abs((info.maxValue - info.minValue) / (info.tickValues[_floor(info.tickValues.length / 2)] - info.minValue || info.maxValue));\n      }\n    }\n  });\n\n  if (!(0, _type.isDefined)(correctValue)) {\n    return;\n  }\n\n  invalidAxisInfo.forEach(function (info) {\n    var firstTick = info.tickValues[0];\n    var correctedTick = firstTick * correctValue;\n\n    if (firstTick > 0) {\n      info.maxValue = correctedTick;\n      info.minValue = 0;\n    } else {\n      if (firstTick < 0) {\n        info.minValue = correctedTick;\n        info.maxValue = 0;\n      }\n    }\n  });\n}\n\nfunction updateMinorTicks(axesInfo) {\n  axesInfo.forEach(function (axisInfo) {\n    if (!axisInfo.minorTickInterval) {\n      return;\n    }\n\n    var ticks = [];\n    var interval = axisInfo.minorTickInterval;\n    var tickCount = axisInfo.tickInterval / interval - 1;\n\n    for (var i = 1; i < axisInfo.tickValues.length; i++) {\n      var tick = axisInfo.tickValues[i - 1];\n\n      for (var j = 0; j < tickCount; j++) {\n        tick += interval;\n        ticks.push(tick);\n      }\n    }\n\n    axisInfo.minorValues = ticks;\n  });\n}\n\nvar multiAxesSynchronizer = {\n  synchronize: function synchronize(valueAxes) {\n    (0, _iterator.each)(getValueAxesPerPanes(valueAxes), function (_, axes) {\n      var axesInfo;\n      var paddings;\n\n      if (axes.length > 1) {\n        axesInfo = populateAxesInfo(axes);\n\n        if (axesInfo.length < 2 || !getMainAxisInfo(axesInfo)) {\n          return;\n        }\n\n        updateTickValues(axesInfo);\n        correctMinMaxValues(axesInfo);\n        paddings = calculatePaddings(axesInfo);\n        correctMinMaxValuesByPaddings(axesInfo, paddings);\n        correctAfterSynchronize(axesInfo);\n        updateTickValuesIfSynchronizedValueUsed(axesInfo);\n        updateMinorTicks(axesInfo);\n        axesInfo.forEach(function (info) {\n          convertAxisInfo(info, logConverter);\n        });\n        applyMinMaxValues(axesInfo);\n      }\n    });\n  }\n};\nmodule.exports = multiAxesSynchronizer;","map":{"version":3,"sources":["C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/devextreme/viz/chart_components/multi_axes_synchronizer.js"],"names":["_console","require","_type","_iterator","_utils","_math2","_math","_floor","_max","_abs","result","valueAxes","pane","axis","linearConverter","transform","addInterval","v","getInterval","logConverter","axisInfo","base","tickValues","ticks","converter","interval","tick","ticksValues","majorTicks","options","businessRange","visibleArea","tickInterval","synchronizedValue","startValue","endValue","minValue","maxValue","isLogarithmic","logarithmicBase","minorValues","minorTickInterval","oldMinValue","oldMaxValue","inverted","convertAxisInfo","maxTicksCount","axesInfo","additionalStartTicksCount","ticksMultiplier","ticksCount","i","mainAxisInfo","getMainAxisInfo","mainAxisInfoTickInterval","scale","getAxisRange","mainAxisBaseValueOffset","valueFromAxisInfo","move","startPadding","endPadding","minPadding","maxPadding","start","end","range","info","paddings","hasSynchronizedValue","minorTicks","invalidAxisInfo","correctValue","firstTick","correctedTick","tickCount","j","multiAxesSynchronizer","synchronize","getValueAxesPerPanes","axes","populateAxesInfo","updateTickValues","correctMinMaxValues","calculatePaddings","correctMinMaxValuesByPaddings","correctAfterSynchronize","updateTickValuesIfSynchronizedValueUsed","updateMinorTicks","applyMinMaxValues","module"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (viz/chart_components/multi_axes_synchronizer.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nvar _console = require(\"../../core/utils/console\");\r\nvar _type = require(\"../../core/utils/type\");\r\nvar _iterator = require(\"../../core/utils/iterator\");\r\nvar _utils = require(\"../core/utils\");\r\nvar _math2 = require(\"../../core/utils/math\");\r\nvar _math = Math;\r\nvar _floor = _math.floor;\r\nvar _max = _math.max;\r\nvar _abs = _math.abs;\r\n\r\nfunction getValueAxesPerPanes(valueAxes) {\r\n    var result = {};\r\n    valueAxes.forEach(function(axis) {\r\n        var pane = axis.pane;\r\n        if (!result[pane]) {\r\n            result[pane] = []\r\n        }\r\n        result[pane].push(axis)\r\n    });\r\n    return result\r\n}\r\nvar linearConverter = {\r\n    transform: function(v, b) {\r\n        return (0, _math2.adjust)((0, _utils.getLog)(v, b))\r\n    },\r\n    addInterval: function(v, i) {\r\n        return (0, _math2.adjust)(v + i)\r\n    },\r\n    getInterval: function(base, tickInterval) {\r\n        return tickInterval\r\n    }\r\n};\r\nvar logConverter = {\r\n    transform: function(v, b) {\r\n        return (0, _math2.adjust)((0, _utils.raiseTo)(v, b))\r\n    },\r\n    addInterval: function(v, i) {\r\n        return (0, _math2.adjust)(v * i)\r\n    },\r\n    getInterval: function(base, tickInterval) {\r\n        return _math.pow(base, tickInterval)\r\n    }\r\n};\r\n\r\nfunction convertAxisInfo(axisInfo, converter) {\r\n    if (!axisInfo.isLogarithmic) {\r\n        return\r\n    }\r\n    var base = axisInfo.logarithmicBase;\r\n    var tickValues = axisInfo.tickValues;\r\n    var tick;\r\n    var ticks = [];\r\n    var interval;\r\n    axisInfo.minValue = converter.transform(axisInfo.minValue, base);\r\n    axisInfo.oldMinValue = converter.transform(axisInfo.oldMinValue, base);\r\n    axisInfo.maxValue = converter.transform(axisInfo.maxValue, base);\r\n    axisInfo.oldMaxValue = converter.transform(axisInfo.oldMaxValue, base);\r\n    axisInfo.tickInterval = _math.round(axisInfo.tickInterval);\r\n    if (axisInfo.tickInterval < 1) {\r\n        axisInfo.tickInterval = 1\r\n    }\r\n    interval = converter.getInterval(base, axisInfo.tickInterval);\r\n    tick = converter.transform(tickValues[0], base);\r\n    while (ticks.length < tickValues.length) {\r\n        ticks.push(tick);\r\n        tick = converter.addInterval(tick, interval)\r\n    }\r\n    ticks.tickInterval = axisInfo.tickInterval;\r\n    axisInfo.tickValues = ticks\r\n}\r\n\r\nfunction populateAxesInfo(axes) {\r\n    return axes.reduce(function(result, axis) {\r\n        var ticksValues = axis.getTicksValues();\r\n        var majorTicks = ticksValues.majorTicksValues;\r\n        var options = axis.getOptions();\r\n        var businessRange = axis.getTranslator().getBusinessRange();\r\n        var visibleArea = axis.getVisibleArea();\r\n        var axisInfo;\r\n        var tickInterval = axis._tickInterval;\r\n        var synchronizedValue = options.synchronizedValue;\r\n        if (majorTicks && majorTicks.length > 0 && (0, _type.isNumeric)(majorTicks[0]) && \"discrete\" !== options.type && !businessRange.isEmpty() && !(businessRange.breaks && businessRange.breaks.length) && \"zoom\" !== axis.getViewport().action) {\r\n            axis.applyMargins();\r\n            var startValue = axis.getTranslator().from(visibleArea[0]);\r\n            var endValue = axis.getTranslator().from(visibleArea[1]);\r\n            var minValue = startValue < endValue ? startValue : endValue;\r\n            var maxValue = startValue < endValue ? endValue : startValue;\r\n            if (minValue === maxValue && (0, _type.isDefined)(synchronizedValue)) {\r\n                tickInterval = _abs(majorTicks[0] - synchronizedValue) || 1;\r\n                minValue = majorTicks[0] - tickInterval;\r\n                maxValue = majorTicks[0] + tickInterval\r\n            }\r\n            axisInfo = {\r\n                axis: axis,\r\n                isLogarithmic: \"logarithmic\" === options.type,\r\n                logarithmicBase: businessRange.base,\r\n                tickValues: majorTicks,\r\n                minorValues: ticksValues.minorTicksValues,\r\n                minorTickInterval: axis._minorTickInterval,\r\n                minValue: minValue,\r\n                oldMinValue: minValue,\r\n                maxValue: maxValue,\r\n                oldMaxValue: maxValue,\r\n                inverted: businessRange.invert,\r\n                tickInterval: tickInterval,\r\n                synchronizedValue: synchronizedValue\r\n            };\r\n            convertAxisInfo(axisInfo, linearConverter);\r\n            result.push(axisInfo)\r\n        }\r\n        return result\r\n    }, [])\r\n}\r\n\r\nfunction updateTickValues(axesInfo) {\r\n    var maxTicksCount = axesInfo.reduce(function(max, axisInfo) {\r\n        return _max(max, axisInfo.tickValues.length)\r\n    }, 0);\r\n    axesInfo.forEach(function(axisInfo) {\r\n        var ticksMultiplier;\r\n        var ticksCount;\r\n        var additionalStartTicksCount = 0;\r\n        var synchronizedValue = axisInfo.synchronizedValue;\r\n        var tickValues = axisInfo.tickValues;\r\n        var tickInterval = axisInfo.tickInterval;\r\n        if ((0, _type.isDefined)(synchronizedValue)) {\r\n            axisInfo.baseTickValue = axisInfo.invertedBaseTickValue = synchronizedValue;\r\n            axisInfo.tickValues = [axisInfo.baseTickValue]\r\n        } else {\r\n            if (tickValues.length > 1 && tickInterval) {\r\n                ticksMultiplier = _floor((maxTicksCount + 1) / tickValues.length);\r\n                ticksCount = ticksMultiplier > 1 ? _floor((maxTicksCount + 1) / ticksMultiplier) : maxTicksCount;\r\n                additionalStartTicksCount = _floor((ticksCount - tickValues.length) / 2);\r\n                while (additionalStartTicksCount > 0 && 0 !== tickValues[0]) {\r\n                    tickValues.unshift((0, _math2.adjust)(tickValues[0] - tickInterval));\r\n                    additionalStartTicksCount--\r\n                }\r\n                while (tickValues.length < ticksCount) {\r\n                    tickValues.push((0, _math2.adjust)(tickValues[tickValues.length - 1] + tickInterval))\r\n                }\r\n                axisInfo.tickInterval = tickInterval / ticksMultiplier\r\n            }\r\n            axisInfo.baseTickValue = tickValues[0];\r\n            axisInfo.invertedBaseTickValue = tickValues[tickValues.length - 1]\r\n        }\r\n    })\r\n}\r\n\r\nfunction getAxisRange(axisInfo) {\r\n    return axisInfo.maxValue - axisInfo.minValue || 1\r\n}\r\n\r\nfunction getMainAxisInfo(axesInfo) {\r\n    for (var i = 0; i < axesInfo.length; i++) {\r\n        if (!axesInfo[i].stubData) {\r\n            return axesInfo[i]\r\n        }\r\n    }\r\n    return null\r\n}\r\n\r\nfunction correctMinMaxValues(axesInfo) {\r\n    var mainAxisInfo = getMainAxisInfo(axesInfo);\r\n    var mainAxisInfoTickInterval = mainAxisInfo.tickInterval;\r\n    axesInfo.forEach(function(axisInfo) {\r\n        var scale;\r\n        var move;\r\n        var mainAxisBaseValueOffset;\r\n        var valueFromAxisInfo;\r\n        if (axisInfo !== mainAxisInfo) {\r\n            if (mainAxisInfoTickInterval && axisInfo.tickInterval) {\r\n                if (axisInfo.stubData && (0, _type.isDefined)(axisInfo.synchronizedValue)) {\r\n                    axisInfo.oldMinValue = axisInfo.minValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.minValue) / mainAxisInfoTickInterval * axisInfo.tickInterval;\r\n                    axisInfo.oldMaxValue = axisInfo.maxValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.maxValue) / mainAxisInfoTickInterval * axisInfo.tickInterval\r\n                }\r\n                scale = mainAxisInfoTickInterval / getAxisRange(mainAxisInfo) / axisInfo.tickInterval * getAxisRange(axisInfo);\r\n                axisInfo.maxValue = axisInfo.minValue + getAxisRange(axisInfo) / scale\r\n            }\r\n            if (mainAxisInfo.inverted && !axisInfo.inverted || !mainAxisInfo.inverted && axisInfo.inverted) {\r\n                mainAxisBaseValueOffset = mainAxisInfo.maxValue - mainAxisInfo.invertedBaseTickValue\r\n            } else {\r\n                mainAxisBaseValueOffset = mainAxisInfo.baseTickValue - mainAxisInfo.minValue\r\n            }\r\n            valueFromAxisInfo = getAxisRange(axisInfo);\r\n            move = (mainAxisBaseValueOffset / getAxisRange(mainAxisInfo) - (axisInfo.baseTickValue - axisInfo.minValue) / valueFromAxisInfo) * valueFromAxisInfo;\r\n            axisInfo.minValue -= move;\r\n            axisInfo.maxValue -= move\r\n        }\r\n    })\r\n}\r\n\r\nfunction calculatePaddings(axesInfo) {\r\n    var minPadding;\r\n    var maxPadding;\r\n    var startPadding = 0;\r\n    var endPadding = 0;\r\n    axesInfo.forEach(function(axisInfo) {\r\n        var inverted = axisInfo.inverted;\r\n        minPadding = axisInfo.minValue > axisInfo.oldMinValue ? (axisInfo.minValue - axisInfo.oldMinValue) / getAxisRange(axisInfo) : 0;\r\n        maxPadding = axisInfo.maxValue < axisInfo.oldMaxValue ? (axisInfo.oldMaxValue - axisInfo.maxValue) / getAxisRange(axisInfo) : 0;\r\n        startPadding = _max(startPadding, inverted ? maxPadding : minPadding);\r\n        endPadding = _max(endPadding, inverted ? minPadding : maxPadding)\r\n    });\r\n    return {\r\n        start: startPadding,\r\n        end: endPadding\r\n    }\r\n}\r\n\r\nfunction correctMinMaxValuesByPaddings(axesInfo, paddings) {\r\n    axesInfo.forEach(function(info) {\r\n        var range = getAxisRange(info);\r\n        var inverted = info.inverted;\r\n        info.minValue = (0, _math2.adjust)(info.minValue - paddings[inverted ? \"end\" : \"start\"] * range);\r\n        info.maxValue = (0, _math2.adjust)(info.maxValue + paddings[inverted ? \"start\" : \"end\"] * range)\r\n    })\r\n}\r\n\r\nfunction updateTickValuesIfSynchronizedValueUsed(axesInfo) {\r\n    var hasSynchronizedValue = false;\r\n    axesInfo.forEach(function(info) {\r\n        hasSynchronizedValue = hasSynchronizedValue || (0, _type.isDefined)(info.synchronizedValue)\r\n    });\r\n    axesInfo.forEach(function(info) {\r\n        var tickInterval = info.tickInterval;\r\n        var tickValues = info.tickValues;\r\n        var maxValue = info.maxValue;\r\n        var minValue = info.minValue;\r\n        var tick;\r\n        if (hasSynchronizedValue && tickInterval) {\r\n            while ((tick = (0, _math2.adjust)(tickValues[0] - tickInterval)) >= minValue) {\r\n                tickValues.unshift(tick)\r\n            }\r\n            tick = tickValues[tickValues.length - 1];\r\n            while ((tick = (0, _math2.adjust)(tick + tickInterval)) <= maxValue) {\r\n                tickValues.push(tick)\r\n            }\r\n        }\r\n        while (tickValues[0] + tickInterval / 10 < minValue) {\r\n            tickValues.shift()\r\n        }\r\n        while (tickValues[tickValues.length - 1] - tickInterval / 10 > maxValue) {\r\n            tickValues.pop()\r\n        }\r\n    })\r\n}\r\n\r\nfunction applyMinMaxValues(axesInfo) {\r\n    axesInfo.forEach(function(info) {\r\n        var axis = info.axis;\r\n        var range = axis.getTranslator().getBusinessRange();\r\n        if (range.min === range.minVisible) {\r\n            range.min = info.minValue\r\n        }\r\n        if (range.max === range.maxVisible) {\r\n            range.max = info.maxValue\r\n        }\r\n        range.minVisible = info.minValue;\r\n        range.maxVisible = info.maxValue;\r\n        if (range.min > range.minVisible) {\r\n            range.min = range.minVisible\r\n        }\r\n        if (range.max < range.maxVisible) {\r\n            range.max = range.maxVisible\r\n        }\r\n        axis.getTranslator().updateBusinessRange(range);\r\n        axis.setTicks({\r\n            majorTicks: info.tickValues,\r\n            minorTicks: info.minorValues\r\n        })\r\n    })\r\n}\r\n\r\nfunction correctAfterSynchronize(axesInfo) {\r\n    var invalidAxisInfo = [];\r\n    var correctValue;\r\n    axesInfo.forEach(function(info) {\r\n        if (info.oldMaxValue - info.oldMinValue === 0) {\r\n            invalidAxisInfo.push(info)\r\n        } else {\r\n            if (!(0, _type.isDefined)(correctValue) && !(0, _type.isDefined)(info.synchronizedValue)) {\r\n                correctValue = _abs((info.maxValue - info.minValue) / (info.tickValues[_floor(info.tickValues.length / 2)] - info.minValue || info.maxValue))\r\n            }\r\n        }\r\n    });\r\n    if (!(0, _type.isDefined)(correctValue)) {\r\n        return\r\n    }\r\n    invalidAxisInfo.forEach(function(info) {\r\n        var firstTick = info.tickValues[0];\r\n        var correctedTick = firstTick * correctValue;\r\n        if (firstTick > 0) {\r\n            info.maxValue = correctedTick;\r\n            info.minValue = 0\r\n        } else {\r\n            if (firstTick < 0) {\r\n                info.minValue = correctedTick;\r\n                info.maxValue = 0\r\n            }\r\n        }\r\n    })\r\n}\r\n\r\nfunction updateMinorTicks(axesInfo) {\r\n    axesInfo.forEach(function(axisInfo) {\r\n        if (!axisInfo.minorTickInterval) {\r\n            return\r\n        }\r\n        var ticks = [];\r\n        var interval = axisInfo.minorTickInterval;\r\n        var tickCount = axisInfo.tickInterval / interval - 1;\r\n        for (var i = 1; i < axisInfo.tickValues.length; i++) {\r\n            var tick = axisInfo.tickValues[i - 1];\r\n            for (var j = 0; j < tickCount; j++) {\r\n                tick += interval;\r\n                ticks.push(tick)\r\n            }\r\n        }\r\n        axisInfo.minorValues = ticks\r\n    })\r\n}\r\nvar multiAxesSynchronizer = {\r\n    synchronize: function(valueAxes) {\r\n        (0, _iterator.each)(getValueAxesPerPanes(valueAxes), function(_, axes) {\r\n            var axesInfo;\r\n            var paddings;\r\n            if (axes.length > 1) {\r\n                axesInfo = populateAxesInfo(axes);\r\n                if (axesInfo.length < 2 || !getMainAxisInfo(axesInfo)) {\r\n                    return\r\n                }\r\n                updateTickValues(axesInfo);\r\n                correctMinMaxValues(axesInfo);\r\n                paddings = calculatePaddings(axesInfo);\r\n                correctMinMaxValuesByPaddings(axesInfo, paddings);\r\n                correctAfterSynchronize(axesInfo);\r\n                updateTickValuesIfSynchronizedValueUsed(axesInfo);\r\n                updateMinorTicks(axesInfo);\r\n                axesInfo.forEach(function(info) {\r\n                    convertAxisInfo(info, logConverter)\r\n                });\r\n                applyMinMaxValues(axesInfo)\r\n            }\r\n        })\r\n    }\r\n};\r\nmodule.exports = multiAxesSynchronizer;\r\n"]},"metadata":{},"sourceType":"module"}