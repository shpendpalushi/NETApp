{"ast":null,"code":"/**\r\n * DevExtreme (viz/funnel/label.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _label = require(\"../series/points/label\");\n\nvar _label2 = _interopRequireDefault(_label);\n\nvar _utils = require(\"../core/utils\");\n\nvar _extend = require(\"../../core/utils/extend\");\n\nvar _common = require(\"../../core/utils/common\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || \"[object Arguments]\" === Object.prototype.toString.call(arr))) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _e = void 0;\n\n  try {\n    for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) {\n        break;\n      }\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && null != _i.return) {\n        _i.return();\n      }\n    } finally {\n      if (_d) {\n        throw _e;\n      }\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) {\n    return arr;\n  }\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || \"[object Arguments]\" === Object.prototype.toString.call(iter)) {\n    return Array.from(iter);\n  }\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nvar OUTSIDE_POSITION = \"outside\";\nvar INSIDE_POSITION = \"inside\";\nvar OUTSIDE_LABEL_INDENT = 5;\nvar COLUMNS_LABEL_INDENT = 20;\nvar CONNECTOR_INDENT = 4;\nvar PREVENT_EMPTY_PIXEL_OFFSET = 1;\n\nfunction getLabelIndent(pos) {\n  pos = (0, _utils.normalizeEnum)(pos);\n\n  if (pos === OUTSIDE_POSITION) {\n    return OUTSIDE_LABEL_INDENT;\n  } else {\n    if (pos === INSIDE_POSITION) {\n      return 0;\n    }\n  }\n\n  return COLUMNS_LABEL_INDENT;\n}\n\nfunction isOutsidePosition(pos) {\n  pos = (0, _utils.normalizeEnum)(pos);\n  return pos === OUTSIDE_POSITION || pos !== INSIDE_POSITION;\n}\n\nfunction correctYForInverted(y, bBox, inverted) {\n  return inverted ? y - bBox.height : y;\n}\n\nfunction getOutsideRightLabelPosition(coords, bBox, options, inverted) {\n  return {\n    x: coords[2] + options.horizontalOffset + OUTSIDE_LABEL_INDENT,\n    y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)\n  };\n}\n\nfunction getOutsideLeftLabelPosition(coords, bBox, options, inverted) {\n  return {\n    x: coords[0] - bBox.width - options.horizontalOffset - OUTSIDE_LABEL_INDENT,\n    y: correctYForInverted(coords[1] + options.verticalOffset, bBox, inverted)\n  };\n}\n\nfunction getInsideLabelPosition(coords, bBox, options) {\n  var width = coords[2] - coords[0];\n  var height = coords[7] - coords[1];\n  return {\n    x: coords[0] + width / 2 + options.horizontalOffset - bBox.width / 2,\n    y: coords[1] + options.verticalOffset + height / 2 - bBox.height / 2\n  };\n}\n\nfunction getColumnLabelRightPosition(labelRect, rect, textAlignment) {\n  return function (coords, bBox, options, inverted) {\n    return {\n      x: \"left\" === textAlignment ? rect[2] + options.horizontalOffset + COLUMNS_LABEL_INDENT : labelRect[2] - bBox.width,\n      y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)\n    };\n  };\n}\n\nfunction getColumnLabelLeftPosition(labelRect, rect, textAlignment) {\n  return function (coords, bBox, options, inverted) {\n    return {\n      x: \"left\" === textAlignment ? labelRect[0] : rect[0] - bBox.width - options.horizontalOffset - COLUMNS_LABEL_INDENT,\n      y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)\n    };\n  };\n}\n\nfunction getConnectorStrategy(options, inverted) {\n  var isLeftPos = \"left\" === options.horizontalAlignment;\n  var connectorIndent = isLeftPos ? CONNECTOR_INDENT : -CONNECTOR_INDENT;\n  var verticalCorrection = inverted ? -PREVENT_EMPTY_PIXEL_OFFSET : 0;\n\n  function getFigureCenter(figure) {\n    return isLeftPos ? [figure[0] + PREVENT_EMPTY_PIXEL_OFFSET, figure[1] + verticalCorrection] : [figure[2] - PREVENT_EMPTY_PIXEL_OFFSET, figure[3] + verticalCorrection];\n  }\n\n  return {\n    isLabelInside: function isLabelInside() {\n      return !isOutsidePosition(options.position);\n    },\n    getFigureCenter: getFigureCenter,\n    prepareLabelPoints: function prepareLabelPoints(bBox) {\n      var x = bBox.x + connectorIndent;\n      var y = bBox.y;\n      var x1 = x + bBox.width;\n      return _toConsumableArray(Array(bBox.height + 1)).map(function (_, i) {\n        return [x, y + i];\n      }).concat(_toConsumableArray(Array(bBox.height + 1)).map(function (_, i) {\n        return [x1, y + i];\n      }));\n    },\n    isHorizontal: function isHorizontal() {\n      return true;\n    },\n    findFigurePoint: function findFigurePoint(figure) {\n      return getFigureCenter(figure);\n    },\n    adjustPoints: function adjustPoints(points) {\n      return points.map(Math.round);\n    }\n  };\n}\n\nfunction getLabelOptions(labelOptions, defaultColor, defaultTextAlignment) {\n  var opt = labelOptions || {};\n  var labelFont = (0, _extend.extend)({}, opt.font) || {};\n  var labelBorder = opt.border || {};\n  var labelConnector = opt.connector || {};\n  var backgroundAttr = {\n    fill: opt.backgroundColor || defaultColor,\n    \"stroke-width\": labelBorder.visible ? labelBorder.width || 0 : 0,\n    stroke: labelBorder.visible && labelBorder.width ? labelBorder.color : \"none\",\n    dashStyle: labelBorder.dashStyle\n  };\n  var connectorAttr = {\n    stroke: labelConnector.visible && labelConnector.width ? labelConnector.color || defaultColor : \"none\",\n    \"stroke-width\": labelConnector.visible ? labelConnector.width || 0 : 0,\n    opacity: labelConnector.opacity\n  };\n  labelFont.color = \"none\" === opt.backgroundColor && \"#ffffff\" === (0, _utils.normalizeEnum)(labelFont.color) && \"inside\" !== opt.position ? defaultColor : labelFont.color;\n  return {\n    format: opt.format,\n    textAlignment: opt.textAlignment || (isOutsidePosition(opt.position) ? defaultTextAlignment : \"center\"),\n    customizeText: opt.customizeText,\n    attributes: {\n      font: labelFont\n    },\n    visible: 0 !== labelFont.size ? opt.visible : false,\n    showForZeroValues: opt.showForZeroValues,\n    horizontalOffset: opt.horizontalOffset,\n    verticalOffset: opt.verticalOffset,\n    background: backgroundAttr,\n    connector: connectorAttr,\n    wordWrap: labelOptions.wordWrap,\n    textOverflow: labelOptions.textOverflow\n  };\n}\n\nfunction correctLabelPosition(pos, bBox, rect) {\n  if (pos.x < rect[0]) {\n    pos.x = rect[0];\n  }\n\n  if (pos.x + bBox.width > rect[2]) {\n    pos.x = rect[2] - bBox.width;\n  }\n\n  if (pos.y < rect[1]) {\n    pos.y = rect[1];\n  }\n\n  if (pos.y + bBox.height > rect[3]) {\n    pos.y = rect[3] - bBox.height;\n  }\n\n  return pos;\n}\n\nfunction removeEmptySpace(labels, requiredSpace, startPoint) {\n  labels.reduce(function (requiredSpace, label, index, labels) {\n    var prevLabel = labels[index + 1];\n\n    if (requiredSpace > 0) {\n      var bBox = label.getBoundingRect();\n      var point = prevLabel ? prevLabel.getBoundingRect().y + prevLabel.getBoundingRect().height : startPoint;\n      var emptySpace = bBox.y - point;\n      var shift = Math.min(emptySpace, requiredSpace);\n      labels.slice(0, index + 1).forEach(function (label) {\n        var bBox = label.getBoundingRect();\n        label.shift(bBox.x, bBox.y - shift);\n      });\n      requiredSpace -= shift;\n    }\n\n    return requiredSpace;\n  }, requiredSpace);\n}\n\nexports.plugin = {\n  name: \"lables\",\n  init: _common.noop,\n  dispose: _common.noop,\n  extenders: {\n    _initCore: function _initCore() {\n      this._labelsGroup = this._renderer.g().attr({\n        \"class\": this._rootClassPrefix + \"-labels\"\n      }).append(this._renderer.root);\n      this._labels = [];\n    },\n    _applySize: function _applySize() {\n      var options = this._getOption(\"label\");\n\n      var adaptiveLayout = this._getOption(\"adaptiveLayout\");\n\n      var rect = this._rect;\n      var labelWidth = 0;\n      var groupWidth;\n      var width = rect[2] - rect[0];\n      this._labelRect = rect.slice();\n\n      if (!this._labels.length || !isOutsidePosition(options.position)) {\n        if ((0, _utils.normalizeEnum)(\"none\" !== this._getOption(\"resolveLabelOverlapping\", true))) {\n          this._labels.forEach(function (l) {\n            return !l.isVisible() && l.draw(true);\n          });\n        }\n\n        return;\n      }\n\n      groupWidth = this._labels.map(function (label) {\n        label.resetEllipsis();\n        return label.getBoundingRect().width;\n      }).reduce(function (max, width) {\n        return Math.max(max, width);\n      }, 0);\n      labelWidth = groupWidth + options.horizontalOffset + getLabelIndent(options.position);\n\n      if (!adaptiveLayout.keepLabels && width - labelWidth < adaptiveLayout.width) {\n        this._labels.forEach(function (label) {\n          label.draw(false);\n        });\n\n        return;\n      } else {\n        if (width - labelWidth < adaptiveLayout.width) {\n          labelWidth = width - adaptiveLayout.width;\n          labelWidth = labelWidth > 0 ? labelWidth : 0;\n        }\n\n        this._labels.forEach(function (label) {\n          label.draw(true);\n        });\n      }\n\n      if (\"left\" === options.horizontalAlignment) {\n        rect[0] += labelWidth;\n      } else {\n        rect[2] -= labelWidth;\n      }\n    },\n    _buildNodes: function _buildNodes() {\n      this._createLabels();\n    },\n    _change_TILING: function _change_TILING() {\n      var that = this;\n\n      var options = that._getOption(\"label\");\n\n      var getCoords = getInsideLabelPosition;\n\n      var inverted = that._getOption(\"inverted\", true);\n\n      var textAlignment;\n\n      if (isOutsidePosition(options.position)) {\n        if ((0, _utils.normalizeEnum)(options.position) === OUTSIDE_POSITION) {\n          getCoords = \"left\" === options.horizontalAlignment ? getOutsideLeftLabelPosition : getOutsideRightLabelPosition;\n        } else {\n          textAlignment = this._defaultLabelTextAlignment();\n          getCoords = \"left\" === options.horizontalAlignment ? getColumnLabelLeftPosition(this._labelRect, this._rect, textAlignment) : getColumnLabelRightPosition(this._labelRect, this._rect, textAlignment);\n        }\n      }\n\n      that._labels.forEach(function (label, index) {\n        var item = that._items[index];\n        var bBox;\n        var pos;\n        var borderWidth = item.getNormalStyle()[\"stroke-width\"];\n        var halfBorderWidth = inverted ? borderWidth / 2 : -borderWidth / 2;\n        var coords = halfBorderWidth ? item.coords.map(function (coord, index) {\n          if (1 === index || 3 === index) {\n            return coord - halfBorderWidth;\n          } else {\n            if (2 === index) {\n              return coord - borderWidth;\n            } else {\n              if (0 === index) {\n                return coord + borderWidth;\n              }\n            }\n          }\n\n          return coord;\n        }) : item.coords;\n\n        if (!options.showForZeroValues && 0 === item.value) {\n          label.draw(false);\n          return;\n        }\n\n        if (isOutsidePosition(options.position)) {\n          that._correctLabelWidth(label, item.coords, options);\n        }\n\n        bBox = label.getBoundingRect();\n        pos = correctLabelPosition(getCoords(coords, bBox, options, inverted), bBox, that._labelRect);\n        label.setFigureToDrawConnector(coords);\n        label.shift(pos.x, pos.y);\n      });\n\n      that._resolveLabelOverlapping();\n    }\n  },\n  members: {\n    _resolveLabelOverlapping: function _resolveLabelOverlapping() {\n      var that = this;\n      var resolveLabelOverlapping = (0, _utils.normalizeEnum)(that._getOption(\"resolveLabelOverlapping\", true));\n      var labels = this._getOption(\"inverted\", true) ? that._labels.slice().reverse() : that._labels;\n\n      if (\"hide\" === resolveLabelOverlapping) {\n        labels.reduce(function (height, label) {\n          if (label.getBoundingRect().y < height) {\n            label.hide();\n          } else {\n            height = label.getBoundingRect().y + label.getBoundingRect().height;\n          }\n\n          return height;\n        }, 0);\n      } else {\n        if (\"shift\" === resolveLabelOverlapping) {\n          var maxHeight = this._labelRect[3];\n          labels.reduce(function (_ref, label, index, labels) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                height = _ref2[0],\n                emptySpace = _ref2[1];\n\n            var bBox = label.getBoundingRect();\n            var y = bBox.y;\n\n            if (bBox.y < height) {\n              label.shift(bBox.x, height);\n              y = height;\n            }\n\n            if (y - height > 0) {\n              emptySpace += y - height;\n            }\n\n            if (y + bBox.height > maxHeight) {\n              if (emptySpace && emptySpace > y + bBox.height - maxHeight) {\n                removeEmptySpace(labels.slice(0, index).reverse(), y + bBox.height - maxHeight, that._labelRect[1]);\n                emptySpace -= y + bBox.height - maxHeight;\n                label.shift(bBox.x, y - (y + bBox.height - maxHeight));\n                height = y - (y + bBox.height - maxHeight) + bBox.height;\n              } else {\n                label.hide();\n              }\n            } else {\n              height = y + bBox.height;\n            }\n\n            return [height, emptySpace];\n          }, [this._labelRect[1], 0]);\n        }\n      }\n    },\n    _defaultLabelTextAlignment: function _defaultLabelTextAlignment() {\n      return this._getOption(\"rtlEnabled\", true) ? \"right\" : \"left\";\n    },\n    _correctLabelWidth: function _correctLabelWidth(label, item, options) {\n      var isLeftPos = \"left\" === options.horizontalAlignment;\n      var minX = isLeftPos ? this._labelRect[0] : item[2];\n      var maxX = isLeftPos ? item[0] : this._labelRect[2];\n      var maxWidth = maxX - minX;\n\n      if (label.getBoundingRect().width > maxWidth) {\n        label.fit(maxWidth);\n      }\n    },\n    _createLabels: function _createLabels() {\n      var that = this;\n\n      var labelOptions = that._getOption(\"label\");\n\n      var connectorStrategy = getConnectorStrategy(labelOptions, that._getOption(\"inverted\", true));\n\n      this._labelsGroup.clear();\n\n      if (!labelOptions.visible) {\n        return;\n      }\n\n      this._labels = that._items.map(function (item) {\n        var label = new _label2.default.Label({\n          renderer: that._renderer,\n          labelsGroup: that._labelsGroup,\n          strategy: connectorStrategy\n        });\n        label.setOptions(getLabelOptions(labelOptions, item.color, that._defaultLabelTextAlignment()));\n        label.setData({\n          item: item,\n          value: item.value,\n          percent: item.percent\n        });\n        label.draw(true);\n        return label;\n      });\n\n      if (this._labels.length && isOutsidePosition(labelOptions.position)) {\n        this._requestChange([\"LAYOUT\"]);\n      }\n    }\n  },\n  customize: function customize(constructor) {\n    constructor.prototype._proxyData.push(function (x, y) {\n      var that = this;\n      var data;\n\n      that._labels.forEach(function (label, index) {\n        var rect = label.getBoundingRect();\n\n        if (x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height) {\n          var pos = isOutsidePosition(that._getOption(\"label\").position) ? \"outside\" : \"inside\";\n          data = {\n            id: index,\n            type: pos + \"-label\"\n          };\n          return true;\n        }\n      });\n\n      return data;\n    });\n\n    [\"label\", \"resolveLabelOverlapping\"].forEach(function (optionName) {\n      constructor.addChange({\n        code: optionName.toUpperCase(),\n        handler: function handler() {\n          this._createLabels();\n\n          this._requestChange([\"LAYOUT\"]);\n        },\n        isThemeDependent: true,\n        isOptionChange: true,\n        option: optionName\n      });\n    });\n  },\n  fontFields: [\"label.font\"]\n};","map":{"version":3,"sources":["C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/devextreme/viz/funnel/label.js"],"names":["_label","require","_label2","_interopRequireDefault","_utils","_extend","_common","obj","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","Symbol","Object","_arr","_n","_d","_e","_i","arr","_s","i","Array","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","arr2","OUTSIDE_POSITION","INSIDE_POSITION","OUTSIDE_LABEL_INDENT","COLUMNS_LABEL_INDENT","CONNECTOR_INDENT","PREVENT_EMPTY_PIXEL_OFFSET","pos","inverted","y","bBox","x","coords","options","correctYForInverted","width","height","rect","labelRect","isLeftPos","connectorIndent","verticalCorrection","figure","isLabelInside","isOutsidePosition","getFigureCenter","prepareLabelPoints","x1","isHorizontal","findFigurePoint","adjustPoints","points","Math","opt","labelOptions","labelFont","labelBorder","labelConnector","backgroundAttr","fill","stroke","dashStyle","connectorAttr","opacity","format","textAlignment","customizeText","attributes","font","visible","showForZeroValues","horizontalOffset","verticalOffset","background","connector","wordWrap","textOverflow","labels","prevLabel","index","requiredSpace","label","point","emptySpace","shift","exports","name","init","dispose","extenders","_initCore","_applySize","adaptiveLayout","labelWidth","l","groupWidth","getLabelIndent","_buildNodes","_change_TILING","that","getCoords","getColumnLabelLeftPosition","getColumnLabelRightPosition","item","borderWidth","halfBorderWidth","coord","correctLabelPosition","members","_resolveLabelOverlapping","resolveLabelOverlapping","maxHeight","_ref2","_slicedToArray","removeEmptySpace","_defaultLabelTextAlignment","_correctLabelWidth","minX","maxX","maxWidth","_createLabels","connectorStrategy","getConnectorStrategy","renderer","labelsGroup","strategy","getLabelOptions","value","percent","customize","constructor","data","id","type","code","optionName","handler","isThemeDependent","isOptionChange","option","fontFields"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (viz/funnel/label.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nvar _label = require(\"../series/points/label\");\r\nvar _label2 = _interopRequireDefault(_label);\r\nvar _utils = require(\"../core/utils\");\r\nvar _extend = require(\"../../core/utils/extend\");\r\nvar _common = require(\"../../core/utils/common\");\r\n\r\nfunction _interopRequireDefault(obj) {\r\n    return obj && obj.__esModule ? obj : {\r\n        \"default\": obj\r\n    }\r\n}\r\n\r\nfunction _slicedToArray(arr, i) {\r\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest()\r\n}\r\n\r\nfunction _nonIterableRest() {\r\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")\r\n}\r\n\r\nfunction _iterableToArrayLimit(arr, i) {\r\n    if (!(Symbol.iterator in Object(arr) || \"[object Arguments]\" === Object.prototype.toString.call(arr))) {\r\n        return\r\n    }\r\n    var _arr = [];\r\n    var _n = true;\r\n    var _d = false;\r\n    var _e = void 0;\r\n    try {\r\n        for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done); _n = true) {\r\n            _arr.push(_s.value);\r\n            if (i && _arr.length === i) {\r\n                break\r\n            }\r\n        }\r\n    } catch (err) {\r\n        _d = true;\r\n        _e = err\r\n    } finally {\r\n        try {\r\n            if (!_n && null != _i.return) {\r\n                _i.return()\r\n            }\r\n        } finally {\r\n            if (_d) {\r\n                throw _e\r\n            }\r\n        }\r\n    }\r\n    return _arr\r\n}\r\n\r\nfunction _arrayWithHoles(arr) {\r\n    if (Array.isArray(arr)) {\r\n        return arr\r\n    }\r\n}\r\n\r\nfunction _toConsumableArray(arr) {\r\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()\r\n}\r\n\r\nfunction _nonIterableSpread() {\r\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance\")\r\n}\r\n\r\nfunction _iterableToArray(iter) {\r\n    if (Symbol.iterator in Object(iter) || \"[object Arguments]\" === Object.prototype.toString.call(iter)) {\r\n        return Array.from(iter)\r\n    }\r\n}\r\n\r\nfunction _arrayWithoutHoles(arr) {\r\n    if (Array.isArray(arr)) {\r\n        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\r\n            arr2[i] = arr[i]\r\n        }\r\n        return arr2\r\n    }\r\n}\r\nvar OUTSIDE_POSITION = \"outside\";\r\nvar INSIDE_POSITION = \"inside\";\r\nvar OUTSIDE_LABEL_INDENT = 5;\r\nvar COLUMNS_LABEL_INDENT = 20;\r\nvar CONNECTOR_INDENT = 4;\r\nvar PREVENT_EMPTY_PIXEL_OFFSET = 1;\r\n\r\nfunction getLabelIndent(pos) {\r\n    pos = (0, _utils.normalizeEnum)(pos);\r\n    if (pos === OUTSIDE_POSITION) {\r\n        return OUTSIDE_LABEL_INDENT\r\n    } else {\r\n        if (pos === INSIDE_POSITION) {\r\n            return 0\r\n        }\r\n    }\r\n    return COLUMNS_LABEL_INDENT\r\n}\r\n\r\nfunction isOutsidePosition(pos) {\r\n    pos = (0, _utils.normalizeEnum)(pos);\r\n    return pos === OUTSIDE_POSITION || pos !== INSIDE_POSITION\r\n}\r\n\r\nfunction correctYForInverted(y, bBox, inverted) {\r\n    return inverted ? y - bBox.height : y\r\n}\r\n\r\nfunction getOutsideRightLabelPosition(coords, bBox, options, inverted) {\r\n    return {\r\n        x: coords[2] + options.horizontalOffset + OUTSIDE_LABEL_INDENT,\r\n        y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)\r\n    }\r\n}\r\n\r\nfunction getOutsideLeftLabelPosition(coords, bBox, options, inverted) {\r\n    return {\r\n        x: coords[0] - bBox.width - options.horizontalOffset - OUTSIDE_LABEL_INDENT,\r\n        y: correctYForInverted(coords[1] + options.verticalOffset, bBox, inverted)\r\n    }\r\n}\r\n\r\nfunction getInsideLabelPosition(coords, bBox, options) {\r\n    var width = coords[2] - coords[0];\r\n    var height = coords[7] - coords[1];\r\n    return {\r\n        x: coords[0] + width / 2 + options.horizontalOffset - bBox.width / 2,\r\n        y: coords[1] + options.verticalOffset + height / 2 - bBox.height / 2\r\n    }\r\n}\r\n\r\nfunction getColumnLabelRightPosition(labelRect, rect, textAlignment) {\r\n    return function(coords, bBox, options, inverted) {\r\n        return {\r\n            x: \"left\" === textAlignment ? rect[2] + options.horizontalOffset + COLUMNS_LABEL_INDENT : labelRect[2] - bBox.width,\r\n            y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)\r\n        }\r\n    }\r\n}\r\n\r\nfunction getColumnLabelLeftPosition(labelRect, rect, textAlignment) {\r\n    return function(coords, bBox, options, inverted) {\r\n        return {\r\n            x: \"left\" === textAlignment ? labelRect[0] : rect[0] - bBox.width - options.horizontalOffset - COLUMNS_LABEL_INDENT,\r\n            y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)\r\n        }\r\n    }\r\n}\r\n\r\nfunction getConnectorStrategy(options, inverted) {\r\n    var isLeftPos = \"left\" === options.horizontalAlignment;\r\n    var connectorIndent = isLeftPos ? CONNECTOR_INDENT : -CONNECTOR_INDENT;\r\n    var verticalCorrection = inverted ? -PREVENT_EMPTY_PIXEL_OFFSET : 0;\r\n\r\n    function getFigureCenter(figure) {\r\n        return isLeftPos ? [figure[0] + PREVENT_EMPTY_PIXEL_OFFSET, figure[1] + verticalCorrection] : [figure[2] - PREVENT_EMPTY_PIXEL_OFFSET, figure[3] + verticalCorrection]\r\n    }\r\n    return {\r\n        isLabelInside: function() {\r\n            return !isOutsidePosition(options.position)\r\n        },\r\n        getFigureCenter: getFigureCenter,\r\n        prepareLabelPoints: function(bBox) {\r\n            var x = bBox.x + connectorIndent;\r\n            var y = bBox.y;\r\n            var x1 = x + bBox.width;\r\n            return _toConsumableArray(Array(bBox.height + 1)).map(function(_, i) {\r\n                return [x, y + i]\r\n            }).concat(_toConsumableArray(Array(bBox.height + 1)).map(function(_, i) {\r\n                return [x1, y + i]\r\n            }))\r\n        },\r\n        isHorizontal: function() {\r\n            return true\r\n        },\r\n        findFigurePoint: function(figure) {\r\n            return getFigureCenter(figure)\r\n        },\r\n        adjustPoints: function(points) {\r\n            return points.map(Math.round)\r\n        }\r\n    }\r\n}\r\n\r\nfunction getLabelOptions(labelOptions, defaultColor, defaultTextAlignment) {\r\n    var opt = labelOptions || {};\r\n    var labelFont = (0, _extend.extend)({}, opt.font) || {};\r\n    var labelBorder = opt.border || {};\r\n    var labelConnector = opt.connector || {};\r\n    var backgroundAttr = {\r\n        fill: opt.backgroundColor || defaultColor,\r\n        \"stroke-width\": labelBorder.visible ? labelBorder.width || 0 : 0,\r\n        stroke: labelBorder.visible && labelBorder.width ? labelBorder.color : \"none\",\r\n        dashStyle: labelBorder.dashStyle\r\n    };\r\n    var connectorAttr = {\r\n        stroke: labelConnector.visible && labelConnector.width ? labelConnector.color || defaultColor : \"none\",\r\n        \"stroke-width\": labelConnector.visible ? labelConnector.width || 0 : 0,\r\n        opacity: labelConnector.opacity\r\n    };\r\n    labelFont.color = \"none\" === opt.backgroundColor && \"#ffffff\" === (0, _utils.normalizeEnum)(labelFont.color) && \"inside\" !== opt.position ? defaultColor : labelFont.color;\r\n    return {\r\n        format: opt.format,\r\n        textAlignment: opt.textAlignment || (isOutsidePosition(opt.position) ? defaultTextAlignment : \"center\"),\r\n        customizeText: opt.customizeText,\r\n        attributes: {\r\n            font: labelFont\r\n        },\r\n        visible: 0 !== labelFont.size ? opt.visible : false,\r\n        showForZeroValues: opt.showForZeroValues,\r\n        horizontalOffset: opt.horizontalOffset,\r\n        verticalOffset: opt.verticalOffset,\r\n        background: backgroundAttr,\r\n        connector: connectorAttr,\r\n        wordWrap: labelOptions.wordWrap,\r\n        textOverflow: labelOptions.textOverflow\r\n    }\r\n}\r\n\r\nfunction correctLabelPosition(pos, bBox, rect) {\r\n    if (pos.x < rect[0]) {\r\n        pos.x = rect[0]\r\n    }\r\n    if (pos.x + bBox.width > rect[2]) {\r\n        pos.x = rect[2] - bBox.width\r\n    }\r\n    if (pos.y < rect[1]) {\r\n        pos.y = rect[1]\r\n    }\r\n    if (pos.y + bBox.height > rect[3]) {\r\n        pos.y = rect[3] - bBox.height\r\n    }\r\n    return pos\r\n}\r\n\r\nfunction removeEmptySpace(labels, requiredSpace, startPoint) {\r\n    labels.reduce(function(requiredSpace, label, index, labels) {\r\n        var prevLabel = labels[index + 1];\r\n        if (requiredSpace > 0) {\r\n            var bBox = label.getBoundingRect();\r\n            var point = prevLabel ? prevLabel.getBoundingRect().y + prevLabel.getBoundingRect().height : startPoint;\r\n            var emptySpace = bBox.y - point;\r\n            var shift = Math.min(emptySpace, requiredSpace);\r\n            labels.slice(0, index + 1).forEach(function(label) {\r\n                var bBox = label.getBoundingRect();\r\n                label.shift(bBox.x, bBox.y - shift)\r\n            });\r\n            requiredSpace -= shift\r\n        }\r\n        return requiredSpace\r\n    }, requiredSpace)\r\n}\r\nexports.plugin = {\r\n    name: \"lables\",\r\n    init: _common.noop,\r\n    dispose: _common.noop,\r\n    extenders: {\r\n        _initCore: function() {\r\n            this._labelsGroup = this._renderer.g().attr({\r\n                \"class\": this._rootClassPrefix + \"-labels\"\r\n            }).append(this._renderer.root);\r\n            this._labels = []\r\n        },\r\n        _applySize: function() {\r\n            var options = this._getOption(\"label\");\r\n            var adaptiveLayout = this._getOption(\"adaptiveLayout\");\r\n            var rect = this._rect;\r\n            var labelWidth = 0;\r\n            var groupWidth;\r\n            var width = rect[2] - rect[0];\r\n            this._labelRect = rect.slice();\r\n            if (!this._labels.length || !isOutsidePosition(options.position)) {\r\n                if ((0, _utils.normalizeEnum)(\"none\" !== this._getOption(\"resolveLabelOverlapping\", true))) {\r\n                    this._labels.forEach(function(l) {\r\n                        return !l.isVisible() && l.draw(true)\r\n                    })\r\n                }\r\n                return\r\n            }\r\n            groupWidth = this._labels.map(function(label) {\r\n                label.resetEllipsis();\r\n                return label.getBoundingRect().width\r\n            }).reduce(function(max, width) {\r\n                return Math.max(max, width)\r\n            }, 0);\r\n            labelWidth = groupWidth + options.horizontalOffset + getLabelIndent(options.position);\r\n            if (!adaptiveLayout.keepLabels && width - labelWidth < adaptiveLayout.width) {\r\n                this._labels.forEach(function(label) {\r\n                    label.draw(false)\r\n                });\r\n                return\r\n            } else {\r\n                if (width - labelWidth < adaptiveLayout.width) {\r\n                    labelWidth = width - adaptiveLayout.width;\r\n                    labelWidth = labelWidth > 0 ? labelWidth : 0\r\n                }\r\n                this._labels.forEach(function(label) {\r\n                    label.draw(true)\r\n                })\r\n            }\r\n            if (\"left\" === options.horizontalAlignment) {\r\n                rect[0] += labelWidth\r\n            } else {\r\n                rect[2] -= labelWidth\r\n            }\r\n        },\r\n        _buildNodes: function() {\r\n            this._createLabels()\r\n        },\r\n        _change_TILING: function() {\r\n            var that = this;\r\n            var options = that._getOption(\"label\");\r\n            var getCoords = getInsideLabelPosition;\r\n            var inverted = that._getOption(\"inverted\", true);\r\n            var textAlignment;\r\n            if (isOutsidePosition(options.position)) {\r\n                if ((0, _utils.normalizeEnum)(options.position) === OUTSIDE_POSITION) {\r\n                    getCoords = \"left\" === options.horizontalAlignment ? getOutsideLeftLabelPosition : getOutsideRightLabelPosition\r\n                } else {\r\n                    textAlignment = this._defaultLabelTextAlignment();\r\n                    getCoords = \"left\" === options.horizontalAlignment ? getColumnLabelLeftPosition(this._labelRect, this._rect, textAlignment) : getColumnLabelRightPosition(this._labelRect, this._rect, textAlignment)\r\n                }\r\n            }\r\n            that._labels.forEach(function(label, index) {\r\n                var item = that._items[index];\r\n                var bBox;\r\n                var pos;\r\n                var borderWidth = item.getNormalStyle()[\"stroke-width\"];\r\n                var halfBorderWidth = inverted ? borderWidth / 2 : -borderWidth / 2;\r\n                var coords = halfBorderWidth ? item.coords.map(function(coord, index) {\r\n                    if (1 === index || 3 === index) {\r\n                        return coord - halfBorderWidth\r\n                    } else {\r\n                        if (2 === index) {\r\n                            return coord - borderWidth\r\n                        } else {\r\n                            if (0 === index) {\r\n                                return coord + borderWidth\r\n                            }\r\n                        }\r\n                    }\r\n                    return coord\r\n                }) : item.coords;\r\n                if (!options.showForZeroValues && 0 === item.value) {\r\n                    label.draw(false);\r\n                    return\r\n                }\r\n                if (isOutsidePosition(options.position)) {\r\n                    that._correctLabelWidth(label, item.coords, options)\r\n                }\r\n                bBox = label.getBoundingRect();\r\n                pos = correctLabelPosition(getCoords(coords, bBox, options, inverted), bBox, that._labelRect);\r\n                label.setFigureToDrawConnector(coords);\r\n                label.shift(pos.x, pos.y)\r\n            });\r\n            that._resolveLabelOverlapping()\r\n        }\r\n    },\r\n    members: {\r\n        _resolveLabelOverlapping: function() {\r\n            var that = this;\r\n            var resolveLabelOverlapping = (0, _utils.normalizeEnum)(that._getOption(\"resolveLabelOverlapping\", true));\r\n            var labels = this._getOption(\"inverted\", true) ? that._labels.slice().reverse() : that._labels;\r\n            if (\"hide\" === resolveLabelOverlapping) {\r\n                labels.reduce(function(height, label) {\r\n                    if (label.getBoundingRect().y < height) {\r\n                        label.hide()\r\n                    } else {\r\n                        height = label.getBoundingRect().y + label.getBoundingRect().height\r\n                    }\r\n                    return height\r\n                }, 0)\r\n            } else {\r\n                if (\"shift\" === resolveLabelOverlapping) {\r\n                    var maxHeight = this._labelRect[3];\r\n                    labels.reduce(function(_ref, label, index, labels) {\r\n                        var _ref2 = _slicedToArray(_ref, 2),\r\n                            height = _ref2[0],\r\n                            emptySpace = _ref2[1];\r\n                        var bBox = label.getBoundingRect();\r\n                        var y = bBox.y;\r\n                        if (bBox.y < height) {\r\n                            label.shift(bBox.x, height);\r\n                            y = height\r\n                        }\r\n                        if (y - height > 0) {\r\n                            emptySpace += y - height\r\n                        }\r\n                        if (y + bBox.height > maxHeight) {\r\n                            if (emptySpace && emptySpace > y + bBox.height - maxHeight) {\r\n                                removeEmptySpace(labels.slice(0, index).reverse(), y + bBox.height - maxHeight, that._labelRect[1]);\r\n                                emptySpace -= y + bBox.height - maxHeight;\r\n                                label.shift(bBox.x, y - (y + bBox.height - maxHeight));\r\n                                height = y - (y + bBox.height - maxHeight) + bBox.height\r\n                            } else {\r\n                                label.hide()\r\n                            }\r\n                        } else {\r\n                            height = y + bBox.height\r\n                        }\r\n                        return [height, emptySpace]\r\n                    }, [this._labelRect[1], 0])\r\n                }\r\n            }\r\n        },\r\n        _defaultLabelTextAlignment: function() {\r\n            return this._getOption(\"rtlEnabled\", true) ? \"right\" : \"left\"\r\n        },\r\n        _correctLabelWidth: function(label, item, options) {\r\n            var isLeftPos = \"left\" === options.horizontalAlignment;\r\n            var minX = isLeftPos ? this._labelRect[0] : item[2];\r\n            var maxX = isLeftPos ? item[0] : this._labelRect[2];\r\n            var maxWidth = maxX - minX;\r\n            if (label.getBoundingRect().width > maxWidth) {\r\n                label.fit(maxWidth)\r\n            }\r\n        },\r\n        _createLabels: function() {\r\n            var that = this;\r\n            var labelOptions = that._getOption(\"label\");\r\n            var connectorStrategy = getConnectorStrategy(labelOptions, that._getOption(\"inverted\", true));\r\n            this._labelsGroup.clear();\r\n            if (!labelOptions.visible) {\r\n                return\r\n            }\r\n            this._labels = that._items.map(function(item) {\r\n                var label = new _label2.default.Label({\r\n                    renderer: that._renderer,\r\n                    labelsGroup: that._labelsGroup,\r\n                    strategy: connectorStrategy\r\n                });\r\n                label.setOptions(getLabelOptions(labelOptions, item.color, that._defaultLabelTextAlignment()));\r\n                label.setData({\r\n                    item: item,\r\n                    value: item.value,\r\n                    percent: item.percent\r\n                });\r\n                label.draw(true);\r\n                return label\r\n            });\r\n            if (this._labels.length && isOutsidePosition(labelOptions.position)) {\r\n                this._requestChange([\"LAYOUT\"])\r\n            }\r\n        }\r\n    },\r\n    customize: function(constructor) {\r\n        constructor.prototype._proxyData.push(function(x, y) {\r\n            var that = this;\r\n            var data;\r\n            that._labels.forEach(function(label, index) {\r\n                var rect = label.getBoundingRect();\r\n                if (x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height) {\r\n                    var pos = isOutsidePosition(that._getOption(\"label\").position) ? \"outside\" : \"inside\";\r\n                    data = {\r\n                        id: index,\r\n                        type: pos + \"-label\"\r\n                    };\r\n                    return true\r\n                }\r\n            });\r\n            return data\r\n        });\r\n        [\"label\", \"resolveLabelOverlapping\"].forEach(function(optionName) {\r\n            constructor.addChange({\r\n                code: optionName.toUpperCase(),\r\n                handler: function() {\r\n                    this._createLabels();\r\n                    this._requestChange([\"LAYOUT\"])\r\n                },\r\n                isThemeDependent: true,\r\n                isOptionChange: true,\r\n                option: optionName\r\n            })\r\n        })\r\n    },\r\n    fontFields: [\"label.font\"]\r\n};\r\n"]},"metadata":{},"sourceType":"module"}