{"ast":null,"code":"/**\r\n * DevExtreme (viz/translators/category_translator.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar isDefined = require(\"../../core/utils/type\").isDefined;\n\nvar adjust = require(\"../../core/utils/math\").adjust;\n\nvar round = Math.round;\n\nfunction getValue(value) {\n  return value;\n}\n\nmodule.exports = {\n  translate: function translate(category, directionOffset) {\n    var that = this;\n    var canvasOptions = that._canvasOptions;\n\n    var categoryIndex = that._categoriesToPoints[category.valueOf()];\n\n    var stickDelta;\n    var specialValue = that.translateSpecialCase(category);\n    var startPointIndex = canvasOptions.startPointIndex || 0;\n    var stickInterval = that._options.stick ? 0 : .5;\n\n    if (isDefined(specialValue)) {\n      return round(specialValue);\n    }\n\n    if (!categoryIndex && 0 !== categoryIndex) {\n      return null;\n    }\n\n    directionOffset = directionOffset || 0;\n    stickDelta = categoryIndex + stickInterval - startPointIndex + .5 * directionOffset;\n    return round(that._calculateProjection(canvasOptions.interval * stickDelta));\n  },\n  getInterval: function getInterval() {\n    return this._canvasOptions.interval;\n  },\n  getEventScale: function getEventScale(zoomEvent) {\n    var scale = zoomEvent.deltaScale || 1;\n    return 1 - (1 - scale) / (.75 + this.visibleCategories.length / this._categories.length);\n  },\n  zoom: function zoom(translate, scale) {\n    var that = this;\n    var categories = that._categories;\n    var canvasOptions = that._canvasOptions;\n    var stick = that._options.stick;\n    var invert = canvasOptions.invert;\n    var interval = canvasOptions.interval * scale;\n    var translateCategories = translate / interval;\n    var visibleCount = (that.visibleCategories || []).length;\n    var startCategoryIndex = parseInt((canvasOptions.startPointIndex || 0) + translateCategories + .5);\n    var categoriesLength = parseInt(adjust(canvasOptions.canvasLength / interval) + (stick ? 1 : 0)) || 1;\n    var endCategoryIndex;\n    var newVisibleCategories;\n    var newInterval;\n\n    if (invert) {\n      startCategoryIndex = parseInt((canvasOptions.startPointIndex || 0) + visibleCount - translateCategories + .5) - categoriesLength;\n    }\n\n    if (startCategoryIndex < 0) {\n      startCategoryIndex = 0;\n    }\n\n    endCategoryIndex = startCategoryIndex + categoriesLength;\n\n    if (endCategoryIndex > categories.length) {\n      endCategoryIndex = categories.length;\n      startCategoryIndex = endCategoryIndex - categoriesLength;\n\n      if (startCategoryIndex < 0) {\n        startCategoryIndex = 0;\n      }\n    }\n\n    newVisibleCategories = categories.slice(parseInt(startCategoryIndex), parseInt(endCategoryIndex));\n    newInterval = that._getDiscreteInterval(newVisibleCategories.length, canvasOptions);\n    scale = newInterval / canvasOptions.interval;\n    translate = that.translate(!invert ? newVisibleCategories[0] : newVisibleCategories[newVisibleCategories.length - 1]) * scale - (canvasOptions.startPoint + (stick ? 0 : newInterval / 2));\n    return {\n      min: newVisibleCategories[0],\n      max: newVisibleCategories[newVisibleCategories.length - 1],\n      translate: translate,\n      scale: scale\n    };\n  },\n  getMinScale: function getMinScale(zoom) {\n    var that = this;\n    var canvasOptions = that._canvasOptions;\n    var categoriesLength = (that.visibleCategories || that._categories).length;\n    categoriesLength += (parseInt(.1 * categoriesLength) || 1) * (zoom ? -2 : 2);\n    return canvasOptions.canvasLength / (Math.max(categoriesLength, 1) * canvasOptions.interval);\n  },\n  getScale: function getScale(min, max) {\n    var that = this;\n    var canvasOptions = that._canvasOptions;\n    var visibleArea = that.getCanvasVisibleArea();\n    var stickOffset = !that._options.stick && 1;\n    var minPoint = isDefined(min) ? that.translate(min, -stickOffset) : null;\n    var maxPoint = isDefined(max) ? that.translate(max, +stickOffset) : null;\n\n    if (null === minPoint) {\n      minPoint = canvasOptions.invert ? visibleArea.max : visibleArea.min;\n    }\n\n    if (null === maxPoint) {\n      maxPoint = canvasOptions.invert ? visibleArea.min : visibleArea.max;\n    }\n\n    return that.canvasLength / Math.abs(maxPoint - minPoint);\n  },\n  isValid: function isValid(value) {\n    return isDefined(value) ? this._categoriesToPoints[value.valueOf()] >= 0 : false;\n  },\n  getCorrectValue: getValue,\n  to: function to(value, direction) {\n    var canvasOptions = this._canvasOptions;\n\n    var categoryIndex = this._categoriesToPoints[value.valueOf()];\n\n    var startPointIndex = canvasOptions.startPointIndex || 0;\n    var stickDelta = categoryIndex + (this._options.stick ? 0 : .5) - startPointIndex + (this._businessRange.invert ? -1 : 1) * direction * .5;\n    return round(this._calculateProjection(canvasOptions.interval * stickDelta));\n  },\n  from: function from(position) {\n    var direction = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n    var canvasOptions = this._canvasOptions;\n    var startPoint = canvasOptions.startPoint;\n    var categories = this.visibleCategories || this._categories;\n    var categoriesLength = categories.length;\n    var stickInterval = this._options.stick ? .5 : 0;\n    var result = round((position - startPoint) / canvasOptions.interval + stickInterval - .5 - .5 * direction);\n\n    if (result >= categoriesLength) {\n      result = categoriesLength - 1;\n    }\n\n    if (result < 0) {\n      result = 0;\n    }\n\n    if (canvasOptions.invert) {\n      result = categoriesLength - result - 1;\n    }\n\n    return categories[result];\n  },\n  _add: function _add() {\n    return NaN;\n  },\n  _toValue: getValue,\n  isValueProlonged: true\n};","map":{"version":3,"sources":["C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/devextreme/viz/translators/category_translator.js"],"names":["isDefined","require","adjust","round","Math","module","translate","that","canvasOptions","categoryIndex","category","specialValue","startPointIndex","stickInterval","directionOffset","stickDelta","getInterval","getEventScale","scale","zoomEvent","zoom","categories","stick","invert","interval","translateCategories","visibleCount","startCategoryIndex","parseInt","categoriesLength","endCategoryIndex","newVisibleCategories","newInterval","min","max","getMinScale","getScale","visibleArea","stickOffset","minPoint","maxPoint","isValid","value","getCorrectValue","to","from","direction","arguments","startPoint","result","position","_add","_toValue","isValueProlonged"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (viz/translators/category_translator.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nvar isDefined = require(\"../../core/utils/type\").isDefined;\r\nvar adjust = require(\"../../core/utils/math\").adjust;\r\nvar round = Math.round;\r\n\r\nfunction getValue(value) {\r\n    return value\r\n}\r\nmodule.exports = {\r\n    translate: function(category, directionOffset) {\r\n        var that = this;\r\n        var canvasOptions = that._canvasOptions;\r\n        var categoryIndex = that._categoriesToPoints[category.valueOf()];\r\n        var stickDelta;\r\n        var specialValue = that.translateSpecialCase(category);\r\n        var startPointIndex = canvasOptions.startPointIndex || 0;\r\n        var stickInterval = that._options.stick ? 0 : .5;\r\n        if (isDefined(specialValue)) {\r\n            return round(specialValue)\r\n        }\r\n        if (!categoryIndex && 0 !== categoryIndex) {\r\n            return null\r\n        }\r\n        directionOffset = directionOffset || 0;\r\n        stickDelta = categoryIndex + stickInterval - startPointIndex + .5 * directionOffset;\r\n        return round(that._calculateProjection(canvasOptions.interval * stickDelta))\r\n    },\r\n    getInterval: function() {\r\n        return this._canvasOptions.interval\r\n    },\r\n    getEventScale: function(zoomEvent) {\r\n        var scale = zoomEvent.deltaScale || 1;\r\n        return 1 - (1 - scale) / (.75 + this.visibleCategories.length / this._categories.length)\r\n    },\r\n    zoom: function(translate, scale) {\r\n        var that = this;\r\n        var categories = that._categories;\r\n        var canvasOptions = that._canvasOptions;\r\n        var stick = that._options.stick;\r\n        var invert = canvasOptions.invert;\r\n        var interval = canvasOptions.interval * scale;\r\n        var translateCategories = translate / interval;\r\n        var visibleCount = (that.visibleCategories || []).length;\r\n        var startCategoryIndex = parseInt((canvasOptions.startPointIndex || 0) + translateCategories + .5);\r\n        var categoriesLength = parseInt(adjust(canvasOptions.canvasLength / interval) + (stick ? 1 : 0)) || 1;\r\n        var endCategoryIndex;\r\n        var newVisibleCategories;\r\n        var newInterval;\r\n        if (invert) {\r\n            startCategoryIndex = parseInt((canvasOptions.startPointIndex || 0) + visibleCount - translateCategories + .5) - categoriesLength\r\n        }\r\n        if (startCategoryIndex < 0) {\r\n            startCategoryIndex = 0\r\n        }\r\n        endCategoryIndex = startCategoryIndex + categoriesLength;\r\n        if (endCategoryIndex > categories.length) {\r\n            endCategoryIndex = categories.length;\r\n            startCategoryIndex = endCategoryIndex - categoriesLength;\r\n            if (startCategoryIndex < 0) {\r\n                startCategoryIndex = 0\r\n            }\r\n        }\r\n        newVisibleCategories = categories.slice(parseInt(startCategoryIndex), parseInt(endCategoryIndex));\r\n        newInterval = that._getDiscreteInterval(newVisibleCategories.length, canvasOptions);\r\n        scale = newInterval / canvasOptions.interval;\r\n        translate = that.translate(!invert ? newVisibleCategories[0] : newVisibleCategories[newVisibleCategories.length - 1]) * scale - (canvasOptions.startPoint + (stick ? 0 : newInterval / 2));\r\n        return {\r\n            min: newVisibleCategories[0],\r\n            max: newVisibleCategories[newVisibleCategories.length - 1],\r\n            translate: translate,\r\n            scale: scale\r\n        }\r\n    },\r\n    getMinScale: function(zoom) {\r\n        var that = this;\r\n        var canvasOptions = that._canvasOptions;\r\n        var categoriesLength = (that.visibleCategories || that._categories).length;\r\n        categoriesLength += (parseInt(.1 * categoriesLength) || 1) * (zoom ? -2 : 2);\r\n        return canvasOptions.canvasLength / (Math.max(categoriesLength, 1) * canvasOptions.interval)\r\n    },\r\n    getScale: function(min, max) {\r\n        var that = this;\r\n        var canvasOptions = that._canvasOptions;\r\n        var visibleArea = that.getCanvasVisibleArea();\r\n        var stickOffset = !that._options.stick && 1;\r\n        var minPoint = isDefined(min) ? that.translate(min, -stickOffset) : null;\r\n        var maxPoint = isDefined(max) ? that.translate(max, +stickOffset) : null;\r\n        if (null === minPoint) {\r\n            minPoint = canvasOptions.invert ? visibleArea.max : visibleArea.min\r\n        }\r\n        if (null === maxPoint) {\r\n            maxPoint = canvasOptions.invert ? visibleArea.min : visibleArea.max\r\n        }\r\n        return that.canvasLength / Math.abs(maxPoint - minPoint)\r\n    },\r\n    isValid: function(value) {\r\n        return isDefined(value) ? this._categoriesToPoints[value.valueOf()] >= 0 : false\r\n    },\r\n    getCorrectValue: getValue,\r\n    to: function(value, direction) {\r\n        var canvasOptions = this._canvasOptions;\r\n        var categoryIndex = this._categoriesToPoints[value.valueOf()];\r\n        var startPointIndex = canvasOptions.startPointIndex || 0;\r\n        var stickDelta = categoryIndex + (this._options.stick ? 0 : .5) - startPointIndex + (this._businessRange.invert ? -1 : 1) * direction * .5;\r\n        return round(this._calculateProjection(canvasOptions.interval * stickDelta))\r\n    },\r\n    from: function(position) {\r\n        var direction = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\r\n        var canvasOptions = this._canvasOptions;\r\n        var startPoint = canvasOptions.startPoint;\r\n        var categories = this.visibleCategories || this._categories;\r\n        var categoriesLength = categories.length;\r\n        var stickInterval = this._options.stick ? .5 : 0;\r\n        var result = round((position - startPoint) / canvasOptions.interval + stickInterval - .5 - .5 * direction);\r\n        if (result >= categoriesLength) {\r\n            result = categoriesLength - 1\r\n        }\r\n        if (result < 0) {\r\n            result = 0\r\n        }\r\n        if (canvasOptions.invert) {\r\n            result = categoriesLength - result - 1\r\n        }\r\n        return categories[result]\r\n    },\r\n    _add: function() {\r\n        return NaN\r\n    },\r\n    _toValue: getValue,\r\n    isValueProlonged: true\r\n};\r\n"]},"metadata":{},"sourceType":"module"}