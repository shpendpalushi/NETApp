{"ast":null,"code":"import _assertThisInitialized from \"C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nexport function bufferTime(bufferTimeSpan) {\n  var length = arguments.length;\n  var scheduler = async;\n\n  if (isScheduler(arguments[arguments.length - 1])) {\n    scheduler = arguments[arguments.length - 1];\n    length--;\n  }\n\n  var bufferCreationInterval = null;\n\n  if (length >= 2) {\n    bufferCreationInterval = arguments[1];\n  }\n\n  var maxBufferSize = Number.POSITIVE_INFINITY;\n\n  if (length >= 3) {\n    maxBufferSize = arguments[2];\n  }\n\n  return function bufferTimeOperatorFunction(source) {\n    return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n  };\n}\n\nvar BufferTimeOperator = /*#__PURE__*/function () {\n  function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    _classCallCheck(this, BufferTimeOperator);\n\n    this.bufferTimeSpan = bufferTimeSpan;\n    this.bufferCreationInterval = bufferCreationInterval;\n    this.maxBufferSize = maxBufferSize;\n    this.scheduler = scheduler;\n  }\n\n  _createClass(BufferTimeOperator, [{\n    key: \"call\",\n    value: function call(subscriber, source) {\n      return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n    }\n  }]);\n\n  return BufferTimeOperator;\n}();\n\nvar Context = function Context() {\n  _classCallCheck(this, Context);\n\n  this.buffer = [];\n};\n\nvar BufferTimeSubscriber = /*#__PURE__*/function (_Subscriber) {\n  _inherits(BufferTimeSubscriber, _Subscriber);\n\n  var _super = _createSuper(BufferTimeSubscriber);\n\n  function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    var _this;\n\n    _classCallCheck(this, BufferTimeSubscriber);\n\n    _this = _super.call(this, destination);\n    _this.bufferTimeSpan = bufferTimeSpan;\n    _this.bufferCreationInterval = bufferCreationInterval;\n    _this.maxBufferSize = maxBufferSize;\n    _this.scheduler = scheduler;\n    _this.contexts = [];\n\n    var context = _this.openContext();\n\n    _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n\n    if (_this.timespanOnly) {\n      var timeSpanOnlyState = {\n        subscriber: _assertThisInitialized(_this),\n        context: context,\n        bufferTimeSpan: bufferTimeSpan\n      };\n\n      _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    } else {\n      var closeState = {\n        subscriber: _assertThisInitialized(_this),\n        context: context\n      };\n      var creationState = {\n        bufferTimeSpan: bufferTimeSpan,\n        bufferCreationInterval: bufferCreationInterval,\n        subscriber: _assertThisInitialized(_this),\n        scheduler: scheduler\n      };\n\n      _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n\n      _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n    }\n\n    return _this;\n  }\n\n  _createClass(BufferTimeSubscriber, [{\n    key: \"_next\",\n    value: function _next(value) {\n      var contexts = this.contexts;\n      var len = contexts.length;\n      var filledBufferContext;\n\n      for (var i = 0; i < len; i++) {\n        var context = contexts[i];\n        var buffer = context.buffer;\n        buffer.push(value);\n\n        if (buffer.length == this.maxBufferSize) {\n          filledBufferContext = context;\n        }\n      }\n\n      if (filledBufferContext) {\n        this.onBufferFull(filledBufferContext);\n      }\n    }\n  }, {\n    key: \"_error\",\n    value: function _error(err) {\n      this.contexts.length = 0;\n\n      _get(_getPrototypeOf(BufferTimeSubscriber.prototype), \"_error\", this).call(this, err);\n    }\n  }, {\n    key: \"_complete\",\n    value: function _complete() {\n      var contexts = this.contexts,\n          destination = this.destination;\n\n      while (contexts.length > 0) {\n        var context = contexts.shift();\n        destination.next(context.buffer);\n      }\n\n      _get(_getPrototypeOf(BufferTimeSubscriber.prototype), \"_complete\", this).call(this);\n    }\n  }, {\n    key: \"_unsubscribe\",\n    value: function _unsubscribe() {\n      this.contexts = null;\n    }\n  }, {\n    key: \"onBufferFull\",\n    value: function onBufferFull(context) {\n      this.closeContext(context);\n      var closeAction = context.closeAction;\n      closeAction.unsubscribe();\n      this.remove(closeAction);\n\n      if (!this.closed && this.timespanOnly) {\n        context = this.openContext();\n        var bufferTimeSpan = this.bufferTimeSpan;\n        var timeSpanOnlyState = {\n          subscriber: this,\n          context: context,\n          bufferTimeSpan: bufferTimeSpan\n        };\n        this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n      }\n    }\n  }, {\n    key: \"openContext\",\n    value: function openContext() {\n      var context = new Context();\n      this.contexts.push(context);\n      return context;\n    }\n  }, {\n    key: \"closeContext\",\n    value: function closeContext(context) {\n      this.destination.next(context.buffer);\n      var contexts = this.contexts;\n      var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n\n      if (spliceIndex >= 0) {\n        contexts.splice(contexts.indexOf(context), 1);\n      }\n    }\n  }]);\n\n  return BufferTimeSubscriber;\n}(Subscriber);\n\nfunction dispatchBufferTimeSpanOnly(state) {\n  var subscriber = state.subscriber;\n  var prevContext = state.context;\n\n  if (prevContext) {\n    subscriber.closeContext(prevContext);\n  }\n\n  if (!subscriber.closed) {\n    state.context = subscriber.openContext();\n    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n  }\n}\n\nfunction dispatchBufferCreation(state) {\n  var bufferCreationInterval = state.bufferCreationInterval,\n      bufferTimeSpan = state.bufferTimeSpan,\n      subscriber = state.subscriber,\n      scheduler = state.scheduler;\n  var context = subscriber.openContext();\n  var action = this;\n\n  if (!subscriber.closed) {\n    subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, {\n      subscriber: subscriber,\n      context: context\n    }));\n    action.schedule(state, bufferCreationInterval);\n  }\n}\n\nfunction dispatchBufferClose(arg) {\n  var subscriber = arg.subscriber,\n      context = arg.context;\n  subscriber.closeContext(context);\n}","map":{"version":3,"sources":["../../../src/internal/operators/bufferTime.ts"],"names":[],"mappings":"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","sourcesContent":["import { async } from '../scheduler/async';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { isScheduler } from '../util/isScheduler';\r\nexport function bufferTime(bufferTimeSpan) {\r\n    let length = arguments.length;\r\n    let scheduler = async;\r\n    if (isScheduler(arguments[arguments.length - 1])) {\r\n        scheduler = arguments[arguments.length - 1];\r\n        length--;\r\n    }\r\n    let bufferCreationInterval = null;\r\n    if (length >= 2) {\r\n        bufferCreationInterval = arguments[1];\r\n    }\r\n    let maxBufferSize = Number.POSITIVE_INFINITY;\r\n    if (length >= 3) {\r\n        maxBufferSize = arguments[2];\r\n    }\r\n    return function bufferTimeOperatorFunction(source) {\r\n        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\r\n    };\r\n}\r\nclass BufferTimeOperator {\r\n    constructor(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\r\n        this.bufferTimeSpan = bufferTimeSpan;\r\n        this.bufferCreationInterval = bufferCreationInterval;\r\n        this.maxBufferSize = maxBufferSize;\r\n        this.scheduler = scheduler;\r\n    }\r\n    call(subscriber, source) {\r\n        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\r\n    }\r\n}\r\nclass Context {\r\n    constructor() {\r\n        this.buffer = [];\r\n    }\r\n}\r\nclass BufferTimeSubscriber extends Subscriber {\r\n    constructor(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\r\n        super(destination);\r\n        this.bufferTimeSpan = bufferTimeSpan;\r\n        this.bufferCreationInterval = bufferCreationInterval;\r\n        this.maxBufferSize = maxBufferSize;\r\n        this.scheduler = scheduler;\r\n        this.contexts = [];\r\n        const context = this.openContext();\r\n        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\r\n        if (this.timespanOnly) {\r\n            const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\r\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\r\n        }\r\n        else {\r\n            const closeState = { subscriber: this, context };\r\n            const creationState = { bufferTimeSpan, bufferCreationInterval, subscriber: this, scheduler };\r\n            this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\r\n            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\r\n        }\r\n    }\r\n    _next(value) {\r\n        const contexts = this.contexts;\r\n        const len = contexts.length;\r\n        let filledBufferContext;\r\n        for (let i = 0; i < len; i++) {\r\n            const context = contexts[i];\r\n            const buffer = context.buffer;\r\n            buffer.push(value);\r\n            if (buffer.length == this.maxBufferSize) {\r\n                filledBufferContext = context;\r\n            }\r\n        }\r\n        if (filledBufferContext) {\r\n            this.onBufferFull(filledBufferContext);\r\n        }\r\n    }\r\n    _error(err) {\r\n        this.contexts.length = 0;\r\n        super._error(err);\r\n    }\r\n    _complete() {\r\n        const { contexts, destination } = this;\r\n        while (contexts.length > 0) {\r\n            const context = contexts.shift();\r\n            destination.next(context.buffer);\r\n        }\r\n        super._complete();\r\n    }\r\n    _unsubscribe() {\r\n        this.contexts = null;\r\n    }\r\n    onBufferFull(context) {\r\n        this.closeContext(context);\r\n        const closeAction = context.closeAction;\r\n        closeAction.unsubscribe();\r\n        this.remove(closeAction);\r\n        if (!this.closed && this.timespanOnly) {\r\n            context = this.openContext();\r\n            const bufferTimeSpan = this.bufferTimeSpan;\r\n            const timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };\r\n            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\r\n        }\r\n    }\r\n    openContext() {\r\n        const context = new Context();\r\n        this.contexts.push(context);\r\n        return context;\r\n    }\r\n    closeContext(context) {\r\n        this.destination.next(context.buffer);\r\n        const contexts = this.contexts;\r\n        const spliceIndex = contexts ? contexts.indexOf(context) : -1;\r\n        if (spliceIndex >= 0) {\r\n            contexts.splice(contexts.indexOf(context), 1);\r\n        }\r\n    }\r\n}\r\nfunction dispatchBufferTimeSpanOnly(state) {\r\n    const subscriber = state.subscriber;\r\n    const prevContext = state.context;\r\n    if (prevContext) {\r\n        subscriber.closeContext(prevContext);\r\n    }\r\n    if (!subscriber.closed) {\r\n        state.context = subscriber.openContext();\r\n        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\r\n    }\r\n}\r\nfunction dispatchBufferCreation(state) {\r\n    const { bufferCreationInterval, bufferTimeSpan, subscriber, scheduler } = state;\r\n    const context = subscriber.openContext();\r\n    const action = this;\r\n    if (!subscriber.closed) {\r\n        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber, context }));\r\n        action.schedule(state, bufferCreationInterval);\r\n    }\r\n}\r\nfunction dispatchBufferClose(arg) {\r\n    const { subscriber, context } = arg;\r\n    subscriber.closeContext(context);\r\n}\r\n//# sourceMappingURL=bufferTime.js.map"]},"metadata":{},"sourceType":"module"}