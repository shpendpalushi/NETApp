{"ast":null,"code":"import { ticks, tickIncrement } from \"d3-array\";\nimport continuous, { copy } from \"./continuous.js\";\nimport { initRange } from \"./init.js\";\nimport tickFormat from \"./tickFormat.js\";\nexport function linearish(scale) {\n  var domain = scale.domain;\n\n  scale.ticks = function (count) {\n    var d = domain();\n    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);\n  };\n\n  scale.tickFormat = function (count, specifier) {\n    var d = domain();\n    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);\n  };\n\n  scale.nice = function (count) {\n    if (count == null) count = 10;\n    var d = domain(),\n        i0 = 0,\n        i1 = d.length - 1,\n        start = d[i0],\n        stop = d[i1],\n        step;\n\n    if (stop < start) {\n      step = start, start = stop, stop = step;\n      step = i0, i0 = i1, i1 = step;\n    }\n\n    step = tickIncrement(start, stop, count);\n\n    if (step > 0) {\n      start = Math.floor(start / step) * step;\n      stop = Math.ceil(stop / step) * step;\n      step = tickIncrement(start, stop, count);\n    } else if (step < 0) {\n      start = Math.ceil(start * step) / step;\n      stop = Math.floor(stop * step) / step;\n      step = tickIncrement(start, stop, count);\n    }\n\n    if (step > 0) {\n      d[i0] = Math.floor(start / step) * step;\n      d[i1] = Math.ceil(stop / step) * step;\n      domain(d);\n    } else if (step < 0) {\n      d[i0] = Math.ceil(start * step) / step;\n      d[i1] = Math.floor(stop * step) / step;\n      domain(d);\n    }\n\n    return scale;\n  };\n\n  return scale;\n}\nexport default function linear() {\n  var scale = continuous();\n\n  scale.copy = function () {\n    return copy(scale, linear());\n  };\n\n  initRange.apply(scale, arguments);\n  return linearish(scale);\n}","map":{"version":3,"sources":["C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/d3-scale/src/linear.js"],"names":["domain","scale","d","ticks","count","tickFormat","i0","i1","start","stop","step","tickIncrement","Math","continuous","copy","linear","initRange","linearish"],"mappings":"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","sourcesContent":["import {ticks, tickIncrement} from \"d3-array\";\r\nimport continuous, {copy} from \"./continuous.js\";\r\nimport {initRange} from \"./init.js\";\r\nimport tickFormat from \"./tickFormat.js\";\r\n\r\nexport function linearish(scale) {\r\n  var domain = scale.domain;\r\n\r\n  scale.ticks = function(count) {\r\n    var d = domain();\r\n    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);\r\n  };\r\n\r\n  scale.tickFormat = function(count, specifier) {\r\n    var d = domain();\r\n    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);\r\n  };\r\n\r\n  scale.nice = function(count) {\r\n    if (count == null) count = 10;\r\n\r\n    var d = domain(),\r\n        i0 = 0,\r\n        i1 = d.length - 1,\r\n        start = d[i0],\r\n        stop = d[i1],\r\n        step;\r\n\r\n    if (stop < start) {\r\n      step = start, start = stop, stop = step;\r\n      step = i0, i0 = i1, i1 = step;\r\n    }\r\n\r\n    step = tickIncrement(start, stop, count);\r\n\r\n    if (step > 0) {\r\n      start = Math.floor(start / step) * step;\r\n      stop = Math.ceil(stop / step) * step;\r\n      step = tickIncrement(start, stop, count);\r\n    } else if (step < 0) {\r\n      start = Math.ceil(start * step) / step;\r\n      stop = Math.floor(stop * step) / step;\r\n      step = tickIncrement(start, stop, count);\r\n    }\r\n\r\n    if (step > 0) {\r\n      d[i0] = Math.floor(start / step) * step;\r\n      d[i1] = Math.ceil(stop / step) * step;\r\n      domain(d);\r\n    } else if (step < 0) {\r\n      d[i0] = Math.ceil(start * step) / step;\r\n      d[i1] = Math.floor(stop * step) / step;\r\n      domain(d);\r\n    }\r\n\r\n    return scale;\r\n  };\r\n\r\n  return scale;\r\n}\r\n\r\nexport default function linear() {\r\n  var scale = continuous();\r\n\r\n  scale.copy = function() {\r\n    return copy(scale, linear());\r\n  };\r\n\r\n  initRange.apply(scale, arguments);\r\n\r\n  return linearish(scale);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}