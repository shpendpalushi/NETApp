{"ast":null,"code":"/**\r\n * DevExtreme (localization/ldml/date.parser.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar escapeRegExp = require(\"../../core/utils/common\").escapeRegExp;\n\nvar FORMAT_TYPES = {\n  3: \"abbreviated\",\n  4: \"wide\",\n  5: \"narrow\"\n};\n\nvar monthRegExpGenerator = function monthRegExpGenerator(count, dateParts) {\n  if (count > 2) {\n    return Object.keys(FORMAT_TYPES).map(function (count) {\n      return [\"format\", \"standalone\"].map(function (type) {\n        return dateParts.getMonthNames(FORMAT_TYPES[count], type).join(\"|\");\n      }).join(\"|\");\n    }).join(\"|\");\n  }\n\n  return \"0?[1-9]|1[012]\";\n};\n\nvar PATTERN_REGEXPS = {\n  y: function y(count) {\n    return \"[0-9]+\";\n  },\n  M: monthRegExpGenerator,\n  L: monthRegExpGenerator,\n  Q: function Q(count, dateParts) {\n    if (count > 2) {\n      return dateParts.getQuarterNames(FORMAT_TYPES[count], \"format\").join(\"|\");\n    }\n\n    return \"0?[1-4]\";\n  },\n  E: function E(count, dateParts) {\n    return \"\\\\D*\";\n  },\n  a: function a(count, dateParts) {\n    return dateParts.getPeriodNames(FORMAT_TYPES[count < 3 ? 3 : count], \"format\").join(\"|\");\n  },\n  d: function d(count) {\n    return \"0?[1-9]|[12][0-9]|3[01]\";\n  },\n  H: function H(count) {\n    return \"0?[0-9]|1[0-9]|2[0-3]\";\n  },\n  h: function h(count) {\n    return \"0?[1-9]|1[012]\";\n  },\n  m: function m(count) {\n    return \"0?[0-9]|[1-5][0-9]\";\n  },\n  s: function s(count) {\n    return \"0?[0-9]|[1-5][0-9]\";\n  },\n  S: function S(count) {\n    return \"[0-9]{1,\" + count + \"}\";\n  }\n};\nvar parseNumber = Number;\n\nvar caseInsensitiveIndexOf = function caseInsensitiveIndexOf(array, value) {\n  return array.map(function (item) {\n    return item.toLowerCase();\n  }).indexOf(value.toLowerCase());\n};\n\nvar monthPatternParser = function monthPatternParser(text, count, dateParts) {\n  if (count > 2) {\n    return [\"format\", \"standalone\"].map(function (type) {\n      return Object.keys(FORMAT_TYPES).map(function (count) {\n        var monthNames = dateParts.getMonthNames(FORMAT_TYPES[count], type);\n        return caseInsensitiveIndexOf(monthNames, text);\n      });\n    }).reduce(function (a, b) {\n      return a.concat(b);\n    }).filter(function (index) {\n      return index >= 0;\n    })[0];\n  }\n\n  return parseNumber(text) - 1;\n};\n\nvar PATTERN_PARSERS = {\n  y: function y(text, count) {\n    var year = parseNumber(text);\n\n    if (2 === count) {\n      return year < 30 ? 2e3 + year : 1900 + year;\n    }\n\n    return year;\n  },\n  M: monthPatternParser,\n  L: monthPatternParser,\n  Q: function Q(text, count, dateParts) {\n    if (count > 2) {\n      return dateParts.getQuarterNames(FORMAT_TYPES[count], \"format\").indexOf(text);\n    }\n\n    return parseNumber(text) - 1;\n  },\n  E: function E(text, count, dateParts) {\n    var dayNames = dateParts.getDayNames(FORMAT_TYPES[count < 3 ? 3 : count], \"format\");\n    return caseInsensitiveIndexOf(dayNames, text);\n  },\n  a: function a(text, count, dateParts) {\n    var periodNames = dateParts.getPeriodNames(FORMAT_TYPES[count < 3 ? 3 : count], \"format\");\n    return caseInsensitiveIndexOf(periodNames, text);\n  },\n  d: parseNumber,\n  H: parseNumber,\n  h: parseNumber,\n  m: parseNumber,\n  s: parseNumber,\n  S: function S(text, count) {\n    count = Math.max(count, 3);\n    text = text.slice(0, 3);\n\n    while (count < 3) {\n      text += \"0\";\n      count++;\n    }\n\n    return parseNumber(text);\n  }\n};\nvar ORDERED_PATTERNS = [\"y\", \"M\", \"d\", \"h\", \"m\", \"s\", \"S\"];\nvar PATTERN_SETTERS = {\n  y: \"setFullYear\",\n  M: \"setMonth\",\n  L: \"setMonth\",\n  a: function a(date, value) {\n    var hours = date.getHours();\n\n    if (!value && 12 === hours) {\n      date.setHours(0);\n    } else {\n      if (value && 12 !== hours) {\n        date.setHours(hours + 12);\n      }\n    }\n  },\n  d: \"setDate\",\n  H: \"setHours\",\n  h: \"setHours\",\n  m: \"setMinutes\",\n  s: \"setSeconds\",\n  S: \"setMilliseconds\"\n};\n\nvar getSameCharCount = function getSameCharCount(text, index) {\n  var char = text[index];\n  var count = 0;\n\n  do {\n    index++;\n    count++;\n  } while (text[index] === char);\n\n  return count;\n};\n\nvar createPattern = function createPattern(char, count) {\n  var result = \"\";\n\n  for (var i = 0; i < count; i++) {\n    result += char;\n  }\n\n  return result;\n};\n\nvar getRegExpInfo = function getRegExpInfo(format, dateParts) {\n  var regexpText = \"\";\n  var stubText = \"\";\n  var isEscaping;\n  var patterns = [];\n\n  var addPreviousStub = function addPreviousStub() {\n    if (stubText) {\n      patterns.push(\"'\" + stubText + \"'\");\n      regexpText += escapeRegExp(stubText) + \")\";\n      stubText = \"\";\n    }\n  };\n\n  for (var i = 0; i < format.length; i++) {\n    var char = format[i];\n    var isEscapeChar = \"'\" === char;\n    var regexpPart = PATTERN_REGEXPS[char];\n\n    if (isEscapeChar) {\n      isEscaping = !isEscaping;\n\n      if (\"'\" !== format[i - 1]) {\n        continue;\n      }\n    }\n\n    if (regexpPart && !isEscaping) {\n      var count = getSameCharCount(format, i);\n      var pattern = createPattern(char, count);\n      addPreviousStub();\n      patterns.push(pattern);\n      regexpText += \"(\" + regexpPart(count, dateParts) + \")\";\n      i += count - 1;\n    } else {\n      if (!stubText) {\n        regexpText += \"(\";\n      }\n\n      stubText += char;\n    }\n  }\n\n  addPreviousStub();\n  return {\n    patterns: patterns,\n    regexp: new RegExp(\"^\" + regexpText + \"$\", \"i\")\n  };\n};\n\nvar getPatternSetters = function getPatternSetters() {\n  return PATTERN_SETTERS;\n};\n\nvar setPatternPart = function setPatternPart(date, pattern, text, dateParts) {\n  var patternChar = pattern[0];\n  var partSetter = PATTERN_SETTERS[patternChar];\n  var partParser = PATTERN_PARSERS[patternChar];\n\n  if (partSetter && partParser) {\n    var value = partParser(text, pattern.length, dateParts);\n\n    if (date[partSetter]) {\n      date[partSetter](value);\n    } else {\n      partSetter(date, value);\n    }\n  }\n};\n\nvar setPatternPartFromNow = function setPatternPartFromNow(date, pattern, now) {\n  var setterName = PATTERN_SETTERS[pattern];\n  var getterName = \"g\" + setterName.substr(1);\n  date[setterName](now[getterName]());\n};\n\nvar getShortPatterns = function getShortPatterns(fullPatterns) {\n  return fullPatterns.map(function (pattern) {\n    if (\"'\" === pattern[0]) {\n      return \"\";\n    } else {\n      return \"H\" === pattern[0] ? \"h\" : pattern[0];\n    }\n  });\n};\n\nvar getMaxOrderedPatternIndex = function getMaxOrderedPatternIndex(patterns) {\n  var indexes = patterns.map(function (pattern) {\n    return ORDERED_PATTERNS.indexOf(pattern);\n  });\n  return Math.max.apply(Math, indexes);\n};\n\nvar getOrderedFormatPatterns = function getOrderedFormatPatterns(formatPatterns) {\n  var otherPatterns = formatPatterns.filter(function (pattern) {\n    return ORDERED_PATTERNS.indexOf(pattern) < 0;\n  });\n  return ORDERED_PATTERNS.concat(otherPatterns);\n};\n\nvar getParser = function getParser(format, dateParts) {\n  var regExpInfo = getRegExpInfo(format, dateParts);\n  return function (text) {\n    var regExpResult = regExpInfo.regexp.exec(text);\n\n    if (regExpResult) {\n      var now = new Date();\n      var date = new Date(now.getFullYear(), 0, 1);\n      var formatPatterns = getShortPatterns(regExpInfo.patterns);\n      var maxPatternIndex = getMaxOrderedPatternIndex(formatPatterns);\n      var orderedFormatPatterns = getOrderedFormatPatterns(formatPatterns);\n      orderedFormatPatterns.forEach(function (pattern, index) {\n        if (!pattern || index < ORDERED_PATTERNS.length && index > maxPatternIndex) {\n          return;\n        }\n\n        var patternIndex = formatPatterns.indexOf(pattern);\n\n        if (patternIndex >= 0) {\n          setPatternPart(date, regExpInfo.patterns[patternIndex], regExpResult[patternIndex + 1], dateParts);\n        } else {\n          setPatternPartFromNow(date, pattern, now);\n        }\n      });\n      return date;\n    }\n\n    return null;\n  };\n};\n\nexports.getParser = getParser;\nexports.getRegExpInfo = getRegExpInfo;\nexports.getPatternSetters = getPatternSetters;","map":{"version":3,"sources":["C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/devextreme/localization/ldml/date.parser.js"],"names":["escapeRegExp","require","FORMAT_TYPES","monthRegExpGenerator","count","dateParts","PATTERN_REGEXPS","y","M","L","Q","E","a","d","H","h","m","s","S","parseNumber","caseInsensitiveIndexOf","item","value","monthPatternParser","monthNames","index","PATTERN_PARSERS","year","dayNames","periodNames","Math","text","ORDERED_PATTERNS","PATTERN_SETTERS","hours","date","getSameCharCount","char","createPattern","result","i","getRegExpInfo","regexpText","stubText","patterns","addPreviousStub","format","isEscapeChar","regexpPart","isEscaping","pattern","regexp","getPatternSetters","setPatternPart","patternChar","partSetter","partParser","setPatternPartFromNow","setterName","getterName","now","getShortPatterns","getMaxOrderedPatternIndex","indexes","getOrderedFormatPatterns","otherPatterns","getParser","regExpInfo","regExpResult","formatPatterns","maxPatternIndex","orderedFormatPatterns","patternIndex","exports"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (localization/ldml/date.parser.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nvar escapeRegExp = require(\"../../core/utils/common\").escapeRegExp;\r\nvar FORMAT_TYPES = {\r\n    3: \"abbreviated\",\r\n    4: \"wide\",\r\n    5: \"narrow\"\r\n};\r\nvar monthRegExpGenerator = function(count, dateParts) {\r\n    if (count > 2) {\r\n        return Object.keys(FORMAT_TYPES).map(function(count) {\r\n            return [\"format\", \"standalone\"].map(function(type) {\r\n                return dateParts.getMonthNames(FORMAT_TYPES[count], type).join(\"|\")\r\n            }).join(\"|\")\r\n        }).join(\"|\")\r\n    }\r\n    return \"0?[1-9]|1[012]\"\r\n};\r\nvar PATTERN_REGEXPS = {\r\n    y: function(count) {\r\n        return \"[0-9]+\"\r\n    },\r\n    M: monthRegExpGenerator,\r\n    L: monthRegExpGenerator,\r\n    Q: function(count, dateParts) {\r\n        if (count > 2) {\r\n            return dateParts.getQuarterNames(FORMAT_TYPES[count], \"format\").join(\"|\")\r\n        }\r\n        return \"0?[1-4]\"\r\n    },\r\n    E: function(count, dateParts) {\r\n        return \"\\\\D*\"\r\n    },\r\n    a: function(count, dateParts) {\r\n        return dateParts.getPeriodNames(FORMAT_TYPES[count < 3 ? 3 : count], \"format\").join(\"|\")\r\n    },\r\n    d: function(count) {\r\n        return \"0?[1-9]|[12][0-9]|3[01]\"\r\n    },\r\n    H: function(count) {\r\n        return \"0?[0-9]|1[0-9]|2[0-3]\"\r\n    },\r\n    h: function(count) {\r\n        return \"0?[1-9]|1[012]\"\r\n    },\r\n    m: function(count) {\r\n        return \"0?[0-9]|[1-5][0-9]\"\r\n    },\r\n    s: function(count) {\r\n        return \"0?[0-9]|[1-5][0-9]\"\r\n    },\r\n    S: function(count) {\r\n        return \"[0-9]{1,\" + count + \"}\"\r\n    }\r\n};\r\nvar parseNumber = Number;\r\nvar caseInsensitiveIndexOf = function(array, value) {\r\n    return array.map(function(item) {\r\n        return item.toLowerCase()\r\n    }).indexOf(value.toLowerCase())\r\n};\r\nvar monthPatternParser = function(text, count, dateParts) {\r\n    if (count > 2) {\r\n        return [\"format\", \"standalone\"].map(function(type) {\r\n            return Object.keys(FORMAT_TYPES).map(function(count) {\r\n                var monthNames = dateParts.getMonthNames(FORMAT_TYPES[count], type);\r\n                return caseInsensitiveIndexOf(monthNames, text)\r\n            })\r\n        }).reduce(function(a, b) {\r\n            return a.concat(b)\r\n        }).filter(function(index) {\r\n            return index >= 0\r\n        })[0]\r\n    }\r\n    return parseNumber(text) - 1\r\n};\r\nvar PATTERN_PARSERS = {\r\n    y: function(text, count) {\r\n        var year = parseNumber(text);\r\n        if (2 === count) {\r\n            return year < 30 ? 2e3 + year : 1900 + year\r\n        }\r\n        return year\r\n    },\r\n    M: monthPatternParser,\r\n    L: monthPatternParser,\r\n    Q: function(text, count, dateParts) {\r\n        if (count > 2) {\r\n            return dateParts.getQuarterNames(FORMAT_TYPES[count], \"format\").indexOf(text)\r\n        }\r\n        return parseNumber(text) - 1\r\n    },\r\n    E: function(text, count, dateParts) {\r\n        var dayNames = dateParts.getDayNames(FORMAT_TYPES[count < 3 ? 3 : count], \"format\");\r\n        return caseInsensitiveIndexOf(dayNames, text)\r\n    },\r\n    a: function(text, count, dateParts) {\r\n        var periodNames = dateParts.getPeriodNames(FORMAT_TYPES[count < 3 ? 3 : count], \"format\");\r\n        return caseInsensitiveIndexOf(periodNames, text)\r\n    },\r\n    d: parseNumber,\r\n    H: parseNumber,\r\n    h: parseNumber,\r\n    m: parseNumber,\r\n    s: parseNumber,\r\n    S: function(text, count) {\r\n        count = Math.max(count, 3);\r\n        text = text.slice(0, 3);\r\n        while (count < 3) {\r\n            text += \"0\";\r\n            count++\r\n        }\r\n        return parseNumber(text)\r\n    }\r\n};\r\nvar ORDERED_PATTERNS = [\"y\", \"M\", \"d\", \"h\", \"m\", \"s\", \"S\"];\r\nvar PATTERN_SETTERS = {\r\n    y: \"setFullYear\",\r\n    M: \"setMonth\",\r\n    L: \"setMonth\",\r\n    a: function(date, value) {\r\n        var hours = date.getHours();\r\n        if (!value && 12 === hours) {\r\n            date.setHours(0)\r\n        } else {\r\n            if (value && 12 !== hours) {\r\n                date.setHours(hours + 12)\r\n            }\r\n        }\r\n    },\r\n    d: \"setDate\",\r\n    H: \"setHours\",\r\n    h: \"setHours\",\r\n    m: \"setMinutes\",\r\n    s: \"setSeconds\",\r\n    S: \"setMilliseconds\"\r\n};\r\nvar getSameCharCount = function(text, index) {\r\n    var char = text[index];\r\n    var count = 0;\r\n    do {\r\n        index++;\r\n        count++\r\n    } while (text[index] === char);\r\n    return count\r\n};\r\nvar createPattern = function(char, count) {\r\n    var result = \"\";\r\n    for (var i = 0; i < count; i++) {\r\n        result += char\r\n    }\r\n    return result\r\n};\r\nvar getRegExpInfo = function(format, dateParts) {\r\n    var regexpText = \"\";\r\n    var stubText = \"\";\r\n    var isEscaping;\r\n    var patterns = [];\r\n    var addPreviousStub = function() {\r\n        if (stubText) {\r\n            patterns.push(\"'\" + stubText + \"'\");\r\n            regexpText += escapeRegExp(stubText) + \")\";\r\n            stubText = \"\"\r\n        }\r\n    };\r\n    for (var i = 0; i < format.length; i++) {\r\n        var char = format[i];\r\n        var isEscapeChar = \"'\" === char;\r\n        var regexpPart = PATTERN_REGEXPS[char];\r\n        if (isEscapeChar) {\r\n            isEscaping = !isEscaping;\r\n            if (\"'\" !== format[i - 1]) {\r\n                continue\r\n            }\r\n        }\r\n        if (regexpPart && !isEscaping) {\r\n            var count = getSameCharCount(format, i);\r\n            var pattern = createPattern(char, count);\r\n            addPreviousStub();\r\n            patterns.push(pattern);\r\n            regexpText += \"(\" + regexpPart(count, dateParts) + \")\";\r\n            i += count - 1\r\n        } else {\r\n            if (!stubText) {\r\n                regexpText += \"(\"\r\n            }\r\n            stubText += char\r\n        }\r\n    }\r\n    addPreviousStub();\r\n    return {\r\n        patterns: patterns,\r\n        regexp: new RegExp(\"^\" + regexpText + \"$\", \"i\")\r\n    }\r\n};\r\nvar getPatternSetters = function() {\r\n    return PATTERN_SETTERS\r\n};\r\nvar setPatternPart = function(date, pattern, text, dateParts) {\r\n    var patternChar = pattern[0];\r\n    var partSetter = PATTERN_SETTERS[patternChar];\r\n    var partParser = PATTERN_PARSERS[patternChar];\r\n    if (partSetter && partParser) {\r\n        var value = partParser(text, pattern.length, dateParts);\r\n        if (date[partSetter]) {\r\n            date[partSetter](value)\r\n        } else {\r\n            partSetter(date, value)\r\n        }\r\n    }\r\n};\r\nvar setPatternPartFromNow = function(date, pattern, now) {\r\n    var setterName = PATTERN_SETTERS[pattern];\r\n    var getterName = \"g\" + setterName.substr(1);\r\n    date[setterName](now[getterName]())\r\n};\r\nvar getShortPatterns = function(fullPatterns) {\r\n    return fullPatterns.map(function(pattern) {\r\n        if (\"'\" === pattern[0]) {\r\n            return \"\"\r\n        } else {\r\n            return \"H\" === pattern[0] ? \"h\" : pattern[0]\r\n        }\r\n    })\r\n};\r\nvar getMaxOrderedPatternIndex = function(patterns) {\r\n    var indexes = patterns.map(function(pattern) {\r\n        return ORDERED_PATTERNS.indexOf(pattern)\r\n    });\r\n    return Math.max.apply(Math, indexes)\r\n};\r\nvar getOrderedFormatPatterns = function(formatPatterns) {\r\n    var otherPatterns = formatPatterns.filter(function(pattern) {\r\n        return ORDERED_PATTERNS.indexOf(pattern) < 0\r\n    });\r\n    return ORDERED_PATTERNS.concat(otherPatterns)\r\n};\r\nvar getParser = function(format, dateParts) {\r\n    var regExpInfo = getRegExpInfo(format, dateParts);\r\n    return function(text) {\r\n        var regExpResult = regExpInfo.regexp.exec(text);\r\n        if (regExpResult) {\r\n            var now = new Date;\r\n            var date = new Date(now.getFullYear(), 0, 1);\r\n            var formatPatterns = getShortPatterns(regExpInfo.patterns);\r\n            var maxPatternIndex = getMaxOrderedPatternIndex(formatPatterns);\r\n            var orderedFormatPatterns = getOrderedFormatPatterns(formatPatterns);\r\n            orderedFormatPatterns.forEach(function(pattern, index) {\r\n                if (!pattern || index < ORDERED_PATTERNS.length && index > maxPatternIndex) {\r\n                    return\r\n                }\r\n                var patternIndex = formatPatterns.indexOf(pattern);\r\n                if (patternIndex >= 0) {\r\n                    setPatternPart(date, regExpInfo.patterns[patternIndex], regExpResult[patternIndex + 1], dateParts)\r\n                } else {\r\n                    setPatternPartFromNow(date, pattern, now)\r\n                }\r\n            });\r\n            return date\r\n        }\r\n        return null\r\n    }\r\n};\r\nexports.getParser = getParser;\r\nexports.getRegExpInfo = getRegExpInfo;\r\nexports.getPatternSetters = getPatternSetters;\r\n"]},"metadata":{},"sourceType":"module"}