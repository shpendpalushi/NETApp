{"ast":null,"code":"import _classCallCheck from \"C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Subject } from './Subject';\nimport { queue } from './scheduler/queue';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nexport var ReplaySubject = /*#__PURE__*/function (_Subject) {\n  _inherits(ReplaySubject, _Subject);\n\n  var _super = _createSuper(ReplaySubject);\n\n  function ReplaySubject() {\n    var _this;\n\n    var bufferSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.POSITIVE_INFINITY;\n    var windowTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.POSITIVE_INFINITY;\n    var scheduler = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, ReplaySubject);\n\n    _this = _super.call(this);\n    _this.scheduler = scheduler;\n    _this._events = [];\n    _this._infiniteTimeWindow = false;\n    _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    _this._windowTime = windowTime < 1 ? 1 : windowTime;\n\n    if (windowTime === Number.POSITIVE_INFINITY) {\n      _this._infiniteTimeWindow = true;\n      _this.next = _this.nextInfiniteTimeWindow;\n    } else {\n      _this.next = _this.nextTimeWindow;\n    }\n\n    return _this;\n  }\n\n  _createClass(ReplaySubject, [{\n    key: \"nextInfiniteTimeWindow\",\n    value: function nextInfiniteTimeWindow(value) {\n      var _events = this._events;\n\n      _events.push(value);\n\n      if (_events.length > this._bufferSize) {\n        _events.shift();\n      }\n\n      _get(_getPrototypeOf(ReplaySubject.prototype), \"next\", this).call(this, value);\n    }\n  }, {\n    key: \"nextTimeWindow\",\n    value: function nextTimeWindow(value) {\n      this._events.push(new ReplayEvent(this._getNow(), value));\n\n      this._trimBufferThenGetEvents();\n\n      _get(_getPrototypeOf(ReplaySubject.prototype), \"next\", this).call(this, value);\n    }\n  }, {\n    key: \"_subscribe\",\n    value: function _subscribe(subscriber) {\n      var _infiniteTimeWindow = this._infiniteTimeWindow;\n\n      var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n\n      var scheduler = this.scheduler;\n      var len = _events.length;\n      var subscription;\n\n      if (this.closed) {\n        throw new ObjectUnsubscribedError();\n      } else if (this.isStopped || this.hasError) {\n        subscription = Subscription.EMPTY;\n      } else {\n        this.observers.push(subscriber);\n        subscription = new SubjectSubscription(this, subscriber);\n      }\n\n      if (scheduler) {\n        subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n      }\n\n      if (_infiniteTimeWindow) {\n        for (var i = 0; i < len && !subscriber.closed; i++) {\n          subscriber.next(_events[i]);\n        }\n      } else {\n        for (var _i = 0; _i < len && !subscriber.closed; _i++) {\n          subscriber.next(_events[_i].value);\n        }\n      }\n\n      if (this.hasError) {\n        subscriber.error(this.thrownError);\n      } else if (this.isStopped) {\n        subscriber.complete();\n      }\n\n      return subscription;\n    }\n  }, {\n    key: \"_getNow\",\n    value: function _getNow() {\n      return (this.scheduler || queue).now();\n    }\n  }, {\n    key: \"_trimBufferThenGetEvents\",\n    value: function _trimBufferThenGetEvents() {\n      var now = this._getNow();\n\n      var _bufferSize = this._bufferSize;\n      var _windowTime = this._windowTime;\n      var _events = this._events;\n      var eventsCount = _events.length;\n      var spliceCount = 0;\n\n      while (spliceCount < eventsCount) {\n        if (now - _events[spliceCount].time < _windowTime) {\n          break;\n        }\n\n        spliceCount++;\n      }\n\n      if (eventsCount > _bufferSize) {\n        spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n      }\n\n      if (spliceCount > 0) {\n        _events.splice(0, spliceCount);\n      }\n\n      return _events;\n    }\n  }]);\n\n  return ReplaySubject;\n}(Subject);\n\nvar ReplayEvent = function ReplayEvent(time, value) {\n  _classCallCheck(this, ReplayEvent);\n\n  this.time = time;\n  this.value = value;\n};","map":{"version":3,"sources":["../../src/internal/ReplaySubject.ts"],"names":[],"mappings":"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","sourcesContent":["import { Subject } from './Subject';\r\nimport { queue } from './scheduler/queue';\r\nimport { Subscription } from './Subscription';\r\nimport { ObserveOnSubscriber } from './operators/observeOn';\r\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\r\nimport { SubjectSubscription } from './SubjectSubscription';\r\nexport class ReplaySubject extends Subject {\r\n    constructor(bufferSize = Number.POSITIVE_INFINITY, windowTime = Number.POSITIVE_INFINITY, scheduler) {\r\n        super();\r\n        this.scheduler = scheduler;\r\n        this._events = [];\r\n        this._infiniteTimeWindow = false;\r\n        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\r\n        this._windowTime = windowTime < 1 ? 1 : windowTime;\r\n        if (windowTime === Number.POSITIVE_INFINITY) {\r\n            this._infiniteTimeWindow = true;\r\n            this.next = this.nextInfiniteTimeWindow;\r\n        }\r\n        else {\r\n            this.next = this.nextTimeWindow;\r\n        }\r\n    }\r\n    nextInfiniteTimeWindow(value) {\r\n        const _events = this._events;\r\n        _events.push(value);\r\n        if (_events.length > this._bufferSize) {\r\n            _events.shift();\r\n        }\r\n        super.next(value);\r\n    }\r\n    nextTimeWindow(value) {\r\n        this._events.push(new ReplayEvent(this._getNow(), value));\r\n        this._trimBufferThenGetEvents();\r\n        super.next(value);\r\n    }\r\n    _subscribe(subscriber) {\r\n        const _infiniteTimeWindow = this._infiniteTimeWindow;\r\n        const _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\r\n        const scheduler = this.scheduler;\r\n        const len = _events.length;\r\n        let subscription;\r\n        if (this.closed) {\r\n            throw new ObjectUnsubscribedError();\r\n        }\r\n        else if (this.isStopped || this.hasError) {\r\n            subscription = Subscription.EMPTY;\r\n        }\r\n        else {\r\n            this.observers.push(subscriber);\r\n            subscription = new SubjectSubscription(this, subscriber);\r\n        }\r\n        if (scheduler) {\r\n            subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\r\n        }\r\n        if (_infiniteTimeWindow) {\r\n            for (let i = 0; i < len && !subscriber.closed; i++) {\r\n                subscriber.next(_events[i]);\r\n            }\r\n        }\r\n        else {\r\n            for (let i = 0; i < len && !subscriber.closed; i++) {\r\n                subscriber.next(_events[i].value);\r\n            }\r\n        }\r\n        if (this.hasError) {\r\n            subscriber.error(this.thrownError);\r\n        }\r\n        else if (this.isStopped) {\r\n            subscriber.complete();\r\n        }\r\n        return subscription;\r\n    }\r\n    _getNow() {\r\n        return (this.scheduler || queue).now();\r\n    }\r\n    _trimBufferThenGetEvents() {\r\n        const now = this._getNow();\r\n        const _bufferSize = this._bufferSize;\r\n        const _windowTime = this._windowTime;\r\n        const _events = this._events;\r\n        const eventsCount = _events.length;\r\n        let spliceCount = 0;\r\n        while (spliceCount < eventsCount) {\r\n            if ((now - _events[spliceCount].time) < _windowTime) {\r\n                break;\r\n            }\r\n            spliceCount++;\r\n        }\r\n        if (eventsCount > _bufferSize) {\r\n            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\r\n        }\r\n        if (spliceCount > 0) {\r\n            _events.splice(0, spliceCount);\r\n        }\r\n        return _events;\r\n    }\r\n}\r\nclass ReplayEvent {\r\n    constructor(time, value) {\r\n        this.time = time;\r\n        this.value = value;\r\n    }\r\n}\r\n//# sourceMappingURL=ReplaySubject.js.map"]},"metadata":{},"sourceType":"module"}