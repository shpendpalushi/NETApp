{"ast":null,"code":"import exponent from \"./exponent.js\";\nimport formatGroup from \"./formatGroup.js\";\nimport formatNumerals from \"./formatNumerals.js\";\nimport formatSpecifier from \"./formatSpecifier.js\";\nimport formatTrim from \"./formatTrim.js\";\nimport formatTypes from \"./formatTypes.js\";\nimport { prefixExponent } from \"./formatPrefixAuto.js\";\nimport identity from \"./identity.js\";\nvar map = Array.prototype.map,\n    prefixes = [\"y\", \"z\", \"a\", \"f\", \"p\", \"n\", \"µ\", \"m\", \"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\"];\nexport default function (locale) {\n  var group = locale.grouping === undefined || locale.thousands === undefined ? identity : formatGroup(map.call(locale.grouping, Number), locale.thousands + \"\"),\n      currencyPrefix = locale.currency === undefined ? \"\" : locale.currency[0] + \"\",\n      currencySuffix = locale.currency === undefined ? \"\" : locale.currency[1] + \"\",\n      decimal = locale.decimal === undefined ? \".\" : locale.decimal + \"\",\n      numerals = locale.numerals === undefined ? identity : formatNumerals(map.call(locale.numerals, String)),\n      percent = locale.percent === undefined ? \"%\" : locale.percent + \"\",\n      minus = locale.minus === undefined ? \"-\" : locale.minus + \"\",\n      nan = locale.nan === undefined ? \"NaN\" : locale.nan + \"\";\n\n  function newFormat(specifier) {\n    specifier = formatSpecifier(specifier);\n    var fill = specifier.fill,\n        align = specifier.align,\n        sign = specifier.sign,\n        symbol = specifier.symbol,\n        zero = specifier.zero,\n        width = specifier.width,\n        comma = specifier.comma,\n        precision = specifier.precision,\n        trim = specifier.trim,\n        type = specifier.type; // The \"n\" type is an alias for \",g\".\n\n    if (type === \"n\") comma = true, type = \"g\"; // The \"\" type, and any invalid type, is an alias for \".12~g\".\n    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = \"g\"; // If zero fill is specified, padding goes after sign and before digits.\n\n    if (zero || fill === \"0\" && align === \"=\") zero = true, fill = \"0\", align = \"=\"; // Compute the prefix and suffix.\n    // For SI-prefix, the suffix is lazily computed.\n\n    var prefix = symbol === \"$\" ? currencyPrefix : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n        suffix = symbol === \"$\" ? currencySuffix : /[%p]/.test(type) ? percent : \"\"; // What format function should we use?\n    // Is this an integer type?\n    // Can this type generate exponential notation?\n\n    var formatType = formatTypes[type],\n        maybeSuffix = /[defgprs%]/.test(type); // Set the default precision if not specified,\n    // or clamp the specified precision to the supported range.\n    // For significant precision, it must be in [1, 21].\n    // For fixed precision, it must be in [0, 20].\n\n    precision = precision === undefined ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));\n\n    function format(value) {\n      var valuePrefix = prefix,\n          valueSuffix = suffix,\n          i,\n          n,\n          c;\n\n      if (type === \"c\") {\n        valueSuffix = formatType(value) + valueSuffix;\n        value = \"\";\n      } else {\n        value = +value; // Determine the sign. -0 is not less than 0, but 1 / -0 is!\n\n        var valueNegative = value < 0 || 1 / value < 0; // Perform the initial formatting.\n\n        value = isNaN(value) ? nan : formatType(Math.abs(value), precision); // Trim insignificant zeros.\n\n        if (trim) value = formatTrim(value); // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.\n\n        if (valueNegative && +value === 0 && sign !== \"+\") valueNegative = false; // Compute the prefix and suffix.\n\n        valuePrefix = (valueNegative ? sign === \"(\" ? sign : minus : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n        valueSuffix = (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + valueSuffix + (valueNegative && sign === \"(\" ? \")\" : \"\"); // Break the formatted value into the integer “value” part that can be\n        // grouped, and fractional or exponential “suffix” part that is not.\n\n        if (maybeSuffix) {\n          i = -1, n = value.length;\n\n          while (++i < n) {\n            if (c = value.charCodeAt(i), 48 > c || c > 57) {\n              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n              value = value.slice(0, i);\n              break;\n            }\n          }\n        }\n      } // If the fill character is not \"0\", grouping is applied before padding.\n\n\n      if (comma && !zero) value = group(value, Infinity); // Compute the padding.\n\n      var length = valuePrefix.length + value.length + valueSuffix.length,\n          padding = length < width ? new Array(width - length + 1).join(fill) : \"\"; // If the fill character is \"0\", grouping is applied after padding.\n\n      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\"; // Reconstruct the final output based on the desired alignment.\n\n      switch (align) {\n        case \"<\":\n          value = valuePrefix + value + valueSuffix + padding;\n          break;\n\n        case \"=\":\n          value = valuePrefix + padding + value + valueSuffix;\n          break;\n\n        case \"^\":\n          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);\n          break;\n\n        default:\n          value = padding + valuePrefix + value + valueSuffix;\n          break;\n      }\n\n      return numerals(value);\n    }\n\n    format.toString = function () {\n      return specifier + \"\";\n    };\n\n    return format;\n  }\n\n  function formatPrefix(specifier, value) {\n    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\n        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,\n        k = Math.pow(10, -e),\n        prefix = prefixes[8 + e / 3];\n    return function (value) {\n      return f(k * value) + prefix;\n    };\n  }\n\n  return {\n    format: newFormat,\n    formatPrefix: formatPrefix\n  };\n}","map":{"version":3,"sources":["C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/d3-format/src/locale.js"],"names":["map","Array","prefixes","group","locale","formatGroup","currencyPrefix","currencySuffix","decimal","numerals","formatNumerals","percent","minus","nan","specifier","formatSpecifier","fill","align","sign","symbol","zero","width","comma","precision","trim","type","formatTypes","prefix","suffix","formatType","maybeSuffix","Math","valuePrefix","valueSuffix","value","valueNegative","isNaN","formatTrim","prefixExponent","i","n","c","length","padding","format","f","newFormat","e","exponent","k","formatPrefix"],"mappings":"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","sourcesContent":["import exponent from \"./exponent.js\";\r\nimport formatGroup from \"./formatGroup.js\";\r\nimport formatNumerals from \"./formatNumerals.js\";\r\nimport formatSpecifier from \"./formatSpecifier.js\";\r\nimport formatTrim from \"./formatTrim.js\";\r\nimport formatTypes from \"./formatTypes.js\";\r\nimport {prefixExponent} from \"./formatPrefixAuto.js\";\r\nimport identity from \"./identity.js\";\r\n\r\nvar map = Array.prototype.map,\r\n    prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"µ\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\r\n\r\nexport default function(locale) {\r\n  var group = locale.grouping === undefined || locale.thousands === undefined ? identity : formatGroup(map.call(locale.grouping, Number), locale.thousands + \"\"),\r\n      currencyPrefix = locale.currency === undefined ? \"\" : locale.currency[0] + \"\",\r\n      currencySuffix = locale.currency === undefined ? \"\" : locale.currency[1] + \"\",\r\n      decimal = locale.decimal === undefined ? \".\" : locale.decimal + \"\",\r\n      numerals = locale.numerals === undefined ? identity : formatNumerals(map.call(locale.numerals, String)),\r\n      percent = locale.percent === undefined ? \"%\" : locale.percent + \"\",\r\n      minus = locale.minus === undefined ? \"-\" : locale.minus + \"\",\r\n      nan = locale.nan === undefined ? \"NaN\" : locale.nan + \"\";\r\n\r\n  function newFormat(specifier) {\r\n    specifier = formatSpecifier(specifier);\r\n\r\n    var fill = specifier.fill,\r\n        align = specifier.align,\r\n        sign = specifier.sign,\r\n        symbol = specifier.symbol,\r\n        zero = specifier.zero,\r\n        width = specifier.width,\r\n        comma = specifier.comma,\r\n        precision = specifier.precision,\r\n        trim = specifier.trim,\r\n        type = specifier.type;\r\n\r\n    // The \"n\" type is an alias for \",g\".\r\n    if (type === \"n\") comma = true, type = \"g\";\r\n\r\n    // The \"\" type, and any invalid type, is an alias for \".12~g\".\r\n    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = \"g\";\r\n\r\n    // If zero fill is specified, padding goes after sign and before digits.\r\n    if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\r\n\r\n    // Compute the prefix and suffix.\r\n    // For SI-prefix, the suffix is lazily computed.\r\n    var prefix = symbol === \"$\" ? currencyPrefix : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\r\n        suffix = symbol === \"$\" ? currencySuffix : /[%p]/.test(type) ? percent : \"\";\r\n\r\n    // What format function should we use?\r\n    // Is this an integer type?\r\n    // Can this type generate exponential notation?\r\n    var formatType = formatTypes[type],\r\n        maybeSuffix = /[defgprs%]/.test(type);\r\n\r\n    // Set the default precision if not specified,\r\n    // or clamp the specified precision to the supported range.\r\n    // For significant precision, it must be in [1, 21].\r\n    // For fixed precision, it must be in [0, 20].\r\n    precision = precision === undefined ? 6\r\n        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\r\n        : Math.max(0, Math.min(20, precision));\r\n\r\n    function format(value) {\r\n      var valuePrefix = prefix,\r\n          valueSuffix = suffix,\r\n          i, n, c;\r\n\r\n      if (type === \"c\") {\r\n        valueSuffix = formatType(value) + valueSuffix;\r\n        value = \"\";\r\n      } else {\r\n        value = +value;\r\n\r\n        // Determine the sign. -0 is not less than 0, but 1 / -0 is!\r\n        var valueNegative = value < 0 || 1 / value < 0;\r\n\r\n        // Perform the initial formatting.\r\n        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);\r\n\r\n        // Trim insignificant zeros.\r\n        if (trim) value = formatTrim(value);\r\n\r\n        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.\r\n        if (valueNegative && +value === 0 && sign !== \"+\") valueNegative = false;\r\n\r\n        // Compute the prefix and suffix.\r\n        valuePrefix = (valueNegative ? (sign === \"(\" ? sign : minus) : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\r\n        valueSuffix = (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + valueSuffix + (valueNegative && sign === \"(\" ? \")\" : \"\");\r\n\r\n        // Break the formatted value into the integer “value” part that can be\r\n        // grouped, and fractional or exponential “suffix” part that is not.\r\n        if (maybeSuffix) {\r\n          i = -1, n = value.length;\r\n          while (++i < n) {\r\n            if (c = value.charCodeAt(i), 48 > c || c > 57) {\r\n              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\r\n              value = value.slice(0, i);\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // If the fill character is not \"0\", grouping is applied before padding.\r\n      if (comma && !zero) value = group(value, Infinity);\r\n\r\n      // Compute the padding.\r\n      var length = valuePrefix.length + value.length + valueSuffix.length,\r\n          padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\r\n\r\n      // If the fill character is \"0\", grouping is applied after padding.\r\n      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\r\n\r\n      // Reconstruct the final output based on the desired alignment.\r\n      switch (align) {\r\n        case \"<\": value = valuePrefix + value + valueSuffix + padding; break;\r\n        case \"=\": value = valuePrefix + padding + value + valueSuffix; break;\r\n        case \"^\": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;\r\n        default: value = padding + valuePrefix + value + valueSuffix; break;\r\n      }\r\n\r\n      return numerals(value);\r\n    }\r\n\r\n    format.toString = function() {\r\n      return specifier + \"\";\r\n    };\r\n\r\n    return format;\r\n  }\r\n\r\n  function formatPrefix(specifier, value) {\r\n    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\r\n        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,\r\n        k = Math.pow(10, -e),\r\n        prefix = prefixes[8 + e / 3];\r\n    return function(value) {\r\n      return f(k * value) + prefix;\r\n    };\r\n  }\r\n\r\n  return {\r\n    format: newFormat,\r\n    formatPrefix: formatPrefix\r\n  };\r\n}\r\n"]},"metadata":{},"sourceType":"module"}