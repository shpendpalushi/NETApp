{"ast":null,"code":"/**\r\n * DevExtreme (ui/pivot_grid/xmla_store/xmla_store.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar _renderer = require(\"../../../core/renderer\");\n\nvar _renderer2 = _interopRequireDefault(_renderer);\n\nvar _window = require(\"../../../core/utils/window\");\n\nvar _class = require(\"../../../core/class\");\n\nvar _class2 = _interopRequireDefault(_class);\n\nvar _string = require(\"../../../core/utils/string\");\n\nvar _errors = require(\"../../../data/errors\");\n\nvar _common = require(\"../../../core/utils/common\");\n\nvar _extend = require(\"../../../core/utils/extend\");\n\nvar _type = require(\"../../../core/utils/type\");\n\nvar _iterator = require(\"../../../core/utils/iterator\");\n\nvar _array = require(\"../../../core/utils/array\");\n\nvar _uiPivot_grid = require(\"../ui.pivot_grid.utils\");\n\nvar _deferred = require(\"../../../core/utils/deferred\");\n\nvar _language_codes = require(\"../../../localization/language_codes\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || \"[object Arguments]\" === Object.prototype.toString.call(iter)) {\n    return Array.from(iter);\n  }\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nvar window = (0, _window.getWindow)();\nexports.XmlaStore = _class2.default.inherit(function () {\n  var discover = '<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\"><Body><Discover xmlns=\"urn:schemas-microsoft-com:xml-analysis\"><RequestType>{2}</RequestType><Restrictions><RestrictionList><CATALOG_NAME>{0}</CATALOG_NAME><CUBE_NAME>{1}</CUBE_NAME></RestrictionList></Restrictions><Properties><PropertyList><Catalog>{0}</Catalog>{3}</PropertyList></Properties></Discover></Body></Envelope>';\n  var execute = '<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\"><Body><Execute xmlns=\"urn:schemas-microsoft-com:xml-analysis\"><Command><Statement>{0}</Statement></Command><Properties><PropertyList><Catalog>{1}</Catalog><ShowHiddenCubes>True</ShowHiddenCubes><SspropInitAppName>Microsoft SQL Server Management Studio</SspropInitAppName><Timeout>3600</Timeout>{2}</PropertyList></Properties></Execute></Body></Envelope>';\n  var mdx = \"SELECT {2} FROM {0} {1} CELL PROPERTIES VALUE, FORMAT_STRING, LANGUAGE, BACK_COLOR, FORE_COLOR, FONT_FLAGS\";\n  var mdxFilterSelect = \"(SELECT {0} FROM {1})\";\n  var mdxSubset = \"Subset({0}, {1}, {2})\";\n  var mdxOrder = \"Order({0}, {1}, {2})\";\n  var mdxWith = \"{0} {1} as {2}\";\n  var mdxSlice = \"WHERE ({0})\";\n  var mdxNonEmpty = \"NonEmpty({0}, {1})\";\n  var mdxAxis = \"{0} DIMENSION PROPERTIES PARENT_UNIQUE_NAME,HIERARCHY_UNIQUE_NAME, MEMBER_VALUE ON {1}\";\n  var mdxCrossJoin = \"CrossJoin({0})\";\n  var mdxSet = \"{{0}}\";\n  var MEASURE_DEMENSION_KEY = \"DX_MEASURES\";\n  var MD_DIMTYPE_MEASURE = \"2\";\n\n  function execXMLA(requestOptions, data) {\n    var deferred = new _deferred.Deferred();\n    var beforeSend = requestOptions.beforeSend;\n    var ajaxSettings = {\n      url: requestOptions.url,\n      dataType: \"text\",\n      data: data,\n      headers: {\n        \"Content-Type\": \"text/xml\"\n      },\n      xhrFields: {},\n      method: \"POST\"\n    };\n\n    if ((0, _type.isFunction)(beforeSend)) {\n      beforeSend(ajaxSettings);\n    }\n\n    (0, _uiPivot_grid.sendRequest)(ajaxSettings).fail(function () {\n      deferred.reject(arguments);\n    }).done(function (text) {\n      var parser = new window.DOMParser();\n      var xml;\n\n      try {\n        try {\n          xml = parser.parseFromString(text, \"text/xml\");\n        } catch (e) {\n          xml = void 0;\n        }\n\n        if (!xml || xml.getElementsByTagName(\"parsererror\").length || 0 === xml.childNodes.length) {\n          throw new _errors.errors.Error(\"E4023\", text);\n        }\n      } catch (e) {\n        deferred.reject({\n          statusText: e.message,\n          stack: e.stack,\n          responseText: text\n        });\n      }\n\n      deferred.resolve(xml);\n    });\n    return deferred;\n  }\n\n  function getLocaleIdProperty() {\n    var languageId = (0, _language_codes.getLanguageId)();\n\n    if (void 0 !== languageId) {\n      return (0, _string.format)(\"<LocaleIdentifier>{0}</LocaleIdentifier>\", languageId);\n    }\n\n    return \"\";\n  }\n\n  function mdxDescendants(level, levelMember, nextLevel) {\n    var memberExpression = levelMember ? levelMember : level;\n    return \"Descendants({\" + memberExpression + \"}, \" + nextLevel + \", SELF_AND_BEFORE)\";\n  }\n\n  function getAllMember(dimension) {\n    return (dimension.hierarchyName || dimension.dataField) + \".[All]\";\n  }\n\n  function getAllMembers(field) {\n    var result = field.dataField + \".allMembers\";\n    var searchValue = field.searchValue;\n\n    if (searchValue) {\n      searchValue = searchValue.replace(/'/g, \"''\");\n      result = \"Filter(\" + result + \", instr(\" + field.dataField + \".currentmember.member_caption,'\" + searchValue + \"') > 0)\";\n    }\n\n    return result;\n  }\n\n  function crossJoinElements(elements) {\n    var elementsString = elements.join(\",\");\n    return elements.length > 1 ? (0, _string.format)(mdxCrossJoin, elementsString) : elementsString;\n  }\n\n  function union(elements) {\n    var elementsString = elements.join(\",\");\n    return elements.length > 1 ? \"Union(\" + elementsString + \")\" : elementsString;\n  }\n\n  function generateCrossJoin(path, expandLevel, expandAllCount, expandIndex, slicePath, options, axisName, take) {\n    var crossJoinArgs = [];\n    var dimensions = options[axisName];\n    var dataField;\n    var allMember;\n    var fields = [];\n    var hierarchyName;\n    var arg;\n    var prevDimension;\n    var prevHierarchyName;\n    var isLastDimensionInGroup;\n    var isFirstDimensionInGroup;\n    var expandAllIndex;\n    var field;\n    var member;\n    var i;\n\n    for (i = expandIndex; i <= expandLevel; i++) {\n      field = dimensions[i];\n      dataField = field.dataField;\n      prevHierarchyName = dimensions[i - 1] && dimensions[i - 1].hierarchyName;\n      hierarchyName = field.hierarchyName;\n      isLastDimensionInGroup = !hierarchyName || !dimensions[i + 1] || dimensions[i + 1].hierarchyName !== hierarchyName;\n      expandAllIndex = path.length + expandAllCount + expandIndex;\n      arg = null;\n      fields.push(field);\n\n      if (i < path.length) {\n        if (isLastDimensionInGroup) {\n          arg = \"(\" + dataField + \".\" + preparePathValue(path[i], dataField) + \")\";\n        }\n      } else {\n        if (i <= expandAllIndex) {\n          if (0 === i && 0 === expandAllCount) {\n            allMember = getAllMember(dimensions[expandIndex]);\n\n            if (!hierarchyName) {\n              arg = getAllMembers(dimensions[expandIndex]);\n            } else {\n              arg = allMember + \",\" + dimensions[expandIndex].dataField;\n            }\n          } else {\n            if (hierarchyName) {\n              member = preparePathValue(slicePath[slicePath.length - 1]);\n\n              if (isLastDimensionInGroup || i === expandAllIndex) {\n                if (prevHierarchyName === hierarchyName) {\n                  if (slicePath.length) {\n                    prevDimension = dimensions[slicePath.length - 1];\n                  }\n\n                  if (!prevDimension || prevDimension.hierarchyName !== hierarchyName) {\n                    prevDimension = dimensions[i - 1];\n                    member = \"\";\n                  }\n\n                  arg = mdxDescendants(prevDimension.dataField, member, dataField);\n                } else {\n                  arg = getAllMembers(field);\n                }\n              }\n            } else {\n              arg = getAllMembers(field);\n            }\n          }\n        } else {\n          isFirstDimensionInGroup = !hierarchyName || prevHierarchyName !== hierarchyName;\n\n          if (isFirstDimensionInGroup) {\n            arg = \"(\" + getAllMember(field) + \")\";\n          }\n        }\n      }\n\n      if (arg) {\n        arg = (0, _string.format)(mdxSet, arg);\n\n        if (take) {\n          var sortBy = (field.hierarchyName || field.dataField) + (\"displayText\" === field.sortBy ? \".MEMBER_CAPTION\" : \".MEMBER_VALUE\");\n          arg = (0, _string.format)(mdxOrder, arg, sortBy, \"desc\" === field.sortOrder ? \"DESC\" : \"ASC\");\n        }\n\n        crossJoinArgs.push(arg);\n      }\n    }\n\n    return crossJoinElements(crossJoinArgs);\n  }\n\n  function fillCrossJoins(crossJoins, path, expandLevel, expandIndex, slicePath, options, axisName, cellsString, take, totalsOnly) {\n    var expandAllCount = -1;\n    var dimensions = options[axisName];\n    var dimensionIndex;\n\n    do {\n      expandAllCount++;\n      dimensionIndex = path.length + expandAllCount + expandIndex;\n      var crossJoin = generateCrossJoin(path, expandLevel, expandAllCount, expandIndex, slicePath, options, axisName, take);\n\n      if (!take && !totalsOnly) {\n        crossJoin = (0, _string.format)(mdxNonEmpty, crossJoin, cellsString);\n      }\n\n      crossJoins.push(crossJoin);\n    } while (dimensions[dimensionIndex] && dimensions[dimensionIndex + 1] && dimensions[dimensionIndex].expanded);\n  }\n\n  function declare(expression, withArray, name, type) {\n    name = name || \"[DX_Set_\" + withArray.length + \"]\";\n    type = type || \"set\";\n    withArray.push((0, _string.format)(mdxWith, type, name, expression));\n    return name;\n  }\n\n  function generateAxisMdx(options, axisName, cells, withArray, parseOptions) {\n    var dimensions = options[axisName];\n    var crossJoins = [];\n    var path = [];\n    var expandedPaths = [];\n    var expandIndex = 0;\n    var expandLevel = 0;\n    var result = [];\n    var cellsString = (0, _string.format)(mdxSet, cells.join(\",\"));\n\n    if (dimensions && dimensions.length) {\n      if (options.headerName === axisName) {\n        path = options.path;\n        expandIndex = path.length;\n      } else {\n        if (options.headerName && options.oppositePath) {\n          path = options.oppositePath;\n          expandIndex = path.length;\n        } else {\n          expandedPaths = (\"columns\" === axisName ? options.columnExpandedPaths : options.rowExpandedPaths) || expandedPaths;\n        }\n      }\n\n      expandLevel = (0, _uiPivot_grid.getExpandedLevel)(options, axisName);\n      fillCrossJoins(crossJoins, [], expandLevel, expandIndex, path, options, axisName, cellsString, \"rows\" === axisName ? options.rowTake : options.columnTake, options.totalsOnly);\n      (0, _iterator.each)(expandedPaths, function (_, expandedPath) {\n        fillCrossJoins(crossJoins, expandedPath, expandLevel, expandIndex, expandedPath, options, axisName, cellsString);\n      });\n\n      for (var i = expandLevel; i >= path.length; i--) {\n        if (dimensions[i].hierarchyName) {\n          parseOptions.visibleLevels[dimensions[i].hierarchyName] = parseOptions.visibleLevels[dimensions[i].hierarchyName] || [];\n          parseOptions.visibleLevels[dimensions[i].hierarchyName].push(dimensions[i].dataField);\n        }\n      }\n    }\n\n    if (crossJoins.length) {\n      var expression = union(crossJoins);\n\n      if (\"rows\" === axisName && options.rowTake) {\n        expression = (0, _string.format)(mdxSubset, expression, options.rowSkip > 0 ? options.rowSkip + 1 : 0, options.rowSkip > 0 ? options.rowTake : options.rowTake + 1);\n      }\n\n      if (\"columns\" === axisName && options.columnTake) {\n        expression = (0, _string.format)(mdxSubset, expression, options.columnSkip > 0 ? options.columnSkip + 1 : 0, options.columnSkip > 0 ? options.columnTake : options.columnTake + 1);\n      }\n\n      var axisSet = \"[DX_\".concat(axisName, \"]\");\n      result.push(declare(expression, withArray, axisSet));\n\n      if (options.totalsOnly) {\n        result.push(declare(\"COUNT(\".concat(axisSet, \")\"), withArray, \"[DX_\".concat(axisName, \"_count]\"), \"member\"));\n      }\n    }\n\n    if (\"columns\" === axisName && cells.length && !options.skipValues) {\n      result.push(cellsString);\n    }\n\n    return (0, _string.format)(mdxAxis, crossJoinElements(result), axisName);\n  }\n\n  function generateAxisFieldsFilter(fields) {\n    var filterMembers = [];\n    (0, _iterator.each)(fields, function (_, field) {\n      var dataField = field.dataField;\n      var filterExpression = [];\n      var filterValues = field.filterValues || [];\n      var filterStringExpression;\n\n      if (field.hierarchyName && (0, _type.isNumeric)(field.groupIndex)) {\n        return;\n      }\n\n      (0, _iterator.each)(filterValues, function (_, filterValue) {\n        var filterMdx = dataField + \".\" + preparePathValue(Array.isArray(filterValue) ? filterValue[filterValue.length - 1] : filterValue, dataField);\n\n        if (\"exclude\" === field.filterType) {\n          filterExpression.push(filterMdx + \".parent\");\n          filterMdx = \"Descendants(\" + filterMdx + \")\";\n        }\n\n        filterExpression.push(filterMdx);\n      });\n\n      if (filterValues.length) {\n        filterStringExpression = (0, _string.format)(mdxSet, filterExpression.join(\",\"));\n\n        if (\"exclude\" === field.filterType) {\n          filterStringExpression = \"Except(\" + getAllMembers(field) + \",\" + filterStringExpression + \")\";\n        }\n\n        filterMembers.push(filterStringExpression);\n      }\n    });\n    return filterMembers.length ? crossJoinElements(filterMembers) : \"\";\n  }\n\n  function generateFrom(columnsFilter, rowsFilter, filter, cubeName) {\n    var from = \"[\" + cubeName + \"]\";\n    (0, _iterator.each)([columnsFilter, rowsFilter, filter], function (_, filter) {\n      if (filter) {\n        from = (0, _string.format)(mdxFilterSelect, filter + \"on 0\", from);\n      }\n    });\n    return from;\n  }\n\n  function generateMdxCore(axisStrings, withArray, columns, rows, filters, slice, cubeName) {\n    var options = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : {};\n    var mdxString = \"\";\n    var withString = (withArray.length ? \"with \" + withArray.join(\" \") : \"\") + \" \";\n\n    if (axisStrings.length) {\n      var select;\n\n      if (options.totalsOnly) {\n        var countMembers = [];\n\n        if (rows.length) {\n          countMembers.push(\"[DX_rows_count]\");\n        }\n\n        if (columns.length) {\n          countMembers.push(\"[DX_columns_count]\");\n        }\n\n        select = \"{\".concat(countMembers.join(\",\"), \"} on columns\");\n      } else {\n        select = axisStrings.join(\",\");\n      }\n\n      mdxString = withString + (0, _string.format)(mdx, generateFrom(generateAxisFieldsFilter(columns), generateAxisFieldsFilter(rows), generateAxisFieldsFilter(filters || []), cubeName), slice.length ? (0, _string.format)(mdxSlice, slice.join(\",\")) : \"\", select);\n    }\n\n    return mdxString;\n  }\n\n  function prepareDataFields(withArray, valueFields) {\n    return (0, _iterator.map)(valueFields, function (cell) {\n      if ((0, _type.isString)(cell.expression)) {\n        declare(cell.expression, withArray, cell.dataField, \"member\");\n      }\n\n      return cell.dataField;\n    });\n  }\n\n  function addSlices(slices, options, headerName, path) {\n    (0, _iterator.each)(path, function (index, value) {\n      var dimension = options[headerName][index];\n\n      if (!dimension.hierarchyName || dimension.hierarchyName !== options[headerName][index + 1].hierarchyName) {\n        slices.push(dimension.dataField + \".\" + preparePathValue(value, dimension.dataField));\n      }\n    });\n  }\n\n  function generateMDX(options, cubeName, parseOptions) {\n    var columns = options.columns || [];\n    var rows = options.rows || [];\n    var values = options.values && options.values.length ? options.values : [{\n      dataField: \"[Measures]\"\n    }];\n    var slice = [];\n    var withArray = [];\n    var axisStrings = [];\n    var dataFields = prepareDataFields(withArray, values);\n    parseOptions.measureCount = options.skipValues ? 1 : values.length;\n    parseOptions.visibleLevels = {};\n\n    if (options.headerName && options.path) {\n      addSlices(slice, options, options.headerName, options.path);\n    }\n\n    if (options.headerName && options.oppositePath) {\n      addSlices(slice, options, \"rows\" === options.headerName ? \"columns\" : \"rows\", options.oppositePath);\n    }\n\n    if (columns.length || dataFields.length) {\n      axisStrings.push(generateAxisMdx(options, \"columns\", dataFields, withArray, parseOptions));\n    }\n\n    if (rows.length) {\n      axisStrings.push(generateAxisMdx(options, \"rows\", dataFields, withArray, parseOptions));\n    }\n\n    return generateMdxCore(axisStrings, withArray, columns, rows, options.filters, slice, cubeName, options);\n  }\n\n  function createDrillDownAxisSlice(slice, fields, path) {\n    (0, _iterator.each)(path, function (index, value) {\n      var field = fields[index];\n\n      if (field.hierarchyName && (fields[index + 1] || {}).hierarchyName === field.hierarchyName) {\n        return;\n      }\n\n      slice.push(field.dataField + \".\" + preparePathValue(value, field.dataField));\n    });\n  }\n\n  function generateDrillDownMDX(options, cubeName, params) {\n    var columns = options.columns || [];\n    var rows = options.rows || [];\n    var values = options.values && options.values.length ? options.values : [{\n      dataField: \"[Measures]\"\n    }];\n    var slice = [];\n    var withArray = [];\n    var axisStrings = [];\n    var dataFields = prepareDataFields(withArray, values);\n    var maxRowCount = params.maxRowCount;\n    var customColumns = params.customColumns || [];\n    var customColumnsString = customColumns.length > 0 ? \" return \" + customColumns.join(\",\") : \"\";\n    createDrillDownAxisSlice(slice, columns, params.columnPath || []);\n    createDrillDownAxisSlice(slice, rows, params.rowPath || []);\n\n    if (columns.length || columns.length || dataFields.length) {\n      axisStrings.push([(dataFields[params.dataIndex] || dataFields[0]) + \" on 0\"]);\n    }\n\n    var coreMDX = generateMdxCore(axisStrings, withArray, columns, rows, options.filters, slice, cubeName);\n    return coreMDX ? \"drillthrough\" + (maxRowCount > 0 ? \" maxrows \" + maxRowCount : \"\") + coreMDX + customColumnsString : coreMDX;\n  }\n\n  function getNumber(str) {\n    return parseInt(str, 10);\n  }\n\n  function parseValue(valueText) {\n    return (0, _type.isNumeric)(valueText) ? parseFloat(valueText) : valueText;\n  }\n\n  function getFirstChild(node, tagName) {\n    return (node.getElementsByTagName(tagName) || [])[0];\n  }\n\n  function getFirstChildText(node, childTagName) {\n    return getNodeText(getFirstChild(node, childTagName));\n  }\n\n  function parseAxes(xml, skipValues) {\n    var axes = [];\n    (0, _iterator.each)(xml.getElementsByTagName(\"Axis\"), function (_, axisElement) {\n      var name = axisElement.getAttribute(\"name\");\n      var axis = [];\n      var index = 0;\n\n      if (0 === name.indexOf(\"Axis\") && (0, _type.isNumeric)(getNumber(name.substr(4)))) {\n        axes.push(axis);\n        (0, _iterator.each)(axisElement.getElementsByTagName(\"Tuple\"), function (_, tupleElement) {\n          var tupleMembers = tupleElement.childNodes;\n          var tuple;\n          var levelSum = 0;\n          var members = [];\n          var level;\n          var membersCount = skipValues ? tupleMembers.length : tupleMembers.length - 1;\n          var isAxisWithMeasure = 1 === axes.length;\n          var i;\n\n          if (isAxisWithMeasure) {\n            membersCount--;\n          }\n\n          axis.push(members);\n\n          for (i = membersCount; i >= 0; i--) {\n            tuple = tupleMembers[i];\n            level = getNumber(getFirstChildText(tuple, \"LNum\"));\n            members[i] = {\n              caption: getFirstChildText(tuple, \"Caption\"),\n              value: parseValue(getFirstChildText(tuple, \"MEMBER_VALUE\")),\n              level: level,\n              index: index++,\n              hasValue: !levelSum && (!!level || 0 === i),\n              name: getFirstChildText(tuple, \"UName\"),\n              hierarchyName: tupleMembers[i].getAttribute(\"Hierarchy\"),\n              parentName: getFirstChildText(tuple, \"PARENT_UNIQUE_NAME\"),\n              levelName: getFirstChildText(tuple, \"LName\")\n            };\n            levelSum += level;\n          }\n        });\n      }\n    });\n\n    while (axes.length < 2) {\n      axes.push([[{\n        level: 0\n      }]]);\n    }\n\n    return axes;\n  }\n\n  function getNodeText(node) {\n    return node && node && (node.textContent || node.text || node.innerHTML) || \"\";\n  }\n\n  function parseCells(xml, axes, measureCount) {\n    var cells = [];\n    var cell = [];\n    var index = 0;\n    var measureIndex;\n    var cellsOriginal = [];\n    var cellElements = xml.getElementsByTagName(\"Cell\");\n    var errorDictionary = {};\n    var row;\n\n    for (var i = 0; i < cellElements.length; i++) {\n      var xmlCell = cellElements[i];\n      var valueElement = xmlCell.getElementsByTagName(\"Value\")[0];\n      var errorElements = valueElement && valueElement.getElementsByTagName(\"Error\") || [];\n      var text = 0 === errorElements.length ? getNodeText(valueElement) : \"#N/A\";\n      var value = parseFloat(text);\n\n      var _isNumeric = text - value + 1 > 0;\n\n      var cellOrdinal = getNumber(xmlCell.getAttribute(\"CellOrdinal\"));\n\n      if (errorElements.length) {\n        errorDictionary[getNodeText(errorElements[0].getElementsByTagName(\"ErrorCode\")[0])] = getNodeText(errorElements[0].getElementsByTagName(\"Description\")[0]);\n      }\n\n      cellsOriginal[cellOrdinal] = {\n        value: _isNumeric ? value : text || null\n      };\n    }\n\n    (0, _iterator.each)(axes[1], function () {\n      row = [];\n      cells.push(row);\n      (0, _iterator.each)(axes[0], function () {\n        measureIndex = index % measureCount;\n\n        if (0 === measureIndex) {\n          cell = [];\n          row.push(cell);\n        }\n\n        cell.push(cellsOriginal[index] ? cellsOriginal[index].value : null);\n        index++;\n      });\n    });\n    Object.keys(errorDictionary).forEach(function (key) {\n      _errors.errors.log(\"W4002\", errorDictionary[key]);\n    });\n    return cells;\n  }\n\n  function preparePathValue(pathValue, dataField) {\n    if (pathValue) {\n      pathValue = (0, _type.isString)(pathValue) && pathValue.indexOf(\"&\") !== -1 ? pathValue : \"[\" + pathValue + \"]\";\n\n      if (dataField && 0 === pathValue.indexOf(dataField + \".\")) {\n        pathValue = pathValue.slice(dataField.length + 1, pathValue.length);\n      }\n    }\n\n    return pathValue;\n  }\n\n  function getItem(hash, name, member, index) {\n    var item = hash[name];\n\n    if (!item) {\n      item = {};\n      hash[name] = item;\n    }\n\n    if (!(0, _type.isDefined)(item.value) && member) {\n      item.text = member.caption;\n      item.value = member.value;\n      item.key = name ? name : \"\";\n      item.levelName = member.levelName;\n      item.hierarchyName = member.hierarchyName;\n      item.parentName = member.parentName;\n      item.index = index;\n      item.level = member.level;\n    }\n\n    return item;\n  }\n\n  function getVisibleChildren(item, visibleLevels) {\n    var result = [];\n    var children = item.children && (item.children.length ? item.children : Object.keys(item.children.grandTotalHash || {}).reduce(function (result, name) {\n      return result.concat(item.children.grandTotalHash[name].children);\n    }, []));\n    var firstChild = children && children[0];\n\n    if (firstChild && (visibleLevels[firstChild.hierarchyName] && (0, _array.inArray)(firstChild.levelName, visibleLevels[firstChild.hierarchyName]) !== -1 || !visibleLevels[firstChild.hierarchyName] || 0 === firstChild.level)) {\n      var newChildren = children.filter(function (child) {\n        return child.hierarchyName === firstChild.hierarchyName;\n      });\n      newChildren.grandTotalHash = children.grandTotalHash;\n      return newChildren;\n    } else {\n      if (firstChild) {\n        for (var i = 0; i < children.length; i++) {\n          if (children[i].hierarchyName === firstChild.hierarchyName) {\n            result.push.apply(result, getVisibleChildren(children[i], visibleLevels));\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n  function processMember(dataIndex, member, parentItem) {\n    var children = parentItem.children = parentItem.children || [];\n    var hash = children.hash = children.hash || {};\n    var grandTotalHash = children.grandTotalHash = children.grandTotalHash || {};\n\n    if (member.parentName) {\n      parentItem = getItem(hash, member.parentName);\n      children = parentItem.children = parentItem.children || [];\n    }\n\n    var currentItem = getItem(hash, member.name, member, dataIndex);\n\n    if (member.hasValue && !currentItem.added) {\n      currentItem.index = dataIndex;\n      currentItem.added = true;\n      children.push(currentItem);\n    }\n\n    if ((!parentItem.value || !parentItem.parentName) && member.parentName) {\n      grandTotalHash[member.parentName] = parentItem;\n    } else {\n      if (grandTotalHash[parentItem.name]) {\n        delete grandTotalHash[member.parentName];\n      }\n    }\n\n    return currentItem;\n  }\n\n  function getGrandTotalIndex(parentItem, visibleLevels) {\n    var grandTotalIndex;\n\n    if (1 === parentItem.children.length && \"\" === parentItem.children[0].parentName) {\n      grandTotalIndex = parentItem.children[0].index;\n      var grandTotalHash = parentItem.children.grandTotalHash;\n      parentItem.children = parentItem.children[0].children || [];\n      parentItem.children.grandTotalHash = grandTotalHash;\n      parentItem.children = getVisibleChildren(parentItem, visibleLevels);\n    } else {\n      if (0 === parentItem.children.length) {\n        grandTotalIndex = 0;\n      }\n    }\n\n    return grandTotalIndex;\n  }\n\n  function fillDataSourceAxes(dataSourceAxis, axisTuples, measureCount, visibleLevels) {\n    var result = [];\n    (0, _iterator.each)(axisTuples, function (tupleIndex, members) {\n      var parentItem = {\n        children: result\n      };\n      var dataIndex = (0, _type.isDefined)(measureCount) ? Math.floor(tupleIndex / measureCount) : tupleIndex;\n      (0, _iterator.each)(members, function (_, member) {\n        parentItem = processMember(dataIndex, member, parentItem);\n      });\n    });\n    var parentItem = {\n      children: result\n    };\n    parentItem.children = getVisibleChildren(parentItem, visibleLevels);\n    var grandTotalIndex = getGrandTotalIndex(parentItem, visibleLevels);\n    (0, _uiPivot_grid.foreachTree)(parentItem.children, function (items) {\n      var item = items[0];\n      var children = getVisibleChildren(item, visibleLevels);\n\n      if (children.length) {\n        item.children = children;\n      } else {\n        delete item.children;\n      }\n\n      delete item.levelName;\n      delete item.hierarchyName;\n      delete item.added;\n      delete item.parentName;\n      delete item.level;\n    }, true);\n    (0, _iterator.each)(parentItem.children || [], function (_, e) {\n      dataSourceAxis.push(e);\n    });\n    return grandTotalIndex;\n  }\n\n  function checkError(xml) {\n    var faultElementNS = xml.getElementsByTagName(\"soap:Fault\");\n    var faultElement = xml.getElementsByTagName(\"Fault\");\n    var errorElement = (0, _renderer2.default)([].slice.call(faultElement.length ? faultElement : faultElementNS)).find(\"Error\");\n    var description;\n    var error;\n\n    if (errorElement.length) {\n      description = errorElement.attr(\"Description\");\n      error = new _errors.errors.Error(\"E4000\", description);\n\n      _errors.errors.log(\"E4000\", description);\n\n      return error;\n    }\n\n    return null;\n  }\n\n  function parseResult(xml, parseOptions) {\n    var dataSource = {\n      columns: [],\n      rows: []\n    };\n    var measureCount = parseOptions.measureCount;\n    var axes = parseAxes(xml, parseOptions.skipValues);\n    dataSource.grandTotalColumnIndex = fillDataSourceAxes(dataSource.columns, axes[0], measureCount, parseOptions.visibleLevels);\n    dataSource.grandTotalRowIndex = fillDataSourceAxes(dataSource.rows, axes[1], void 0, parseOptions.visibleLevels);\n    dataSource.values = parseCells(xml, axes, measureCount);\n    return dataSource;\n  }\n\n  function parseDiscoverRowSet(xml, schema, dimensions, translatedDisplayFolders) {\n    var result = [];\n    var isMeasure = \"MEASURE\" === schema;\n    var displayFolderField = isMeasure ? \"MEASUREGROUP_NAME\" : schema + \"_DISPLAY_FOLDER\";\n    (0, _iterator.each)(xml.getElementsByTagName(\"row\"), function (_, row) {\n      var hierarchyName = \"LEVEL\" === schema ? getFirstChildText(row, \"HIERARCHY_UNIQUE_NAME\") : void 0;\n      var levelNumber = getFirstChildText(row, \"LEVEL_NUMBER\");\n      var displayFolder = getFirstChildText(row, displayFolderField);\n\n      if (isMeasure) {\n        displayFolder = translatedDisplayFolders[displayFolder] || displayFolder;\n      }\n\n      if ((\"0\" !== levelNumber || \"true\" !== getFirstChildText(row, schema + \"_IS_VISIBLE\")) && getFirstChildText(row, \"DIMENSION_TYPE\") !== MD_DIMTYPE_MEASURE) {\n        var dimension = isMeasure ? MEASURE_DEMENSION_KEY : getFirstChildText(row, \"DIMENSION_UNIQUE_NAME\");\n        var dataField = getFirstChildText(row, schema + \"_UNIQUE_NAME\");\n        result.push({\n          dimension: dimensions.names[dimension] || dimension,\n          groupIndex: levelNumber ? getNumber(levelNumber) - 1 : void 0,\n          dataField: dataField,\n          caption: getFirstChildText(row, schema + \"_CAPTION\"),\n          hierarchyName: hierarchyName,\n          groupName: hierarchyName,\n          displayFolder: displayFolder,\n          isMeasure: isMeasure,\n          isDefault: !!dimensions.defaultHierarchies[dataField]\n        });\n      }\n    });\n    return result;\n  }\n\n  function parseMeasureGroupDiscoverRowSet(xml) {\n    var measureGroups = {};\n    (0, _iterator.each)(xml.getElementsByTagName(\"row\"), function (_, row) {\n      measureGroups[getFirstChildText(row, \"MEASUREGROUP_NAME\")] = getFirstChildText(row, \"MEASUREGROUP_CAPTION\");\n    });\n    return measureGroups;\n  }\n\n  function parseDimensionsDiscoverRowSet(xml) {\n    var result = {\n      names: {},\n      defaultHierarchies: {}\n    };\n    (0, _iterator.each)((0, _renderer2.default)(xml).find(\"row\"), function () {\n      var $row = (0, _renderer2.default)(this);\n      var type = $row.children(\"DIMENSION_TYPE\").text();\n      var dimensionName = type === MD_DIMTYPE_MEASURE ? MEASURE_DEMENSION_KEY : $row.children(\"DIMENSION_UNIQUE_NAME\").text();\n      result.names[dimensionName] = $row.children(\"DIMENSION_CAPTION\").text();\n      result.defaultHierarchies[$row.children(\"DEFAULT_HIERARCHY\").text()] = true;\n    });\n    return result;\n  }\n\n  function parseStringWithUnicodeSymbols(str) {\n    str = str.replace(/_x(....)_/g, function (whole, group1) {\n      return String.fromCharCode(parseInt(group1, 16));\n    });\n    var stringArray = str.match(/\\[.+?\\]/gi);\n\n    if (stringArray && stringArray.length) {\n      str = stringArray[stringArray.length - 1];\n    }\n\n    return str.replace(/\\[/gi, \"\").replace(/\\]/gi, \"\").replace(/\\$/gi, \"\").replace(/\\./gi, \" \");\n  }\n\n  function parseDrillDownRowSet(xml) {\n    var rows = xml.getElementsByTagName(\"row\");\n    var result = [];\n    var columnNames = {};\n\n    for (var i = 0; i < rows.length; i++) {\n      var children = rows[i].childNodes;\n      var item = {};\n\n      for (var j = 0; j < children.length; j++) {\n        var tagName = children[j].tagName;\n        var name = columnNames[tagName] = columnNames[tagName] || parseStringWithUnicodeSymbols(tagName);\n        item[name] = getNodeText(children[j]);\n      }\n\n      result.push(item);\n    }\n\n    return result;\n  }\n\n  function sendQuery(storeOptions, mdxString) {\n    mdxString = (0, _renderer2.default)(\"<div>\").text(mdxString).html();\n    return execXMLA(storeOptions, (0, _string.format)(execute, mdxString, storeOptions.catalog, getLocaleIdProperty()));\n  }\n\n  function processTotalCount(data, options, totalCountXml) {\n    var axes = [];\n    var columnOptions = options.columns || [];\n    var rowOptions = options.rows || [];\n\n    if (columnOptions.length) {\n      axes.push({});\n    }\n\n    if (rowOptions.length) {\n      axes.push({});\n    }\n\n    var cells = parseCells(totalCountXml, [[{}], [{}, {}]], 1);\n\n    if (!columnOptions.length && rowOptions.length) {\n      data.rowCount = Math.max(cells[0][0][0] - 1, 0);\n    }\n\n    if (!rowOptions.length && columnOptions.length) {\n      data.columnCount = Math.max(cells[0][0][0] - 1, 0);\n    }\n\n    if (rowOptions.length && columnOptions.length) {\n      data.rowCount = Math.max(cells[0][0][0] - 1, 0);\n      data.columnCount = Math.max(cells[1][0][0] - 1, 0);\n    }\n\n    if (void 0 !== data.rowCount && options.rowTake) {\n      data.rows = _toConsumableArray(Array(options.rowSkip)).concat(data.rows);\n      data.rows.length = data.rowCount;\n\n      for (var i = 0; i < data.rows.length; i++) {\n        data.rows[i] = data.rows[i] || {};\n      }\n    }\n\n    if (void 0 !== data.columnCount && options.columnTake) {\n      data.columns = _toConsumableArray(Array(options.columnSkip)).concat(data.columns);\n      data.columns.length = data.columnCount;\n\n      for (var _i = 0; _i < data.columns.length; _i++) {\n        data.columns[_i] = data.columns[_i] || {};\n      }\n    }\n  }\n\n  return {\n    ctor: function ctor(options) {\n      this._options = options;\n    },\n    getFields: function getFields() {\n      var options = this._options;\n      var catalog = options.catalog;\n      var cube = options.cube;\n      var localeIdProperty = getLocaleIdProperty();\n      var dimensionsRequest = execXMLA(options, (0, _string.format)(discover, catalog, cube, \"MDSCHEMA_DIMENSIONS\", localeIdProperty));\n      var measuresRequest = execXMLA(options, (0, _string.format)(discover, catalog, cube, \"MDSCHEMA_MEASURES\", localeIdProperty));\n      var hierarchiesRequest = execXMLA(options, (0, _string.format)(discover, catalog, cube, \"MDSCHEMA_HIERARCHIES\", localeIdProperty));\n      var levelsRequest = execXMLA(options, (0, _string.format)(discover, catalog, cube, \"MDSCHEMA_LEVELS\", localeIdProperty));\n      var result = new _deferred.Deferred();\n      (0, _deferred.when)(dimensionsRequest, measuresRequest, hierarchiesRequest, levelsRequest).then(function (dimensionsResponse, measuresResponse, hierarchiesResponse, levelsResponse) {\n        execXMLA(options, (0, _string.format)(discover, catalog, cube, \"MDSCHEMA_MEASUREGROUPS\", localeIdProperty)).done(function (measureGroupsResponse) {\n          var dimensions = parseDimensionsDiscoverRowSet(dimensionsResponse);\n          var hierarchies = parseDiscoverRowSet(hierarchiesResponse, \"HIERARCHY\", dimensions);\n          var levels = parseDiscoverRowSet(levelsResponse, \"LEVEL\", dimensions);\n          var measureGroups = parseMeasureGroupDiscoverRowSet(measureGroupsResponse);\n          var fields = parseDiscoverRowSet(measuresResponse, \"MEASURE\", dimensions, measureGroups).concat(hierarchies);\n          var levelsByHierarchy = {};\n          (0, _iterator.each)(levels, function (_, level) {\n            levelsByHierarchy[level.hierarchyName] = levelsByHierarchy[level.hierarchyName] || [];\n            levelsByHierarchy[level.hierarchyName].push(level);\n          });\n          (0, _iterator.each)(hierarchies, function (_, hierarchy) {\n            if (levelsByHierarchy[hierarchy.dataField] && levelsByHierarchy[hierarchy.dataField].length > 1) {\n              hierarchy.groupName = hierarchy.hierarchyName = hierarchy.dataField;\n              fields.push.apply(fields, levelsByHierarchy[hierarchy.hierarchyName]);\n            }\n          });\n          result.resolve(fields);\n        }).fail(result.reject);\n      }).fail(result.reject);\n      return result;\n    },\n    load: function load(options) {\n      var result = new _deferred.Deferred();\n      var storeOptions = this._options;\n      var parseOptions = {\n        skipValues: options.skipValues\n      };\n      var mdxString = generateMDX(options, storeOptions.cube, parseOptions);\n      var rowCountMdx;\n\n      if (options.rowSkip || options.rowTake || options.columnTake || options.columnSkip) {\n        rowCountMdx = generateMDX((0, _extend.extend)({}, options, {\n          totalsOnly: true,\n          rowSkip: null,\n          rowTake: null,\n          columnSkip: null,\n          columnTake: null\n        }), storeOptions.cube, {});\n      }\n\n      var load = function load() {\n        if (mdxString) {\n          (0, _deferred.when)(sendQuery(storeOptions, mdxString), rowCountMdx && sendQuery(storeOptions, rowCountMdx)).done(function (executeXml, rowCountXml) {\n            var error = checkError(executeXml) || rowCountXml && checkError(rowCountXml);\n\n            if (!error) {\n              var response = parseResult(executeXml, parseOptions);\n\n              if (rowCountXml) {\n                processTotalCount(response, options, rowCountXml);\n              }\n\n              result.resolve(response);\n            } else {\n              result.reject(error);\n            }\n          }).fail(result.reject);\n        } else {\n          result.resolve({\n            columns: [],\n            rows: [],\n            values: [],\n            grandTotalColumnIndex: 0,\n            grandTotalRowIndex: 0\n          });\n        }\n      };\n\n      if (options.delay) {\n        setTimeout(load, options.delay);\n      } else {\n        load();\n      }\n\n      return result;\n    },\n    supportPaging: function supportPaging() {\n      return true;\n    },\n    getDrillDownItems: function getDrillDownItems(options, params) {\n      var result = new _deferred.Deferred();\n      var storeOptions = this._options;\n      var mdxString = generateDrillDownMDX(options, storeOptions.cube, params);\n\n      if (mdxString) {\n        (0, _deferred.when)(sendQuery(storeOptions, mdxString)).done(function (executeXml) {\n          var error = checkError(executeXml);\n\n          if (!error) {\n            result.resolve(parseDrillDownRowSet(executeXml));\n          } else {\n            result.reject(error);\n          }\n        }).fail(result.reject);\n      } else {\n        result.resolve([]);\n      }\n\n      return result;\n    },\n    key: _common.noop,\n    filter: _common.noop\n  };\n}()).include(_uiPivot_grid.storeDrillDownMixin);","map":{"version":3,"sources":["C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/devextreme/ui/pivot_grid/xmla_store/xmla_store.js"],"names":["_renderer","require","_renderer2","_interopRequireDefault","_window","_class","_class2","_string","_errors","_common","_extend","_type","_iterator","_array","_uiPivot_grid","_deferred","_language_codes","obj","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","Symbol","Object","Array","i","arr2","arr","window","exports","discover","execute","mdx","mdxFilterSelect","mdxSubset","mdxOrder","mdxWith","mdxSlice","mdxNonEmpty","mdxAxis","mdxCrossJoin","mdxSet","MEASURE_DEMENSION_KEY","MD_DIMTYPE_MEASURE","deferred","beforeSend","requestOptions","ajaxSettings","url","dataType","data","headers","xhrFields","method","parser","xml","statusText","e","stack","responseText","text","languageId","memberExpression","levelMember","dimension","result","field","searchValue","elementsString","elements","crossJoinArgs","dimensions","options","fields","dataField","prevHierarchyName","hierarchyName","isLastDimensionInGroup","expandAllIndex","path","arg","preparePathValue","allMember","getAllMember","getAllMembers","member","slicePath","prevDimension","mdxDescendants","isFirstDimensionInGroup","sortBy","crossJoinElements","expandAllCount","dimensionIndex","crossJoin","generateCrossJoin","crossJoins","name","withArray","type","expandedPaths","expandIndex","expandLevel","cellsString","cells","fillCrossJoins","parseOptions","expression","union","axisSet","declare","filterMembers","filterExpression","filterValues","filterMdx","filterValue","filterStringExpression","from","filter","arguments","mdxString","withString","axisStrings","countMembers","rows","columns","select","generateFrom","generateAxisFieldsFilter","filters","slice","cell","index","slices","values","dataFields","prepareDataFields","addSlices","generateAxisMdx","generateMdxCore","maxRowCount","params","customColumns","customColumnsString","createDrillDownAxisSlice","coreMDX","parseInt","parseFloat","node","getNodeText","getFirstChild","axes","axisElement","axis","getNumber","tupleMembers","tupleElement","levelSum","members","membersCount","skipValues","isAxisWithMeasure","tuple","level","getFirstChildText","caption","value","parseValue","hasValue","parentName","levelName","cellsOriginal","cellElements","errorDictionary","xmlCell","valueElement","errorElements","_isNumeric","cellOrdinal","row","measureIndex","pathValue","item","hash","children","firstChild","visibleLevels","newChildren","child","getVisibleChildren","parentItem","grandTotalHash","getItem","currentItem","grandTotalIndex","dataIndex","Math","tupleIndex","processMember","getGrandTotalIndex","items","dataSourceAxis","faultElementNS","faultElement","errorElement","description","error","dataSource","measureCount","parseAxes","fillDataSourceAxes","parseCells","isMeasure","displayFolderField","schema","levelNumber","displayFolder","translatedDisplayFolders","groupIndex","groupName","isDefault","measureGroups","names","defaultHierarchies","$row","dimensionName","str","String","stringArray","columnNames","j","tagName","parseStringWithUnicodeSymbols","execXMLA","storeOptions","getLocaleIdProperty","columnOptions","rowOptions","_toConsumableArray","_i","ctor","getFields","catalog","cube","localeIdProperty","dimensionsRequest","measuresRequest","hierarchiesRequest","levelsRequest","parseDimensionsDiscoverRowSet","hierarchies","parseDiscoverRowSet","levels","parseMeasureGroupDiscoverRowSet","levelsByHierarchy","hierarchy","load","generateMDX","rowCountMdx","totalsOnly","rowSkip","rowTake","columnSkip","columnTake","sendQuery","checkError","rowCountXml","response","parseResult","processTotalCount","grandTotalColumnIndex","grandTotalRowIndex","setTimeout","supportPaging","getDrillDownItems","generateDrillDownMDX","parseDrillDownRowSet","key","noop"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (ui/pivot_grid/xmla_store/xmla_store.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nvar _renderer = require(\"../../../core/renderer\");\r\nvar _renderer2 = _interopRequireDefault(_renderer);\r\nvar _window = require(\"../../../core/utils/window\");\r\nvar _class = require(\"../../../core/class\");\r\nvar _class2 = _interopRequireDefault(_class);\r\nvar _string = require(\"../../../core/utils/string\");\r\nvar _errors = require(\"../../../data/errors\");\r\nvar _common = require(\"../../../core/utils/common\");\r\nvar _extend = require(\"../../../core/utils/extend\");\r\nvar _type = require(\"../../../core/utils/type\");\r\nvar _iterator = require(\"../../../core/utils/iterator\");\r\nvar _array = require(\"../../../core/utils/array\");\r\nvar _uiPivot_grid = require(\"../ui.pivot_grid.utils\");\r\nvar _deferred = require(\"../../../core/utils/deferred\");\r\nvar _language_codes = require(\"../../../localization/language_codes\");\r\n\r\nfunction _interopRequireDefault(obj) {\r\n    return obj && obj.__esModule ? obj : {\r\n        \"default\": obj\r\n    }\r\n}\r\n\r\nfunction _toConsumableArray(arr) {\r\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()\r\n}\r\n\r\nfunction _nonIterableSpread() {\r\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance\")\r\n}\r\n\r\nfunction _iterableToArray(iter) {\r\n    if (Symbol.iterator in Object(iter) || \"[object Arguments]\" === Object.prototype.toString.call(iter)) {\r\n        return Array.from(iter)\r\n    }\r\n}\r\n\r\nfunction _arrayWithoutHoles(arr) {\r\n    if (Array.isArray(arr)) {\r\n        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\r\n            arr2[i] = arr[i]\r\n        }\r\n        return arr2\r\n    }\r\n}\r\nvar window = (0, _window.getWindow)();\r\nexports.XmlaStore = _class2.default.inherit(function() {\r\n    var discover = '<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\"><Body><Discover xmlns=\"urn:schemas-microsoft-com:xml-analysis\"><RequestType>{2}</RequestType><Restrictions><RestrictionList><CATALOG_NAME>{0}</CATALOG_NAME><CUBE_NAME>{1}</CUBE_NAME></RestrictionList></Restrictions><Properties><PropertyList><Catalog>{0}</Catalog>{3}</PropertyList></Properties></Discover></Body></Envelope>';\r\n    var execute = '<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\"><Body><Execute xmlns=\"urn:schemas-microsoft-com:xml-analysis\"><Command><Statement>{0}</Statement></Command><Properties><PropertyList><Catalog>{1}</Catalog><ShowHiddenCubes>True</ShowHiddenCubes><SspropInitAppName>Microsoft SQL Server Management Studio</SspropInitAppName><Timeout>3600</Timeout>{2}</PropertyList></Properties></Execute></Body></Envelope>';\r\n    var mdx = \"SELECT {2} FROM {0} {1} CELL PROPERTIES VALUE, FORMAT_STRING, LANGUAGE, BACK_COLOR, FORE_COLOR, FONT_FLAGS\";\r\n    var mdxFilterSelect = \"(SELECT {0} FROM {1})\";\r\n    var mdxSubset = \"Subset({0}, {1}, {2})\";\r\n    var mdxOrder = \"Order({0}, {1}, {2})\";\r\n    var mdxWith = \"{0} {1} as {2}\";\r\n    var mdxSlice = \"WHERE ({0})\";\r\n    var mdxNonEmpty = \"NonEmpty({0}, {1})\";\r\n    var mdxAxis = \"{0} DIMENSION PROPERTIES PARENT_UNIQUE_NAME,HIERARCHY_UNIQUE_NAME, MEMBER_VALUE ON {1}\";\r\n    var mdxCrossJoin = \"CrossJoin({0})\";\r\n    var mdxSet = \"{{0}}\";\r\n    var MEASURE_DEMENSION_KEY = \"DX_MEASURES\";\r\n    var MD_DIMTYPE_MEASURE = \"2\";\r\n\r\n    function execXMLA(requestOptions, data) {\r\n        var deferred = new _deferred.Deferred;\r\n        var beforeSend = requestOptions.beforeSend;\r\n        var ajaxSettings = {\r\n            url: requestOptions.url,\r\n            dataType: \"text\",\r\n            data: data,\r\n            headers: {\r\n                \"Content-Type\": \"text/xml\"\r\n            },\r\n            xhrFields: {},\r\n            method: \"POST\"\r\n        };\r\n        if ((0, _type.isFunction)(beforeSend)) {\r\n            beforeSend(ajaxSettings)\r\n        }(0, _uiPivot_grid.sendRequest)(ajaxSettings).fail(function() {\r\n            deferred.reject(arguments)\r\n        }).done(function(text) {\r\n            var parser = new window.DOMParser;\r\n            var xml;\r\n            try {\r\n                try {\r\n                    xml = parser.parseFromString(text, \"text/xml\")\r\n                } catch (e) {\r\n                    xml = void 0\r\n                }\r\n                if (!xml || xml.getElementsByTagName(\"parsererror\").length || 0 === xml.childNodes.length) {\r\n                    throw new _errors.errors.Error(\"E4023\", text)\r\n                }\r\n            } catch (e) {\r\n                deferred.reject({\r\n                    statusText: e.message,\r\n                    stack: e.stack,\r\n                    responseText: text\r\n                })\r\n            }\r\n            deferred.resolve(xml)\r\n        });\r\n        return deferred\r\n    }\r\n\r\n    function getLocaleIdProperty() {\r\n        var languageId = (0, _language_codes.getLanguageId)();\r\n        if (void 0 !== languageId) {\r\n            return (0, _string.format)(\"<LocaleIdentifier>{0}</LocaleIdentifier>\", languageId)\r\n        }\r\n        return \"\"\r\n    }\r\n\r\n    function mdxDescendants(level, levelMember, nextLevel) {\r\n        var memberExpression = levelMember ? levelMember : level;\r\n        return \"Descendants({\" + memberExpression + \"}, \" + nextLevel + \", SELF_AND_BEFORE)\"\r\n    }\r\n\r\n    function getAllMember(dimension) {\r\n        return (dimension.hierarchyName || dimension.dataField) + \".[All]\"\r\n    }\r\n\r\n    function getAllMembers(field) {\r\n        var result = field.dataField + \".allMembers\";\r\n        var searchValue = field.searchValue;\r\n        if (searchValue) {\r\n            searchValue = searchValue.replace(/'/g, \"''\");\r\n            result = \"Filter(\" + result + \", instr(\" + field.dataField + \".currentmember.member_caption,'\" + searchValue + \"') > 0)\"\r\n        }\r\n        return result\r\n    }\r\n\r\n    function crossJoinElements(elements) {\r\n        var elementsString = elements.join(\",\");\r\n        return elements.length > 1 ? (0, _string.format)(mdxCrossJoin, elementsString) : elementsString\r\n    }\r\n\r\n    function union(elements) {\r\n        var elementsString = elements.join(\",\");\r\n        return elements.length > 1 ? \"Union(\" + elementsString + \")\" : elementsString\r\n    }\r\n\r\n    function generateCrossJoin(path, expandLevel, expandAllCount, expandIndex, slicePath, options, axisName, take) {\r\n        var crossJoinArgs = [];\r\n        var dimensions = options[axisName];\r\n        var dataField;\r\n        var allMember;\r\n        var fields = [];\r\n        var hierarchyName;\r\n        var arg;\r\n        var prevDimension;\r\n        var prevHierarchyName;\r\n        var isLastDimensionInGroup;\r\n        var isFirstDimensionInGroup;\r\n        var expandAllIndex;\r\n        var field;\r\n        var member;\r\n        var i;\r\n        for (i = expandIndex; i <= expandLevel; i++) {\r\n            field = dimensions[i];\r\n            dataField = field.dataField;\r\n            prevHierarchyName = dimensions[i - 1] && dimensions[i - 1].hierarchyName;\r\n            hierarchyName = field.hierarchyName;\r\n            isLastDimensionInGroup = !hierarchyName || !dimensions[i + 1] || dimensions[i + 1].hierarchyName !== hierarchyName;\r\n            expandAllIndex = path.length + expandAllCount + expandIndex;\r\n            arg = null;\r\n            fields.push(field);\r\n            if (i < path.length) {\r\n                if (isLastDimensionInGroup) {\r\n                    arg = \"(\" + dataField + \".\" + preparePathValue(path[i], dataField) + \")\"\r\n                }\r\n            } else {\r\n                if (i <= expandAllIndex) {\r\n                    if (0 === i && 0 === expandAllCount) {\r\n                        allMember = getAllMember(dimensions[expandIndex]);\r\n                        if (!hierarchyName) {\r\n                            arg = getAllMembers(dimensions[expandIndex])\r\n                        } else {\r\n                            arg = allMember + \",\" + dimensions[expandIndex].dataField\r\n                        }\r\n                    } else {\r\n                        if (hierarchyName) {\r\n                            member = preparePathValue(slicePath[slicePath.length - 1]);\r\n                            if (isLastDimensionInGroup || i === expandAllIndex) {\r\n                                if (prevHierarchyName === hierarchyName) {\r\n                                    if (slicePath.length) {\r\n                                        prevDimension = dimensions[slicePath.length - 1]\r\n                                    }\r\n                                    if (!prevDimension || prevDimension.hierarchyName !== hierarchyName) {\r\n                                        prevDimension = dimensions[i - 1];\r\n                                        member = \"\"\r\n                                    }\r\n                                    arg = mdxDescendants(prevDimension.dataField, member, dataField)\r\n                                } else {\r\n                                    arg = getAllMembers(field)\r\n                                }\r\n                            }\r\n                        } else {\r\n                            arg = getAllMembers(field)\r\n                        }\r\n                    }\r\n                } else {\r\n                    isFirstDimensionInGroup = !hierarchyName || prevHierarchyName !== hierarchyName;\r\n                    if (isFirstDimensionInGroup) {\r\n                        arg = \"(\" + getAllMember(field) + \")\"\r\n                    }\r\n                }\r\n            }\r\n            if (arg) {\r\n                arg = (0, _string.format)(mdxSet, arg);\r\n                if (take) {\r\n                    var sortBy = (field.hierarchyName || field.dataField) + (\"displayText\" === field.sortBy ? \".MEMBER_CAPTION\" : \".MEMBER_VALUE\");\r\n                    arg = (0, _string.format)(mdxOrder, arg, sortBy, \"desc\" === field.sortOrder ? \"DESC\" : \"ASC\")\r\n                }\r\n                crossJoinArgs.push(arg)\r\n            }\r\n        }\r\n        return crossJoinElements(crossJoinArgs)\r\n    }\r\n\r\n    function fillCrossJoins(crossJoins, path, expandLevel, expandIndex, slicePath, options, axisName, cellsString, take, totalsOnly) {\r\n        var expandAllCount = -1;\r\n        var dimensions = options[axisName];\r\n        var dimensionIndex;\r\n        do {\r\n            expandAllCount++;\r\n            dimensionIndex = path.length + expandAllCount + expandIndex;\r\n            var crossJoin = generateCrossJoin(path, expandLevel, expandAllCount, expandIndex, slicePath, options, axisName, take);\r\n            if (!take && !totalsOnly) {\r\n                crossJoin = (0, _string.format)(mdxNonEmpty, crossJoin, cellsString)\r\n            }\r\n            crossJoins.push(crossJoin)\r\n        } while (dimensions[dimensionIndex] && dimensions[dimensionIndex + 1] && dimensions[dimensionIndex].expanded)\r\n    }\r\n\r\n    function declare(expression, withArray, name, type) {\r\n        name = name || \"[DX_Set_\" + withArray.length + \"]\";\r\n        type = type || \"set\";\r\n        withArray.push((0, _string.format)(mdxWith, type, name, expression));\r\n        return name\r\n    }\r\n\r\n    function generateAxisMdx(options, axisName, cells, withArray, parseOptions) {\r\n        var dimensions = options[axisName];\r\n        var crossJoins = [];\r\n        var path = [];\r\n        var expandedPaths = [];\r\n        var expandIndex = 0;\r\n        var expandLevel = 0;\r\n        var result = [];\r\n        var cellsString = (0, _string.format)(mdxSet, cells.join(\",\"));\r\n        if (dimensions && dimensions.length) {\r\n            if (options.headerName === axisName) {\r\n                path = options.path;\r\n                expandIndex = path.length\r\n            } else {\r\n                if (options.headerName && options.oppositePath) {\r\n                    path = options.oppositePath;\r\n                    expandIndex = path.length\r\n                } else {\r\n                    expandedPaths = (\"columns\" === axisName ? options.columnExpandedPaths : options.rowExpandedPaths) || expandedPaths\r\n                }\r\n            }\r\n            expandLevel = (0, _uiPivot_grid.getExpandedLevel)(options, axisName);\r\n            fillCrossJoins(crossJoins, [], expandLevel, expandIndex, path, options, axisName, cellsString, \"rows\" === axisName ? options.rowTake : options.columnTake, options.totalsOnly);\r\n            (0, _iterator.each)(expandedPaths, function(_, expandedPath) {\r\n                fillCrossJoins(crossJoins, expandedPath, expandLevel, expandIndex, expandedPath, options, axisName, cellsString)\r\n            });\r\n            for (var i = expandLevel; i >= path.length; i--) {\r\n                if (dimensions[i].hierarchyName) {\r\n                    parseOptions.visibleLevels[dimensions[i].hierarchyName] = parseOptions.visibleLevels[dimensions[i].hierarchyName] || [];\r\n                    parseOptions.visibleLevels[dimensions[i].hierarchyName].push(dimensions[i].dataField)\r\n                }\r\n            }\r\n        }\r\n        if (crossJoins.length) {\r\n            var expression = union(crossJoins);\r\n            if (\"rows\" === axisName && options.rowTake) {\r\n                expression = (0, _string.format)(mdxSubset, expression, options.rowSkip > 0 ? options.rowSkip + 1 : 0, options.rowSkip > 0 ? options.rowTake : options.rowTake + 1)\r\n            }\r\n            if (\"columns\" === axisName && options.columnTake) {\r\n                expression = (0, _string.format)(mdxSubset, expression, options.columnSkip > 0 ? options.columnSkip + 1 : 0, options.columnSkip > 0 ? options.columnTake : options.columnTake + 1)\r\n            }\r\n            var axisSet = \"[DX_\".concat(axisName, \"]\");\r\n            result.push(declare(expression, withArray, axisSet));\r\n            if (options.totalsOnly) {\r\n                result.push(declare(\"COUNT(\".concat(axisSet, \")\"), withArray, \"[DX_\".concat(axisName, \"_count]\"), \"member\"))\r\n            }\r\n        }\r\n        if (\"columns\" === axisName && cells.length && !options.skipValues) {\r\n            result.push(cellsString)\r\n        }\r\n        return (0, _string.format)(mdxAxis, crossJoinElements(result), axisName)\r\n    }\r\n\r\n    function generateAxisFieldsFilter(fields) {\r\n        var filterMembers = [];\r\n        (0, _iterator.each)(fields, function(_, field) {\r\n            var dataField = field.dataField;\r\n            var filterExpression = [];\r\n            var filterValues = field.filterValues || [];\r\n            var filterStringExpression;\r\n            if (field.hierarchyName && (0, _type.isNumeric)(field.groupIndex)) {\r\n                return\r\n            }(0, _iterator.each)(filterValues, function(_, filterValue) {\r\n                var filterMdx = dataField + \".\" + preparePathValue(Array.isArray(filterValue) ? filterValue[filterValue.length - 1] : filterValue, dataField);\r\n                if (\"exclude\" === field.filterType) {\r\n                    filterExpression.push(filterMdx + \".parent\");\r\n                    filterMdx = \"Descendants(\" + filterMdx + \")\"\r\n                }\r\n                filterExpression.push(filterMdx)\r\n            });\r\n            if (filterValues.length) {\r\n                filterStringExpression = (0, _string.format)(mdxSet, filterExpression.join(\",\"));\r\n                if (\"exclude\" === field.filterType) {\r\n                    filterStringExpression = \"Except(\" + getAllMembers(field) + \",\" + filterStringExpression + \")\"\r\n                }\r\n                filterMembers.push(filterStringExpression)\r\n            }\r\n        });\r\n        return filterMembers.length ? crossJoinElements(filterMembers) : \"\"\r\n    }\r\n\r\n    function generateFrom(columnsFilter, rowsFilter, filter, cubeName) {\r\n        var from = \"[\" + cubeName + \"]\";\r\n        (0, _iterator.each)([columnsFilter, rowsFilter, filter], function(_, filter) {\r\n            if (filter) {\r\n                from = (0, _string.format)(mdxFilterSelect, filter + \"on 0\", from)\r\n            }\r\n        });\r\n        return from\r\n    }\r\n\r\n    function generateMdxCore(axisStrings, withArray, columns, rows, filters, slice, cubeName) {\r\n        var options = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : {};\r\n        var mdxString = \"\";\r\n        var withString = (withArray.length ? \"with \" + withArray.join(\" \") : \"\") + \" \";\r\n        if (axisStrings.length) {\r\n            var select;\r\n            if (options.totalsOnly) {\r\n                var countMembers = [];\r\n                if (rows.length) {\r\n                    countMembers.push(\"[DX_rows_count]\")\r\n                }\r\n                if (columns.length) {\r\n                    countMembers.push(\"[DX_columns_count]\")\r\n                }\r\n                select = \"{\".concat(countMembers.join(\",\"), \"} on columns\")\r\n            } else {\r\n                select = axisStrings.join(\",\")\r\n            }\r\n            mdxString = withString + (0, _string.format)(mdx, generateFrom(generateAxisFieldsFilter(columns), generateAxisFieldsFilter(rows), generateAxisFieldsFilter(filters || []), cubeName), slice.length ? (0, _string.format)(mdxSlice, slice.join(\",\")) : \"\", select)\r\n        }\r\n        return mdxString\r\n    }\r\n\r\n    function prepareDataFields(withArray, valueFields) {\r\n        return (0, _iterator.map)(valueFields, function(cell) {\r\n            if ((0, _type.isString)(cell.expression)) {\r\n                declare(cell.expression, withArray, cell.dataField, \"member\")\r\n            }\r\n            return cell.dataField\r\n        })\r\n    }\r\n\r\n    function addSlices(slices, options, headerName, path) {\r\n        (0, _iterator.each)(path, function(index, value) {\r\n            var dimension = options[headerName][index];\r\n            if (!dimension.hierarchyName || dimension.hierarchyName !== options[headerName][index + 1].hierarchyName) {\r\n                slices.push(dimension.dataField + \".\" + preparePathValue(value, dimension.dataField))\r\n            }\r\n        })\r\n    }\r\n\r\n    function generateMDX(options, cubeName, parseOptions) {\r\n        var columns = options.columns || [];\r\n        var rows = options.rows || [];\r\n        var values = options.values && options.values.length ? options.values : [{\r\n            dataField: \"[Measures]\"\r\n        }];\r\n        var slice = [];\r\n        var withArray = [];\r\n        var axisStrings = [];\r\n        var dataFields = prepareDataFields(withArray, values);\r\n        parseOptions.measureCount = options.skipValues ? 1 : values.length;\r\n        parseOptions.visibleLevels = {};\r\n        if (options.headerName && options.path) {\r\n            addSlices(slice, options, options.headerName, options.path)\r\n        }\r\n        if (options.headerName && options.oppositePath) {\r\n            addSlices(slice, options, \"rows\" === options.headerName ? \"columns\" : \"rows\", options.oppositePath)\r\n        }\r\n        if (columns.length || dataFields.length) {\r\n            axisStrings.push(generateAxisMdx(options, \"columns\", dataFields, withArray, parseOptions))\r\n        }\r\n        if (rows.length) {\r\n            axisStrings.push(generateAxisMdx(options, \"rows\", dataFields, withArray, parseOptions))\r\n        }\r\n        return generateMdxCore(axisStrings, withArray, columns, rows, options.filters, slice, cubeName, options)\r\n    }\r\n\r\n    function createDrillDownAxisSlice(slice, fields, path) {\r\n        (0, _iterator.each)(path, function(index, value) {\r\n            var field = fields[index];\r\n            if (field.hierarchyName && (fields[index + 1] || {}).hierarchyName === field.hierarchyName) {\r\n                return\r\n            }\r\n            slice.push(field.dataField + \".\" + preparePathValue(value, field.dataField))\r\n        })\r\n    }\r\n\r\n    function generateDrillDownMDX(options, cubeName, params) {\r\n        var columns = options.columns || [];\r\n        var rows = options.rows || [];\r\n        var values = options.values && options.values.length ? options.values : [{\r\n            dataField: \"[Measures]\"\r\n        }];\r\n        var slice = [];\r\n        var withArray = [];\r\n        var axisStrings = [];\r\n        var dataFields = prepareDataFields(withArray, values);\r\n        var maxRowCount = params.maxRowCount;\r\n        var customColumns = params.customColumns || [];\r\n        var customColumnsString = customColumns.length > 0 ? \" return \" + customColumns.join(\",\") : \"\";\r\n        createDrillDownAxisSlice(slice, columns, params.columnPath || []);\r\n        createDrillDownAxisSlice(slice, rows, params.rowPath || []);\r\n        if (columns.length || columns.length || dataFields.length) {\r\n            axisStrings.push([(dataFields[params.dataIndex] || dataFields[0]) + \" on 0\"])\r\n        }\r\n        var coreMDX = generateMdxCore(axisStrings, withArray, columns, rows, options.filters, slice, cubeName);\r\n        return coreMDX ? \"drillthrough\" + (maxRowCount > 0 ? \" maxrows \" + maxRowCount : \"\") + coreMDX + customColumnsString : coreMDX\r\n    }\r\n\r\n    function getNumber(str) {\r\n        return parseInt(str, 10)\r\n    }\r\n\r\n    function parseValue(valueText) {\r\n        return (0, _type.isNumeric)(valueText) ? parseFloat(valueText) : valueText\r\n    }\r\n\r\n    function getFirstChild(node, tagName) {\r\n        return (node.getElementsByTagName(tagName) || [])[0]\r\n    }\r\n\r\n    function getFirstChildText(node, childTagName) {\r\n        return getNodeText(getFirstChild(node, childTagName))\r\n    }\r\n\r\n    function parseAxes(xml, skipValues) {\r\n        var axes = [];\r\n        (0, _iterator.each)(xml.getElementsByTagName(\"Axis\"), function(_, axisElement) {\r\n            var name = axisElement.getAttribute(\"name\");\r\n            var axis = [];\r\n            var index = 0;\r\n            if (0 === name.indexOf(\"Axis\") && (0, _type.isNumeric)(getNumber(name.substr(4)))) {\r\n                axes.push(axis);\r\n                (0, _iterator.each)(axisElement.getElementsByTagName(\"Tuple\"), function(_, tupleElement) {\r\n                    var tupleMembers = tupleElement.childNodes;\r\n                    var tuple;\r\n                    var levelSum = 0;\r\n                    var members = [];\r\n                    var level;\r\n                    var membersCount = skipValues ? tupleMembers.length : tupleMembers.length - 1;\r\n                    var isAxisWithMeasure = 1 === axes.length;\r\n                    var i;\r\n                    if (isAxisWithMeasure) {\r\n                        membersCount--\r\n                    }\r\n                    axis.push(members);\r\n                    for (i = membersCount; i >= 0; i--) {\r\n                        tuple = tupleMembers[i];\r\n                        level = getNumber(getFirstChildText(tuple, \"LNum\"));\r\n                        members[i] = {\r\n                            caption: getFirstChildText(tuple, \"Caption\"),\r\n                            value: parseValue(getFirstChildText(tuple, \"MEMBER_VALUE\")),\r\n                            level: level,\r\n                            index: index++,\r\n                            hasValue: !levelSum && (!!level || 0 === i),\r\n                            name: getFirstChildText(tuple, \"UName\"),\r\n                            hierarchyName: tupleMembers[i].getAttribute(\"Hierarchy\"),\r\n                            parentName: getFirstChildText(tuple, \"PARENT_UNIQUE_NAME\"),\r\n                            levelName: getFirstChildText(tuple, \"LName\")\r\n                        };\r\n                        levelSum += level\r\n                    }\r\n                })\r\n            }\r\n        });\r\n        while (axes.length < 2) {\r\n            axes.push([\r\n                [{\r\n                    level: 0\r\n                }]\r\n            ])\r\n        }\r\n        return axes\r\n    }\r\n\r\n    function getNodeText(node) {\r\n        return node && node && (node.textContent || node.text || node.innerHTML) || \"\"\r\n    }\r\n\r\n    function parseCells(xml, axes, measureCount) {\r\n        var cells = [];\r\n        var cell = [];\r\n        var index = 0;\r\n        var measureIndex;\r\n        var cellsOriginal = [];\r\n        var cellElements = xml.getElementsByTagName(\"Cell\");\r\n        var errorDictionary = {};\r\n        var row;\r\n        for (var i = 0; i < cellElements.length; i++) {\r\n            var xmlCell = cellElements[i];\r\n            var valueElement = xmlCell.getElementsByTagName(\"Value\")[0];\r\n            var errorElements = valueElement && valueElement.getElementsByTagName(\"Error\") || [];\r\n            var text = 0 === errorElements.length ? getNodeText(valueElement) : \"#N/A\";\r\n            var value = parseFloat(text);\r\n            var _isNumeric = text - value + 1 > 0;\r\n            var cellOrdinal = getNumber(xmlCell.getAttribute(\"CellOrdinal\"));\r\n            if (errorElements.length) {\r\n                errorDictionary[getNodeText(errorElements[0].getElementsByTagName(\"ErrorCode\")[0])] = getNodeText(errorElements[0].getElementsByTagName(\"Description\")[0])\r\n            }\r\n            cellsOriginal[cellOrdinal] = {\r\n                value: _isNumeric ? value : text || null\r\n            }\r\n        }(0, _iterator.each)(axes[1], function() {\r\n            row = [];\r\n            cells.push(row);\r\n            (0, _iterator.each)(axes[0], function() {\r\n                measureIndex = index % measureCount;\r\n                if (0 === measureIndex) {\r\n                    cell = [];\r\n                    row.push(cell)\r\n                }\r\n                cell.push(cellsOriginal[index] ? cellsOriginal[index].value : null);\r\n                index++\r\n            })\r\n        });\r\n        Object.keys(errorDictionary).forEach(function(key) {\r\n            _errors.errors.log(\"W4002\", errorDictionary[key])\r\n        });\r\n        return cells\r\n    }\r\n\r\n    function preparePathValue(pathValue, dataField) {\r\n        if (pathValue) {\r\n            pathValue = (0, _type.isString)(pathValue) && pathValue.indexOf(\"&\") !== -1 ? pathValue : \"[\" + pathValue + \"]\";\r\n            if (dataField && 0 === pathValue.indexOf(dataField + \".\")) {\r\n                pathValue = pathValue.slice(dataField.length + 1, pathValue.length)\r\n            }\r\n        }\r\n        return pathValue\r\n    }\r\n\r\n    function getItem(hash, name, member, index) {\r\n        var item = hash[name];\r\n        if (!item) {\r\n            item = {};\r\n            hash[name] = item\r\n        }\r\n        if (!(0, _type.isDefined)(item.value) && member) {\r\n            item.text = member.caption;\r\n            item.value = member.value;\r\n            item.key = name ? name : \"\";\r\n            item.levelName = member.levelName;\r\n            item.hierarchyName = member.hierarchyName;\r\n            item.parentName = member.parentName;\r\n            item.index = index;\r\n            item.level = member.level\r\n        }\r\n        return item\r\n    }\r\n\r\n    function getVisibleChildren(item, visibleLevels) {\r\n        var result = [];\r\n        var children = item.children && (item.children.length ? item.children : Object.keys(item.children.grandTotalHash || {}).reduce(function(result, name) {\r\n            return result.concat(item.children.grandTotalHash[name].children)\r\n        }, []));\r\n        var firstChild = children && children[0];\r\n        if (firstChild && (visibleLevels[firstChild.hierarchyName] && (0, _array.inArray)(firstChild.levelName, visibleLevels[firstChild.hierarchyName]) !== -1 || !visibleLevels[firstChild.hierarchyName] || 0 === firstChild.level)) {\r\n            var newChildren = children.filter(function(child) {\r\n                return child.hierarchyName === firstChild.hierarchyName\r\n            });\r\n            newChildren.grandTotalHash = children.grandTotalHash;\r\n            return newChildren\r\n        } else {\r\n            if (firstChild) {\r\n                for (var i = 0; i < children.length; i++) {\r\n                    if (children[i].hierarchyName === firstChild.hierarchyName) {\r\n                        result.push.apply(result, getVisibleChildren(children[i], visibleLevels))\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result\r\n    }\r\n\r\n    function processMember(dataIndex, member, parentItem) {\r\n        var children = parentItem.children = parentItem.children || [];\r\n        var hash = children.hash = children.hash || {};\r\n        var grandTotalHash = children.grandTotalHash = children.grandTotalHash || {};\r\n        if (member.parentName) {\r\n            parentItem = getItem(hash, member.parentName);\r\n            children = parentItem.children = parentItem.children || []\r\n        }\r\n        var currentItem = getItem(hash, member.name, member, dataIndex);\r\n        if (member.hasValue && !currentItem.added) {\r\n            currentItem.index = dataIndex;\r\n            currentItem.added = true;\r\n            children.push(currentItem)\r\n        }\r\n        if ((!parentItem.value || !parentItem.parentName) && member.parentName) {\r\n            grandTotalHash[member.parentName] = parentItem\r\n        } else {\r\n            if (grandTotalHash[parentItem.name]) {\r\n                delete grandTotalHash[member.parentName]\r\n            }\r\n        }\r\n        return currentItem\r\n    }\r\n\r\n    function getGrandTotalIndex(parentItem, visibleLevels) {\r\n        var grandTotalIndex;\r\n        if (1 === parentItem.children.length && \"\" === parentItem.children[0].parentName) {\r\n            grandTotalIndex = parentItem.children[0].index;\r\n            var grandTotalHash = parentItem.children.grandTotalHash;\r\n            parentItem.children = parentItem.children[0].children || [];\r\n            parentItem.children.grandTotalHash = grandTotalHash;\r\n            parentItem.children = getVisibleChildren(parentItem, visibleLevels)\r\n        } else {\r\n            if (0 === parentItem.children.length) {\r\n                grandTotalIndex = 0\r\n            }\r\n        }\r\n        return grandTotalIndex\r\n    }\r\n\r\n    function fillDataSourceAxes(dataSourceAxis, axisTuples, measureCount, visibleLevels) {\r\n        var result = [];\r\n        (0, _iterator.each)(axisTuples, function(tupleIndex, members) {\r\n            var parentItem = {\r\n                children: result\r\n            };\r\n            var dataIndex = (0, _type.isDefined)(measureCount) ? Math.floor(tupleIndex / measureCount) : tupleIndex;\r\n            (0, _iterator.each)(members, function(_, member) {\r\n                parentItem = processMember(dataIndex, member, parentItem)\r\n            })\r\n        });\r\n        var parentItem = {\r\n            children: result\r\n        };\r\n        parentItem.children = getVisibleChildren(parentItem, visibleLevels);\r\n        var grandTotalIndex = getGrandTotalIndex(parentItem, visibleLevels);\r\n        (0, _uiPivot_grid.foreachTree)(parentItem.children, function(items) {\r\n            var item = items[0];\r\n            var children = getVisibleChildren(item, visibleLevels);\r\n            if (children.length) {\r\n                item.children = children\r\n            } else {\r\n                delete item.children\r\n            }\r\n            delete item.levelName;\r\n            delete item.hierarchyName;\r\n            delete item.added;\r\n            delete item.parentName;\r\n            delete item.level\r\n        }, true);\r\n        (0, _iterator.each)(parentItem.children || [], function(_, e) {\r\n            dataSourceAxis.push(e)\r\n        });\r\n        return grandTotalIndex\r\n    }\r\n\r\n    function checkError(xml) {\r\n        var faultElementNS = xml.getElementsByTagName(\"soap:Fault\");\r\n        var faultElement = xml.getElementsByTagName(\"Fault\");\r\n        var errorElement = (0, _renderer2.default)([].slice.call(faultElement.length ? faultElement : faultElementNS)).find(\"Error\");\r\n        var description;\r\n        var error;\r\n        if (errorElement.length) {\r\n            description = errorElement.attr(\"Description\");\r\n            error = new _errors.errors.Error(\"E4000\", description);\r\n            _errors.errors.log(\"E4000\", description);\r\n            return error\r\n        }\r\n        return null\r\n    }\r\n\r\n    function parseResult(xml, parseOptions) {\r\n        var dataSource = {\r\n            columns: [],\r\n            rows: []\r\n        };\r\n        var measureCount = parseOptions.measureCount;\r\n        var axes = parseAxes(xml, parseOptions.skipValues);\r\n        dataSource.grandTotalColumnIndex = fillDataSourceAxes(dataSource.columns, axes[0], measureCount, parseOptions.visibleLevels);\r\n        dataSource.grandTotalRowIndex = fillDataSourceAxes(dataSource.rows, axes[1], void 0, parseOptions.visibleLevels);\r\n        dataSource.values = parseCells(xml, axes, measureCount);\r\n        return dataSource\r\n    }\r\n\r\n    function parseDiscoverRowSet(xml, schema, dimensions, translatedDisplayFolders) {\r\n        var result = [];\r\n        var isMeasure = \"MEASURE\" === schema;\r\n        var displayFolderField = isMeasure ? \"MEASUREGROUP_NAME\" : schema + \"_DISPLAY_FOLDER\";\r\n        (0, _iterator.each)(xml.getElementsByTagName(\"row\"), function(_, row) {\r\n            var hierarchyName = \"LEVEL\" === schema ? getFirstChildText(row, \"HIERARCHY_UNIQUE_NAME\") : void 0;\r\n            var levelNumber = getFirstChildText(row, \"LEVEL_NUMBER\");\r\n            var displayFolder = getFirstChildText(row, displayFolderField);\r\n            if (isMeasure) {\r\n                displayFolder = translatedDisplayFolders[displayFolder] || displayFolder\r\n            }\r\n            if ((\"0\" !== levelNumber || \"true\" !== getFirstChildText(row, schema + \"_IS_VISIBLE\")) && getFirstChildText(row, \"DIMENSION_TYPE\") !== MD_DIMTYPE_MEASURE) {\r\n                var dimension = isMeasure ? MEASURE_DEMENSION_KEY : getFirstChildText(row, \"DIMENSION_UNIQUE_NAME\");\r\n                var dataField = getFirstChildText(row, schema + \"_UNIQUE_NAME\");\r\n                result.push({\r\n                    dimension: dimensions.names[dimension] || dimension,\r\n                    groupIndex: levelNumber ? getNumber(levelNumber) - 1 : void 0,\r\n                    dataField: dataField,\r\n                    caption: getFirstChildText(row, schema + \"_CAPTION\"),\r\n                    hierarchyName: hierarchyName,\r\n                    groupName: hierarchyName,\r\n                    displayFolder: displayFolder,\r\n                    isMeasure: isMeasure,\r\n                    isDefault: !!dimensions.defaultHierarchies[dataField]\r\n                })\r\n            }\r\n        });\r\n        return result\r\n    }\r\n\r\n    function parseMeasureGroupDiscoverRowSet(xml) {\r\n        var measureGroups = {};\r\n        (0, _iterator.each)(xml.getElementsByTagName(\"row\"), function(_, row) {\r\n            measureGroups[getFirstChildText(row, \"MEASUREGROUP_NAME\")] = getFirstChildText(row, \"MEASUREGROUP_CAPTION\")\r\n        });\r\n        return measureGroups\r\n    }\r\n\r\n    function parseDimensionsDiscoverRowSet(xml) {\r\n        var result = {\r\n            names: {},\r\n            defaultHierarchies: {}\r\n        };\r\n        (0, _iterator.each)((0, _renderer2.default)(xml).find(\"row\"), function() {\r\n            var $row = (0, _renderer2.default)(this);\r\n            var type = $row.children(\"DIMENSION_TYPE\").text();\r\n            var dimensionName = type === MD_DIMTYPE_MEASURE ? MEASURE_DEMENSION_KEY : $row.children(\"DIMENSION_UNIQUE_NAME\").text();\r\n            result.names[dimensionName] = $row.children(\"DIMENSION_CAPTION\").text();\r\n            result.defaultHierarchies[$row.children(\"DEFAULT_HIERARCHY\").text()] = true\r\n        });\r\n        return result\r\n    }\r\n\r\n    function parseStringWithUnicodeSymbols(str) {\r\n        str = str.replace(/_x(....)_/g, function(whole, group1) {\r\n            return String.fromCharCode(parseInt(group1, 16))\r\n        });\r\n        var stringArray = str.match(/\\[.+?\\]/gi);\r\n        if (stringArray && stringArray.length) {\r\n            str = stringArray[stringArray.length - 1]\r\n        }\r\n        return str.replace(/\\[/gi, \"\").replace(/\\]/gi, \"\").replace(/\\$/gi, \"\").replace(/\\./gi, \" \")\r\n    }\r\n\r\n    function parseDrillDownRowSet(xml) {\r\n        var rows = xml.getElementsByTagName(\"row\");\r\n        var result = [];\r\n        var columnNames = {};\r\n        for (var i = 0; i < rows.length; i++) {\r\n            var children = rows[i].childNodes;\r\n            var item = {};\r\n            for (var j = 0; j < children.length; j++) {\r\n                var tagName = children[j].tagName;\r\n                var name = columnNames[tagName] = columnNames[tagName] || parseStringWithUnicodeSymbols(tagName);\r\n                item[name] = getNodeText(children[j])\r\n            }\r\n            result.push(item)\r\n        }\r\n        return result\r\n    }\r\n\r\n    function sendQuery(storeOptions, mdxString) {\r\n        mdxString = (0, _renderer2.default)(\"<div>\").text(mdxString).html();\r\n        return execXMLA(storeOptions, (0, _string.format)(execute, mdxString, storeOptions.catalog, getLocaleIdProperty()))\r\n    }\r\n\r\n    function processTotalCount(data, options, totalCountXml) {\r\n        var axes = [];\r\n        var columnOptions = options.columns || [];\r\n        var rowOptions = options.rows || [];\r\n        if (columnOptions.length) {\r\n            axes.push({})\r\n        }\r\n        if (rowOptions.length) {\r\n            axes.push({})\r\n        }\r\n        var cells = parseCells(totalCountXml, [\r\n            [{}],\r\n            [{}, {}]\r\n        ], 1);\r\n        if (!columnOptions.length && rowOptions.length) {\r\n            data.rowCount = Math.max(cells[0][0][0] - 1, 0)\r\n        }\r\n        if (!rowOptions.length && columnOptions.length) {\r\n            data.columnCount = Math.max(cells[0][0][0] - 1, 0)\r\n        }\r\n        if (rowOptions.length && columnOptions.length) {\r\n            data.rowCount = Math.max(cells[0][0][0] - 1, 0);\r\n            data.columnCount = Math.max(cells[1][0][0] - 1, 0)\r\n        }\r\n        if (void 0 !== data.rowCount && options.rowTake) {\r\n            data.rows = _toConsumableArray(Array(options.rowSkip)).concat(data.rows);\r\n            data.rows.length = data.rowCount;\r\n            for (var i = 0; i < data.rows.length; i++) {\r\n                data.rows[i] = data.rows[i] || {}\r\n            }\r\n        }\r\n        if (void 0 !== data.columnCount && options.columnTake) {\r\n            data.columns = _toConsumableArray(Array(options.columnSkip)).concat(data.columns);\r\n            data.columns.length = data.columnCount;\r\n            for (var _i = 0; _i < data.columns.length; _i++) {\r\n                data.columns[_i] = data.columns[_i] || {}\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        ctor: function(options) {\r\n            this._options = options\r\n        },\r\n        getFields: function() {\r\n            var options = this._options;\r\n            var catalog = options.catalog;\r\n            var cube = options.cube;\r\n            var localeIdProperty = getLocaleIdProperty();\r\n            var dimensionsRequest = execXMLA(options, (0, _string.format)(discover, catalog, cube, \"MDSCHEMA_DIMENSIONS\", localeIdProperty));\r\n            var measuresRequest = execXMLA(options, (0, _string.format)(discover, catalog, cube, \"MDSCHEMA_MEASURES\", localeIdProperty));\r\n            var hierarchiesRequest = execXMLA(options, (0, _string.format)(discover, catalog, cube, \"MDSCHEMA_HIERARCHIES\", localeIdProperty));\r\n            var levelsRequest = execXMLA(options, (0, _string.format)(discover, catalog, cube, \"MDSCHEMA_LEVELS\", localeIdProperty));\r\n            var result = new _deferred.Deferred;\r\n            (0, _deferred.when)(dimensionsRequest, measuresRequest, hierarchiesRequest, levelsRequest).then(function(dimensionsResponse, measuresResponse, hierarchiesResponse, levelsResponse) {\r\n                execXMLA(options, (0, _string.format)(discover, catalog, cube, \"MDSCHEMA_MEASUREGROUPS\", localeIdProperty)).done(function(measureGroupsResponse) {\r\n                    var dimensions = parseDimensionsDiscoverRowSet(dimensionsResponse);\r\n                    var hierarchies = parseDiscoverRowSet(hierarchiesResponse, \"HIERARCHY\", dimensions);\r\n                    var levels = parseDiscoverRowSet(levelsResponse, \"LEVEL\", dimensions);\r\n                    var measureGroups = parseMeasureGroupDiscoverRowSet(measureGroupsResponse);\r\n                    var fields = parseDiscoverRowSet(measuresResponse, \"MEASURE\", dimensions, measureGroups).concat(hierarchies);\r\n                    var levelsByHierarchy = {};\r\n                    (0, _iterator.each)(levels, function(_, level) {\r\n                        levelsByHierarchy[level.hierarchyName] = levelsByHierarchy[level.hierarchyName] || [];\r\n                        levelsByHierarchy[level.hierarchyName].push(level)\r\n                    });\r\n                    (0, _iterator.each)(hierarchies, function(_, hierarchy) {\r\n                        if (levelsByHierarchy[hierarchy.dataField] && levelsByHierarchy[hierarchy.dataField].length > 1) {\r\n                            hierarchy.groupName = hierarchy.hierarchyName = hierarchy.dataField;\r\n                            fields.push.apply(fields, levelsByHierarchy[hierarchy.hierarchyName])\r\n                        }\r\n                    });\r\n                    result.resolve(fields)\r\n                }).fail(result.reject)\r\n            }).fail(result.reject);\r\n            return result\r\n        },\r\n        load: function load(options) {\r\n            var result = new _deferred.Deferred;\r\n            var storeOptions = this._options;\r\n            var parseOptions = {\r\n                skipValues: options.skipValues\r\n            };\r\n            var mdxString = generateMDX(options, storeOptions.cube, parseOptions);\r\n            var rowCountMdx;\r\n            if (options.rowSkip || options.rowTake || options.columnTake || options.columnSkip) {\r\n                rowCountMdx = generateMDX((0, _extend.extend)({}, options, {\r\n                    totalsOnly: true,\r\n                    rowSkip: null,\r\n                    rowTake: null,\r\n                    columnSkip: null,\r\n                    columnTake: null\r\n                }), storeOptions.cube, {})\r\n            }\r\n            var load = function() {\r\n                if (mdxString) {\r\n                    (0, _deferred.when)(sendQuery(storeOptions, mdxString), rowCountMdx && sendQuery(storeOptions, rowCountMdx)).done(function(executeXml, rowCountXml) {\r\n                        var error = checkError(executeXml) || rowCountXml && checkError(rowCountXml);\r\n                        if (!error) {\r\n                            var response = parseResult(executeXml, parseOptions);\r\n                            if (rowCountXml) {\r\n                                processTotalCount(response, options, rowCountXml)\r\n                            }\r\n                            result.resolve(response)\r\n                        } else {\r\n                            result.reject(error)\r\n                        }\r\n                    }).fail(result.reject)\r\n                } else {\r\n                    result.resolve({\r\n                        columns: [],\r\n                        rows: [],\r\n                        values: [],\r\n                        grandTotalColumnIndex: 0,\r\n                        grandTotalRowIndex: 0\r\n                    })\r\n                }\r\n            };\r\n            if (options.delay) {\r\n                setTimeout(load, options.delay)\r\n            } else {\r\n                load()\r\n            }\r\n            return result\r\n        },\r\n        supportPaging: function() {\r\n            return true\r\n        },\r\n        getDrillDownItems: function(options, params) {\r\n            var result = new _deferred.Deferred;\r\n            var storeOptions = this._options;\r\n            var mdxString = generateDrillDownMDX(options, storeOptions.cube, params);\r\n            if (mdxString) {\r\n                (0, _deferred.when)(sendQuery(storeOptions, mdxString)).done(function(executeXml) {\r\n                    var error = checkError(executeXml);\r\n                    if (!error) {\r\n                        result.resolve(parseDrillDownRowSet(executeXml))\r\n                    } else {\r\n                        result.reject(error)\r\n                    }\r\n                }).fail(result.reject)\r\n            } else {\r\n                result.resolve([])\r\n            }\r\n            return result\r\n        },\r\n        key: _common.noop,\r\n        filter: _common.noop\r\n    }\r\n}()).include(_uiPivot_grid.storeDrillDownMixin);\r\n"]},"metadata":{},"sourceType":"module"}