{"ast":null,"code":"/*\r\n* loglevel - https://github.com/pimterry/loglevel\r\n*\r\n* Copyright (c) 2013 Tim Perry\r\n* Licensed under the MIT license.\r\n*/\n(function (root, definition) {\n  \"use strict\";\n\n  if (typeof define === 'function' && define.amd) {\n    define(definition);\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = definition();\n  } else {\n    root.log = definition();\n  }\n})(this, function () {\n  \"use strict\"; // Slightly dubious tricks to cut down minimized file size\n\n  var noop = function noop() {};\n\n  var undefinedType = \"undefined\";\n  var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\n  var logMethods = [\"trace\", \"debug\", \"info\", \"warn\", \"error\"]; // Cross-browser bind equivalent that works at least back to IE6\n\n  function bindMethod(obj, methodName) {\n    var method = obj[methodName];\n\n    if (typeof method.bind === 'function') {\n      return method.bind(obj);\n    } else {\n      try {\n        return Function.prototype.bind.call(method, obj);\n      } catch (e) {\n        // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n        return function () {\n          return Function.prototype.apply.apply(method, [obj, arguments]);\n        };\n      }\n    }\n  } // Trace() doesn't print the message in IE, so for that case we need to wrap it\n\n\n  function traceForIE() {\n    if (console.log) {\n      if (console.log.apply) {\n        console.log.apply(console, arguments);\n      } else {\n        // In old IE, native console methods themselves don't have apply().\n        Function.prototype.apply.apply(console.log, [console, arguments]);\n      }\n    }\n\n    if (console.trace) console.trace();\n  } // Build the best logging method possible for this env\n  // Wherever possible we want to bind, not wrap, to preserve stack traces\n\n\n  function realMethod(methodName) {\n    if (methodName === 'debug') {\n      methodName = 'log';\n    }\n\n    if (typeof console === undefinedType) {\n      return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n    } else if (methodName === 'trace' && isIE) {\n      return traceForIE;\n    } else if (console[methodName] !== undefined) {\n      return bindMethod(console, methodName);\n    } else if (console.log !== undefined) {\n      return bindMethod(console, 'log');\n    } else {\n      return noop;\n    }\n  } // These private functions always need `this` to be set properly\n\n\n  function replaceLoggingMethods(level, loggerName) {\n    /*jshint validthis:true */\n    for (var i = 0; i < logMethods.length; i++) {\n      var methodName = logMethods[i];\n      this[methodName] = i < level ? noop : this.methodFactory(methodName, level, loggerName);\n    } // Define log.log as an alias for log.debug\n\n\n    this.log = this.debug;\n  } // In old IE versions, the console isn't present until you first open it.\n  // We build realMethod() replacements here that regenerate logging methods\n\n\n  function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n    return function () {\n      if (typeof console !== undefinedType) {\n        replaceLoggingMethods.call(this, level, loggerName);\n        this[methodName].apply(this, arguments);\n      }\n    };\n  } // By default, we use closely bound real methods wherever possible, and\n  // otherwise we wait for a console to appear, and then try again.\n\n\n  function defaultMethodFactory(methodName, level, loggerName) {\n    /*jshint validthis:true */\n    return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n  }\n\n  function Logger(name, defaultLevel, factory) {\n    var self = this;\n    var currentLevel;\n    var storageKey = \"loglevel\";\n\n    if (typeof name === \"string\") {\n      storageKey += \":\" + name;\n    } else if (typeof name === \"symbol\") {\n      storageKey = undefined;\n    }\n\n    function persistLevelIfPossible(levelNum) {\n      var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n      if (typeof window === undefinedType || !storageKey) return; // Use localStorage if available\n\n      try {\n        window.localStorage[storageKey] = levelName;\n        return;\n      } catch (ignore) {} // Use session cookie as fallback\n\n\n      try {\n        window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n      } catch (ignore) {}\n    }\n\n    function getPersistedLevel() {\n      var storedLevel;\n      if (typeof window === undefinedType || !storageKey) return;\n\n      try {\n        storedLevel = window.localStorage[storageKey];\n      } catch (ignore) {} // Fallback to cookies if local storage gives us nothing\n\n\n      if (typeof storedLevel === undefinedType) {\n        try {\n          var cookie = window.document.cookie;\n          var location = cookie.indexOf(encodeURIComponent(storageKey) + \"=\");\n\n          if (location !== -1) {\n            storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n          }\n        } catch (ignore) {}\n      } // If the stored level is not valid, treat it as if nothing was stored.\n\n\n      if (self.levels[storedLevel] === undefined) {\n        storedLevel = undefined;\n      }\n\n      return storedLevel;\n    }\n    /*\r\n     *\r\n     * Public logger API - see https://github.com/pimterry/loglevel for details\r\n     *\r\n     */\n\n\n    self.name = name;\n    self.levels = {\n      \"TRACE\": 0,\n      \"DEBUG\": 1,\n      \"INFO\": 2,\n      \"WARN\": 3,\n      \"ERROR\": 4,\n      \"SILENT\": 5\n    };\n    self.methodFactory = factory || defaultMethodFactory;\n\n    self.getLevel = function () {\n      return currentLevel;\n    };\n\n    self.setLevel = function (level, persist) {\n      if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n        level = self.levels[level.toUpperCase()];\n      }\n\n      if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n        currentLevel = level;\n\n        if (persist !== false) {\n          // defaults to true\n          persistLevelIfPossible(level);\n        }\n\n        replaceLoggingMethods.call(self, level, name);\n\n        if (typeof console === undefinedType && level < self.levels.SILENT) {\n          return \"No console available for logging\";\n        }\n      } else {\n        throw \"log.setLevel() called with invalid level: \" + level;\n      }\n    };\n\n    self.setDefaultLevel = function (level) {\n      if (!getPersistedLevel()) {\n        self.setLevel(level, false);\n      }\n    };\n\n    self.enableAll = function (persist) {\n      self.setLevel(self.levels.TRACE, persist);\n    };\n\n    self.disableAll = function (persist) {\n      self.setLevel(self.levels.SILENT, persist);\n    }; // Initialize with the right level\n\n\n    var initialLevel = getPersistedLevel();\n\n    if (initialLevel == null) {\n      initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n    }\n\n    self.setLevel(initialLevel, false);\n  }\n  /*\r\n   *\r\n   * Top-level API\r\n   *\r\n   */\n\n\n  var defaultLogger = new Logger();\n  var _loggersByName = {};\n\n  defaultLogger.getLogger = function getLogger(name) {\n    if (typeof name !== \"symbol\" && typeof name !== \"string\" || name === \"\") {\n      throw new TypeError(\"You must supply a name when creating a logger.\");\n    }\n\n    var logger = _loggersByName[name];\n\n    if (!logger) {\n      logger = _loggersByName[name] = new Logger(name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n    }\n\n    return logger;\n  }; // Grab the current global log variable in case of overwrite\n\n\n  var _log = typeof window !== undefinedType ? window.log : undefined;\n\n  defaultLogger.noConflict = function () {\n    if (typeof window !== undefinedType && window.log === defaultLogger) {\n      window.log = _log;\n    }\n\n    return defaultLogger;\n  };\n\n  defaultLogger.getLoggers = function getLoggers() {\n    return _loggersByName;\n  }; // ES6 default export, for compatibility\n\n\n  defaultLogger['default'] = defaultLogger;\n  return defaultLogger;\n});","map":{"version":3,"sources":["C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/loglevel/lib/loglevel.js"],"names":["define","module","definition","root","noop","undefinedType","isIE","window","logMethods","method","obj","Function","console","methodName","bindMethod","i","replaceLoggingMethods","realMethod","enableLoggingWhenConsoleArrives","self","storageKey","levelName","encodeURIComponent","storedLevel","cookie","location","factory","level","currentLevel","persist","persistLevelIfPossible","getPersistedLevel","initialLevel","defaultLevel","defaultLogger","_loggersByName","name","logger","_log"],"mappings":"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","sourcesContent":["/*\r\n* loglevel - https://github.com/pimterry/loglevel\r\n*\r\n* Copyright (c) 2013 Tim Perry\r\n* Licensed under the MIT license.\r\n*/\r\n(function (root, definition) {\r\n    \"use strict\";\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(definition);\r\n    } else if (typeof module === 'object' && module.exports) {\r\n        module.exports = definition();\r\n    } else {\r\n        root.log = definition();\r\n    }\r\n}(this, function () {\r\n    \"use strict\";\r\n\r\n    // Slightly dubious tricks to cut down minimized file size\r\n    var noop = function() {};\r\n    var undefinedType = \"undefined\";\r\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\r\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\r\n    );\r\n\r\n    var logMethods = [\r\n        \"trace\",\r\n        \"debug\",\r\n        \"info\",\r\n        \"warn\",\r\n        \"error\"\r\n    ];\r\n\r\n    // Cross-browser bind equivalent that works at least back to IE6\r\n    function bindMethod(obj, methodName) {\r\n        var method = obj[methodName];\r\n        if (typeof method.bind === 'function') {\r\n            return method.bind(obj);\r\n        } else {\r\n            try {\r\n                return Function.prototype.bind.call(method, obj);\r\n            } catch (e) {\r\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\r\n                return function() {\r\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\r\n    function traceForIE() {\r\n        if (console.log) {\r\n            if (console.log.apply) {\r\n                console.log.apply(console, arguments);\r\n            } else {\r\n                // In old IE, native console methods themselves don't have apply().\r\n                Function.prototype.apply.apply(console.log, [console, arguments]);\r\n            }\r\n        }\r\n        if (console.trace) console.trace();\r\n    }\r\n\r\n    // Build the best logging method possible for this env\r\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\r\n    function realMethod(methodName) {\r\n        if (methodName === 'debug') {\r\n            methodName = 'log';\r\n        }\r\n\r\n        if (typeof console === undefinedType) {\r\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\r\n        } else if (methodName === 'trace' && isIE) {\r\n            return traceForIE;\r\n        } else if (console[methodName] !== undefined) {\r\n            return bindMethod(console, methodName);\r\n        } else if (console.log !== undefined) {\r\n            return bindMethod(console, 'log');\r\n        } else {\r\n            return noop;\r\n        }\r\n    }\r\n\r\n    // These private functions always need `this` to be set properly\r\n\r\n    function replaceLoggingMethods(level, loggerName) {\r\n        /*jshint validthis:true */\r\n        for (var i = 0; i < logMethods.length; i++) {\r\n            var methodName = logMethods[i];\r\n            this[methodName] = (i < level) ?\r\n                noop :\r\n                this.methodFactory(methodName, level, loggerName);\r\n        }\r\n\r\n        // Define log.log as an alias for log.debug\r\n        this.log = this.debug;\r\n    }\r\n\r\n    // In old IE versions, the console isn't present until you first open it.\r\n    // We build realMethod() replacements here that regenerate logging methods\r\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\r\n        return function () {\r\n            if (typeof console !== undefinedType) {\r\n                replaceLoggingMethods.call(this, level, loggerName);\r\n                this[methodName].apply(this, arguments);\r\n            }\r\n        };\r\n    }\r\n\r\n    // By default, we use closely bound real methods wherever possible, and\r\n    // otherwise we wait for a console to appear, and then try again.\r\n    function defaultMethodFactory(methodName, level, loggerName) {\r\n        /*jshint validthis:true */\r\n        return realMethod(methodName) ||\r\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\r\n    }\r\n\r\n    function Logger(name, defaultLevel, factory) {\r\n      var self = this;\r\n      var currentLevel;\r\n\r\n      var storageKey = \"loglevel\";\r\n      if (typeof name === \"string\") {\r\n        storageKey += \":\" + name;\r\n      } else if (typeof name === \"symbol\") {\r\n        storageKey = undefined;\r\n      }\r\n\r\n      function persistLevelIfPossible(levelNum) {\r\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\r\n\r\n          if (typeof window === undefinedType || !storageKey) return;\r\n\r\n          // Use localStorage if available\r\n          try {\r\n              window.localStorage[storageKey] = levelName;\r\n              return;\r\n          } catch (ignore) {}\r\n\r\n          // Use session cookie as fallback\r\n          try {\r\n              window.document.cookie =\r\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\r\n          } catch (ignore) {}\r\n      }\r\n\r\n      function getPersistedLevel() {\r\n          var storedLevel;\r\n\r\n          if (typeof window === undefinedType || !storageKey) return;\r\n\r\n          try {\r\n              storedLevel = window.localStorage[storageKey];\r\n          } catch (ignore) {}\r\n\r\n          // Fallback to cookies if local storage gives us nothing\r\n          if (typeof storedLevel === undefinedType) {\r\n              try {\r\n                  var cookie = window.document.cookie;\r\n                  var location = cookie.indexOf(\r\n                      encodeURIComponent(storageKey) + \"=\");\r\n                  if (location !== -1) {\r\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\r\n                  }\r\n              } catch (ignore) {}\r\n          }\r\n\r\n          // If the stored level is not valid, treat it as if nothing was stored.\r\n          if (self.levels[storedLevel] === undefined) {\r\n              storedLevel = undefined;\r\n          }\r\n\r\n          return storedLevel;\r\n      }\r\n\r\n      /*\r\n       *\r\n       * Public logger API - see https://github.com/pimterry/loglevel for details\r\n       *\r\n       */\r\n\r\n      self.name = name;\r\n\r\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\r\n          \"ERROR\": 4, \"SILENT\": 5};\r\n\r\n      self.methodFactory = factory || defaultMethodFactory;\r\n\r\n      self.getLevel = function () {\r\n          return currentLevel;\r\n      };\r\n\r\n      self.setLevel = function (level, persist) {\r\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\r\n              level = self.levels[level.toUpperCase()];\r\n          }\r\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\r\n              currentLevel = level;\r\n              if (persist !== false) {  // defaults to true\r\n                  persistLevelIfPossible(level);\r\n              }\r\n              replaceLoggingMethods.call(self, level, name);\r\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\r\n                  return \"No console available for logging\";\r\n              }\r\n          } else {\r\n              throw \"log.setLevel() called with invalid level: \" + level;\r\n          }\r\n      };\r\n\r\n      self.setDefaultLevel = function (level) {\r\n          if (!getPersistedLevel()) {\r\n              self.setLevel(level, false);\r\n          }\r\n      };\r\n\r\n      self.enableAll = function(persist) {\r\n          self.setLevel(self.levels.TRACE, persist);\r\n      };\r\n\r\n      self.disableAll = function(persist) {\r\n          self.setLevel(self.levels.SILENT, persist);\r\n      };\r\n\r\n      // Initialize with the right level\r\n      var initialLevel = getPersistedLevel();\r\n      if (initialLevel == null) {\r\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\r\n      }\r\n      self.setLevel(initialLevel, false);\r\n    }\r\n\r\n    /*\r\n     *\r\n     * Top-level API\r\n     *\r\n     */\r\n\r\n    var defaultLogger = new Logger();\r\n\r\n    var _loggersByName = {};\r\n    defaultLogger.getLogger = function getLogger(name) {\r\n        if ((typeof name !== \"symbol\" && typeof name !== \"string\") || name === \"\") {\r\n          throw new TypeError(\"You must supply a name when creating a logger.\");\r\n        }\r\n\r\n        var logger = _loggersByName[name];\r\n        if (!logger) {\r\n          logger = _loggersByName[name] = new Logger(\r\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\r\n        }\r\n        return logger;\r\n    };\r\n\r\n    // Grab the current global log variable in case of overwrite\r\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\r\n    defaultLogger.noConflict = function() {\r\n        if (typeof window !== undefinedType &&\r\n               window.log === defaultLogger) {\r\n            window.log = _log;\r\n        }\r\n\r\n        return defaultLogger;\r\n    };\r\n\r\n    defaultLogger.getLoggers = function getLoggers() {\r\n        return _loggersByName;\r\n    };\r\n\r\n    // ES6 default export, for compatibility\r\n    defaultLogger['default'] = defaultLogger;\r\n\r\n    return defaultLogger;\r\n}));\r\n"]},"metadata":{},"sourceType":"module"}