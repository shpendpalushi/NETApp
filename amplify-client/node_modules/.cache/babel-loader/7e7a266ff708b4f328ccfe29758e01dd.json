{"ast":null,"code":"/**\r\n * DevExtreme (ui/number_box/number_box.caret.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar fitIntoRange = require(\"../../core/utils/math\").fitIntoRange;\n\nvar escapeRegExp = require(\"../../core/utils/common\").escapeRegExp;\n\nvar number = require(\"../../localization/number\");\n\nvar getCaretBoundaries = function getCaretBoundaries(text, format) {\n  var signParts = format.split(\";\");\n  var sign = number.getSign(text, format);\n  signParts[1] = signParts[1] || \"-\" + signParts[0];\n  format = signParts[sign < 0 ? 1 : 0];\n\n  var mockEscapedStubs = function mockEscapedStubs(str) {\n    return str.replace(/'([^']*)'/g, function (str) {\n      return str.split(\"\").map(function () {\n        return \" \";\n      }).join(\"\").substr(2);\n    });\n  };\n\n  format = mockEscapedStubs(format);\n  var prefixStubLength = /^[^#0.,]*/.exec(format)[0].length;\n  var postfixStubLength = /[^#0.,]*$/.exec(format)[0].length;\n  return {\n    start: prefixStubLength,\n    end: text.length - postfixStubLength\n  };\n};\n\nvar _getDigitCountBeforeIndex = function _getDigitCountBeforeIndex(index, text) {\n  var decimalSeparator = number.getDecimalSeparator();\n  var regExp = new RegExp(\"[^0-9\" + escapeRegExp(decimalSeparator) + \"]\", \"g\");\n  var textBeforePosition = text.slice(0, index);\n  return textBeforePosition.replace(regExp, \"\").length;\n};\n\nvar _reverseText = function _reverseText(text) {\n  return text.split(\"\").reverse().join(\"\");\n};\n\nvar _getDigitPositionByIndex = function _getDigitPositionByIndex(digitIndex, text) {\n  if (!digitIndex) {\n    return -1;\n  }\n\n  var regExp = /[0-9]/g;\n  var counter = 1;\n  var index = null;\n  var result = regExp.exec(text);\n\n  while (result) {\n    index = result.index;\n\n    if (!digitIndex || counter >= digitIndex) {\n      return index;\n    }\n\n    counter++;\n    result = regExp.exec(text);\n  }\n\n  return null === index ? text.length : index;\n};\n\nvar getCaretWithOffset = function getCaretWithOffset(caret, offset) {\n  if (void 0 === caret.start) {\n    caret = {\n      start: caret,\n      end: caret\n    };\n  }\n\n  return {\n    start: caret.start + offset,\n    end: caret.end + offset\n  };\n};\n\nvar getCaretAfterFormat = function getCaretAfterFormat(text, formatted, caret, format) {\n  caret = getCaretWithOffset(caret, 0);\n  var point = number.getDecimalSeparator();\n  var isSeparatorBasedText = isSeparatorBasedString(text);\n  var pointPosition = isSeparatorBasedText ? 0 : text.indexOf(point);\n  var newPointPosition = formatted.indexOf(point);\n  var textParts = isSeparatorBasedText ? text.split(text[pointPosition]) : text.split(point);\n  var formattedParts = formatted.split(point);\n  var isCaretOnFloat = pointPosition !== -1 && caret.start > pointPosition;\n\n  if (isCaretOnFloat) {\n    var relativeIndex = caret.start - pointPosition - 1;\n\n    var digitsBefore = _getDigitCountBeforeIndex(relativeIndex, textParts[1]);\n\n    var newPosition = formattedParts[1] ? newPointPosition + 1 + _getDigitPositionByIndex(digitsBefore, formattedParts[1]) + 1 : formatted.length;\n    return getCaretInBoundaries(newPosition, formatted, format);\n  } else {\n    var positionFromEnd = textParts[0].length - caret.start;\n\n    var digitsFromEnd = _getDigitCountBeforeIndex(positionFromEnd, _reverseText(textParts[0]));\n\n    var newPositionFromEnd = _getDigitPositionByIndex(digitsFromEnd, _reverseText(formattedParts[0]));\n\n    var newPositionFromBegin = formattedParts[0].length - (newPositionFromEnd + 1);\n    return getCaretInBoundaries(newPositionFromBegin, formatted, format);\n  }\n};\n\nvar isSeparatorBasedString = function isSeparatorBasedString(text) {\n  return 1 === text.length && !!text.match(/^[,.][0-9]*$/g);\n};\n\nvar isCaretInBoundaries = function isCaretInBoundaries(caret, text, format) {\n  caret = getCaretWithOffset(caret, 0);\n  var boundaries = getCaretInBoundaries(caret, text, format);\n  return caret.start >= boundaries.start && caret.end <= boundaries.end;\n};\n\nvar getCaretInBoundaries = function getCaretInBoundaries(caret, text, format) {\n  caret = getCaretWithOffset(caret, 0);\n  var boundaries = getCaretBoundaries(text, format);\n  var adjustedCaret = {\n    start: fitIntoRange(caret.start, boundaries.start, boundaries.end),\n    end: fitIntoRange(caret.end, boundaries.start, boundaries.end)\n  };\n  return adjustedCaret;\n};\n\nvar getCaretOffset = function getCaretOffset(previousText, newText, format) {\n  var previousBoundaries = getCaretBoundaries(previousText, format);\n  var newBoundaries = getCaretBoundaries(newText, format);\n  return newBoundaries.start - previousBoundaries.start;\n};\n\nexports.getCaretBoundaries = getCaretBoundaries;\nexports.isCaretInBoundaries = isCaretInBoundaries;\nexports.getCaretWithOffset = getCaretWithOffset;\nexports.getCaretInBoundaries = getCaretInBoundaries;\nexports.getCaretAfterFormat = getCaretAfterFormat;\nexports.getCaretOffset = getCaretOffset;","map":{"version":3,"sources":["C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/devextreme/ui/number_box/number_box.caret.js"],"names":["fitIntoRange","require","escapeRegExp","number","getCaretBoundaries","signParts","format","sign","mockEscapedStubs","prefixStubLength","postfixStubLength","start","end","text","_getDigitCountBeforeIndex","decimalSeparator","regExp","textBeforePosition","_reverseText","_getDigitPositionByIndex","counter","index","result","getCaretWithOffset","caret","offset","getCaretAfterFormat","point","isSeparatorBasedText","isSeparatorBasedString","pointPosition","newPointPosition","formatted","textParts","formattedParts","isCaretOnFloat","relativeIndex","digitsBefore","newPosition","getCaretInBoundaries","positionFromEnd","digitsFromEnd","newPositionFromEnd","newPositionFromBegin","isCaretInBoundaries","boundaries","adjustedCaret","getCaretOffset","previousBoundaries","newBoundaries","exports"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (ui/number_box/number_box.caret.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nvar fitIntoRange = require(\"../../core/utils/math\").fitIntoRange;\r\nvar escapeRegExp = require(\"../../core/utils/common\").escapeRegExp;\r\nvar number = require(\"../../localization/number\");\r\nvar getCaretBoundaries = function(text, format) {\r\n    var signParts = format.split(\";\");\r\n    var sign = number.getSign(text, format);\r\n    signParts[1] = signParts[1] || \"-\" + signParts[0];\r\n    format = signParts[sign < 0 ? 1 : 0];\r\n    var mockEscapedStubs = function(str) {\r\n        return str.replace(/'([^']*)'/g, function(str) {\r\n            return str.split(\"\").map(function() {\r\n                return \" \"\r\n            }).join(\"\").substr(2)\r\n        })\r\n    };\r\n    format = mockEscapedStubs(format);\r\n    var prefixStubLength = /^[^#0.,]*/.exec(format)[0].length;\r\n    var postfixStubLength = /[^#0.,]*$/.exec(format)[0].length;\r\n    return {\r\n        start: prefixStubLength,\r\n        end: text.length - postfixStubLength\r\n    }\r\n};\r\nvar _getDigitCountBeforeIndex = function(index, text) {\r\n    var decimalSeparator = number.getDecimalSeparator();\r\n    var regExp = new RegExp(\"[^0-9\" + escapeRegExp(decimalSeparator) + \"]\", \"g\");\r\n    var textBeforePosition = text.slice(0, index);\r\n    return textBeforePosition.replace(regExp, \"\").length\r\n};\r\nvar _reverseText = function(text) {\r\n    return text.split(\"\").reverse().join(\"\")\r\n};\r\nvar _getDigitPositionByIndex = function(digitIndex, text) {\r\n    if (!digitIndex) {\r\n        return -1\r\n    }\r\n    var regExp = /[0-9]/g;\r\n    var counter = 1;\r\n    var index = null;\r\n    var result = regExp.exec(text);\r\n    while (result) {\r\n        index = result.index;\r\n        if (!digitIndex || counter >= digitIndex) {\r\n            return index\r\n        }\r\n        counter++;\r\n        result = regExp.exec(text)\r\n    }\r\n    return null === index ? text.length : index\r\n};\r\nvar getCaretWithOffset = function(caret, offset) {\r\n    if (void 0 === caret.start) {\r\n        caret = {\r\n            start: caret,\r\n            end: caret\r\n        }\r\n    }\r\n    return {\r\n        start: caret.start + offset,\r\n        end: caret.end + offset\r\n    }\r\n};\r\nvar getCaretAfterFormat = function(text, formatted, caret, format) {\r\n    caret = getCaretWithOffset(caret, 0);\r\n    var point = number.getDecimalSeparator();\r\n    var isSeparatorBasedText = isSeparatorBasedString(text);\r\n    var pointPosition = isSeparatorBasedText ? 0 : text.indexOf(point);\r\n    var newPointPosition = formatted.indexOf(point);\r\n    var textParts = isSeparatorBasedText ? text.split(text[pointPosition]) : text.split(point);\r\n    var formattedParts = formatted.split(point);\r\n    var isCaretOnFloat = pointPosition !== -1 && caret.start > pointPosition;\r\n    if (isCaretOnFloat) {\r\n        var relativeIndex = caret.start - pointPosition - 1;\r\n        var digitsBefore = _getDigitCountBeforeIndex(relativeIndex, textParts[1]);\r\n        var newPosition = formattedParts[1] ? newPointPosition + 1 + _getDigitPositionByIndex(digitsBefore, formattedParts[1]) + 1 : formatted.length;\r\n        return getCaretInBoundaries(newPosition, formatted, format)\r\n    } else {\r\n        var positionFromEnd = textParts[0].length - caret.start;\r\n        var digitsFromEnd = _getDigitCountBeforeIndex(positionFromEnd, _reverseText(textParts[0]));\r\n        var newPositionFromEnd = _getDigitPositionByIndex(digitsFromEnd, _reverseText(formattedParts[0]));\r\n        var newPositionFromBegin = formattedParts[0].length - (newPositionFromEnd + 1);\r\n        return getCaretInBoundaries(newPositionFromBegin, formatted, format)\r\n    }\r\n};\r\nvar isSeparatorBasedString = function(text) {\r\n    return 1 === text.length && !!text.match(/^[,.][0-9]*$/g)\r\n};\r\nvar isCaretInBoundaries = function(caret, text, format) {\r\n    caret = getCaretWithOffset(caret, 0);\r\n    var boundaries = getCaretInBoundaries(caret, text, format);\r\n    return caret.start >= boundaries.start && caret.end <= boundaries.end\r\n};\r\nvar getCaretInBoundaries = function(caret, text, format) {\r\n    caret = getCaretWithOffset(caret, 0);\r\n    var boundaries = getCaretBoundaries(text, format);\r\n    var adjustedCaret = {\r\n        start: fitIntoRange(caret.start, boundaries.start, boundaries.end),\r\n        end: fitIntoRange(caret.end, boundaries.start, boundaries.end)\r\n    };\r\n    return adjustedCaret\r\n};\r\nvar getCaretOffset = function(previousText, newText, format) {\r\n    var previousBoundaries = getCaretBoundaries(previousText, format);\r\n    var newBoundaries = getCaretBoundaries(newText, format);\r\n    return newBoundaries.start - previousBoundaries.start\r\n};\r\nexports.getCaretBoundaries = getCaretBoundaries;\r\nexports.isCaretInBoundaries = isCaretInBoundaries;\r\nexports.getCaretWithOffset = getCaretWithOffset;\r\nexports.getCaretInBoundaries = getCaretInBoundaries;\r\nexports.getCaretAfterFormat = getCaretAfterFormat;\r\nexports.getCaretOffset = getCaretOffset;\r\n"]},"metadata":{},"sourceType":"module"}