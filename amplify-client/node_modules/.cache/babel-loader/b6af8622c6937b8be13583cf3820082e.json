{"ast":null,"code":"'use strict';\n/* global self */\n\nvar url = require('url');\n\nvar getCurrentScriptSource = require('./getCurrentScriptSource');\n\nfunction createSocketUrl(resourceQuery, currentLocation) {\n  var urlParts;\n\n  if (typeof resourceQuery === 'string' && resourceQuery !== '') {\n    // If this bundle is inlined, use the resource query to get the correct url.\n    // format is like `?http://0.0.0.0:8096&sockPort=8097&sockHost=localhost`\n    urlParts = url.parse(resourceQuery // strip leading `?` from query string to get a valid URL\n    .substr(1) // replace first `&` with `?` to have a valid query string\n    .replace('&', '?'), true);\n  } else {\n    // Else, get the url from the <script> this file was called with.\n    var scriptHost = getCurrentScriptSource();\n    urlParts = url.parse(scriptHost || '/', true, true);\n  } // Use parameter to allow passing location in unit tests\n\n\n  if (typeof currentLocation === 'string' && currentLocation !== '') {\n    currentLocation = url.parse(currentLocation);\n  } else {\n    currentLocation = self.location;\n  }\n\n  return getSocketUrl(urlParts, currentLocation);\n}\n/*\r\n * Gets socket URL based on Script Source/Location\r\n * (scriptSrc: URL, location: URL) -> URL\r\n */\n\n\nfunction getSocketUrl(urlParts, loc) {\n  var auth = urlParts.auth,\n      query = urlParts.query;\n  var hostname = urlParts.hostname,\n      protocol = urlParts.protocol,\n      port = urlParts.port;\n\n  if (!port || port === '0') {\n    port = loc.port;\n  } // check ipv4 and ipv6 `all hostname`\n  // why do we need this check?\n  // hostname n/a for file protocol (example, when using electron, ionic)\n  // see: https://github.com/webpack/webpack-dev-server/pull/384\n\n\n  if ((hostname === '0.0.0.0' || hostname === '::') && loc.hostname && loc.protocol.indexOf('http') === 0) {\n    hostname = loc.hostname;\n  } // `hostname` can be empty when the script path is relative. In that case, specifying\n  // a protocol would result in an invalid URL.\n  // When https is used in the app, secure websockets are always necessary\n  // because the browser doesn't accept non-secure websockets.\n\n\n  if (hostname && hostname !== '127.0.0.1' && (loc.protocol === 'https:' || urlParts.hostname === '0.0.0.0')) {\n    protocol = loc.protocol;\n  } // all of these sock url params are optionally passed in through\n  // resourceQuery, so we need to fall back to the default if\n  // they are not provided\n\n\n  var sockHost = query.sockHost || hostname;\n  var sockPath = query.sockPath || '/sockjs-node';\n  var sockPort = query.sockPort || port;\n\n  if (sockPort === 'location') {\n    sockPort = loc.port;\n  }\n\n  return url.format({\n    protocol: protocol,\n    auth: auth,\n    hostname: sockHost,\n    port: sockPort,\n    // If sockPath is provided it'll be passed in via the resourceQuery as a\n    // query param so it has to be parsed out of the querystring in order for the\n    // client to open the socket to the correct location.\n    pathname: sockPath\n  });\n}\n\nmodule.exports = createSocketUrl;","map":{"version":3,"sources":["C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/webpack-dev-server/client/utils/createSocketUrl.js"],"names":["url","require","getCurrentScriptSource","resourceQuery","urlParts","scriptHost","currentLocation","self","getSocketUrl","auth","query","hostname","protocol","port","loc","sockHost","sockPath","sockPort","pathname","module"],"mappings":"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","sourcesContent":["'use strict';\r\n/* global self */\r\n\r\nvar url = require('url');\r\n\r\nvar getCurrentScriptSource = require('./getCurrentScriptSource');\r\n\r\nfunction createSocketUrl(resourceQuery, currentLocation) {\r\n  var urlParts;\r\n\r\n  if (typeof resourceQuery === 'string' && resourceQuery !== '') {\r\n    // If this bundle is inlined, use the resource query to get the correct url.\r\n    // format is like `?http://0.0.0.0:8096&sockPort=8097&sockHost=localhost`\r\n    urlParts = url.parse(resourceQuery // strip leading `?` from query string to get a valid URL\r\n    .substr(1) // replace first `&` with `?` to have a valid query string\r\n    .replace('&', '?'), true);\r\n  } else {\r\n    // Else, get the url from the <script> this file was called with.\r\n    var scriptHost = getCurrentScriptSource();\r\n    urlParts = url.parse(scriptHost || '/', true, true);\r\n  } // Use parameter to allow passing location in unit tests\r\n\r\n\r\n  if (typeof currentLocation === 'string' && currentLocation !== '') {\r\n    currentLocation = url.parse(currentLocation);\r\n  } else {\r\n    currentLocation = self.location;\r\n  }\r\n\r\n  return getSocketUrl(urlParts, currentLocation);\r\n}\r\n/*\r\n * Gets socket URL based on Script Source/Location\r\n * (scriptSrc: URL, location: URL) -> URL\r\n */\r\n\r\n\r\nfunction getSocketUrl(urlParts, loc) {\r\n  var auth = urlParts.auth,\r\n      query = urlParts.query;\r\n  var hostname = urlParts.hostname,\r\n      protocol = urlParts.protocol,\r\n      port = urlParts.port;\r\n\r\n  if (!port || port === '0') {\r\n    port = loc.port;\r\n  } // check ipv4 and ipv6 `all hostname`\r\n  // why do we need this check?\r\n  // hostname n/a for file protocol (example, when using electron, ionic)\r\n  // see: https://github.com/webpack/webpack-dev-server/pull/384\r\n\r\n\r\n  if ((hostname === '0.0.0.0' || hostname === '::') && loc.hostname && loc.protocol.indexOf('http') === 0) {\r\n    hostname = loc.hostname;\r\n  } // `hostname` can be empty when the script path is relative. In that case, specifying\r\n  // a protocol would result in an invalid URL.\r\n  // When https is used in the app, secure websockets are always necessary\r\n  // because the browser doesn't accept non-secure websockets.\r\n\r\n\r\n  if (hostname && hostname !== '127.0.0.1' && (loc.protocol === 'https:' || urlParts.hostname === '0.0.0.0')) {\r\n    protocol = loc.protocol;\r\n  } // all of these sock url params are optionally passed in through\r\n  // resourceQuery, so we need to fall back to the default if\r\n  // they are not provided\r\n\r\n\r\n  var sockHost = query.sockHost || hostname;\r\n  var sockPath = query.sockPath || '/sockjs-node';\r\n  var sockPort = query.sockPort || port;\r\n\r\n  if (sockPort === 'location') {\r\n    sockPort = loc.port;\r\n  }\r\n\r\n  return url.format({\r\n    protocol: protocol,\r\n    auth: auth,\r\n    hostname: sockHost,\r\n    port: sockPort,\r\n    // If sockPath is provided it'll be passed in via the resourceQuery as a\r\n    // query param so it has to be parsed out of the querystring in order for the\r\n    // client to open the socket to the correct location.\r\n    pathname: sockPath\r\n  });\r\n}\r\n\r\nmodule.exports = createSocketUrl;"]},"metadata":{},"sourceType":"module"}