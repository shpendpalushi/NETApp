{"ast":null,"code":"/**\r\n * DevExtreme (animation/position.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\n\"use strict\";\n\nvar $ = require(\"../core/renderer\");\n\nvar commonUtils = require(\"../core/utils/common\");\n\nvar each = require(\"../core/utils/iterator\").each;\n\nvar windowUtils = require(\"../core/utils/window\");\n\nvar window = windowUtils.getWindow();\n\nvar domAdapter = require(\"../core/dom_adapter\");\n\nvar isWindow = require(\"../core/utils/type\").isWindow;\n\nvar extend = require(\"../core/utils/extend\").extend;\n\nvar browser = require(\"../core/utils/browser\");\n\nvar translator = require(\"./translator\");\n\nvar support = require(\"../core/utils/support\");\n\nvar horzRe = /left|right/;\nvar vertRe = /top|bottom/;\nvar collisionRe = /fit|flip|none/;\nvar IS_SAFARI = browser.safari;\n\nvar normalizeAlign = function normalizeAlign(raw) {\n  var result = {\n    h: \"center\",\n    v: \"center\"\n  };\n  var pair = commonUtils.splitPair(raw);\n\n  if (pair) {\n    each(pair, function () {\n      var w = String(this).toLowerCase();\n\n      if (horzRe.test(w)) {\n        result.h = w;\n      } else {\n        if (vertRe.test(w)) {\n          result.v = w;\n        }\n      }\n    });\n  }\n\n  return result;\n};\n\nvar normalizeOffset = function normalizeOffset(raw) {\n  return commonUtils.pairToObject(raw);\n};\n\nvar normalizeCollision = function normalizeCollision(raw) {\n  var pair = commonUtils.splitPair(raw);\n  var h = String(pair && pair[0]).toLowerCase();\n  var v = String(pair && pair[1]).toLowerCase();\n\n  if (!collisionRe.test(h)) {\n    h = \"none\";\n  }\n\n  if (!collisionRe.test(v)) {\n    v = h;\n  }\n\n  return {\n    h: h,\n    v: v\n  };\n};\n\nvar getAlignFactor = function getAlignFactor(align) {\n  switch (align) {\n    case \"center\":\n      return .5;\n\n    case \"right\":\n    case \"bottom\":\n      return 1;\n\n    default:\n      return 0;\n  }\n};\n\nvar inverseAlign = function inverseAlign(align) {\n  switch (align) {\n    case \"left\":\n      return \"right\";\n\n    case \"right\":\n      return \"left\";\n\n    case \"top\":\n      return \"bottom\";\n\n    case \"bottom\":\n      return \"top\";\n\n    default:\n      return align;\n  }\n};\n\nvar calculateOversize = function calculateOversize(data, bounds) {\n  var oversize = 0;\n\n  if (data.myLocation < bounds.min) {\n    oversize += bounds.min - data.myLocation;\n  }\n\n  if (data.myLocation > bounds.max) {\n    oversize += data.myLocation - bounds.max;\n  }\n\n  return oversize;\n};\n\nvar collisionSide = function collisionSide(direction, data, bounds) {\n  if (data.myLocation < bounds.min) {\n    return \"h\" === direction ? \"left\" : \"top\";\n  }\n\n  if (data.myLocation > bounds.max) {\n    return \"h\" === direction ? \"right\" : \"bottom\";\n  }\n\n  return \"none\";\n};\n\nvar initMyLocation = function initMyLocation(data) {\n  data.myLocation = data.atLocation + getAlignFactor(data.atAlign) * data.atSize - getAlignFactor(data.myAlign) * data.mySize + data.offset;\n};\n\nvar collisionResolvers = {\n  fit: function fit(data, bounds) {\n    var result = false;\n\n    if (data.myLocation > bounds.max) {\n      data.myLocation = bounds.max;\n      result = true;\n    }\n\n    if (data.myLocation < bounds.min) {\n      data.myLocation = bounds.min;\n      result = true;\n    }\n\n    data.fit = result;\n  },\n  flip: function flip(data, bounds) {\n    data.flip = false;\n\n    if (\"center\" === data.myAlign && \"center\" === data.atAlign) {\n      return;\n    }\n\n    if (data.myLocation < bounds.min || data.myLocation > bounds.max) {\n      var inverseData = extend({}, data, {\n        myAlign: inverseAlign(data.myAlign),\n        atAlign: inverseAlign(data.atAlign),\n        offset: -data.offset\n      });\n      initMyLocation(inverseData);\n      inverseData.oversize = calculateOversize(inverseData, bounds);\n\n      if (inverseData.myLocation >= bounds.min && inverseData.myLocation <= bounds.max || data.oversize > inverseData.oversize) {\n        data.myLocation = inverseData.myLocation;\n        data.oversize = inverseData.oversize;\n        data.flip = true;\n      }\n    }\n  },\n  flipfit: function flipfit(data, bounds) {\n    this.flip(data, bounds);\n    this.fit(data, bounds);\n  },\n  none: function none(data) {\n    data.oversize = 0;\n  }\n};\nvar scrollbarWidth;\n\nvar calculateScrollbarWidth = function calculateScrollbarWidth() {\n  var $scrollDiv = $(\"<div>\").css({\n    width: 100,\n    height: 100,\n    overflow: \"scroll\",\n    position: \"absolute\",\n    top: -9999\n  }).appendTo($(\"body\"));\n  var result = $scrollDiv.get(0).offsetWidth - $scrollDiv.get(0).clientWidth;\n  $scrollDiv.remove();\n  scrollbarWidth = result;\n};\n\nvar defaultPositionResult = {\n  h: {\n    location: 0,\n    flip: false,\n    fit: false,\n    oversize: 0\n  },\n  v: {\n    location: 0,\n    flip: false,\n    fit: false,\n    oversize: 0\n  }\n};\n\nvar calculatePosition = function calculatePosition(what, options) {\n  var $what = $(what);\n  var currentOffset = $what.offset();\n  var result = extend(true, {}, defaultPositionResult, {\n    h: {\n      location: currentOffset.left\n    },\n    v: {\n      location: currentOffset.top\n    }\n  });\n\n  if (!options) {\n    return result;\n  }\n\n  var my = normalizeAlign(options.my);\n  var at = normalizeAlign(options.at);\n  var of = $(options.of).length && options.of || window;\n  var offset = normalizeOffset(options.offset);\n  var collision = normalizeCollision(options.collision);\n  var boundary = options.boundary;\n  var boundaryOffset = normalizeOffset(options.boundaryOffset);\n  var h = {\n    mySize: $what.outerWidth(),\n    myAlign: my.h,\n    atAlign: at.h,\n    offset: offset.h,\n    collision: collision.h,\n    boundaryOffset: boundaryOffset.h\n  };\n  var v = {\n    mySize: $what.outerHeight(),\n    myAlign: my.v,\n    atAlign: at.v,\n    offset: offset.v,\n    collision: collision.v,\n    boundaryOffset: boundaryOffset.v\n  };\n\n  if (of.preventDefault) {\n    h.atLocation = of.pageX;\n    v.atLocation = of.pageY;\n    h.atSize = 0;\n    v.atSize = 0;\n  } else {\n    of = $(of);\n\n    if (isWindow(of[0])) {\n      h.atLocation = of.scrollLeft();\n      v.atLocation = of.scrollTop();\n      h.atSize = of[0].innerWidth >= of[0].outerWidth ? of[0].innerWidth : of.width();\n      v.atSize = of[0].innerHeight >= of[0].outerHeight || IS_SAFARI ? of[0].innerHeight : of.height();\n    } else {\n      if (9 === of[0].nodeType) {\n        h.atLocation = 0;\n        v.atLocation = 0;\n        h.atSize = of.width();\n        v.atSize = of.height();\n      } else {\n        var o = of.offset();\n        h.atLocation = o.left;\n        v.atLocation = o.top;\n        h.atSize = of.outerWidth();\n        v.atSize = of.outerHeight();\n      }\n    }\n  }\n\n  initMyLocation(h);\n  initMyLocation(v);\n\n  var bounds = function () {\n    var win = $(window);\n    var windowWidth = win.width();\n    var windowHeight = win.height();\n    var left = win.scrollLeft();\n    var top = win.scrollTop();\n    var documentElement = domAdapter.getDocumentElement();\n    var hZoomLevel = support.touch ? documentElement.clientWidth / windowWidth : 1;\n    var vZoomLevel = support.touch ? documentElement.clientHeight / windowHeight : 1;\n\n    if (void 0 === scrollbarWidth) {\n      calculateScrollbarWidth();\n    }\n\n    var boundaryWidth = windowWidth;\n    var boundaryHeight = windowHeight;\n\n    if (boundary) {\n      var $boundary = $(boundary);\n      var boundaryPosition = $boundary.offset();\n      left = boundaryPosition.left;\n      top = boundaryPosition.top;\n      boundaryWidth = $boundary.width();\n      boundaryHeight = $boundary.height();\n    }\n\n    return {\n      h: {\n        min: left + h.boundaryOffset,\n        max: left + boundaryWidth / hZoomLevel - h.mySize - h.boundaryOffset\n      },\n      v: {\n        min: top + v.boundaryOffset,\n        max: top + boundaryHeight / vZoomLevel - v.mySize - v.boundaryOffset\n      }\n    };\n  }();\n\n  h.oversize = calculateOversize(h, bounds.h);\n  v.oversize = calculateOversize(v, bounds.v);\n  h.collisionSide = collisionSide(\"h\", h, bounds.h);\n  v.collisionSide = collisionSide(\"v\", v, bounds.v);\n\n  if (collisionResolvers[h.collision]) {\n    collisionResolvers[h.collision](h, bounds.h);\n  }\n\n  if (collisionResolvers[v.collision]) {\n    collisionResolvers[v.collision](v, bounds.v);\n  }\n\n  var preciser = function preciser(number) {\n    return options.precise ? number : Math.round(number);\n  };\n\n  extend(true, result, {\n    h: {\n      location: preciser(h.myLocation),\n      oversize: preciser(h.oversize),\n      fit: h.fit,\n      flip: h.flip,\n      collisionSide: h.collisionSide\n    },\n    v: {\n      location: preciser(v.myLocation),\n      oversize: preciser(v.oversize),\n      fit: v.fit,\n      flip: v.flip,\n      collisionSide: v.collisionSide\n    },\n    precise: options.precise\n  });\n  return result;\n};\n\nvar position = function position(what, options) {\n  var $what = $(what);\n\n  if (!options) {\n    return $what.offset();\n  }\n\n  translator.resetPosition($what, true);\n  var offset = $what.offset();\n  var targetPosition = options.h && options.v ? options : calculatePosition($what, options);\n\n  var preciser = function preciser(number) {\n    return options.precise ? number : Math.round(number);\n  };\n\n  translator.move($what, {\n    left: targetPosition.h.location - preciser(offset.left),\n    top: targetPosition.v.location - preciser(offset.top)\n  });\n  return targetPosition;\n};\n\nvar offset = function offset(element) {\n  element = $(element).get(0);\n\n  if (isWindow(element)) {\n    return null;\n  } else {\n    if (element && \"pageY\" in element && \"pageX\" in element) {\n      return {\n        top: element.pageY,\n        left: element.pageX\n      };\n    }\n  }\n\n  return $(element).offset();\n};\n\nif (!position.inverseAlign) {\n  position.inverseAlign = inverseAlign;\n}\n\nif (!position.normalizeAlign) {\n  position.normalizeAlign = normalizeAlign;\n}\n\nmodule.exports = {\n  calculateScrollbarWidth: calculateScrollbarWidth,\n  calculate: calculatePosition,\n  setup: position,\n  offset: offset\n};","map":{"version":3,"sources":["C:/Users/User/Documents/Personals/Creation/NETApp/amplify-client/node_modules/devextreme/animation/position.js"],"names":["$","require","commonUtils","each","windowUtils","window","domAdapter","isWindow","extend","browser","translator","support","horzRe","vertRe","collisionRe","IS_SAFARI","normalizeAlign","result","h","v","pair","w","String","normalizeOffset","normalizeCollision","getAlignFactor","inverseAlign","calculateOversize","oversize","data","bounds","collisionSide","initMyLocation","collisionResolvers","fit","flip","inverseData","myAlign","atAlign","offset","flipfit","none","calculateScrollbarWidth","$scrollDiv","width","height","overflow","position","top","scrollbarWidth","defaultPositionResult","location","calculatePosition","$what","currentOffset","left","my","options","at","of","collision","boundary","boundaryOffset","mySize","o","win","windowWidth","windowHeight","documentElement","hZoomLevel","vZoomLevel","boundaryWidth","boundaryHeight","$boundary","boundaryPosition","min","max","preciser","Math","precise","targetPosition","element","pageX","module","calculate","setup"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (animation/position.js)\r\n * Version: 19.2.6\r\n * Build date: Thu Jan 30 2020\r\n *\r\n * Copyright (c) 2012 - 2020 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\n\"use strict\";\r\nvar $ = require(\"../core/renderer\");\r\nvar commonUtils = require(\"../core/utils/common\");\r\nvar each = require(\"../core/utils/iterator\").each;\r\nvar windowUtils = require(\"../core/utils/window\");\r\nvar window = windowUtils.getWindow();\r\nvar domAdapter = require(\"../core/dom_adapter\");\r\nvar isWindow = require(\"../core/utils/type\").isWindow;\r\nvar extend = require(\"../core/utils/extend\").extend;\r\nvar browser = require(\"../core/utils/browser\");\r\nvar translator = require(\"./translator\");\r\nvar support = require(\"../core/utils/support\");\r\nvar horzRe = /left|right/;\r\nvar vertRe = /top|bottom/;\r\nvar collisionRe = /fit|flip|none/;\r\nvar IS_SAFARI = browser.safari;\r\nvar normalizeAlign = function(raw) {\r\n    var result = {\r\n        h: \"center\",\r\n        v: \"center\"\r\n    };\r\n    var pair = commonUtils.splitPair(raw);\r\n    if (pair) {\r\n        each(pair, function() {\r\n            var w = String(this).toLowerCase();\r\n            if (horzRe.test(w)) {\r\n                result.h = w\r\n            } else {\r\n                if (vertRe.test(w)) {\r\n                    result.v = w\r\n                }\r\n            }\r\n        })\r\n    }\r\n    return result\r\n};\r\nvar normalizeOffset = function(raw) {\r\n    return commonUtils.pairToObject(raw)\r\n};\r\nvar normalizeCollision = function(raw) {\r\n    var pair = commonUtils.splitPair(raw);\r\n    var h = String(pair && pair[0]).toLowerCase();\r\n    var v = String(pair && pair[1]).toLowerCase();\r\n    if (!collisionRe.test(h)) {\r\n        h = \"none\"\r\n    }\r\n    if (!collisionRe.test(v)) {\r\n        v = h\r\n    }\r\n    return {\r\n        h: h,\r\n        v: v\r\n    }\r\n};\r\nvar getAlignFactor = function(align) {\r\n    switch (align) {\r\n        case \"center\":\r\n            return .5;\r\n        case \"right\":\r\n        case \"bottom\":\r\n            return 1;\r\n        default:\r\n            return 0\r\n    }\r\n};\r\nvar inverseAlign = function(align) {\r\n    switch (align) {\r\n        case \"left\":\r\n            return \"right\";\r\n        case \"right\":\r\n            return \"left\";\r\n        case \"top\":\r\n            return \"bottom\";\r\n        case \"bottom\":\r\n            return \"top\";\r\n        default:\r\n            return align\r\n    }\r\n};\r\nvar calculateOversize = function(data, bounds) {\r\n    var oversize = 0;\r\n    if (data.myLocation < bounds.min) {\r\n        oversize += bounds.min - data.myLocation\r\n    }\r\n    if (data.myLocation > bounds.max) {\r\n        oversize += data.myLocation - bounds.max\r\n    }\r\n    return oversize\r\n};\r\nvar collisionSide = function(direction, data, bounds) {\r\n    if (data.myLocation < bounds.min) {\r\n        return \"h\" === direction ? \"left\" : \"top\"\r\n    }\r\n    if (data.myLocation > bounds.max) {\r\n        return \"h\" === direction ? \"right\" : \"bottom\"\r\n    }\r\n    return \"none\"\r\n};\r\nvar initMyLocation = function(data) {\r\n    data.myLocation = data.atLocation + getAlignFactor(data.atAlign) * data.atSize - getAlignFactor(data.myAlign) * data.mySize + data.offset\r\n};\r\nvar collisionResolvers = {\r\n    fit: function(data, bounds) {\r\n        var result = false;\r\n        if (data.myLocation > bounds.max) {\r\n            data.myLocation = bounds.max;\r\n            result = true\r\n        }\r\n        if (data.myLocation < bounds.min) {\r\n            data.myLocation = bounds.min;\r\n            result = true\r\n        }\r\n        data.fit = result\r\n    },\r\n    flip: function(data, bounds) {\r\n        data.flip = false;\r\n        if (\"center\" === data.myAlign && \"center\" === data.atAlign) {\r\n            return\r\n        }\r\n        if (data.myLocation < bounds.min || data.myLocation > bounds.max) {\r\n            var inverseData = extend({}, data, {\r\n                myAlign: inverseAlign(data.myAlign),\r\n                atAlign: inverseAlign(data.atAlign),\r\n                offset: -data.offset\r\n            });\r\n            initMyLocation(inverseData);\r\n            inverseData.oversize = calculateOversize(inverseData, bounds);\r\n            if (inverseData.myLocation >= bounds.min && inverseData.myLocation <= bounds.max || data.oversize > inverseData.oversize) {\r\n                data.myLocation = inverseData.myLocation;\r\n                data.oversize = inverseData.oversize;\r\n                data.flip = true\r\n            }\r\n        }\r\n    },\r\n    flipfit: function(data, bounds) {\r\n        this.flip(data, bounds);\r\n        this.fit(data, bounds)\r\n    },\r\n    none: function(data) {\r\n        data.oversize = 0\r\n    }\r\n};\r\nvar scrollbarWidth;\r\nvar calculateScrollbarWidth = function() {\r\n    var $scrollDiv = $(\"<div>\").css({\r\n        width: 100,\r\n        height: 100,\r\n        overflow: \"scroll\",\r\n        position: \"absolute\",\r\n        top: -9999\r\n    }).appendTo($(\"body\"));\r\n    var result = $scrollDiv.get(0).offsetWidth - $scrollDiv.get(0).clientWidth;\r\n    $scrollDiv.remove();\r\n    scrollbarWidth = result\r\n};\r\nvar defaultPositionResult = {\r\n    h: {\r\n        location: 0,\r\n        flip: false,\r\n        fit: false,\r\n        oversize: 0\r\n    },\r\n    v: {\r\n        location: 0,\r\n        flip: false,\r\n        fit: false,\r\n        oversize: 0\r\n    }\r\n};\r\nvar calculatePosition = function(what, options) {\r\n    var $what = $(what);\r\n    var currentOffset = $what.offset();\r\n    var result = extend(true, {}, defaultPositionResult, {\r\n        h: {\r\n            location: currentOffset.left\r\n        },\r\n        v: {\r\n            location: currentOffset.top\r\n        }\r\n    });\r\n    if (!options) {\r\n        return result\r\n    }\r\n    var my = normalizeAlign(options.my);\r\n    var at = normalizeAlign(options.at);\r\n    var of = $(options.of).length && options.of || window;\r\n    var offset = normalizeOffset(options.offset);\r\n    var collision = normalizeCollision(options.collision);\r\n    var boundary = options.boundary;\r\n    var boundaryOffset = normalizeOffset(options.boundaryOffset);\r\n    var h = {\r\n        mySize: $what.outerWidth(),\r\n        myAlign: my.h,\r\n        atAlign: at.h,\r\n        offset: offset.h,\r\n        collision: collision.h,\r\n        boundaryOffset: boundaryOffset.h\r\n    };\r\n    var v = {\r\n        mySize: $what.outerHeight(),\r\n        myAlign: my.v,\r\n        atAlign: at.v,\r\n        offset: offset.v,\r\n        collision: collision.v,\r\n        boundaryOffset: boundaryOffset.v\r\n    };\r\n    if ( of .preventDefault) {\r\n        h.atLocation = of .pageX;\r\n        v.atLocation = of .pageY;\r\n        h.atSize = 0;\r\n        v.atSize = 0\r\n    } else {\r\n        of = $( of );\r\n        if (isWindow( of [0])) {\r\n            h.atLocation = of .scrollLeft();\r\n            v.atLocation = of .scrollTop();\r\n            h.atSize = of [0].innerWidth >= of [0].outerWidth ? of [0].innerWidth : of .width();\r\n            v.atSize = of [0].innerHeight >= of [0].outerHeight || IS_SAFARI ? of [0].innerHeight : of .height()\r\n        } else {\r\n            if (9 === of [0].nodeType) {\r\n                h.atLocation = 0;\r\n                v.atLocation = 0;\r\n                h.atSize = of .width();\r\n                v.atSize = of .height()\r\n            } else {\r\n                var o = of .offset();\r\n                h.atLocation = o.left;\r\n                v.atLocation = o.top;\r\n                h.atSize = of .outerWidth();\r\n                v.atSize = of .outerHeight()\r\n            }\r\n        }\r\n    }\r\n    initMyLocation(h);\r\n    initMyLocation(v);\r\n    var bounds = function() {\r\n        var win = $(window);\r\n        var windowWidth = win.width();\r\n        var windowHeight = win.height();\r\n        var left = win.scrollLeft();\r\n        var top = win.scrollTop();\r\n        var documentElement = domAdapter.getDocumentElement();\r\n        var hZoomLevel = support.touch ? documentElement.clientWidth / windowWidth : 1;\r\n        var vZoomLevel = support.touch ? documentElement.clientHeight / windowHeight : 1;\r\n        if (void 0 === scrollbarWidth) {\r\n            calculateScrollbarWidth()\r\n        }\r\n        var boundaryWidth = windowWidth;\r\n        var boundaryHeight = windowHeight;\r\n        if (boundary) {\r\n            var $boundary = $(boundary);\r\n            var boundaryPosition = $boundary.offset();\r\n            left = boundaryPosition.left;\r\n            top = boundaryPosition.top;\r\n            boundaryWidth = $boundary.width();\r\n            boundaryHeight = $boundary.height()\r\n        }\r\n        return {\r\n            h: {\r\n                min: left + h.boundaryOffset,\r\n                max: left + boundaryWidth / hZoomLevel - h.mySize - h.boundaryOffset\r\n            },\r\n            v: {\r\n                min: top + v.boundaryOffset,\r\n                max: top + boundaryHeight / vZoomLevel - v.mySize - v.boundaryOffset\r\n            }\r\n        }\r\n    }();\r\n    h.oversize = calculateOversize(h, bounds.h);\r\n    v.oversize = calculateOversize(v, bounds.v);\r\n    h.collisionSide = collisionSide(\"h\", h, bounds.h);\r\n    v.collisionSide = collisionSide(\"v\", v, bounds.v);\r\n    if (collisionResolvers[h.collision]) {\r\n        collisionResolvers[h.collision](h, bounds.h)\r\n    }\r\n    if (collisionResolvers[v.collision]) {\r\n        collisionResolvers[v.collision](v, bounds.v)\r\n    }\r\n    var preciser = function(number) {\r\n        return options.precise ? number : Math.round(number)\r\n    };\r\n    extend(true, result, {\r\n        h: {\r\n            location: preciser(h.myLocation),\r\n            oversize: preciser(h.oversize),\r\n            fit: h.fit,\r\n            flip: h.flip,\r\n            collisionSide: h.collisionSide\r\n        },\r\n        v: {\r\n            location: preciser(v.myLocation),\r\n            oversize: preciser(v.oversize),\r\n            fit: v.fit,\r\n            flip: v.flip,\r\n            collisionSide: v.collisionSide\r\n        },\r\n        precise: options.precise\r\n    });\r\n    return result\r\n};\r\nvar position = function(what, options) {\r\n    var $what = $(what);\r\n    if (!options) {\r\n        return $what.offset()\r\n    }\r\n    translator.resetPosition($what, true);\r\n    var offset = $what.offset();\r\n    var targetPosition = options.h && options.v ? options : calculatePosition($what, options);\r\n    var preciser = function(number) {\r\n        return options.precise ? number : Math.round(number)\r\n    };\r\n    translator.move($what, {\r\n        left: targetPosition.h.location - preciser(offset.left),\r\n        top: targetPosition.v.location - preciser(offset.top)\r\n    });\r\n    return targetPosition\r\n};\r\nvar offset = function(element) {\r\n    element = $(element).get(0);\r\n    if (isWindow(element)) {\r\n        return null\r\n    } else {\r\n        if (element && \"pageY\" in element && \"pageX\" in element) {\r\n            return {\r\n                top: element.pageY,\r\n                left: element.pageX\r\n            }\r\n        }\r\n    }\r\n    return $(element).offset()\r\n};\r\nif (!position.inverseAlign) {\r\n    position.inverseAlign = inverseAlign\r\n}\r\nif (!position.normalizeAlign) {\r\n    position.normalizeAlign = normalizeAlign\r\n}\r\nmodule.exports = {\r\n    calculateScrollbarWidth: calculateScrollbarWidth,\r\n    calculate: calculatePosition,\r\n    setup: position,\r\n    offset: offset\r\n};\r\n"]},"metadata":{},"sourceType":"module"}